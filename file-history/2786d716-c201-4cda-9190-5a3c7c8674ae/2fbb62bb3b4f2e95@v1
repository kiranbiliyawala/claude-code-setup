# Repository Pattern

## Overview

finhq-verse uses a **custom Repository pattern** that wraps Spring Data JPA. This custom layer:

1. **Enforces tenant scoping** - Every query requires a `RepositoryScope`
2. **Uses cursor pagination** - No offset-based pagination
3. **Provides audit access** - Query historical revisions via Envers
4. **Handles soft deletes** - Entities can be soft-deleted

---

## Why Not Standard Spring Data JPA?

| Standard JpaRepository | finhq Repository |
|------------------------|------------------|
| No built-in multi-tenancy | Mandatory `RepositoryScope` parameter |
| Offset pagination (`Pageable`) | Cursor pagination (`CursorPageRequest`) |
| No audit queries | Built-in `findRevision()` |
| Hard deletes | Soft delete support |
| `Optional` or null returns | `*OrFail()` methods throw exceptions |

---

## Core Interface

**Location:** `finhq-commons-spring/finhq-entity/src/main/java/io/finhq/commons/spring/entity/repository/Repository.java`

```java
@NoRepositoryBean
public interface Repository<T extends AbstractEntity>
        extends JpaRepository<T, Long>, JpaSpecificationExecutor<T> {

    // ═══════════════════════════════════════════════════════════════════
    // QUERY METHODS
    // ═══════════════════════════════════════════════════════════════════

    /**
     * Find one entity matching specification within scope.
     */
    Optional<T> findOne(RepositoryScope scope, Specification<T> spec);

    /**
     * Find by external ID.
     */
    Optional<T> findByExternalId(RepositoryScope scope, String externalId);

    /**
     * Find by external ID or throw NOT_FOUND.
     */
    default T findByExternalIdOrFail(RepositoryScope scope, String externalId) {
        return findByExternalId(scope, externalId)
                .orElseThrow(() -> new ApplicationException(EntityErrorCode.ENTITY_NOT_FOUND));
    }

    /**
     * Find by external reference (for ExternalReferenceable entities).
     */
    Optional<T> findByExternalReference(RepositoryScope scope, String externalReference);

    /**
     * Find by external reference or throw.
     */
    default T findByExternalReferenceOrFail(RepositoryScope scope, String externalReference) {
        return findByExternalReference(scope, externalReference)
                .orElseThrow(() -> new ApplicationException(EntityErrorCode.ENTITY_NOT_FOUND));
    }

    // ═══════════════════════════════════════════════════════════════════
    // PAGINATION
    // ═══════════════════════════════════════════════════════════════════

    /**
     * Find all with cursor-based pagination.
     */
    CursorPage<T> findAll(RepositoryScope scope, Specification<T> spec, CursorPageRequest pageRequest);

    // ═══════════════════════════════════════════════════════════════════
    // CRUD OPERATIONS
    // ═══════════════════════════════════════════════════════════════════

    /**
     * Create a new entity.
     */
    <S extends T> S create(RepositoryScope scope, S entity);

    /**
     * Update with entity.
     */
    T update(RepositoryScope scope, T entity, T entityUpdates);

    /**
     * Update with EntityUpdates (for partial updates).
     */
    T update(RepositoryScope scope, T entity, EntityUpdates<T> entityUpdates);

    /**
     * Delete (soft delete if SoftDeletable, otherwise throws).
     */
    void delete(RepositoryScope scope, T entity);

    // ═══════════════════════════════════════════════════════════════════
    // AUDIT METHODS
    // ═══════════════════════════════════════════════════════════════════

    /**
     * Get entity at specific revision.
     */
    T findRevision(RepositoryScope scope, String externalId, int revisionId);

    /**
     * Get entity at specific revision (from entity instance).
     */
    T findRevision(RepositoryScope scope, T entity, int revisionId);

    // ═══════════════════════════════════════════════════════════════════
    // EXISTENCE CHECKS
    // ═══════════════════════════════════════════════════════════════════

    /**
     * Check if entity exists.
     */
    boolean exists(RepositoryScope scope, Specification<T> spec);

    /**
     * Throw if entity exists (for uniqueness validation).
     */
    default void failIfExists(RepositoryScope scope, Specification<T> spec) {
        if (exists(scope, spec)) {
            throw new ApplicationException(EntityErrorCode.ENTITY_ALREADY_EXISTS);
        }
    }
}
```

---

## RepositoryScope

**Location:** `finhq-commons-spring/finhq-entity/src/main/java/io/finhq/commons/spring/entity/repository/RepositoryScope.java`

```java
@Getter
@Builder
public class RepositoryScope {
    private final String orgId;
    private final String namespaceId;

    /**
     * Create scope from current PassportContext.
     * This is the most common usage.
     */
    public static RepositoryScope create() {
        Passport passport = PassportContext.get();
        return RepositoryScope.builder()
                .orgId(passport.getOrgId())
                .namespaceId(passport.getNamespaceId())
                .build();
    }

    /**
     * Create empty scope for system-level operations.
     * Use sparingly - bypasses tenant filtering!
     */
    public static RepositoryScope empty() {
        return RepositoryScope.builder().build();
    }
}
```

### When to Use Each

| Method | Use Case |
|--------|----------|
| `RepositoryScope.create()` | 99% of cases - normal tenant-scoped operations |
| `RepositoryScope.empty()` | System operations, migrations, admin tasks |

---

## Cursor-Based Pagination

### Why Cursor Instead of Offset?

**Offset pagination problems:**
```sql
-- Page 1: SELECT * FROM items LIMIT 10 OFFSET 0
-- User sees items 1-10

-- New item inserted at position 5

-- Page 2: SELECT * FROM items LIMIT 10 OFFSET 10
-- User sees items 11-20, but item 10 is now at offset 9
-- Item 10 was SKIPPED!
```

**Cursor pagination is stable:**
```sql
-- Page 1: SELECT * FROM items WHERE id < 'cursor' ORDER BY id DESC LIMIT 10
-- Returns consistent results regardless of inserts/deletes
```

### CursorPageRequest

```java
// First page
CursorPageRequest pageRequest = CursorPageRequest.first(20);

// Next page (after cursor)
CursorPageRequest pageRequest = new CursorPageRequest(
    cursor,                    // externalId of last item
    20,                        // page size
    CursorDirection.NEXT       // direction
);

// Previous page (before cursor)
CursorPageRequest pageRequest = new CursorPageRequest(
    cursor,
    20,
    CursorDirection.PREVIOUS
);
```

### CursorPage

```java
CursorPage<Entity> page = repository.findAll(scope, spec, pageRequest);

List<Entity> items = page.getContent();      // The items
String nextCursor = page.getNextCursor();    // For "Load More"
String prevCursor = page.getPreviousCursor(); // For "Back"
int size = page.getSize();                   // Actual count returned
```

---

## Implementing a Repository

### 1. Define the Interface

```java
public interface OrganizationRepository extends Repository<OrganizationEntity> {
    // Add custom methods if needed
}
```

### 2. Implement the Repository

```java
@Component
public class OrganizationRepositoryImpl
        extends AbstractRepositoryImpl<OrganizationEntity>
        implements OrganizationRepository {

    public OrganizationRepositoryImpl(
            JpaRepository<OrganizationEntity, Long> jpaRepository,
            EntityManager entityManager) {
        super(jpaRepository, entityManager, OrganizationEntity.class);
    }

    // Override methods if custom behavior needed
}
```

### 3. Define JPA Repository (Spring Data)

```java
@org.springframework.stereotype.Repository
public interface OrganizationJpaRepository
        extends JpaRepository<OrganizationEntity, Long>,
                JpaSpecificationExecutor<OrganizationEntity> {
    // Spring Data methods if needed
}
```

---

## AbstractRepositoryImpl

The base implementation handles:

1. **Scope application** - Adds org/namespace filters to all queries
2. **Cursor pagination** - Converts cursor to SQL
3. **Audit queries** - Uses Hibernate Envers AuditReader
4. **Soft deletes** - Checks `SoftDeletable` interface

```java
public abstract class AbstractRepositoryImpl<T extends AbstractEntity>
        implements Repository<T> {

    @Override
    public Optional<T> findByExternalId(RepositoryScope scope, String externalId) {
        // Build specification with scope filtering
        Specification<T> spec = Specification.where(
            hasExternalId(externalId)
            .and(inScope(scope))
        );
        return jpaRepository.findOne(spec);
    }

    @Override
    public <S extends T> S create(RepositoryScope scope, S entity) {
        // Set scope fields on entity before save
        if (entity instanceof AbstractOrgScopedEntity orgEntity) {
            orgEntity.setOrgId(scope.getOrgId());
        }
        if (entity instanceof AbstractNamespaceScopedEntity nsEntity) {
            nsEntity.setNamespaceId(scope.getNamespaceId());
        }
        return jpaRepository.save(entity);
    }

    // ... other implementations
}
```

---

## Specifications for Complex Queries

Use JPA Specifications for complex filtering:

```java
public class OrganizationSpecification {

    public static Specification<OrganizationEntity> hasName(String name) {
        return (root, query, cb) -> cb.equal(root.get("name"), name);
    }

    public static Specification<OrganizationEntity> hasStatus(Status status) {
        return (root, query, cb) -> cb.equal(root.get("status"), status);
    }

    public static Specification<OrganizationEntity> createdAfter(LocalDateTime date) {
        return (root, query, cb) -> cb.greaterThan(root.get("createdAt"), date);
    }
}
```

Usage:

```java
Specification<OrganizationEntity> spec = Specification
    .where(hasStatus(Status.ACTIVE))
    .and(createdAfter(lastMonth));

CursorPage<OrganizationEntity> page = repository.findAll(scope, spec, pageRequest);
```

---

## Audit Queries (Hibernate Envers)

Every `@Audited` entity has history stored in `*_aud` tables:

```java
// Get entity at revision 5
OrganizationEntity atRevision5 = repository.findRevision(scope, externalId, 5);

// Compare with current
OrganizationEntity current = repository.findByExternalIdOrFail(scope, externalId);
```

Revision metadata is stored in `revinfo`:
```sql
SELECT * FROM revinfo WHERE id = 5;
-- Returns: id, timestamp, username
```

---

## Error Handling

Repository methods throw `ApplicationException`:

| Error Code | When |
|------------|------|
| `ENTITY_NOT_FOUND` | `findByExternalIdOrFail` finds nothing |
| `ENTITY_ALREADY_EXISTS` | `failIfExists` finds match |
| `INVALID_ENTITY_TYPE` | Entity doesn't support operation |

```java
try {
    Entity entity = repository.findByExternalIdOrFail(scope, id);
} catch (ApplicationException e) {
    if (e.matchesErrorCode(EntityErrorCode.ENTITY_NOT_FOUND)) {
        // Handle not found
    }
}
```

---

## Key Takeaways

1. **Always pass RepositoryScope** - No scope = no query execution
2. **Use `*OrFail` methods** - They throw proper exceptions
3. **Cursor pagination only** - No offset support
4. **Scoping is automatic** - Repository handles org/namespace filtering
5. **Audit built-in** - Use `findRevision()` for history
6. **Specifications for complex queries** - Compose filters cleanly

---

## Next Steps

- [Service Pattern](./03-service-pattern.md) - How services use repositories
- [Entity Pattern](./04-entity-pattern.md) - Entity hierarchy and auditing
