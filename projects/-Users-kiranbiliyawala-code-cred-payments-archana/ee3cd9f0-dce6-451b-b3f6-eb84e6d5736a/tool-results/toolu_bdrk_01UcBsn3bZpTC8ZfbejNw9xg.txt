diff --git a/lcm-client/gradle.properties b/lcm-client/gradle.properties
index 1870124e..d4e18c10 100644
--- a/lcm-client/gradle.properties
+++ b/lcm-client/gradle.properties
@@ -1 +1 @@
-version=1.0.36
+version=1.0.37
diff --git a/lcm-datatype/gradle.properties b/lcm-datatype/gradle.properties
index 1870124e..d4e18c10 100644
--- a/lcm-datatype/gradle.properties
+++ b/lcm-datatype/gradle.properties
@@ -1 +1 @@
-version=1.0.36
+version=1.0.37
diff --git a/lcm-server/core/src/main/java/in/dreamplug/lcm/server/core/manager/enablement/DiscoverMerchantPaymentMethodsManager.java b/lcm-server/core/src/main/java/in/dreamplug/lcm/server/core/manager/enablement/DiscoverMerchantPaymentMethodsManager.java
index 63f0d381..e44ca938 100644
--- a/lcm-server/core/src/main/java/in/dreamplug/lcm/server/core/manager/enablement/DiscoverMerchantPaymentMethodsManager.java
+++ b/lcm-server/core/src/main/java/in/dreamplug/lcm/server/core/manager/enablement/DiscoverMerchantPaymentMethodsManager.java
@@ -53,10 +53,7 @@ public DiscoverPaymentMethodsResponse discoverPaymentMethodsForMerchant(
         validateRequest(request);
         Map<PaymentMethodType, PaymentMethodDto> enablementConfigMap =
                 merchantPaymentMethodsEnablementManager.getEnablementConfigMapForMerchant(
-                        merchantId,
-                        Objects.isNull(request.getTransactionType())
-                                ? TransactionType.PAY
-                                : request.getTransactionType());
+                        merchantId, getTransactionTypeOrDefault(request));
         List<PaymentMethod> enabledMethods =
                 merchantPaymentMethodsEnablementManager.getPaymentMethodsForMerchantV3(enablementConfigMap);
         List<PaymentMethod> methodsProcessedWithConstraints =
@@ -64,8 +61,8 @@ public DiscoverPaymentMethodsResponse discoverPaymentMethodsForMerchant(
         List<PaymentMethod> methodsProcessedWithPreferences =
                 merchantPreferenceEnablementManager.enrichPaymentMethodsWithPreferencesInformation(
                         merchantId, request.getOrderDetails(), methodsProcessedWithConstraints);
-        List<PaymentMethod> sanitizedPaymentMethods =
-                sanitizePaymentMethodsIfMethodDisabled(methodsProcessedWithPreferences);
+        List<PaymentMethod> sanitizedPaymentMethods = sanitizePaymentMethodsIfMethodDisabled(
+                methodsProcessedWithPreferences, getTransactionTypeOrDefault(request));
         enrichPriorityForDisablementContext(sanitizedPaymentMethods);
         DiscoverPaymentMethodsResponse response =
                 (new DiscoverPaymentMethodsResponse()).paymentMethods(sanitizedPaymentMethods);
@@ -73,12 +70,17 @@ public DiscoverPaymentMethodsResponse discoverPaymentMethodsForMerchant(
         return response;
     }
 
-    private List<PaymentMethod> sanitizePaymentMethodsIfMethodDisabled(List<PaymentMethod> methods) {
+    private TransactionType getTransactionTypeOrDefault(DiscoverPaymentMethodsRequest request) {
+        return Objects.isNull(request.getTransactionType()) ? TransactionType.PAY : request.getTransactionType();
+    }
+
+    private List<PaymentMethod> sanitizePaymentMethodsIfMethodDisabled(
+            List<PaymentMethod> methods, TransactionType transactionType) {
         return methods.stream()
                 .map(paymentMethod -> ((PaymentMethodListingProcessor)
                                 paymentMethodProcessorFactory.getPaymentMethodProcessor(
                                         paymentMethod.getType(), ProcessorFlowType.LISTING))
-                        .sanitizePaymentMethodIfMethodDisabled(paymentMethod))
+                        .sanitizePaymentMethodIfMethodDisabled(paymentMethod, transactionType))
                 .toList();
     }
 
diff --git a/lcm-server/core/src/main/java/in/dreamplug/lcm/server/core/manager/enablement/MerchantPaymentMethodsEnablementManager.java b/lcm-server/core/src/main/java/in/dreamplug/lcm/server/core/manager/enablement/MerchantPaymentMethodsEnablementManager.java
index 5c4ea499..e5e6b2b4 100644
--- a/lcm-server/core/src/main/java/in/dreamplug/lcm/server/core/manager/enablement/MerchantPaymentMethodsEnablementManager.java
+++ b/lcm-server/core/src/main/java/in/dreamplug/lcm/server/core/manager/enablement/MerchantPaymentMethodsEnablementManager.java
@@ -100,7 +100,7 @@ public List<PaymentMethod> getPaymentMethodsForMerchant(String merchantId, Trans
                 .toList();
     }
 
-    // TODO @chara use mandateFlow in UPI for dimension filtering
+    // TODO @charan use mandateFlow in UPI for dimension filtering
     public Optional<PaymentMethod> buildPaymentMethod(
             String merchantId, PaymentMethodType paymentMethodType, TransactionType transactionType) {
         PaymentMethodDto paymentMethodDto = getPaymentMethodDtoByMerchantIdAndMethodType(merchantId, paymentMethodType);
diff --git a/lcm-server/core/src/main/java/in/dreamplug/lcm/server/core/processor/methods/enablement/PaymentMethodListingProcessor.java b/lcm-server/core/src/main/java/in/dreamplug/lcm/server/core/processor/methods/enablement/PaymentMethodListingProcessor.java
index 51b25a96..dd26f294 100644
--- a/lcm-server/core/src/main/java/in/dreamplug/lcm/server/core/processor/methods/enablement/PaymentMethodListingProcessor.java
+++ b/lcm-server/core/src/main/java/in/dreamplug/lcm/server/core/processor/methods/enablement/PaymentMethodListingProcessor.java
@@ -2,6 +2,7 @@
 
 import in.dreamplug.lcm.datatype.PaymentMethod;
 import in.dreamplug.lcm.datatype.PaymentMethodType;
+import in.dreamplug.lcm.datatype.TransactionType;
 import in.dreamplug.lcm.server.core.dto.PaymentMethodDto;
 import in.dreamplug.lcm.server.core.dto.PaymentSubMethodDto;
 import in.dreamplug.lcm.server.core.dto.ProcessorFlowType;
@@ -51,20 +52,22 @@ public void enrichPriorityForDisablementContext(PaymentMethod paymentMethod) {
     }
     // TODO csals unit tests
 
-    public final PaymentMethod sanitizePaymentMethodIfMethodDisabled(PaymentMethod paymentMethod) {
+    public final PaymentMethod sanitizePaymentMethodIfMethodDisabled(
+            PaymentMethod paymentMethod, TransactionType transactionType) {
         if (!paymentMethod.getEnabled()) {
             return new PaymentMethod()
                     .enabled(false)
                     .type(paymentMethod.getType())
                     .disabledContext(paymentMethod.getDisabledContext());
         }
-        return sanitizePaymentMethodIfSubMethodDisabled(paymentMethod);
+        return sanitizePaymentMethodIfSubMethodDisabled(paymentMethod, transactionType);
     }
 
     /**
      * If hierarchy present then need to disable sub methods if parent sub method is disabled (not for the case where entire method itself is disabled)
      */
-    protected PaymentMethod sanitizePaymentMethodIfSubMethodDisabled(PaymentMethod paymentMethod) {
+    protected PaymentMethod sanitizePaymentMethodIfSubMethodDisabled(
+            PaymentMethod paymentMethod, TransactionType transactionType) {
         return paymentMethod;
     }
 }
diff --git a/lcm-server/core/src/main/java/in/dreamplug/lcm/server/core/processor/methods/enablement/UpiMethodListingProcessor.java b/lcm-server/core/src/main/java/in/dreamplug/lcm/server/core/processor/methods/enablement/UpiMethodListingProcessor.java
index bdb7f574..4b1f5a3e 100644
--- a/lcm-server/core/src/main/java/in/dreamplug/lcm/server/core/processor/methods/enablement/UpiMethodListingProcessor.java
+++ b/lcm-server/core/src/main/java/in/dreamplug/lcm/server/core/processor/methods/enablement/UpiMethodListingProcessor.java
@@ -6,6 +6,7 @@
 import in.dreamplug.lcm.datatype.PaymentMethod;
 import in.dreamplug.lcm.datatype.PaymentMethodDisabledContext;
 import in.dreamplug.lcm.datatype.PaymentMethodType;
+import in.dreamplug.lcm.datatype.TransactionType;
 import in.dreamplug.lcm.datatype.UpiPaymentMethod;
 import in.dreamplug.lcm.datatype.UpiType;
 import in.dreamplug.lcm.datatype.UpiTypeDetail;
@@ -223,7 +224,8 @@ private void setPriorityInDisabledContextMap(
     }
 
     @Override
-    public PaymentMethod sanitizePaymentMethodIfSubMethodDisabled(PaymentMethod paymentMethod) {
+    public PaymentMethod sanitizePaymentMethodIfSubMethodDisabled(
+            PaymentMethod paymentMethod, TransactionType transactionType) {
         UpiPaymentMethod upiPaymentMethod = paymentMethod.getUpi();
         Optional<UpiTypeDetail> upiTypeDetail = upiPaymentMethod.getUpiTypes().stream()
                 .filter(detail -> Objects.equals(detail.getEnabled(), false)
diff --git a/lcm-server/core/src/main/java/in/dreamplug/lcm/server/core/processor/methods/enablement/WalletMethodListingProcessor.java b/lcm-server/core/src/main/java/in/dreamplug/lcm/server/core/processor/methods/enablement/WalletMethodListingProcessor.java
index 0f913799..acf06d21 100644
--- a/lcm-server/core/src/main/java/in/dreamplug/lcm/server/core/processor/methods/enablement/WalletMethodListingProcessor.java
+++ b/lcm-server/core/src/main/java/in/dreamplug/lcm/server/core/processor/methods/enablement/WalletMethodListingProcessor.java
@@ -1,13 +1,20 @@
 package in.dreamplug.lcm.server.core.processor.methods.enablement;
 
+import in.dreamplug.lcm.datatype.PaymentMethod;
 import in.dreamplug.lcm.datatype.PaymentMethodType;
+import in.dreamplug.lcm.datatype.TransactionType;
+import in.dreamplug.lcm.datatype.WalletIssuer;
+import in.dreamplug.lcm.datatype.WalletPaymentMethod;
 import in.dreamplug.lcm.server.core.dto.dimension.Dimension;
 import java.util.List;
+import java.util.Objects;
 import org.springframework.stereotype.Component;
 
 @Component
 public class WalletMethodListingProcessor extends PaymentMethodListingProcessor {
 
+    List<WalletIssuer> ENABLED_ISSUERS_FOR_MANDATE_WITH_PAY = List.of(WalletIssuer.CRED_BALANCE);
+
     public WalletMethodListingProcessor() {
         super(PaymentMethodType.WALLET);
     }
@@ -16,4 +23,16 @@ public WalletMethodListingProcessor() {
     public List<Dimension> getEnablementResponseDimensions() {
         return List.of(Dimension.WALLET_ISSUER);
     }
+
+    @Override
+    public PaymentMethod sanitizePaymentMethodIfSubMethodDisabled(
+            PaymentMethod paymentMethod, TransactionType transactionType) {
+        if (Objects.equals(transactionType, TransactionType.MANDATE_WITH_PAY)) {
+            WalletPaymentMethod walletPaymentMethod = paymentMethod.getWallet();
+            walletPaymentMethod.getIssuers().stream()
+                    .filter(issuerDetail -> !ENABLED_ISSUERS_FOR_MANDATE_WITH_PAY.contains(issuerDetail.getIssuer()))
+                    .forEach(issuerDetail -> issuerDetail.setEnabled(false));
+        }
+        return paymentMethod;
+    }
 }
diff --git a/lcm-server/core/src/main/java/in/dreamplug/lcm/server/core/utility/PaymentDomainUtils.java b/lcm-server/core/src/main/java/in/dreamplug/lcm/server/core/utility/PaymentDomainUtils.java
index 12ce2da2..5d0cf8db 100644
--- a/lcm-server/core/src/main/java/in/dreamplug/lcm/server/core/utility/PaymentDomainUtils.java
+++ b/lcm-server/core/src/main/java/in/dreamplug/lcm/server/core/utility/PaymentDomainUtils.java
@@ -95,6 +95,10 @@ private static InstrumentType getInstrumentTypeForReward(RewardPaymentMethodRequ
     public static final List<PaymentMethodType> PAYMENT_METHODS_SUPPORTED_FOR_MANDATE_AND_TRANSACTION_FLOW =
             List.of(PaymentMethodType.UPI);
 
+    @NonNull
+    public static final List<PaymentMethodType> AUTHLESS_PAYMENT_METHODS_SUPPORTED_FOR_MANDATE_AND_TRANSACTION_FLOW =
+            List.of(PaymentMethodType.WALLET);
+
     @NonNull
     public static List<PaymentMethodType> getPaymentMethodTypes(TransactionType transactionType) {
         if (Objects.equals(TransactionType.MANDATE, transactionType)) {
@@ -102,6 +106,11 @@ public static List<PaymentMethodType> getPaymentMethodTypes(TransactionType tran
                             PAYMENT_METHODS_SUPPORTED_ONLY_FOR_MANDATE_FLOW.stream(),
                             PAYMENT_METHODS_SUPPORTED_FOR_MANDATE_AND_TRANSACTION_FLOW.stream())
                     .collect(Collectors.toList());
+        } else if (Objects.equals(TransactionType.MANDATE_WITH_PAY, transactionType)) {
+            return Stream.concat(
+                            PAYMENT_METHODS_SUPPORTED_FOR_MANDATE_AND_TRANSACTION_FLOW.stream(),
+                            AUTHLESS_PAYMENT_METHODS_SUPPORTED_FOR_MANDATE_AND_TRANSACTION_FLOW.stream())
+                    .collect(Collectors.toList());
         }
         return Stream.of(
                         PaymentMethodType.UPI,
diff --git a/lcm-server/core/src/test/java/in/dreamplug/lcm/server/core/manager/DiscoverMerchantPaymentMethodsManagerMandateWithPayTest.java b/lcm-server/core/src/test/java/in/dreamplug/lcm/server/core/manager/DiscoverMerchantPaymentMethodsManagerMandateWithPayTest.java
new file mode 100644
index 00000000..7daccfd4
--- /dev/null
+++ b/lcm-server/core/src/test/java/in/dreamplug/lcm/server/core/manager/DiscoverMerchantPaymentMethodsManagerMandateWithPayTest.java
@@ -0,0 +1,182 @@
+package in.dreamplug.lcm.server.core.manager;
+
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import in.dreamplug.lcm.datatype.PaymentMethod;
+import in.dreamplug.lcm.datatype.PaymentMethodType;
+import in.dreamplug.lcm.datatype.TransactionType;
+import in.dreamplug.lcm.datatype.WalletIssuer;
+import in.dreamplug.lcm.datatype.WalletIssuerDetail;
+import in.dreamplug.lcm.datatype.WalletPaymentMethod;
+import in.dreamplug.lcm.server.core.processor.methods.enablement.WalletMethodListingProcessor;
+import java.util.Arrays;
+import java.util.stream.Collectors;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Integration test suite for WalletMethodListingProcessor with MANDATE_WITH_PAY transaction type.
+ * Validates that wallet payment methods are correctly sanitized for MANDATE_WITH_PAY transactions
+ * in the payment method discovery pipeline.
+ */
+class DiscoverMerchantPaymentMethodsManagerMandateWithPayTest {
+
+    private WalletMethodListingProcessor walletMethodListingProcessor;
+
+    @BeforeEach
+    public void setUp() {
+        walletMethodListingProcessor = new WalletMethodListingProcessor();
+    }
+
+    /**
+     * Test that MANDATE_WITH_PAY transaction type correctly filters wallet issuers through the
+     * sanitization pipeline.
+     */
+    @Test
+    void sanitizePaymentMethod_mandateWithPay_filtersWalletIssuersCorrectly() {
+        // Given
+        PaymentMethod walletPaymentMethod = createWalletPaymentMethodWithMultipleIssuers();
+
+        // When
+        PaymentMethod result = walletMethodListingProcessor.sanitizePaymentMethodIfSubMethodDisabled(
+                walletPaymentMethod, TransactionType.MANDATE_WITH_PAY);
+
+        // Then
+        assertNotNull(result);
+        assertTrue(result.getEnabled());
+        assertTrue(result.getType() == PaymentMethodType.WALLET);
+
+        WalletPaymentMethod wallet = result.getWallet();
+        assertNotNull(wallet);
+        assertNotNull(wallet.getIssuers());
+
+        // Verify only CRED_BALANCE is enabled
+        long enabledCount = wallet.getIssuers().stream()
+                .filter(WalletIssuerDetail::getEnabled)
+                .count();
+        assertTrue(enabledCount >= 1, "At least CRED_BALANCE should be enabled");
+
+        boolean credBalanceEnabled = wallet.getIssuers().stream()
+                .anyMatch(issuer -> issuer.getIssuer() == WalletIssuer.CRED_BALANCE && issuer.getEnabled());
+        assertTrue(credBalanceEnabled, "CRED_BALANCE should be enabled for MANDATE_WITH_PAY");
+    }
+
+    /**
+     * Test that PAY transaction type does not filter wallet issuers.
+     */
+    @Test
+    void sanitizePaymentMethod_payTransaction_doesNotFilterIssuers() {
+        // Given
+        PaymentMethod walletPaymentMethod = createWalletPaymentMethodWithMultipleIssuers();
+
+        // When
+        PaymentMethod result = walletMethodListingProcessor.sanitizePaymentMethodIfSubMethodDisabled(
+                walletPaymentMethod, TransactionType.PAY);
+
+        // Then
+        assertNotNull(result);
+        assertTrue(result.getEnabled());
+
+        WalletPaymentMethod wallet = result.getWallet();
+        long enabledCount = wallet.getIssuers().stream()
+                .filter(WalletIssuerDetail::getEnabled)
+                .count();
+
+        // For PAY, all issuers should remain enabled
+        assertTrue(enabledCount >= 2, "Multiple issuers should be enabled for PAY transaction");
+    }
+
+    /**
+     * Test that MANDATE transaction type does not filter wallet issuers.
+     */
+    @Test
+    void sanitizePaymentMethod_mandateTransaction_doesNotFilterIssuers() {
+        // Given
+        PaymentMethod walletPaymentMethod = createWalletPaymentMethodWithMultipleIssuers();
+
+        // When
+        PaymentMethod result = walletMethodListingProcessor.sanitizePaymentMethodIfSubMethodDisabled(
+                walletPaymentMethod, TransactionType.MANDATE);
+
+        // Then
+        assertNotNull(result);
+        assertTrue(result.getEnabled());
+
+        WalletPaymentMethod wallet = result.getWallet();
+        long enabledCount = wallet.getIssuers().stream()
+                .filter(WalletIssuerDetail::getEnabled)
+                .count();
+
+        // For MANDATE, all issuers should remain enabled
+        assertTrue(enabledCount >= 2, "Multiple issuers should be enabled for MANDATE transaction");
+    }
+
+    /**
+     * Test that null transaction type defaults to PAY behavior (no filtering).
+     */
+    @Test
+    void sanitizePaymentMethod_nullTransactionType_defaultsToPay() {
+        // Given
+        PaymentMethod walletPaymentMethod = createWalletPaymentMethodWithMultipleIssuers();
+
+        // When
+        PaymentMethod result =
+                walletMethodListingProcessor.sanitizePaymentMethodIfSubMethodDisabled(walletPaymentMethod, null);
+
+        // Then
+        assertNotNull(result);
+        assertTrue(result.getEnabled());
+
+        WalletPaymentMethod wallet = result.getWallet();
+        long enabledCount = wallet.getIssuers().stream()
+                .filter(WalletIssuerDetail::getEnabled)
+                .count();
+
+        // For null (defaults to PAY), all issuers should remain enabled
+        assertTrue(enabledCount >= 2, "Multiple issuers should be enabled for null transaction type");
+    }
+
+    /**
+     * Test that wallet payment method type is correctly identified.
+     */
+    @Test
+    void getPaymentMethodType_returnsWallet() {
+        // When
+        PaymentMethodType type = walletMethodListingProcessor.getPaymentMethodType();
+
+        // Then
+        assertTrue(type == PaymentMethodType.WALLET);
+    }
+
+    /**
+     * Test that enrichPriorityForDisablementContext processes wallet payment methods.
+     */
+    @Test
+    void enrichPriorityForDisablementContext_processesWalletMethod() {
+        // Given
+        PaymentMethod walletPaymentMethod = createWalletPaymentMethodWithMultipleIssuers();
+
+        // When
+        walletMethodListingProcessor.enrichPriorityForDisablementContext(walletPaymentMethod);
+
+        // Then
+        assertNotNull(walletPaymentMethod);
+        assertTrue(walletPaymentMethod.getType() == PaymentMethodType.WALLET);
+    }
+
+    // Helper methods
+
+    private PaymentMethod createWalletPaymentMethodWithMultipleIssuers() {
+        return new PaymentMethod()
+                .type(PaymentMethodType.WALLET)
+                .enabled(true)
+                .wallet(new WalletPaymentMethod()
+                        .issuers(Arrays.stream(WalletIssuer.values())
+                                .limit(2)
+                                .map(walletIssuer -> new WalletIssuerDetail()
+                                        .issuer(walletIssuer)
+                                        .enabled(true))
+                                .collect(Collectors.toList())));
+    }
+}
diff --git a/lcm-server/core/src/test/java/in/dreamplug/lcm/server/core/processor/methods/enablement/WalletMethodListingProcessorMandateWithPayTest.java b/lcm-server/core/src/test/java/in/dreamplug/lcm/server/core/processor/methods/enablement/WalletMethodListingProcessorMandateWithPayTest.java
new file mode 100644
index 00000000..f5fc4346
--- /dev/null
+++ b/lcm-server/core/src/test/java/in/dreamplug/lcm/server/core/processor/methods/enablement/WalletMethodListingProcessorMandateWithPayTest.java
@@ -0,0 +1,268 @@
+package in.dreamplug.lcm.server.core.processor.methods.enablement;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import in.dreamplug.lcm.datatype.PaymentMethod;
+import in.dreamplug.lcm.datatype.PaymentMethodType;
+import in.dreamplug.lcm.datatype.TransactionType;
+import in.dreamplug.lcm.datatype.WalletIssuer;
+import in.dreamplug.lcm.datatype.WalletIssuerDetail;
+import in.dreamplug.lcm.datatype.WalletPaymentMethod;
+import java.util.Arrays;
+import java.util.List;
+import java.util.stream.Collectors;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Test suite for WalletMethodListingProcessor with MANDATE_WITH_PAY transaction type.
+ * Validates that only CRED_BALANCE wallet issuer is enabled for MANDATE_WITH_PAY transactions.
+ */
+class WalletMethodListingProcessorMandateWithPayTest {
+
+    private WalletMethodListingProcessor walletMethodListingProcessor;
+
+    @BeforeEach
+    public void setUp() {
+        walletMethodListingProcessor = new WalletMethodListingProcessor();
+    }
+
+    /**
+     * Test that MANDATE_WITH_PAY transaction type disables all wallet issuers except CRED_BALANCE.
+     */
+    @Test
+    void sanitizePaymentMethodIfSubMethodDisabled_mandateWithPay_disablesNonCredBalanceIssuers() {
+        // Given
+        PaymentMethod walletPaymentMethod =
+                createWalletPaymentMethodForListing(List.of(WalletIssuer.CRED_BALANCE, WalletIssuer.CRED_PPI));
+
+        // When
+        PaymentMethod result = walletMethodListingProcessor.sanitizePaymentMethodIfSubMethodDisabled(
+                walletPaymentMethod, TransactionType.MANDATE_WITH_PAY);
+
+        // Then
+        assertNotNull(result);
+        assertEquals(PaymentMethodType.WALLET, result.getType());
+        assertTrue(result.getEnabled());
+
+        WalletPaymentMethod wallet = result.getWallet();
+        assertNotNull(wallet);
+        assertNotNull(wallet.getIssuers());
+
+        // Verify CRED_BALANCE is enabled
+        WalletIssuerDetail credBalanceIssuer = wallet.getIssuers().stream()
+                .filter(issuer -> issuer.getIssuer() == WalletIssuer.CRED_BALANCE)
+                .findFirst()
+                .orElse(null);
+        assertNotNull(credBalanceIssuer);
+        assertTrue(credBalanceIssuer.getEnabled());
+
+        // Verify CRED_PPI is disabled
+        WalletIssuerDetail credPpiIssuer = wallet.getIssuers().stream()
+                .filter(issuer -> issuer.getIssuer() == WalletIssuer.CRED_PPI)
+                .findFirst()
+                .orElse(null);
+        assertNotNull(credPpiIssuer);
+        assertFalse(credPpiIssuer.getEnabled());
+    }
+
+    /**
+     * Test that only CRED_BALANCE is enabled when all wallet issuers are available for MANDATE_WITH_PAY.
+     */
+    @Test
+    void sanitizePaymentMethodIfSubMethodDisabled_mandateWithPay_onlyCredBalanceEnabled() {
+        // Given
+        PaymentMethod walletPaymentMethod = createWalletPaymentMethodForListing(List.of(WalletIssuer.values()));
+
+        // When
+        PaymentMethod result = walletMethodListingProcessor.sanitizePaymentMethodIfSubMethodDisabled(
+                walletPaymentMethod, TransactionType.MANDATE_WITH_PAY);
+
+        // Then
+        WalletPaymentMethod wallet = result.getWallet();
+        long enabledIssuersCount = wallet.getIssuers().stream()
+                .filter(WalletIssuerDetail::getEnabled)
+                .count();
+
+        assertEquals(1, enabledIssuersCount, "Only one issuer should be enabled for MANDATE_WITH_PAY");
+
+        WalletIssuerDetail enabledIssuer = wallet.getIssuers().stream()
+                .filter(WalletIssuerDetail::getEnabled)
+                .findFirst()
+                .orElse(null);
+        assertNotNull(enabledIssuer);
+        assertEquals(WalletIssuer.CRED_BALANCE, enabledIssuer.getIssuer());
+    }
+
+    /**
+     * Test that PAY transaction type does not disable any wallet issuers.
+     */
+    @Test
+    void sanitizePaymentMethodIfSubMethodDisabled_payTransaction_noIssuersDisabled() {
+        // Given
+        PaymentMethod walletPaymentMethod =
+                createWalletPaymentMethodForListing(List.of(WalletIssuer.CRED_BALANCE, WalletIssuer.CRED_PPI));
+
+        // When
+        PaymentMethod result = walletMethodListingProcessor.sanitizePaymentMethodIfSubMethodDisabled(
+                walletPaymentMethod, TransactionType.PAY);
+
+        // Then
+        WalletPaymentMethod wallet = result.getWallet();
+        long enabledIssuersCount = wallet.getIssuers().stream()
+                .filter(WalletIssuerDetail::getEnabled)
+                .count();
+
+        // Both issuers should remain enabled for PAY transaction
+        assertEquals(2, enabledIssuersCount);
+    }
+
+    /**
+     * Test that MANDATE transaction type does not disable any wallet issuers.
+     */
+    @Test
+    void sanitizePaymentMethodIfSubMethodDisabled_mandateTransaction_noIssuersDisabled() {
+        // Given
+        PaymentMethod walletPaymentMethod =
+                createWalletPaymentMethodForListing(List.of(WalletIssuer.CRED_BALANCE, WalletIssuer.CRED_PPI));
+
+        // When
+        PaymentMethod result = walletMethodListingProcessor.sanitizePaymentMethodIfSubMethodDisabled(
+                walletPaymentMethod, TransactionType.MANDATE);
+
+        // Then
+        WalletPaymentMethod wallet = result.getWallet();
+        long enabledIssuersCount = wallet.getIssuers().stream()
+                .filter(WalletIssuerDetail::getEnabled)
+                .count();
+
+        // Both issuers should remain enabled for MANDATE transaction
+        assertEquals(2, enabledIssuersCount);
+    }
+
+    /**
+     * Test that null transaction type does not disable any wallet issuers.
+     */
+    @Test
+    void sanitizePaymentMethodIfSubMethodDisabled_nullTransactionType_noIssuersDisabled() {
+        // Given
+        PaymentMethod walletPaymentMethod =
+                createWalletPaymentMethodForListing(List.of(WalletIssuer.CRED_BALANCE, WalletIssuer.CRED_PPI));
+
+        // When
+        PaymentMethod result =
+                walletMethodListingProcessor.sanitizePaymentMethodIfSubMethodDisabled(walletPaymentMethod, null);
+
+        // Then
+        WalletPaymentMethod wallet = result.getWallet();
+        long enabledIssuersCount = wallet.getIssuers().stream()
+                .filter(WalletIssuerDetail::getEnabled)
+                .count();
+
+        // Both issuers should remain enabled for null transaction type
+        assertEquals(2, enabledIssuersCount);
+    }
+
+    /**
+     * Test that MANDATE_WITH_PAY with only CRED_BALANCE issuer keeps it enabled.
+     */
+    @Test
+    void sanitizePaymentMethodIfSubMethodDisabled_mandateWithPay_credBalanceOnly() {
+        // Given
+        PaymentMethod walletPaymentMethod = createWalletPaymentMethodForListing(List.of(WalletIssuer.CRED_BALANCE));
+
+        // When
+        PaymentMethod result = walletMethodListingProcessor.sanitizePaymentMethodIfSubMethodDisabled(
+                walletPaymentMethod, TransactionType.MANDATE_WITH_PAY);
+
+        // Then
+        WalletPaymentMethod wallet = result.getWallet();
+        long enabledIssuersCount = wallet.getIssuers().stream()
+                .filter(WalletIssuerDetail::getEnabled)
+                .count();
+
+        assertEquals(1, enabledIssuersCount);
+        WalletIssuerDetail enabledIssuer = wallet.getIssuers().stream()
+                .filter(WalletIssuerDetail::getEnabled)
+                .findFirst()
+                .orElse(null);
+        assertNotNull(enabledIssuer);
+        assertEquals(WalletIssuer.CRED_BALANCE, enabledIssuer.getIssuer());
+    }
+
+    /**
+     * Test that MANDATE_WITH_PAY disables CRED_PPI issuer.
+     */
+    @Test
+    void sanitizePaymentMethodIfSubMethodDisabled_mandateWithPay_credPpiDisabled() {
+        // Given
+        PaymentMethod walletPaymentMethod = createWalletPaymentMethodForListing(List.of(WalletIssuer.CRED_PPI));
+
+        // When
+        PaymentMethod result = walletMethodListingProcessor.sanitizePaymentMethodIfSubMethodDisabled(
+                walletPaymentMethod, TransactionType.MANDATE_WITH_PAY);
+
+        // Then
+        WalletPaymentMethod wallet = result.getWallet();
+        long enabledIssuersCount = wallet.getIssuers().stream()
+                .filter(WalletIssuerDetail::getEnabled)
+                .count();
+
+        assertEquals(0, enabledIssuersCount, "CRED_PPI should be disabled for MANDATE_WITH_PAY");
+
+        WalletIssuerDetail credPpiIssuer = wallet.getIssuers().stream()
+                .filter(issuer -> issuer.getIssuer() == WalletIssuer.CRED_PPI)
+                .findFirst()
+                .orElse(null);
+        assertNotNull(credPpiIssuer);
+        assertFalse(credPpiIssuer.getEnabled());
+    }
+
+    /**
+     * Test that payment method type is correctly identified as WALLET.
+     */
+    @Test
+    void getPaymentMethodType_returnsWallet() {
+        // When
+        PaymentMethodType type = walletMethodListingProcessor.getPaymentMethodType();
+
+        // Then
+        assertEquals(PaymentMethodType.WALLET, type);
+    }
+
+    /**
+     * Test that getEnablementResponseDimensions returns WALLET_ISSUER dimension.
+     */
+    @Test
+    void getEnablementResponseDimensions_returnsWalletIssuerDimension() {
+        // When
+        var dimensions = walletMethodListingProcessor.getEnablementResponseDimensions();
+
+        // Then
+        assertNotNull(dimensions);
+        assertFalse(dimensions.isEmpty());
+    }
+
+    // Helper method
+    private PaymentMethod createWalletPaymentMethodForListing(List<WalletIssuer> walletIssuers) {
+        return new PaymentMethod()
+                .type(PaymentMethodType.WALLET)
+                .enabled(true)
+                .wallet(new WalletPaymentMethod()
+                        .issuers(Arrays.stream(WalletIssuer.values())
+                                .map(walletIssuer -> {
+                                    WalletIssuerDetail walletIssuerDetail =
+                                            new WalletIssuerDetail().issuer(walletIssuer);
+                                    if (walletIssuers.contains(walletIssuer)) {
+                                        walletIssuerDetail.setEnabled(true);
+                                    } else {
+                                        walletIssuerDetail.setEnabled(false);
+                                    }
+                                    return walletIssuerDetail;
+                                })
+                                .collect(Collectors.toList())));
+    }
+}
diff --git a/lcm-server/core/src/test/java/in/dreamplug/lcm/server/core/utility/PaymentDomainUtilsMandateWithPayTest.java b/lcm-server/core/src/test/java/in/dreamplug/lcm/server/core/utility/PaymentDomainUtilsMandateWithPayTest.java
new file mode 100644
index 00000000..4c378a04
--- /dev/null
+++ b/lcm-server/core/src/test/java/in/dreamplug/lcm/server/core/utility/PaymentDomainUtilsMandateWithPayTest.java
@@ -0,0 +1,324 @@
+package in.dreamplug.lcm.server.core.utility;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import in.dreamplug.lcm.datatype.PaymentMethodType;
+import in.dreamplug.lcm.datatype.TransactionType;
+import java.util.List;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Test suite for PaymentDomainUtils with MANDATE_WITH_PAY transaction type support.
+ * Validates that MANDATE_WITH_PAY transaction type includes both UPI and WALLET payment methods.
+ */
+class PaymentDomainUtilsMandateWithPayTest {
+
+    /**
+     * Test that MANDATE_WITH_PAY transaction type includes UPI payment method.
+     */
+    @Test
+    void getPaymentMethodTypes_mandateWithPay_includesUpi() {
+        // When
+        List<PaymentMethodType> result = PaymentDomainUtils.getPaymentMethodTypes(TransactionType.MANDATE_WITH_PAY);
+
+        // Then
+        assertNotNull(result);
+        assertTrue(result.contains(PaymentMethodType.UPI), "UPI should be included for MANDATE_WITH_PAY");
+    }
+
+    /**
+     * Test that MANDATE_WITH_PAY transaction type includes WALLET payment method.
+     */
+    @Test
+    void getPaymentMethodTypes_mandateWithPay_includesWallet() {
+        // When
+        List<PaymentMethodType> result = PaymentDomainUtils.getPaymentMethodTypes(TransactionType.MANDATE_WITH_PAY);
+
+        // Then
+        assertNotNull(result);
+        assertTrue(result.contains(PaymentMethodType.WALLET), "WALLET should be included for MANDATE_WITH_PAY");
+    }
+
+    /**
+     * Test that MANDATE_WITH_PAY transaction type does not include EMANDATE payment method.
+     */
+    @Test
+    void getPaymentMethodTypes_mandateWithPay_excludesEmandate() {
+        // When
+        List<PaymentMethodType> result = PaymentDomainUtils.getPaymentMethodTypes(TransactionType.MANDATE_WITH_PAY);
+
+        // Then
+        assertNotNull(result);
+        assertFalse(
+                result.contains(PaymentMethodType.EMANDATE), "EMANDATE should not be included for MANDATE_WITH_PAY");
+    }
+
+    /**
+     * Test that MANDATE_WITH_PAY transaction type does not include CARD payment method.
+     */
+    @Test
+    void getPaymentMethodTypes_mandateWithPay_excludesCard() {
+        // When
+        List<PaymentMethodType> result = PaymentDomainUtils.getPaymentMethodTypes(TransactionType.MANDATE_WITH_PAY);
+
+        // Then
+        assertNotNull(result);
+        assertFalse(result.contains(PaymentMethodType.CARD), "CARD should not be included for MANDATE_WITH_PAY");
+    }
+
+    /**
+     * Test that MANDATE_WITH_PAY transaction type does not include NETBANKING payment method.
+     */
+    @Test
+    void getPaymentMethodTypes_mandateWithPay_excludesNetbanking() {
+        // When
+        List<PaymentMethodType> result = PaymentDomainUtils.getPaymentMethodTypes(TransactionType.MANDATE_WITH_PAY);
+
+        // Then
+        assertNotNull(result);
+        assertFalse(
+                result.contains(PaymentMethodType.NETBANKING),
+                "NETBANKING should not be included for MANDATE_WITH_PAY");
+    }
+
+    /**
+     * Test that MANDATE_WITH_PAY transaction type does not include BNPL payment method.
+     */
+    @Test
+    void getPaymentMethodTypes_mandateWithPay_excludesBnpl() {
+        // When
+        List<PaymentMethodType> result = PaymentDomainUtils.getPaymentMethodTypes(TransactionType.MANDATE_WITH_PAY);
+
+        // Then
+        assertNotNull(result);
+        assertFalse(result.contains(PaymentMethodType.BNPL), "BNPL should not be included for MANDATE_WITH_PAY");
+    }
+
+    /**
+     * Test that MANDATE_WITH_PAY transaction type does not include REWARD payment method.
+     */
+    @Test
+    void getPaymentMethodTypes_mandateWithPay_excludesReward() {
+        // When
+        List<PaymentMethodType> result = PaymentDomainUtils.getPaymentMethodTypes(TransactionType.MANDATE_WITH_PAY);
+
+        // Then
+        assertNotNull(result);
+        assertFalse(result.contains(PaymentMethodType.REWARD), "REWARD should not be included for MANDATE_WITH_PAY");
+    }
+
+    /**
+     * Test that MANDATE_WITH_PAY transaction type returns exactly 2 payment methods (UPI and WALLET).
+     */
+    @Test
+    void getPaymentMethodTypes_mandateWithPay_returnsExactlyTwoMethods() {
+        // When
+        List<PaymentMethodType> result = PaymentDomainUtils.getPaymentMethodTypes(TransactionType.MANDATE_WITH_PAY);
+
+        // Then
+        assertNotNull(result);
+        assertEquals(2, result.size(), "MANDATE_WITH_PAY should support exactly 2 payment methods");
+    }
+
+    /**
+     * Test that MANDATE transaction type does not include WALLET payment method.
+     */
+    @Test
+    void getPaymentMethodTypes_mandate_excludesWallet() {
+        // When
+        List<PaymentMethodType> result = PaymentDomainUtils.getPaymentMethodTypes(TransactionType.MANDATE);
+
+        // Then
+        assertNotNull(result);
+        assertFalse(result.contains(PaymentMethodType.WALLET), "WALLET should not be included for MANDATE");
+    }
+
+    /**
+     * Test that MANDATE transaction type includes EMANDATE payment method.
+     */
+    @Test
+    void getPaymentMethodTypes_mandate_includesEmandate() {
+        // When
+        List<PaymentMethodType> result = PaymentDomainUtils.getPaymentMethodTypes(TransactionType.MANDATE);
+
+        // Then
+        assertNotNull(result);
+        assertTrue(result.contains(PaymentMethodType.EMANDATE), "EMANDATE should be included for MANDATE");
+    }
+
+    /**
+     * Test that MANDATE transaction type includes UPI payment method.
+     */
+    @Test
+    void getPaymentMethodTypes_mandate_includesUpi() {
+        // When
+        List<PaymentMethodType> result = PaymentDomainUtils.getPaymentMethodTypes(TransactionType.MANDATE);
+
+        // Then
+        assertNotNull(result);
+        assertTrue(result.contains(PaymentMethodType.UPI), "UPI should be included for MANDATE");
+    }
+
+    /**
+     * Test that PAY transaction type includes WALLET payment method.
+     */
+    @Test
+    void getPaymentMethodTypes_pay_includesWallet() {
+        // When
+        List<PaymentMethodType> result = PaymentDomainUtils.getPaymentMethodTypes(TransactionType.PAY);
+
+        // Then
+        assertNotNull(result);
+        assertTrue(result.contains(PaymentMethodType.WALLET), "WALLET should be included for PAY");
+    }
+
+    /**
+     * Test that PAY transaction type includes CARD payment method.
+     */
+    @Test
+    void getPaymentMethodTypes_pay_includesCard() {
+        // When
+        List<PaymentMethodType> result = PaymentDomainUtils.getPaymentMethodTypes(TransactionType.PAY);
+
+        // Then
+        assertNotNull(result);
+        assertTrue(result.contains(PaymentMethodType.CARD), "CARD should be included for PAY");
+    }
+
+    /**
+     * Test that PAY transaction type includes UPI payment method.
+     */
+    @Test
+    void getPaymentMethodTypes_pay_includesUpi() {
+        // When
+        List<PaymentMethodType> result = PaymentDomainUtils.getPaymentMethodTypes(TransactionType.PAY);
+
+        // Then
+        assertNotNull(result);
+        assertTrue(result.contains(PaymentMethodType.UPI), "UPI should be included for PAY");
+    }
+
+    /**
+     * Test that PAY transaction type does not include EMANDATE payment method.
+     */
+    @Test
+    void getPaymentMethodTypes_pay_excludesEmandate() {
+        // When
+        List<PaymentMethodType> result = PaymentDomainUtils.getPaymentMethodTypes(TransactionType.PAY);
+
+        // Then
+        assertNotNull(result);
+        assertFalse(result.contains(PaymentMethodType.EMANDATE), "EMANDATE should not be included for PAY");
+    }
+
+    /**
+     * Test that null transaction type defaults to PAY behavior.
+     */
+    @Test
+    void getPaymentMethodTypes_nullTransactionType_defaultsToPay() {
+        // When
+        List<PaymentMethodType> result = PaymentDomainUtils.getPaymentMethodTypes(null);
+
+        // Then
+        assertNotNull(result);
+        assertTrue(result.contains(PaymentMethodType.WALLET), "WALLET should be included for null transaction type");
+        assertTrue(result.contains(PaymentMethodType.CARD), "CARD should be included for null transaction type");
+        assertFalse(
+                result.contains(PaymentMethodType.EMANDATE),
+                "EMANDATE should not be included for null transaction type");
+    }
+
+    /**
+     * Test that AUTHLESS_PAYMENT_METHODS_SUPPORTED_FOR_MANDATE_AND_TRANSACTION_FLOW contains WALLET.
+     */
+    @Test
+    void authlessPaymentMethodsConstant_includesWallet() {
+        // When
+        List<PaymentMethodType> authlessMethods =
+                PaymentDomainUtils.AUTHLESS_PAYMENT_METHODS_SUPPORTED_FOR_MANDATE_AND_TRANSACTION_FLOW;
+
+        // Then
+        assertNotNull(authlessMethods);
+        assertTrue(authlessMethods.contains(PaymentMethodType.WALLET), "WALLET should be in authless payment methods");
+    }
+
+    /**
+     * Test that AUTHLESS_PAYMENT_METHODS_SUPPORTED_FOR_MANDATE_AND_TRANSACTION_FLOW contains only WALLET.
+     */
+    @Test
+    void authlessPaymentMethodsConstant_containsOnlyWallet() {
+        // When
+        List<PaymentMethodType> authlessMethods =
+                PaymentDomainUtils.AUTHLESS_PAYMENT_METHODS_SUPPORTED_FOR_MANDATE_AND_TRANSACTION_FLOW;
+
+        // Then
+        assertNotNull(authlessMethods);
+        assertEquals(1, authlessMethods.size(), "Only WALLET should be in authless payment methods");
+        assertEquals(PaymentMethodType.WALLET, authlessMethods.get(0));
+    }
+
+    /**
+     * Test that PAYMENT_METHODS_SUPPORTED_FOR_MANDATE_AND_TRANSACTION_FLOW contains UPI.
+     */
+    @Test
+    void mandateAndTransactionFlowConstant_includesUpi() {
+        // When
+        List<PaymentMethodType> mandateAndTransactionMethods =
+                PaymentDomainUtils.PAYMENT_METHODS_SUPPORTED_FOR_MANDATE_AND_TRANSACTION_FLOW;
+
+        // Then
+        assertNotNull(mandateAndTransactionMethods);
+        assertTrue(
+                mandateAndTransactionMethods.contains(PaymentMethodType.UPI),
+                "UPI should be in mandate and transaction flow methods");
+    }
+
+    /**
+     * Test that PAYMENT_METHODS_SUPPORTED_FOR_MANDATE_AND_TRANSACTION_FLOW does not contain WALLET.
+     */
+    @Test
+    void mandateAndTransactionFlowConstant_excludesWallet() {
+        // When
+        List<PaymentMethodType> mandateAndTransactionMethods =
+                PaymentDomainUtils.PAYMENT_METHODS_SUPPORTED_FOR_MANDATE_AND_TRANSACTION_FLOW;
+
+        // Then
+        assertNotNull(mandateAndTransactionMethods);
+        assertFalse(
+                mandateAndTransactionMethods.contains(PaymentMethodType.WALLET),
+                "WALLET should not be in mandate and transaction flow methods");
+    }
+
+    /**
+     * Test that PAYMENT_METHODS_SUPPORTED_ONLY_FOR_MANDATE_FLOW contains EMANDATE.
+     */
+    @Test
+    void mandateOnlyFlowConstant_includesEmandate() {
+        // When
+        List<PaymentMethodType> mandateOnlyMethods = PaymentDomainUtils.PAYMENT_METHODS_SUPPORTED_ONLY_FOR_MANDATE_FLOW;
+
+        // Then
+        assertNotNull(mandateOnlyMethods);
+        assertTrue(
+                mandateOnlyMethods.contains(PaymentMethodType.EMANDATE),
+                "EMANDATE should be in mandate only flow methods");
+    }
+
+    /**
+     * Test that PAYMENT_METHODS_SUPPORTED_ONLY_FOR_MANDATE_FLOW does not contain WALLET.
+     */
+    @Test
+    void mandateOnlyFlowConstant_excludesWallet() {
+        // When
+        List<PaymentMethodType> mandateOnlyMethods = PaymentDomainUtils.PAYMENT_METHODS_SUPPORTED_ONLY_FOR_MANDATE_FLOW;
+
+        // Then
+        assertNotNull(mandateOnlyMethods);
+        assertFalse(
+                mandateOnlyMethods.contains(PaymentMethodType.WALLET),
+                "WALLET should not be in mandate only flow methods");
+    }
+}
diff --git a/openapi-repo b/openapi-repo
index fc483293..68645ed3 160000
--- a/openapi-repo
+++ b/openapi-repo
@@ -1 +1 @@
-Subproject commit fc483293b596c3edbdf866c2a0b931f7c6f5780b
+Subproject commit 68645ed38fa84faf206a182046190221d3c2c3a5
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0100   120    0   120    0     0    301      0 --:--:-- --:--:-- --:--:--   301