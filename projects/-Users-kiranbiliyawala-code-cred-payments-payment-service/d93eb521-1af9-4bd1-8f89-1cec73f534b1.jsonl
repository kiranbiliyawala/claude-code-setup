{"type":"file-history-snapshot","messageId":"d45f605f-3b46-4e1b-98c8-ec586e880e08","snapshot":{"messageId":"d45f605f-3b46-4e1b-98c8-ec586e880e08","trackedFileBackups":{},"timestamp":"2025-12-31T09:26:15.368Z"},"isSnapshotUpdate":false}
{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","type":"user","message":{"role":"user","content":"help me understand this repository step by step as a deep study to become the expert "},"uuid":"d45f605f-3b46-4e1b-98c8-ec586e880e08","timestamp":"2025-12-31T09:26:15.360Z","thinkingMetadata":{"level":"high","disabled":false,"triggers":[]},"todos":[]}
{"parentUuid":"d45f605f-3b46-4e1b-98c8-ec586e880e08","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","type":"user","message":{"role":"user","content":[{"type":"text","text":"[Request interrupted by user]"}]},"uuid":"f17f8c4a-ca2f-4380-8be4-5dd124e1ed3d","timestamp":"2025-12-31T09:26:19.582Z"}
{"type":"file-history-snapshot","messageId":"9ae2a85d-d090-4d6a-b924-d8f0216b466a","snapshot":{"messageId":"9ae2a85d-d090-4d6a-b924-d8f0216b466a","trackedFileBackups":{},"timestamp":"2025-12-31T09:26:28.134Z"},"isSnapshotUpdate":false}
{"parentUuid":"f17f8c4a-ca2f-4380-8be4-5dd124e1ed3d","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","type":"user","message":{"role":"user","content":"help me understand this repository step by step as a deep study to become the expert "},"uuid":"9ae2a85d-d090-4d6a-b924-d8f0216b466a","timestamp":"2025-12-31T09:26:28.128Z","thinkingMetadata":{"level":"high","disabled":false,"triggers":[]},"todos":[]}
{"parentUuid":"9ae2a85d-d090-4d6a-b924-d8f0216b466a","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01FnvSLTb9H4jz1DDyp7YgXf","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user wants to deeply understand this repository (payment-service) to become an expert in it. This is a research/exploration task, not an implementation task. Let me launch multiple Explore agents in parallel to understand different aspects of the codebase comprehensively.\n\nI should explore:\n1. Overall architecture and structure - what are the main components, entry points, configuration\n2. Core business logic - payment flows, transaction handling\n3. Data layer - models, database interactions, external integrations\n\nLet me launch 3 Explore agents in parallel to cover these areas.","signature":"EvMFCkgICxABGAIqQCh/+y+0X8lGmjTUrrOfgPaYieidWTF1jbdamIoWjsFuBPQttT1T8hlcv7rnur3NMp+P2HoBF4l2PPXl/aO5JEYSDFcCL+T6Qu1dejp32BoMxTQXr7uiNYjpDgJLIjCFHwHpd9z75vU11kZ0Zq37jOKyCHEMTpYSCtE0ja2tLxy7s2RPmc3i9LEMORlm1X8q2AQf2TmcjziTqwGhqcawsNb1LQkqMTyRiORLQO5fFTnmE5DvYAkZJdwtitkbNU2l+gBr2qQhWacqVo3+F4Fh20H0rRXBa5IqFV6wUjVQLNd/jBCcQc2ygL11g6N04k8xtwaj+9MtPVDG02jB33nEP3esp+vPUfqH7AczkwFsq/emVbiX+InZTs7K+Yz4p6Rb130malGssazsH3fGcsZZuNJbLRsRarkCy/r9pqEB6pXS8GLwQZEEfuUkzg0OgSWaZO3ZV4/bZ9jG9IPOeghAk161GUbDp7ZLJOv0az62mzHIu5FQ387ip002DmtZ3j881BgxyHzwoeWE60RCIMcEVatjVMQ02C+2bzWU8dUCLR0l+LVHyIaFAhrXwdpNRv290KgxFGCSFH3MuzqKMgh4GsZIUie3Ts4kMNopGV66EQ8C/p9MYOQZWz05QvpKCCFdHgrGArP1Oe7qVbA3ZixkOivyZEXTq4WIIKy2pLKFhAjhcqsrl5sr4itE7c6O2pFLAYyrQlbHYJeBzbKcgWvR8pgnjzqeGViUTSoVGXE+Y1wLrholhEuyUY4X8V9MK2icRyAq+opDtFOxwoweqrEvuQKgF+iagiWRCcIX5sWCGWWR0IxqquZSijBv92gw7ldbU5A0uGxV3x881vAlhquf1Z5/xVfy1iynjbUNZcXcEirgGMi+38xeI79vSj8dTJsnSEftA+QsE7nfGIQlbSibd7PHkL7vgQVt3xwEr/Xqx0omho+qhBYzUhEkkStBk82g8qk92jqIqCxny9vFLEvo574+tUxMPQD5luwYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":1503,"cache_read_input_tokens":22510,"cache_creation":{"ephemeral_5m_input_tokens":1503,"ephemeral_1h_input_tokens":0},"output_tokens":3}},"type":"assistant","uuid":"a4e59707-51f1-4aad-9e57-27c651936e18","timestamp":"2025-12-31T09:26:35.700Z"}
{"parentUuid":"a4e59707-51f1-4aad-9e57-27c651936e18","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01FnvSLTb9H4jz1DDyp7YgXf","type":"message","role":"assistant","content":[{"type":"text","text":"I'll help you become an expert on this payment-service repository. Let me launch multiple exploration agents in parallel to analyze different aspects of the codebase comprehensively."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":1503,"cache_read_input_tokens":22510,"cache_creation":{"ephemeral_5m_input_tokens":1503,"ephemeral_1h_input_tokens":0},"output_tokens":3}},"type":"assistant","uuid":"979d0342-c947-4dd5-b8ef-1936a2825f59","timestamp":"2025-12-31T09:26:36.687Z"}
{"parentUuid":"979d0342-c947-4dd5-b8ef-1936a2825f59","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01FnvSLTb9H4jz1DDyp7YgXf","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_bdrk_01N9VeX9tDhyf13DHUiY5iPh","name":"Task","input":{"description":"Explore overall architecture","prompt":"Thoroughly explore this payment-service repository to understand its overall architecture:\n\n1. What is the project structure? List the main directories and their purposes\n2. What framework/language is this built with?\n3. What are the main entry points (main files, server startup)?\n4. How is the application configured (config files, environment variables)?\n5. What are the key dependencies (package.json, build files)?\n6. Is there a README or documentation explaining the project?\n\nProvide a comprehensive summary with file paths.","subagent_type":"Explore"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":1503,"cache_read_input_tokens":22510,"cache_creation":{"ephemeral_5m_input_tokens":1503,"ephemeral_1h_input_tokens":0},"output_tokens":3}},"type":"assistant","uuid":"06edb2f8-4e73-4d12-8b33-bc251c2b17a9","timestamp":"2025-12-31T09:26:39.844Z"}
{"parentUuid":"06edb2f8-4e73-4d12-8b33-bc251c2b17a9","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01FnvSLTb9H4jz1DDyp7YgXf","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_bdrk_019Kx8JCAgFCfPmv88K9BkE6","name":"Task","input":{"description":"Explore core payment logic","prompt":"Thoroughly explore this payment-service repository to understand its core business logic:\n\n1. What are the main payment flows and transaction types supported?\n2. What are the key services/controllers handling payments?\n3. How are payment intents/transactions created and processed?\n4. What payment providers/gateways are integrated?\n5. How is error handling done for payment failures?\n6. Are there any state machines or workflow engines for payment states?\n\nProvide detailed findings with specific file paths and code locations.","subagent_type":"Explore"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":1503,"cache_read_input_tokens":22510,"cache_creation":{"ephemeral_5m_input_tokens":1503,"ephemeral_1h_input_tokens":0},"output_tokens":3}},"type":"assistant","uuid":"37650ee2-7d9e-424a-9603-500a4dc0181a","timestamp":"2025-12-31T09:26:41.959Z"}
{"parentUuid":"37650ee2-7d9e-424a-9603-500a4dc0181a","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01FnvSLTb9H4jz1DDyp7YgXf","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_bdrk_01J7tMBo9w7W5XgDRKnJDe71","name":"Task","input":{"description":"Explore data and integrations","prompt":"Thoroughly explore this payment-service repository to understand its data layer and external integrations:\n\n1. What database(s) are used? Find database configuration and connection handling\n2. What are the main data models/entities (transactions, payments, users, etc.)?\n3. What external services/APIs does this integrate with?\n4. How is caching implemented (Redis, in-memory)?\n5. What message queues or async processing patterns are used?\n6. How are API endpoints structured (REST, GraphQL)?\n7. What authentication/authorization mechanisms are in place?\n\nProvide detailed findings with specific file paths.","subagent_type":"Explore"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":1503,"cache_read_input_tokens":22510,"cache_creation":{"ephemeral_5m_input_tokens":1503,"ephemeral_1h_input_tokens":0},"output_tokens":762}},"type":"assistant","uuid":"0ae61da5-0577-4aed-bcb8-073507539c62","timestamp":"2025-12-31T09:26:44.616Z"}
{"parentUuid":"0ae61da5-0577-4aed-bcb8-073507539c62","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01N9VeX9tDhyf13DHUiY5iPh","type":"tool_result","content":[{"type":"text","text":"Excellent! Now I have enough information. Let me compile the comprehensive summary:\n\n## Comprehensive Payment-Service Repository Architecture\n\nI've thoroughly explored the payment-service repository. Here's a detailed analysis:\n\n### 1. Project Structure\n\n**Main Directory Layout:**\n```\n/Users/kiranbiliyawala/code/cred/payments/payment-service/\n├── src/\n│   ├── main/\n│   │   ├── java/in/dreamplug/darwin/      (1,093 Java files)\n│   │   └── resources/\n│   │       └── application.properties      (95KB config file)\n│   └── test/\n│       ├── java/\n│       └── resources/fixtures/             (Test data)\n├── codepipeline/                           (CI/CD configurations)\n├── build.gradle                            (Gradle build config)\n├── Dockerfile                              (Docker container setup)\n├── bitbucket-pipelines.yml                 (Bitbucket CI/CD)\n├── README.md                               (Documentation)\n└── settings.gradle                         (Gradle settings)\n```\n\n### 2. Framework & Language\n\n**Technology Stack:**\n- **Language:** Java 17 (as per .sdkmanrc: `java=17.0.9-amzn`)\n- **Build Tool:** Gradle 7.6\n- **Framework:** Spring Boot 2.7.14\n  - Spring Web (REST API)\n  - Spring Data JPA (Hibernate ORM)\n  - Spring Retry\n  - Spring AOP\n  - Spring Scheduling\n- **Project Name:** Darwin (internal name for payment-service)\n- **Group:** `in.dreamplug.payment`\n- **Version:** 1.0.0-SNAPSHOT\n\n**Key File:**\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/build.gradle`\n\n### 3. Main Entry Points\n\n**Application Startup Class:**\n- File: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/DarwinApplication.java`\n- Main Method: Runs Spring Boot application\n- Port: 9010 (configured in application.properties)\n- Context Path: `/payments`\n- Features:\n  - RetryEnable, EntityScan, AspectJAutoProxy, Scheduling, ComponentScan configured\n  - Sets UTC timezone globally\n\n**Server Configuration:**\n- Port: 9010\n- Context Path: `/payments`\n- Servlet Multipart Max File Size: 128KB\n- Actuator Endpoints: Exposed on health, metrics, mappings, scheduledtasks, etc.\n\n### 4. Configuration\n\n**Configuration Files:**\n\n1. **Main Config:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/resources/application.properties` (1,309 lines)\n   - Database connections (MySQL master/replica)\n   - External service clients (payment gateways, microservices)\n   - AWS configuration (SQS, DynamoDB, S3)\n   - Kafka/Eventi configuration\n   - Redis configuration\n   - Logging levels\n\n2. **Environment-specific Configs:** Located in `/Users/kiranbiliyawala/code/cred/payments/payment-service/codepipeline/configs/`\n   - `stage.yaml`\n   - `dpsplcat1.yaml`\n   - `uat.yaml`\n   - Shadow configs (for testing)\n\n**Key Environment Variables Used:**\n- `DB_HOST`, `DB_USER`, `DB_PASSWORD` (MySQL master)\n- `REPLICA_DB_HOST`, `REPLICA_DB_USER`, `REPLICA_DB_PASSWORD` (MySQL replica)\n- `AWS_*` variables (for AWS services)\n- `REDIS_*` variables (for caching)\n- `DP_RUN_ENV` (deployment environment)\n\n### 5. Key Dependencies\n\n**Major External Client Libraries:**\n- **Payment Gateways:**\n  - Razorpay (multiple versions)\n  - Juspay\n  - PayU\n  - Cashfree\n  - Cybersource\n  - Digio\n  - MPGS (Mastercard)\n  - Pinelabs\n  - Lazypay\n\n- **UPI/Banking:**\n  - Axis UPI, ICICI UPI, YBL UPI, RBL UPI\n  - Various net banking providers\n\n- **Internal Services:**\n  - payment-domain (v1.10.26)\n  - fees (v0.18.0)\n  - pricing-utils\n  - user-service-client\n  - merchant-service-client\n  - mandate-java-client\n  - genie-java-client\n  - arsenal (instrument vault)\n  - falcon (offers/promotions)\n\n- **Infrastructure:**\n  - MySQL connector\n  - Spring Cloud AWS\n  - Redisson (Redis)\n  - Kafka messaging\n  - AWS SQS/DynamoDB SDKs\n  - Datadog metrics\n\n- **Development Tools:**\n  - Lombok\n  - MapStruct\n  - JaCoCo (code coverage)\n  - SonarQube\n\n**Build File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/build.gradle`\n\n### 6. Documentation\n\n**README Location:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/README.md`\n\n**Key Documentation Sections:**\n1. **Git Hooks Setup** - Pre-commit formatting using Prettier\n2. **Local Development** - Instructions for:\n   - Installing sdkmanrc\n   - Setting Java/Gradle versions\n   - OKTA IAM setup for AWS credentials\n   - Running service locally with environment variables\n3. **Deployment** - Canary deployment process with Jenkins:\n   - Traffic routing using ALB controller\n   - Monitoring on Datadog/Coralogix\n   - Rollback procedures\n\n### 7. Main Directory Purposes\n\nKey Package Directories:\n```\nin/dreamplug/darwin/\n├── controller/          - REST API endpoints (payment, orders, webhooks, admin)\n├── service/             - Business logic (payment processing, refunds, fees)\n├── repository/          - Data access layer\n├── entity/              - JPA domain entities (Order, Payment, Refund, etc.)\n├── provider/            - Payment provider integrations\n├── dao/                 - Custom data access objects\n├── configuration/       - Spring configuration classes\n├── cache/               - Caching layer (Caffeine cache)\n├── client/              - External service clients\n├── validators/          - Request/business validation\n├── statemachine/        - Payment state machine workflows\n├── workflow/            - Orchestration workflows\n├── planner/             - Decision tree/routing logic\n├── dto/                 - Request/response DTOs\n├── interceptors/        - Spring interceptors\n├── commons/             - Shared utilities\n├── error/               - Error handling\n├── event/               - Event publishing\n├── kafka/               - Kafka producer/consumer\n├── sqs/                 - AWS SQS message handling\n├── v2/                  - V2 API implementation\n└── adapter/             - Adapter pattern implementations\n```\n\n### 8. CI/CD Infrastructure\n\n**Build & Deployment:**\n- **Gradle Build Script:** `build.gradle` (with SonarQube, JaCoCo integration)\n- **Docker:** `Dockerfile` (CorettoJRE-17 base, Datadog Java agent)\n- **Jenkins Pipelines:** Multiple Jenkinsfiles for:\n  - `/Users/kiranbiliyawala/code/cred/payments/payment-service/codepipeline/Jenkinsfile.env-dpsplcat1.groovy`\n  - `/Users/kiranbiliyawala/code/cred/payments/payment-service/codepipeline/Jenkinsfile.env-stage.groovy`\n  - Canary deployments with traffic control\n  - Shadow deployments\n\n### 9. Key Controllers & APIs\n\n**Main REST Controllers:**\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/controller/WebhookController.java` - POST `/v1/webhooks`\n- Order controllers (admin/client)\n- Payment controllers (initiation, status)\n- Refund controllers (creation, reversal)\n- Payment attempt controllers\n- Downtime controllers (maintenance mode)\n- Auth token controllers\n- Provider account controllers\n- Payment method/bank controllers\n\n### 10. Database\n\n**Type:** MySQL (Master-Replica architecture)\n- **Master:** Used for writes\n- **Replica:** Used for reads (configurable per provider)\n- **Connection Pooling:** HikariCP\n- **ORM:** Hibernate with JPA\n- **Multi-tenancy:** `payments_multi_tenancy` database\n\n### 11. External Integrations\n\nThe service integrates with:\n- **30+ Payment Providers** (Razorpay, Juspay, PayU, Cashfree, etc.)\n- **AWS Services** (SQS, DynamoDB, S3, KMS, CloudWatch)\n- **Internal Microservices** (User Service, Merchant Service, Mandate Service, etc.)\n- **Messaging** (Kafka, SNS, SQS)\n- **Caching** (Redis/ElastiCache)\n- **Monitoring** (Datadog, StatsD, Prometheus)\n\nThis is a comprehensive, enterprise-grade payment processing microservice built with Spring Boot, handling multi-provider payment orchestration with state machines, decision trees, dynamic routing, and extensive integration capabilities."},{"type":"text","text":"agentId: a2925c7 (for resuming to continue this agent's work if needed)"}]}]},"uuid":"3a2f6755-1af9-4441-bbd1-b0b7a0e4f75e","timestamp":"2025-12-31T09:27:45.464Z","toolUseResult":{"status":"completed","prompt":"Thoroughly explore this payment-service repository to understand its overall architecture:\n\n1. What is the project structure? List the main directories and their purposes\n2. What framework/language is this built with?\n3. What are the main entry points (main files, server startup)?\n4. How is the application configured (config files, environment variables)?\n5. What are the key dependencies (package.json, build files)?\n6. Is there a README or documentation explaining the project?\n\nProvide a comprehensive summary with file paths.","agentId":"a2925c7","content":[{"type":"text","text":"Excellent! Now I have enough information. Let me compile the comprehensive summary:\n\n## Comprehensive Payment-Service Repository Architecture\n\nI've thoroughly explored the payment-service repository. Here's a detailed analysis:\n\n### 1. Project Structure\n\n**Main Directory Layout:**\n```\n/Users/kiranbiliyawala/code/cred/payments/payment-service/\n├── src/\n│   ├── main/\n│   │   ├── java/in/dreamplug/darwin/      (1,093 Java files)\n│   │   └── resources/\n│   │       └── application.properties      (95KB config file)\n│   └── test/\n│       ├── java/\n│       └── resources/fixtures/             (Test data)\n├── codepipeline/                           (CI/CD configurations)\n├── build.gradle                            (Gradle build config)\n├── Dockerfile                              (Docker container setup)\n├── bitbucket-pipelines.yml                 (Bitbucket CI/CD)\n├── README.md                               (Documentation)\n└── settings.gradle                         (Gradle settings)\n```\n\n### 2. Framework & Language\n\n**Technology Stack:**\n- **Language:** Java 17 (as per .sdkmanrc: `java=17.0.9-amzn`)\n- **Build Tool:** Gradle 7.6\n- **Framework:** Spring Boot 2.7.14\n  - Spring Web (REST API)\n  - Spring Data JPA (Hibernate ORM)\n  - Spring Retry\n  - Spring AOP\n  - Spring Scheduling\n- **Project Name:** Darwin (internal name for payment-service)\n- **Group:** `in.dreamplug.payment`\n- **Version:** 1.0.0-SNAPSHOT\n\n**Key File:**\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/build.gradle`\n\n### 3. Main Entry Points\n\n**Application Startup Class:**\n- File: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/DarwinApplication.java`\n- Main Method: Runs Spring Boot application\n- Port: 9010 (configured in application.properties)\n- Context Path: `/payments`\n- Features:\n  - RetryEnable, EntityScan, AspectJAutoProxy, Scheduling, ComponentScan configured\n  - Sets UTC timezone globally\n\n**Server Configuration:**\n- Port: 9010\n- Context Path: `/payments`\n- Servlet Multipart Max File Size: 128KB\n- Actuator Endpoints: Exposed on health, metrics, mappings, scheduledtasks, etc.\n\n### 4. Configuration\n\n**Configuration Files:**\n\n1. **Main Config:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/resources/application.properties` (1,309 lines)\n   - Database connections (MySQL master/replica)\n   - External service clients (payment gateways, microservices)\n   - AWS configuration (SQS, DynamoDB, S3)\n   - Kafka/Eventi configuration\n   - Redis configuration\n   - Logging levels\n\n2. **Environment-specific Configs:** Located in `/Users/kiranbiliyawala/code/cred/payments/payment-service/codepipeline/configs/`\n   - `stage.yaml`\n   - `dpsplcat1.yaml`\n   - `uat.yaml`\n   - Shadow configs (for testing)\n\n**Key Environment Variables Used:**\n- `DB_HOST`, `DB_USER`, `DB_PASSWORD` (MySQL master)\n- `REPLICA_DB_HOST`, `REPLICA_DB_USER`, `REPLICA_DB_PASSWORD` (MySQL replica)\n- `AWS_*` variables (for AWS services)\n- `REDIS_*` variables (for caching)\n- `DP_RUN_ENV` (deployment environment)\n\n### 5. Key Dependencies\n\n**Major External Client Libraries:**\n- **Payment Gateways:**\n  - Razorpay (multiple versions)\n  - Juspay\n  - PayU\n  - Cashfree\n  - Cybersource\n  - Digio\n  - MPGS (Mastercard)\n  - Pinelabs\n  - Lazypay\n\n- **UPI/Banking:**\n  - Axis UPI, ICICI UPI, YBL UPI, RBL UPI\n  - Various net banking providers\n\n- **Internal Services:**\n  - payment-domain (v1.10.26)\n  - fees (v0.18.0)\n  - pricing-utils\n  - user-service-client\n  - merchant-service-client\n  - mandate-java-client\n  - genie-java-client\n  - arsenal (instrument vault)\n  - falcon (offers/promotions)\n\n- **Infrastructure:**\n  - MySQL connector\n  - Spring Cloud AWS\n  - Redisson (Redis)\n  - Kafka messaging\n  - AWS SQS/DynamoDB SDKs\n  - Datadog metrics\n\n- **Development Tools:**\n  - Lombok\n  - MapStruct\n  - JaCoCo (code coverage)\n  - SonarQube\n\n**Build File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/build.gradle`\n\n### 6. Documentation\n\n**README Location:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/README.md`\n\n**Key Documentation Sections:**\n1. **Git Hooks Setup** - Pre-commit formatting using Prettier\n2. **Local Development** - Instructions for:\n   - Installing sdkmanrc\n   - Setting Java/Gradle versions\n   - OKTA IAM setup for AWS credentials\n   - Running service locally with environment variables\n3. **Deployment** - Canary deployment process with Jenkins:\n   - Traffic routing using ALB controller\n   - Monitoring on Datadog/Coralogix\n   - Rollback procedures\n\n### 7. Main Directory Purposes\n\nKey Package Directories:\n```\nin/dreamplug/darwin/\n├── controller/          - REST API endpoints (payment, orders, webhooks, admin)\n├── service/             - Business logic (payment processing, refunds, fees)\n├── repository/          - Data access layer\n├── entity/              - JPA domain entities (Order, Payment, Refund, etc.)\n├── provider/            - Payment provider integrations\n├── dao/                 - Custom data access objects\n├── configuration/       - Spring configuration classes\n├── cache/               - Caching layer (Caffeine cache)\n├── client/              - External service clients\n├── validators/          - Request/business validation\n├── statemachine/        - Payment state machine workflows\n├── workflow/            - Orchestration workflows\n├── planner/             - Decision tree/routing logic\n├── dto/                 - Request/response DTOs\n├── interceptors/        - Spring interceptors\n├── commons/             - Shared utilities\n├── error/               - Error handling\n├── event/               - Event publishing\n├── kafka/               - Kafka producer/consumer\n├── sqs/                 - AWS SQS message handling\n├── v2/                  - V2 API implementation\n└── adapter/             - Adapter pattern implementations\n```\n\n### 8. CI/CD Infrastructure\n\n**Build & Deployment:**\n- **Gradle Build Script:** `build.gradle` (with SonarQube, JaCoCo integration)\n- **Docker:** `Dockerfile` (CorettoJRE-17 base, Datadog Java agent)\n- **Jenkins Pipelines:** Multiple Jenkinsfiles for:\n  - `/Users/kiranbiliyawala/code/cred/payments/payment-service/codepipeline/Jenkinsfile.env-dpsplcat1.groovy`\n  - `/Users/kiranbiliyawala/code/cred/payments/payment-service/codepipeline/Jenkinsfile.env-stage.groovy`\n  - Canary deployments with traffic control\n  - Shadow deployments\n\n### 9. Key Controllers & APIs\n\n**Main REST Controllers:**\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/controller/WebhookController.java` - POST `/v1/webhooks`\n- Order controllers (admin/client)\n- Payment controllers (initiation, status)\n- Refund controllers (creation, reversal)\n- Payment attempt controllers\n- Downtime controllers (maintenance mode)\n- Auth token controllers\n- Provider account controllers\n- Payment method/bank controllers\n\n### 10. Database\n\n**Type:** MySQL (Master-Replica architecture)\n- **Master:** Used for writes\n- **Replica:** Used for reads (configurable per provider)\n- **Connection Pooling:** HikariCP\n- **ORM:** Hibernate with JPA\n- **Multi-tenancy:** `payments_multi_tenancy` database\n\n### 11. External Integrations\n\nThe service integrates with:\n- **30+ Payment Providers** (Razorpay, Juspay, PayU, Cashfree, etc.)\n- **AWS Services** (SQS, DynamoDB, S3, KMS, CloudWatch)\n- **Internal Microservices** (User Service, Merchant Service, Mandate Service, etc.)\n- **Messaging** (Kafka, SNS, SQS)\n- **Caching** (Redis/ElastiCache)\n- **Monitoring** (Datadog, StatsD, Prometheus)\n\nThis is a comprehensive, enterprise-grade payment processing microservice built with Spring Boot, handling multi-provider payment orchestration with state machines, decision trees, dynamic routing, and extensive integration capabilities."}],"totalDurationMs":60683,"totalTokens":78446,"totalToolUseCount":26,"usage":{"input_tokens":7,"cache_creation_input_tokens":2037,"cache_read_input_tokens":74073,"cache_creation":{"ephemeral_5m_input_tokens":2037,"ephemeral_1h_input_tokens":0},"output_tokens":2329}}}
{"parentUuid":"3a2f6755-1af9-4441-bbd1-b0b7a0e4f75e","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_019Kx8JCAgFCfPmv88K9BkE6","type":"tool_result","content":[{"type":"text","text":"Perfect! I now have enough information to compile a comprehensive report. Let me generate the findings:\n\n## COMPREHENSIVE PAYMENT SERVICE ARCHITECTURE ANALYSIS\n\nBased on my thorough exploration of the payment-service repository, here are the detailed findings on the core business logic and payment infrastructure:\n\n### 1. MAIN PAYMENT FLOWS AND TRANSACTION TYPES SUPPORTED\n\n**Payment Flow Architecture:**\n- **Bulk Payment Creation Flow**: Clients create multiple payments for orders via `/v2/orders/{orderId}/payments` endpoint\n- **Payment Attempt Flow**: Create individual payment attempts via `/v2/payments/{paymentId}/attempts` or `/v2/payments/by-order-id/{orderId}/attempts`\n- **Authentication Flow**: Supports 3DS authentication, native OTP, and redirect-based authentication\n- **Capture & Refund Flow**: Authorize and capture transactions, then process refunds\n\n**Supported Transaction Types:**\n- **Card Payments**: Credit/Debit cards with 3DS authentication\n- **UPI (Unified Payments Interface)**: Multiple variants:\n  - UPI Apps (Phonepe, Google Pay, BHIM, etc.)\n  - UPI Collect\n  - UPI Credential-based\n- **Net Banking**: Multiple issuer support\n- **E-Mandates**: Recurring payment authorizations with token management\n- **Reward Points/Cred Coins**: Internal redemption mechanisms\n- **Push Payments**: Direct account transfers\n\n### 2. KEY SERVICES/CONTROLLERS HANDLING PAYMENTS\n\n**Main Controllers:**\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/controller/v2/payment/PaymentV2Controller.java` - Bulk payment creation\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/controller/v2/paymentattempt/PaymentAttemptV2Controller.java` - Payment attempt endpoints\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/controller/v2/order/OrderV2Controller.java` - Order management\n\n**Payment Services:**\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/service/PaymentAttemptService.java` - Core payment attempt logic\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/service/PaymentProviderService.java` - Provider management\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/service/WspService.java` - White Space Platform integration for native OTP\n\n### 3. PAYMENT INTENTS/TRANSACTIONS CREATION AND PROCESSING\n\n**Payment Intent/Transaction Creation Architecture:**\n\n**Step 1: Bulk Payment Creation** (`BulkPaymentCreateWorkflow.java`):\n- File: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/payments/bulk/BulkPaymentCreateWorkflow.java`\n- Validates order entity and creates multiple `PaymentV2Entity` objects\n- Payment modes prioritized (sorted by execution priority)\n- Existing non-discarded payments are marked for discard to prevent duplicates\n\n**Step 2: Payment Attempt Creation** (`PaymentAttemptCreateWorkflow.java`):\n- File: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java`\n- **Data Enrichment Pipeline**:\n  1. **Instrument Validation & Enrichment**: Via `InstrumentTypeProcessorManager` - validates payment instrument compatibility with payment mode\n  2. **Decision Tree Routing**: `ProviderDeciderRouter` determines optimal payment provider based on:\n     - Client configurations\n     - Instrument type\n     - Order characteristics\n     - Customer data\n  3. **Auth Type Decision**: Via `AuthTypeDeciderFactory` - determines 3DS requirement, native OTP, or no-auth\n  4. **Settlement Route Validation**: Via `SettlementRouteValidator` - ensures proper settlement configuration\n\n- **Entity Creation**:\n  - Creates `PaymentAttemptV2Entity` with CREATED status\n  - Generates unique external ID via `PaymentAttemptUUIdGenerator`\n  - Stores routing decision results in attributes\n  - Associates with provider account\n\n**Step 3: Processing** (Processor Phase):\n- Calls appropriate `IPaymentProviderAdapter` implementation\n- Provider-specific request building and API invocation\n- Response handling and status update based on provider response\n\n**Step 4: Post-Processing**:\n- Updates payment attempt entity with provider response\n- Sets provider reference ID and gateway reference ID\n- Updates status to PROCESSING, COMPLETED, or FAILED based on provider status\n\n### 4. PAYMENT PROVIDERS/GATEWAYS INTEGRATED\n\n**Provider Adapters Located**: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/providers/`\n\n**Major Payment Providers Integrated** (24+ adapter implementations):\n\n1. **Cybersource** - `CybersourceProviderAdapter.java`\n   - 3DS payment processing\n   - Supports Cards, E-Mandates\n   - Transaction search and reconciliation\n   - Multi-application flow support (ics_bill, ics_auth, ics_pa_validate)\n\n2. **Cashfree** - `CashfreeProviderAdapter.java` + variants\n   - Card payments: `CashfreeCardProviderAdapter.java`\n   - Net Banking: `CashfreeNetBankingProviderAdapter.java`\n   - UPI variants: `CashfreeUPIProviderAdapter.java`, `CashfreeUPIAppsProviderAdapter.java`, `CashfreeUPICredProviderAdapter.java`\n\n3. **PayU** - `PayuProviderAdapter.java` + variants\n   - Card: `PayuCardProviderAdapter.java`\n   - Net Banking: `PayuNetBankingProviderAdapter.java`\n\n4. **Pine Labs Edge** - `PineLabsEdgeProviderAdapter.java` + variants\n   - Multiple payment mode variants\n\n5. **Razorpay** - `RazorpayWebhookController.java` (webhook endpoint)\n\n6. **Juspay** - `JuspayWebhookController.java`\n\n7. **ICICI Bank** - `ICICIWebhookController.java`\n\n8. **Yes Bank (YBL)** - `YBLWebhookController.java`\n\n9. **RBL UPI** - `RBLUpiWebhookController.java`\n\n10. **Digio** - `DigioWebhookController.java` + `DigioMandateRegisterProviderAdapter.java`\n\n11. **Cred Coins/Reward Points** - `CredPointsProviderAdapter.java`, `RewardPointsProviderAdapter.java`\n\n12. **Native Auth Token** - `AuthTokenNativeProviderAdapter.java`\n\n**Provider Selection Logic** (`ProviderDeciderRouter.java`):\n- Routes through **LCM (LendingCloudManager)** if enabled for instrument type\n- Falls back to **Decision Tree (DT)** engine for dynamic routing\n- Decision trees are JSON-based rule configurations cached in `DecisionTreeObjectCache`\n\n### 5. ERROR HANDLING FOR PAYMENT FAILURES\n\n**Error Framework** (`Error.java`):\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/error/Error.java`\n- Enum-based error definitions with HTTP status codes and messages\n\n**Key Error Types**:\n- `provider_api_failure` - Generic provider API errors\n- `invalid_payment_id`, `invalid_order_id` - Invalid entity references\n- `payment_retry_not_allowed` - Terminal order states\n- `completed_transactions_already_exists` - Duplicate completion prevention\n- `order_flow_type_not_supported` - Provider doesn't support order flow\n- `fee_validation_failure` - Fee calculation mismatches\n- `incompatible_instrument_type_for_payment_mode` - Instrument validation errors\n\n**Error Handling Mechanisms**:\n\n1. **Custom Exceptions**:\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/error/ProviderException.java`\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/error/ProviderRetryableFailureException.java`\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/error/WalletProviderException.java`\n\n2. **Provider Error Mapping**:\n   - `PaymentErrorMessageMappingService` - Maps provider-specific error codes to user-friendly messages\n   - Cached in `PaymentErrorMessageMappingCache`\n\n3. **Response Handling** (in `PaymentAttemptCreateWorkflow.postProcess()`):\n   ```\n   - ProviderRequestStatus.REQUEST_SUCCESS: Payment processed successfully\n   - ProviderRequestStatus.TIMED_OUT: Set error code to TIMED_OUT\n   - Other statuses: Determine if PROCESSING or FAILED based on payment mode\n   - Failed statuses (per Cybersource): 101-211, 220-251, 400-461, 476, 480-481, 520, 700-703\n   - Processing statuses: 110, 475, 480\n   ```\n\n4. **Workflow Error Collection**:\n   - `PaymentAttemptCreateContext` collects `WorkflowInternalError` objects\n   - Exception handler converts workflow errors to `AppException` in `throwErrorIfRequired()`\n\n5. **Global Exception Handler**:\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/commons/spring/filters/DarwinResponseEntityExceptionHandler.java`\n\n### 6. STATE MACHINES AND WORKFLOW ENGINES\n\n**State Machine Architecture:**\n\n**Payment State Machine** (`PaymentStateMachine.java`):\n- File: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/statemachine/payment/PaymentStateMachine.java`\n- **Event-driven** using Google's EventBus\n- **Event Types** published via `PaymentAttemptEventFactory`:\n  - `PaymentAttemptCreatedEvent` → Updates payment status if payment was FAILED\n  - `PaymentAttemptCompletedEvent` → Updates payment to COMPLETED\n  - `PaymentAttemptAuthorizedEvent` → Updates payment to AUTHORIZED\n  - `PaymentAttemptFailedEvent` → Updates payment to FAILED if no other active attempts\n  - `PaymentAttemptProcessingEvent` → Updates payment to PROCESSING\n  - `PaymentAttemptBlockedEvent` → Updates payment to BLOCKED\n  - `PaymentAttemptAuthenticationSuccessfulEvent` → Updates to AUTHENTICATION_SUCCESSFUL\n  - `PaymentAttemptAuthenticationFailedEvent` → Updates to AUTHENTICATION_FAILED\n  - `PaymentAttemptReversedEvent` → Updates to FAILED\n\n**Payment Status Transitions** (Terminal Statuses: COMPLETED, FAILED, FORCE_FAILED, DISCARDED):\n- CREATED → PROCESSING → AUTHORIZED → COMPLETED\n- CREATED → PROCESSING → COMPLETED (direct)\n- CREATED → FAILED\n- AUTHENTICATION_SUCCESSFUL → AUTHORIZED/COMPLETED\n- Any → BLOCKED\n\n**Order State Machine** (`OrderStateMachine.java`):\n- File: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/statemachine/order/OrderStateMachine.java`\n- Subscribes to payment events\n- **Order Status Transitions**:\n  - `CREATED` → `PROCESSING` (on payment processing)\n  - `CREATED` → `COMPLETED` (when all payments completed)\n  - Any → `FAILED` (when payment fails and no other active attempts)\n  - Special: `AUTHLESS_READY_TO_PROCESS` (for non-auth requiring payments matching order amount)\n\n**Refund State Machine** (`RefundStateMachine.java`, `RefundAttemptStateMachine.java`):\n- File: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/statemachine/RefundStateMachine.java`\n- Manages refund lifecycle (CREATED, PROCESSING, COMPLETED, FAILED, MANUAL_REVIEW)\n\n**Workflow Execution**:\n- Base workflow class: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/Workflow.java`\n- **Execution Pipeline**:\n  1. `validateAndEnrichContext()` - Validate inputs, enrich with business data\n  2. `persistIntent()` - Save entities to database\n  3. `persistNonRelationalIntent()` - Save to DynamoDB (e.g., native OTP details)\n  4. `process()` - Execute core business logic (provider API calls)\n  5. `postProcess()` - Transform results to response objects\n  6. `postPersistNonRelationalDataStore()` - Update non-relational stores\n  7. `publishEntityChangeEvents()` - Post events to event bus for state machines\n  8. `throwErrorIfRequired()` - Throw exceptions if workflow failed\n\n**3DS/Authentication Workflow** (for cards requiring 3DS):\n- `PaymentAttempt3DSWorkflowExecutor` - Manages multi-step 3DS flows\n- `PaymentAttemptInitiateAuthenticationWorkflow` - Generates authentication challenge\n- `PaymentAttemptAuthenticateWorkflow` - Submits authentication response\n- `PaymentAttemptValidateAuthenticationWorkflow` - Validates auth completion\n\n**Entity Lifecycle Example** (Payment Attempt):\n1. Created with status CREATED\n2. Provider adapter called → status updates based on response\n3. EventBus publishes appropriate event\n4. State machines react and transition parent entities\n5. Eventos service publishes to analytics/webhooks\n6. SyncManager queues for distributed sync\n\n**Key Architectural Components**:\n\n| Component | File Location | Purpose |\n|-----------|---------------|---------|\n| Payment Intent Creator | `PaymentAttemptCreateWorkflow.java` | Creates payment attempt entities |\n| Provider Router | `ProviderDeciderRouter.java` | Routes to appropriate payment provider |\n| Provider Adapter Registry | `PaymentProviderFactory.java` | Dynamically selects provider adapter |\n| Decision Tree Engine | `DecisionTreeWorkflow.java` | Rule-based provider selection |\n| Event Publisher | `EventBus` (Guava) | Publishes payment events synchronously |\n| State Machines | `PaymentStateMachine`, `OrderStateMachine` | React to events and update entity states |\n| Webhook Handlers | Multiple `*WebhookController` | Receive async updates from providers |\n| Fee Engine | `FeeService`, `FeeCreateWorkflow` | Calculates and applies transaction fees |\n| Mandate Service | `MandateServiceDataManager` | Manages recurring payment authorizations |\n| Authentication Service | `AuthenticationService` | Handles 3DS redirects and OTP |\n| Sync Module | `SyncManager` | Distributes changes across systems |\n\nThis architecture provides a highly flexible, provider-agnostic payment processing system with comprehensive error handling, state management, and event-driven workflows."},{"type":"text","text":"agentId: a71d77d (for resuming to continue this agent's work if needed)"}]}]},"uuid":"362d93a3-3a47-424e-8aaf-bd633fc4c78e","timestamp":"2025-12-31T09:28:32.576Z","toolUseResult":{"status":"completed","prompt":"Thoroughly explore this payment-service repository to understand its core business logic:\n\n1. What are the main payment flows and transaction types supported?\n2. What are the key services/controllers handling payments?\n3. How are payment intents/transactions created and processed?\n4. What payment providers/gateways are integrated?\n5. How is error handling done for payment failures?\n6. Are there any state machines or workflow engines for payment states?\n\nProvide detailed findings with specific file paths and code locations.","agentId":"a71d77d","content":[{"type":"text","text":"Perfect! I now have enough information to compile a comprehensive report. Let me generate the findings:\n\n## COMPREHENSIVE PAYMENT SERVICE ARCHITECTURE ANALYSIS\n\nBased on my thorough exploration of the payment-service repository, here are the detailed findings on the core business logic and payment infrastructure:\n\n### 1. MAIN PAYMENT FLOWS AND TRANSACTION TYPES SUPPORTED\n\n**Payment Flow Architecture:**\n- **Bulk Payment Creation Flow**: Clients create multiple payments for orders via `/v2/orders/{orderId}/payments` endpoint\n- **Payment Attempt Flow**: Create individual payment attempts via `/v2/payments/{paymentId}/attempts` or `/v2/payments/by-order-id/{orderId}/attempts`\n- **Authentication Flow**: Supports 3DS authentication, native OTP, and redirect-based authentication\n- **Capture & Refund Flow**: Authorize and capture transactions, then process refunds\n\n**Supported Transaction Types:**\n- **Card Payments**: Credit/Debit cards with 3DS authentication\n- **UPI (Unified Payments Interface)**: Multiple variants:\n  - UPI Apps (Phonepe, Google Pay, BHIM, etc.)\n  - UPI Collect\n  - UPI Credential-based\n- **Net Banking**: Multiple issuer support\n- **E-Mandates**: Recurring payment authorizations with token management\n- **Reward Points/Cred Coins**: Internal redemption mechanisms\n- **Push Payments**: Direct account transfers\n\n### 2. KEY SERVICES/CONTROLLERS HANDLING PAYMENTS\n\n**Main Controllers:**\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/controller/v2/payment/PaymentV2Controller.java` - Bulk payment creation\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/controller/v2/paymentattempt/PaymentAttemptV2Controller.java` - Payment attempt endpoints\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/controller/v2/order/OrderV2Controller.java` - Order management\n\n**Payment Services:**\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/service/PaymentAttemptService.java` - Core payment attempt logic\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/service/PaymentProviderService.java` - Provider management\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/service/WspService.java` - White Space Platform integration for native OTP\n\n### 3. PAYMENT INTENTS/TRANSACTIONS CREATION AND PROCESSING\n\n**Payment Intent/Transaction Creation Architecture:**\n\n**Step 1: Bulk Payment Creation** (`BulkPaymentCreateWorkflow.java`):\n- File: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/payments/bulk/BulkPaymentCreateWorkflow.java`\n- Validates order entity and creates multiple `PaymentV2Entity` objects\n- Payment modes prioritized (sorted by execution priority)\n- Existing non-discarded payments are marked for discard to prevent duplicates\n\n**Step 2: Payment Attempt Creation** (`PaymentAttemptCreateWorkflow.java`):\n- File: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java`\n- **Data Enrichment Pipeline**:\n  1. **Instrument Validation & Enrichment**: Via `InstrumentTypeProcessorManager` - validates payment instrument compatibility with payment mode\n  2. **Decision Tree Routing**: `ProviderDeciderRouter` determines optimal payment provider based on:\n     - Client configurations\n     - Instrument type\n     - Order characteristics\n     - Customer data\n  3. **Auth Type Decision**: Via `AuthTypeDeciderFactory` - determines 3DS requirement, native OTP, or no-auth\n  4. **Settlement Route Validation**: Via `SettlementRouteValidator` - ensures proper settlement configuration\n\n- **Entity Creation**:\n  - Creates `PaymentAttemptV2Entity` with CREATED status\n  - Generates unique external ID via `PaymentAttemptUUIdGenerator`\n  - Stores routing decision results in attributes\n  - Associates with provider account\n\n**Step 3: Processing** (Processor Phase):\n- Calls appropriate `IPaymentProviderAdapter` implementation\n- Provider-specific request building and API invocation\n- Response handling and status update based on provider response\n\n**Step 4: Post-Processing**:\n- Updates payment attempt entity with provider response\n- Sets provider reference ID and gateway reference ID\n- Updates status to PROCESSING, COMPLETED, or FAILED based on provider status\n\n### 4. PAYMENT PROVIDERS/GATEWAYS INTEGRATED\n\n**Provider Adapters Located**: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/providers/`\n\n**Major Payment Providers Integrated** (24+ adapter implementations):\n\n1. **Cybersource** - `CybersourceProviderAdapter.java`\n   - 3DS payment processing\n   - Supports Cards, E-Mandates\n   - Transaction search and reconciliation\n   - Multi-application flow support (ics_bill, ics_auth, ics_pa_validate)\n\n2. **Cashfree** - `CashfreeProviderAdapter.java` + variants\n   - Card payments: `CashfreeCardProviderAdapter.java`\n   - Net Banking: `CashfreeNetBankingProviderAdapter.java`\n   - UPI variants: `CashfreeUPIProviderAdapter.java`, `CashfreeUPIAppsProviderAdapter.java`, `CashfreeUPICredProviderAdapter.java`\n\n3. **PayU** - `PayuProviderAdapter.java` + variants\n   - Card: `PayuCardProviderAdapter.java`\n   - Net Banking: `PayuNetBankingProviderAdapter.java`\n\n4. **Pine Labs Edge** - `PineLabsEdgeProviderAdapter.java` + variants\n   - Multiple payment mode variants\n\n5. **Razorpay** - `RazorpayWebhookController.java` (webhook endpoint)\n\n6. **Juspay** - `JuspayWebhookController.java`\n\n7. **ICICI Bank** - `ICICIWebhookController.java`\n\n8. **Yes Bank (YBL)** - `YBLWebhookController.java`\n\n9. **RBL UPI** - `RBLUpiWebhookController.java`\n\n10. **Digio** - `DigioWebhookController.java` + `DigioMandateRegisterProviderAdapter.java`\n\n11. **Cred Coins/Reward Points** - `CredPointsProviderAdapter.java`, `RewardPointsProviderAdapter.java`\n\n12. **Native Auth Token** - `AuthTokenNativeProviderAdapter.java`\n\n**Provider Selection Logic** (`ProviderDeciderRouter.java`):\n- Routes through **LCM (LendingCloudManager)** if enabled for instrument type\n- Falls back to **Decision Tree (DT)** engine for dynamic routing\n- Decision trees are JSON-based rule configurations cached in `DecisionTreeObjectCache`\n\n### 5. ERROR HANDLING FOR PAYMENT FAILURES\n\n**Error Framework** (`Error.java`):\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/error/Error.java`\n- Enum-based error definitions with HTTP status codes and messages\n\n**Key Error Types**:\n- `provider_api_failure` - Generic provider API errors\n- `invalid_payment_id`, `invalid_order_id` - Invalid entity references\n- `payment_retry_not_allowed` - Terminal order states\n- `completed_transactions_already_exists` - Duplicate completion prevention\n- `order_flow_type_not_supported` - Provider doesn't support order flow\n- `fee_validation_failure` - Fee calculation mismatches\n- `incompatible_instrument_type_for_payment_mode` - Instrument validation errors\n\n**Error Handling Mechanisms**:\n\n1. **Custom Exceptions**:\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/error/ProviderException.java`\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/error/ProviderRetryableFailureException.java`\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/error/WalletProviderException.java`\n\n2. **Provider Error Mapping**:\n   - `PaymentErrorMessageMappingService` - Maps provider-specific error codes to user-friendly messages\n   - Cached in `PaymentErrorMessageMappingCache`\n\n3. **Response Handling** (in `PaymentAttemptCreateWorkflow.postProcess()`):\n   ```\n   - ProviderRequestStatus.REQUEST_SUCCESS: Payment processed successfully\n   - ProviderRequestStatus.TIMED_OUT: Set error code to TIMED_OUT\n   - Other statuses: Determine if PROCESSING or FAILED based on payment mode\n   - Failed statuses (per Cybersource): 101-211, 220-251, 400-461, 476, 480-481, 520, 700-703\n   - Processing statuses: 110, 475, 480\n   ```\n\n4. **Workflow Error Collection**:\n   - `PaymentAttemptCreateContext` collects `WorkflowInternalError` objects\n   - Exception handler converts workflow errors to `AppException` in `throwErrorIfRequired()`\n\n5. **Global Exception Handler**:\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/commons/spring/filters/DarwinResponseEntityExceptionHandler.java`\n\n### 6. STATE MACHINES AND WORKFLOW ENGINES\n\n**State Machine Architecture:**\n\n**Payment State Machine** (`PaymentStateMachine.java`):\n- File: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/statemachine/payment/PaymentStateMachine.java`\n- **Event-driven** using Google's EventBus\n- **Event Types** published via `PaymentAttemptEventFactory`:\n  - `PaymentAttemptCreatedEvent` → Updates payment status if payment was FAILED\n  - `PaymentAttemptCompletedEvent` → Updates payment to COMPLETED\n  - `PaymentAttemptAuthorizedEvent` → Updates payment to AUTHORIZED\n  - `PaymentAttemptFailedEvent` → Updates payment to FAILED if no other active attempts\n  - `PaymentAttemptProcessingEvent` → Updates payment to PROCESSING\n  - `PaymentAttemptBlockedEvent` → Updates payment to BLOCKED\n  - `PaymentAttemptAuthenticationSuccessfulEvent` → Updates to AUTHENTICATION_SUCCESSFUL\n  - `PaymentAttemptAuthenticationFailedEvent` → Updates to AUTHENTICATION_FAILED\n  - `PaymentAttemptReversedEvent` → Updates to FAILED\n\n**Payment Status Transitions** (Terminal Statuses: COMPLETED, FAILED, FORCE_FAILED, DISCARDED):\n- CREATED → PROCESSING → AUTHORIZED → COMPLETED\n- CREATED → PROCESSING → COMPLETED (direct)\n- CREATED → FAILED\n- AUTHENTICATION_SUCCESSFUL → AUTHORIZED/COMPLETED\n- Any → BLOCKED\n\n**Order State Machine** (`OrderStateMachine.java`):\n- File: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/statemachine/order/OrderStateMachine.java`\n- Subscribes to payment events\n- **Order Status Transitions**:\n  - `CREATED` → `PROCESSING` (on payment processing)\n  - `CREATED` → `COMPLETED` (when all payments completed)\n  - Any → `FAILED` (when payment fails and no other active attempts)\n  - Special: `AUTHLESS_READY_TO_PROCESS` (for non-auth requiring payments matching order amount)\n\n**Refund State Machine** (`RefundStateMachine.java`, `RefundAttemptStateMachine.java`):\n- File: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/statemachine/RefundStateMachine.java`\n- Manages refund lifecycle (CREATED, PROCESSING, COMPLETED, FAILED, MANUAL_REVIEW)\n\n**Workflow Execution**:\n- Base workflow class: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/Workflow.java`\n- **Execution Pipeline**:\n  1. `validateAndEnrichContext()` - Validate inputs, enrich with business data\n  2. `persistIntent()` - Save entities to database\n  3. `persistNonRelationalIntent()` - Save to DynamoDB (e.g., native OTP details)\n  4. `process()` - Execute core business logic (provider API calls)\n  5. `postProcess()` - Transform results to response objects\n  6. `postPersistNonRelationalDataStore()` - Update non-relational stores\n  7. `publishEntityChangeEvents()` - Post events to event bus for state machines\n  8. `throwErrorIfRequired()` - Throw exceptions if workflow failed\n\n**3DS/Authentication Workflow** (for cards requiring 3DS):\n- `PaymentAttempt3DSWorkflowExecutor` - Manages multi-step 3DS flows\n- `PaymentAttemptInitiateAuthenticationWorkflow` - Generates authentication challenge\n- `PaymentAttemptAuthenticateWorkflow` - Submits authentication response\n- `PaymentAttemptValidateAuthenticationWorkflow` - Validates auth completion\n\n**Entity Lifecycle Example** (Payment Attempt):\n1. Created with status CREATED\n2. Provider adapter called → status updates based on response\n3. EventBus publishes appropriate event\n4. State machines react and transition parent entities\n5. Eventos service publishes to analytics/webhooks\n6. SyncManager queues for distributed sync\n\n**Key Architectural Components**:\n\n| Component | File Location | Purpose |\n|-----------|---------------|---------|\n| Payment Intent Creator | `PaymentAttemptCreateWorkflow.java` | Creates payment attempt entities |\n| Provider Router | `ProviderDeciderRouter.java` | Routes to appropriate payment provider |\n| Provider Adapter Registry | `PaymentProviderFactory.java` | Dynamically selects provider adapter |\n| Decision Tree Engine | `DecisionTreeWorkflow.java` | Rule-based provider selection |\n| Event Publisher | `EventBus` (Guava) | Publishes payment events synchronously |\n| State Machines | `PaymentStateMachine`, `OrderStateMachine` | React to events and update entity states |\n| Webhook Handlers | Multiple `*WebhookController` | Receive async updates from providers |\n| Fee Engine | `FeeService`, `FeeCreateWorkflow` | Calculates and applies transaction fees |\n| Mandate Service | `MandateServiceDataManager` | Manages recurring payment authorizations |\n| Authentication Service | `AuthenticationService` | Handles 3DS redirects and OTP |\n| Sync Module | `SyncManager` | Distributes changes across systems |\n\nThis architecture provides a highly flexible, provider-agnostic payment processing system with comprehensive error handling, state management, and event-driven workflows."}],"totalDurationMs":107797,"totalTokens":90268,"totalToolUseCount":39,"usage":{"input_tokens":1705,"cache_creation_input_tokens":910,"cache_read_input_tokens":83690,"cache_creation":{"ephemeral_5m_input_tokens":910,"ephemeral_1h_input_tokens":0},"output_tokens":3963}}}
{"parentUuid":"362d93a3-3a47-424e-8aaf-bd633fc4c78e","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01J7tMBo9w7W5XgDRKnJDe71","type":"tool_result","content":[{"type":"text","text":"Perfect! Now I have gathered comprehensive information. Let me compile the final detailed report:\n\n## COMPREHENSIVE PAYMENT SERVICE EXPLORATION REPORT\n\nBased on my thorough exploration of the payment-service repository, here are the detailed findings:\n\n---\n\n## 1. DATABASE CONFIGURATION\n\n**Database Used:** MySQL with Master-Replica architecture\n\n**Key Configuration Files:**\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/resources/application.properties` (lines 21-47)\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/configuration/database/MasterDataSourceConfiguration.java`\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/configuration/database/ReplicaDataSourceConfiguration.java`\n\n**Database Details:**\n- **Master Database:** Configured for write operations\n  - Connection: `jdbc:mysql://${DB_HOST:stage-master-db.stg.dreamplug.net}:3306/${DB_NAME:payments_multi_tenancy}`\n  - Pool: HikariCP with configurable min/max pool sizes (default 10 connections)\n  - Timeout: 10 seconds (configurable via `${MASTER_TRANSACTION_TIMEOUT_IN_SEC}`)\n  - Connection timeout: 2000ms, Idle timeout: 30000ms, Max lifetime: 1800000ms\n\n- **Replica Database:** Configured for read operations (read-only mode)\n  - Connection: `jdbc:mysql://${REPLICA_DB_HOST}:3306/${REPLICA_DB_NAME}`\n  - Read-only flag: `setReadOnly(true)`\n  - Separate pool configuration for replicas\n\n**Connection Handling:**\n- HikariCP connection pooling with leak detection\n- JPA + Hibernate ORM for entity management\n- Annotation-based routing via `@ReplicaRepository` for read operations\n\n---\n\n## 2. MAIN DATA MODELS/ENTITIES\n\n**Core Entities (Base Classes):**\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/commons/BaseEntity.java` - Base with ID, timestamps, audit fields\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/provider/BaseExternalEntity.java` - External reference management\n- `CoreBaseEntity.java` - Core application entity base\n\n**Payment-Related Entities (v2 - main schema):**\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/v2/PaymentV2Entity.java` - Payment records\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/v2/PaymentAttemptV2Entity.java` - Payment attempts\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/v2/RefundEntity.java` - Refund records\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/v2/RefundAttemptEntity.java` - Refund attempts\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/v2/FeeEntity.java` - Fee tracking\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/v2/ClientRefundRequestEntity.java` - Refund requests\n\n**Order & Customer Entities:**\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/OrderEntity.java` - Orders with metadata and attributes\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/CustomerEntity.java` - Customer records\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/OrderAttributeEntity.java` - Order attributes\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/OrderUdfEntity.java` - Order custom fields\n\n**Configuration & Provider Entities:**\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/ClientEntity.java` - Application clients\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/ProviderAccountEntity.java` - Payment provider accounts\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/PaymentProviderEntity.java` - Provider configuration\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/MasterConfigurationEntity.java` - Master configurations\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/DisputeEntity.java` - Dispute records\n\n**Metadata Entities (directory: `entity/metadata/`):**\n- CardBrandRepository, PaymentErrorMessageMappingRepository, ProviderCardBrandMappingRepository\n- NetBankingConfigurationRepository, SettlementRouteRepository, and others\n\n---\n\n## 3. EXTERNAL SERVICES/APIs INTEGRATION\n\n**Payment Gateway Providers (from build.gradle and config):**\n\n1. **Razorpay** - Primary payment gateway\n   - Client: `razorpay-payment-client:1.2.18`\n   - URL: `https://api.razorpay.com/v1`\n   - Direct client: `razorpay-direct-client:1.2.19`\n\n2. **Plutus** - Secondary payment provider\n   - Client: `plutus-payment-client:1.0.2`\n\n3. **PayU** - Indian payment gateway\n   - Client: `payu-provider-client:1.0.16`\n   - Base URL: `https://secure.payu.in`\n\n4. **Cybersource** - Card payment processor\n   - Client: `cybersource-provider-client:1.0.35`\n   - URL: `api.in.cybersource.com`\n\n5. **Cashfree** - Payment aggregator\n   - Client: `cashfree-payment-client:1.0.11`\n   - URL: `https://api.cashfree.com/pg`\n\n6. **JusPay** - Payment orchestration\n   - Client: `juspay-java-client:2.5.11`\n   - URL: `https://sandbox.juspay.in`\n\n7. **MPGS (Mastercard Payment Gateway Services)**\n   - HDFC variant: `mpgs-client:1.0.5`\n   - Axis variant: `mpgs-client:1.0.5`\n\n8. **UPI Providers:**\n   - Axis UPI: `axis-upi-client:0.5.3`\n   - ICICI UPI: `icici-upi-client:1.0.10`\n   - YBL (Yellow Bank Limit): `ybl-upi-client:1.0.10`\n   - RBL UPI: `rbl-upi-client:1.0.4`\n\n9. **BNPL/Lending:**\n   - Lending provider: `lending-provider-client:1.3.3`\n   - Lazypay: `lazypay-client:1.0.11`\n   - Cred BNPL: `cred-bnpl:1.0.3`\n\n10. **Additional Payment Methods:**\n    - Pinelabs: `pinelabs-provider-client:1.0.10` and edge variant `pinelabs-edge-provider-client:1.0.3`\n    - DigiO (eSignature): `digio-provider-client:1.0.10`\n    - Cred Wallet: `cred-wallet-client:1.0.6`\n    - Cred PPI: `cred-ppi-client:1.0.2`\n    - Web Miner: `web-miner-client:1.0.0`\n\n**Internal Service Integrations:**\n- **User Service:** `user-service-client:4.0.1` - User data retrieval\n- **Merchant Service:** `merchant-service-client:1.0.3` - Merchant info\n- **Arsenal:** Payment instrument management\n- **Falcon:** Offer management\n- **Genie:** Service for configuration/rules\n- **Mandate Service:** `mandate-java-client:1.0.4` - Recurring payment mandates\n- **Points Service:** `points-java-client:1.1.5` - Loyalty points\n- **Rewards Service:** Reward management\n- **Fee Service:** `fees:0.18.0` - Fee calculation\n\n**Specialized Services (from configuration):**\n- **LCM (Loading Capability Manager):** Terminal resolution\n- **Artemis:** Service for metadata\n- **Syndicate:** Client authentication\n- **Narad:** Dynamic routing service\n- **Invoker:** Task invocation\n- **Leia:** ID generation\n- **Vault:** Token vaulting service\n- **Merchant Beneficiary Service:** Beneficiary management\n- **Arsenal:** Instrument vault\n\n**Client List (directory: `/darwin/client/`):**\n- arsenal, arthemis, fee, invoker, lcm, leia, mbs, merchant, narad, rewards, syndicate, transientvault\n\n---\n\n## 4. CACHING IMPLEMENTATION\n\n**Cache Technology:** Caffeine (in-memory) + Redis (distributed)\n\n**Configuration Files:**\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/configuration/CacheConfig.java`\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/configuration/RedissonAutoConfiguration.java`\n\n**Redis Configuration (from application.properties, lines 953-958):**\n```\naws.elastiCache.url=${REDIS_ADDRESS:127.0.0.1}\naws.elastiCache.port=${REDIS_PORT:6379}\naws.elastiCache.authEnabled=${REDIS_AUTH_ENABLED:false}\naws.elastiCache.password=${REDIS_PASSWORD:dummy}\naws.elastiCache.watchDogTimeout=${REDIS_WATCHDOG_TIMEOUT:60000}\n```\n- **Client Library:** Redisson 3.19.1 with Kryo5Codec\n- **Single-server mode** for Redis connectivity\n- **Watchdog timeout:** 60 seconds (configurable)\n\n**Cache Layer Implementations:**\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/cache/MerchantCache.java` - Merchant data (async loading cache)\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/cache/ClientConfigurationCache.java` - Client settings\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/cache/PaymentProviderCache.java` - Provider configs\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/cache/ProviderAccountCache.java` - Provider accounts\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/cache/ClientPaymentProviderConfigCache.java` - Provider mappings\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/cache/DecisionTreeObjectCache.java` - Decision tree rules\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/cache/CardBinCache.java` - Card BIN data\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/cache/FeeCache.java` - Fee calculations\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/cache/MasterConfigurationCache.java` - Master config\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/cache/NativeOTPSupportedProviderCache.java` - OTP provider support\n\n**Cache Refresh Pattern:**\n- Uses `refreshAfterWrite()` for automatic cache refresh\n- Configurable TTL per cache type\n- AOP-based cache annotation support (DP_Cache)\n- Topic-based cache refresh: `darwin_cache_refresh_topic`\n\n---\n\n## 5. MESSAGE QUEUES & ASYNC PROCESSING\n\n**Message Queue Technologies:**\n\n**A. Kafka** (for analytics and events)\n- Configuration: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/kafka/MessagingConfigs.java`\n- Library: `io.github.devlibx.easy:messaging-kafka:0.0.69`\n- Topics configured (from application.properties):\n  - `payment-attempt-platform-metrics-pinot-out-new-1` (primary)\n  - `payment-attempt-platform-metrics-pinot-out-new-1` (DPSPL variant)\n- Event classes: `/darwin/kafka/dto/`\n  - `PaymentAttemptAnalyticsEvent.java` - Base event\n  - `CardPaymentAttemptAnalyticsEvent.java` - Card payments\n  - `NetBankingPaymentAttemptAnalyticsEvent.java` - Netbanking\n  - `UPIAppsPaymentAttemptAnalyticsEvent.java` - UPI apps\n  - `UPICredPaymentAttemptAnalyticsEvent.java` - UPI CRED\n  - `UPICollectPaymentAttemptAnalyticsEvent.java` - UPI Collect\n\n**B. AWS SQS** (for task processing)\n- Configuration: application.properties (lines 94-156)\n- Multiple queue configurations:\n  - **FORCE_PAYMENT_FAILURE_QUEUE** - Manual payment failure forcing\n  - **MANDATE_EXPIRY_CRON_QUEUE** - Recurring payment mandate expiry\n  - **REFUND_RESCHEDULE_QUEUE** - Refund scheduling\n  - **ORDER_EXPIRY_QUEUE** - Order expiration\n  - **PENDENCY_AUTOMATION_QUEUE** - Pending transaction automation\n  - **ARN_DATA_BACKFILL_QUEUE** - Data backfill with DLQ\n  - Separate INVOKER variants for async invocation\n  - Region: ap-south-1\n\n**SQS Message Processors:**\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/sqs/DarwinSQSMessageProcessor.java` - Base processor\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/sqs/DarwinSQSMessageReceiver.java` - Message receiver\n- Specialized processors:\n  - `ForcePaymentFailureInvokerSQSMessageProcessor.java`\n  - `OrderExpiryInvokerSQSMessageProcessor.java`\n  - `RefundRescheduleInvokerSQSMessageProcessor.java`\n  - `PaymentsPendencyAutomationSQSMessageProcessor.java`\n  - `ArnDataBackfillSQSMessageProcessor.java`\n\n**C. Eventi** (internal event framework)\n- Configuration: application.properties (lines 67-91)\n- Library: `in.dreamplug.legos.eventi.producer:eventi-producer-springboot:6.0.0`\n- Producer configuration\n- Async queue pattern with configurable worker threads\n\n**Async Processing Pattern:**\n- Thread pools for async operations\n- Eventi executor: CorePoolSize=4, MaxPoolSize=16\n- SignalFx executor: CorePoolSize=8, MaxPoolSize=24\n\n---\n\n## 6. API ENDPOINT STRUCTURE\n\n**API Format:** REST (JSON-based)\n\n**Base Configuration:**\n- Server port: 9010\n- Context path: `/payments`\n- Request/Response format: JSON\n\n**REST Controller Endpoints:**\n\n1. **Webhook Controller** - `/v1/webhooks`\n   - POST `/v1/webhooks` - Process provider webhooks\n\n2. **Payment Attempt** - `/v1/payment-attempts` (admin)\n   - Admin endpoints for payment attempt management\n\n3. **Order Management** - Admin endpoints\n   - Order operations and status management\n\n4. **Refund Operations** - Admin refund endpoints\n   - Refund requests and scheduling\n\n5. **Auth Token** - `/v1/customers/auth-token/{userId}`\n   - Customer authentication token generation\n\n6. **Payment Methods** - `/v1/banks`\n   - Supported banks and payment methods\n\n7. **JusPay Vault** - `/v1/juspay-vault`\n   - JusPay token vault configuration\n\n8. **Provider Configuration** - `/v1/provider-account`\n   - Provider account setup\n\n9. **Downtime** - `/v1/downtime`\n   - Service downtime management\n\n10. **Reversal Operations** - `/v1/reversals`\n    - Payment reversal endpoints\n\n11. **Metadata Base Controllers** - Metadata CRUD operations\n    - Generic metadata management endpoints\n\n**Request/Response Handling:**\n- Validation using `@Valid` annotations\n- DTOs for data transfer objects (location: `/dto/` directories)\n- MapStruct for object mapping (`mapstruct:1.4.2.Final`)\n- ModelMapper for complex object mapping (`modelmapper:3.1.1`)\n\n---\n\n## 7. AUTHENTICATION & AUTHORIZATION\n\n**Authentication Filters:**\n\n1. **ApplicationContextBuilderFilter** (`/commons/spring/filters/ApplicationContextBuilderFilter.java`)\n   - Builds application context from request headers\n   - Validates Client ID or Merchant ID\n   - Enriches context with device info (Device ID, OS, OS Version, App Version)\n   - Clears context after request completion\n\n2. **PAMerchantAuthenticationFilter** (`/commons/spring/filters/PAMerchantAuthenticationFilter.java`)\n   - Partner (PA) merchant authentication via token\n   - Validates merchant access token with Syndicate service\n   - Header: `${PA_MERCHANT_ACCESS_TOKEN}`\n   - Extracts merchant ID from auth response\n\n3. **PAPartnerAuthorizationFilter** (`/commons/spring/filters/PAPartnerAuthorizationFilter.java`)\n   - Partner authorization validation\n   - Checks merchant-partner associations\n\n4. **SkipContextBuildAwareFilter** (`/commons/spring/filters/SkipContextBuildAwareFilter.java`)\n   - Base filter with skip capability\n   - Allows selective context building via `@SkipContextBuild` annotation\n\n**Authorization Mechanism:**\n\n**Token-Based Authorization:**\n- Application-level tokens defined in configuration\n- Authorized applications (from application.properties, lines 1001-1018):\n  - DARWIN - Main application\n  - ACCESS_TOKEN - API access\n  - SUPER_ADMIN - Administrative access\n  - MANDATE_SERVICE - Mandate service\n  - HEART_BEAT - Health check\n  - DARWIN_WORKER - Background worker\n- Each token has configurable status (active/inactive)\n\n**Request Header Requirements:**\n- `${CLIENT_HEADER_KEY}` - Client identifier (External ID)\n- `${MERCHANT_HEADER_KEY}` - Merchant identifier\n- `${PA_MERCHANT_ACCESS_TOKEN}` - Partner merchant token (optional)\n- Device info headers: DEVICE_ID, OS, OS_VERSION, APP_VERSION\n\n**Security Components:**\n- Spring Security Core: `spring-security-core:5.2.1.RELEASE`\n- Custom context injection via ApplicationContext singleton\n- Per-request authentication context with thread-local storage\n- Rate limiting via `in.dreamplug.payments:rate-limiter:1.0.5`\n\n**Client Rate Limiting:**\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/configuration/ClientRateLimiter.java`\n- Redisson-based distributed rate limiting\n- Configuration stored in database via ProviderRateLimitConfigRepository\n\n---\n\n## 8. ADDITIONAL DATA STORAGE\n\n**DynamoDB (AWS NoSQL):**\n- Configuration: application.properties (lines 158-163)\n- DAOs for specialized data:\n  - `/darwin/dynamo/dao/DarwinPaymentAttemptMetadataAuditEntityDAO.java` - Audit logs\n  - `/darwin/dynamo/dao/PaymentAttemptNativeOTPDetailEntityDAO.java` - OTP details\n  - `/darwin/dynamo/dao/PaymentAttemptWorkflowContextDAO.java` - Workflow state\n  - `/darwin/dynamo/dao/DarwinPaymentAttemptRedirectionDetailDAO.java` - Redirection data\n- Mapper library: `com.amazonaws:aws-java-sdk-dynamodb` via SDK\n- Codec: Kryo5 for serialization\n\n**DynamoDB Entities:**\n- `DarwinPaymentAttemptMetadataAuditEntity.java` - Full audit trail\n- `PaymentAttemptNativeOTPDetailEntity.java` - OTP authentication details\n- `PaymentAttemptWorkflowContextEntity.java` - Workflow execution context\n- `DarwinPaymentAttemptRedirectionDetailEntity.java` - Redirect URLs and forms\n\n---\n\n## SUMMARY TABLE\n\n| Component | Technology | Details |\n|-----------|-----------|---------|\n| **Primary DB** | MySQL | Master-Replica with HikariCP |\n| **Secondary Storage** | DynamoDB | AWS NoSQL for audit/state |\n| **Cache** | Caffeine + Redisson | In-memory + Redis |\n| **Message Queues** | Kafka + AWS SQS + Eventi | Event streaming and task processing |\n| **API Format** | REST | JSON-based endpoints |\n| **Authentication** | Token-based | Header-based with context injection |\n| **Framework** | Spring Boot 2.7.14 | Java 17, JPA + Hibernate |\n| **ORM** | JPA + Hibernate 5 | Standard ORM with custom configs |\n\n---\n\n**Key Files for Reference:**\n- Configuration: `/src/main/resources/application.properties`\n- Database: `/src/main/java/in/dreamplug/darwin/configuration/database/`\n- Entities: `/src/main/java/in/dreamplug/darwin/entity/` (v2 for main models)\n- Repositories: `/src/main/java/in/dreamplug/darwin/repository/`\n- Services: `/src/main/java/in/dreamplug/darwin/service/`\n- Caching: `/src/main/java/in/dreamplug/darwin/cache/`\n- Messaging: `/src/main/java/in/dreamplug/darwin/kafka/` and `/darwin/sqs/`\n- Controllers: `/src/main/java/in/dreamplug/darwin/controller/`\n- Security: `/src/main/java/in/dreamplug/darwin/commons/spring/filters/`"},{"type":"text","text":"agentId: a02d1a2 (for resuming to continue this agent's work if needed)"}]}]},"uuid":"4e3e1433-4244-4e6d-92de-b40b2c8bbe0b","timestamp":"2025-12-31T09:28:53.899Z","toolUseResult":{"status":"completed","prompt":"Thoroughly explore this payment-service repository to understand its data layer and external integrations:\n\n1. What database(s) are used? Find database configuration and connection handling\n2. What are the main data models/entities (transactions, payments, users, etc.)?\n3. What external services/APIs does this integrate with?\n4. How is caching implemented (Redis, in-memory)?\n5. What message queues or async processing patterns are used?\n6. How are API endpoints structured (REST, GraphQL)?\n7. What authentication/authorization mechanisms are in place?\n\nProvide detailed findings with specific file paths.","agentId":"a02d1a2","content":[{"type":"text","text":"Perfect! Now I have gathered comprehensive information. Let me compile the final detailed report:\n\n## COMPREHENSIVE PAYMENT SERVICE EXPLORATION REPORT\n\nBased on my thorough exploration of the payment-service repository, here are the detailed findings:\n\n---\n\n## 1. DATABASE CONFIGURATION\n\n**Database Used:** MySQL with Master-Replica architecture\n\n**Key Configuration Files:**\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/resources/application.properties` (lines 21-47)\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/configuration/database/MasterDataSourceConfiguration.java`\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/configuration/database/ReplicaDataSourceConfiguration.java`\n\n**Database Details:**\n- **Master Database:** Configured for write operations\n  - Connection: `jdbc:mysql://${DB_HOST:stage-master-db.stg.dreamplug.net}:3306/${DB_NAME:payments_multi_tenancy}`\n  - Pool: HikariCP with configurable min/max pool sizes (default 10 connections)\n  - Timeout: 10 seconds (configurable via `${MASTER_TRANSACTION_TIMEOUT_IN_SEC}`)\n  - Connection timeout: 2000ms, Idle timeout: 30000ms, Max lifetime: 1800000ms\n\n- **Replica Database:** Configured for read operations (read-only mode)\n  - Connection: `jdbc:mysql://${REPLICA_DB_HOST}:3306/${REPLICA_DB_NAME}`\n  - Read-only flag: `setReadOnly(true)`\n  - Separate pool configuration for replicas\n\n**Connection Handling:**\n- HikariCP connection pooling with leak detection\n- JPA + Hibernate ORM for entity management\n- Annotation-based routing via `@ReplicaRepository` for read operations\n\n---\n\n## 2. MAIN DATA MODELS/ENTITIES\n\n**Core Entities (Base Classes):**\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/commons/BaseEntity.java` - Base with ID, timestamps, audit fields\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/provider/BaseExternalEntity.java` - External reference management\n- `CoreBaseEntity.java` - Core application entity base\n\n**Payment-Related Entities (v2 - main schema):**\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/v2/PaymentV2Entity.java` - Payment records\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/v2/PaymentAttemptV2Entity.java` - Payment attempts\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/v2/RefundEntity.java` - Refund records\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/v2/RefundAttemptEntity.java` - Refund attempts\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/v2/FeeEntity.java` - Fee tracking\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/v2/ClientRefundRequestEntity.java` - Refund requests\n\n**Order & Customer Entities:**\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/OrderEntity.java` - Orders with metadata and attributes\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/CustomerEntity.java` - Customer records\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/OrderAttributeEntity.java` - Order attributes\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/OrderUdfEntity.java` - Order custom fields\n\n**Configuration & Provider Entities:**\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/ClientEntity.java` - Application clients\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/ProviderAccountEntity.java` - Payment provider accounts\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/PaymentProviderEntity.java` - Provider configuration\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/MasterConfigurationEntity.java` - Master configurations\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/DisputeEntity.java` - Dispute records\n\n**Metadata Entities (directory: `entity/metadata/`):**\n- CardBrandRepository, PaymentErrorMessageMappingRepository, ProviderCardBrandMappingRepository\n- NetBankingConfigurationRepository, SettlementRouteRepository, and others\n\n---\n\n## 3. EXTERNAL SERVICES/APIs INTEGRATION\n\n**Payment Gateway Providers (from build.gradle and config):**\n\n1. **Razorpay** - Primary payment gateway\n   - Client: `razorpay-payment-client:1.2.18`\n   - URL: `https://api.razorpay.com/v1`\n   - Direct client: `razorpay-direct-client:1.2.19`\n\n2. **Plutus** - Secondary payment provider\n   - Client: `plutus-payment-client:1.0.2`\n\n3. **PayU** - Indian payment gateway\n   - Client: `payu-provider-client:1.0.16`\n   - Base URL: `https://secure.payu.in`\n\n4. **Cybersource** - Card payment processor\n   - Client: `cybersource-provider-client:1.0.35`\n   - URL: `api.in.cybersource.com`\n\n5. **Cashfree** - Payment aggregator\n   - Client: `cashfree-payment-client:1.0.11`\n   - URL: `https://api.cashfree.com/pg`\n\n6. **JusPay** - Payment orchestration\n   - Client: `juspay-java-client:2.5.11`\n   - URL: `https://sandbox.juspay.in`\n\n7. **MPGS (Mastercard Payment Gateway Services)**\n   - HDFC variant: `mpgs-client:1.0.5`\n   - Axis variant: `mpgs-client:1.0.5`\n\n8. **UPI Providers:**\n   - Axis UPI: `axis-upi-client:0.5.3`\n   - ICICI UPI: `icici-upi-client:1.0.10`\n   - YBL (Yellow Bank Limit): `ybl-upi-client:1.0.10`\n   - RBL UPI: `rbl-upi-client:1.0.4`\n\n9. **BNPL/Lending:**\n   - Lending provider: `lending-provider-client:1.3.3`\n   - Lazypay: `lazypay-client:1.0.11`\n   - Cred BNPL: `cred-bnpl:1.0.3`\n\n10. **Additional Payment Methods:**\n    - Pinelabs: `pinelabs-provider-client:1.0.10` and edge variant `pinelabs-edge-provider-client:1.0.3`\n    - DigiO (eSignature): `digio-provider-client:1.0.10`\n    - Cred Wallet: `cred-wallet-client:1.0.6`\n    - Cred PPI: `cred-ppi-client:1.0.2`\n    - Web Miner: `web-miner-client:1.0.0`\n\n**Internal Service Integrations:**\n- **User Service:** `user-service-client:4.0.1` - User data retrieval\n- **Merchant Service:** `merchant-service-client:1.0.3` - Merchant info\n- **Arsenal:** Payment instrument management\n- **Falcon:** Offer management\n- **Genie:** Service for configuration/rules\n- **Mandate Service:** `mandate-java-client:1.0.4` - Recurring payment mandates\n- **Points Service:** `points-java-client:1.1.5` - Loyalty points\n- **Rewards Service:** Reward management\n- **Fee Service:** `fees:0.18.0` - Fee calculation\n\n**Specialized Services (from configuration):**\n- **LCM (Loading Capability Manager):** Terminal resolution\n- **Artemis:** Service for metadata\n- **Syndicate:** Client authentication\n- **Narad:** Dynamic routing service\n- **Invoker:** Task invocation\n- **Leia:** ID generation\n- **Vault:** Token vaulting service\n- **Merchant Beneficiary Service:** Beneficiary management\n- **Arsenal:** Instrument vault\n\n**Client List (directory: `/darwin/client/`):**\n- arsenal, arthemis, fee, invoker, lcm, leia, mbs, merchant, narad, rewards, syndicate, transientvault\n\n---\n\n## 4. CACHING IMPLEMENTATION\n\n**Cache Technology:** Caffeine (in-memory) + Redis (distributed)\n\n**Configuration Files:**\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/configuration/CacheConfig.java`\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/configuration/RedissonAutoConfiguration.java`\n\n**Redis Configuration (from application.properties, lines 953-958):**\n```\naws.elastiCache.url=${REDIS_ADDRESS:127.0.0.1}\naws.elastiCache.port=${REDIS_PORT:6379}\naws.elastiCache.authEnabled=${REDIS_AUTH_ENABLED:false}\naws.elastiCache.password=${REDIS_PASSWORD:dummy}\naws.elastiCache.watchDogTimeout=${REDIS_WATCHDOG_TIMEOUT:60000}\n```\n- **Client Library:** Redisson 3.19.1 with Kryo5Codec\n- **Single-server mode** for Redis connectivity\n- **Watchdog timeout:** 60 seconds (configurable)\n\n**Cache Layer Implementations:**\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/cache/MerchantCache.java` - Merchant data (async loading cache)\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/cache/ClientConfigurationCache.java` - Client settings\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/cache/PaymentProviderCache.java` - Provider configs\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/cache/ProviderAccountCache.java` - Provider accounts\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/cache/ClientPaymentProviderConfigCache.java` - Provider mappings\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/cache/DecisionTreeObjectCache.java` - Decision tree rules\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/cache/CardBinCache.java` - Card BIN data\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/cache/FeeCache.java` - Fee calculations\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/cache/MasterConfigurationCache.java` - Master config\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/cache/NativeOTPSupportedProviderCache.java` - OTP provider support\n\n**Cache Refresh Pattern:**\n- Uses `refreshAfterWrite()` for automatic cache refresh\n- Configurable TTL per cache type\n- AOP-based cache annotation support (DP_Cache)\n- Topic-based cache refresh: `darwin_cache_refresh_topic`\n\n---\n\n## 5. MESSAGE QUEUES & ASYNC PROCESSING\n\n**Message Queue Technologies:**\n\n**A. Kafka** (for analytics and events)\n- Configuration: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/kafka/MessagingConfigs.java`\n- Library: `io.github.devlibx.easy:messaging-kafka:0.0.69`\n- Topics configured (from application.properties):\n  - `payment-attempt-platform-metrics-pinot-out-new-1` (primary)\n  - `payment-attempt-platform-metrics-pinot-out-new-1` (DPSPL variant)\n- Event classes: `/darwin/kafka/dto/`\n  - `PaymentAttemptAnalyticsEvent.java` - Base event\n  - `CardPaymentAttemptAnalyticsEvent.java` - Card payments\n  - `NetBankingPaymentAttemptAnalyticsEvent.java` - Netbanking\n  - `UPIAppsPaymentAttemptAnalyticsEvent.java` - UPI apps\n  - `UPICredPaymentAttemptAnalyticsEvent.java` - UPI CRED\n  - `UPICollectPaymentAttemptAnalyticsEvent.java` - UPI Collect\n\n**B. AWS SQS** (for task processing)\n- Configuration: application.properties (lines 94-156)\n- Multiple queue configurations:\n  - **FORCE_PAYMENT_FAILURE_QUEUE** - Manual payment failure forcing\n  - **MANDATE_EXPIRY_CRON_QUEUE** - Recurring payment mandate expiry\n  - **REFUND_RESCHEDULE_QUEUE** - Refund scheduling\n  - **ORDER_EXPIRY_QUEUE** - Order expiration\n  - **PENDENCY_AUTOMATION_QUEUE** - Pending transaction automation\n  - **ARN_DATA_BACKFILL_QUEUE** - Data backfill with DLQ\n  - Separate INVOKER variants for async invocation\n  - Region: ap-south-1\n\n**SQS Message Processors:**\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/sqs/DarwinSQSMessageProcessor.java` - Base processor\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/sqs/DarwinSQSMessageReceiver.java` - Message receiver\n- Specialized processors:\n  - `ForcePaymentFailureInvokerSQSMessageProcessor.java`\n  - `OrderExpiryInvokerSQSMessageProcessor.java`\n  - `RefundRescheduleInvokerSQSMessageProcessor.java`\n  - `PaymentsPendencyAutomationSQSMessageProcessor.java`\n  - `ArnDataBackfillSQSMessageProcessor.java`\n\n**C. Eventi** (internal event framework)\n- Configuration: application.properties (lines 67-91)\n- Library: `in.dreamplug.legos.eventi.producer:eventi-producer-springboot:6.0.0`\n- Producer configuration\n- Async queue pattern with configurable worker threads\n\n**Async Processing Pattern:**\n- Thread pools for async operations\n- Eventi executor: CorePoolSize=4, MaxPoolSize=16\n- SignalFx executor: CorePoolSize=8, MaxPoolSize=24\n\n---\n\n## 6. API ENDPOINT STRUCTURE\n\n**API Format:** REST (JSON-based)\n\n**Base Configuration:**\n- Server port: 9010\n- Context path: `/payments`\n- Request/Response format: JSON\n\n**REST Controller Endpoints:**\n\n1. **Webhook Controller** - `/v1/webhooks`\n   - POST `/v1/webhooks` - Process provider webhooks\n\n2. **Payment Attempt** - `/v1/payment-attempts` (admin)\n   - Admin endpoints for payment attempt management\n\n3. **Order Management** - Admin endpoints\n   - Order operations and status management\n\n4. **Refund Operations** - Admin refund endpoints\n   - Refund requests and scheduling\n\n5. **Auth Token** - `/v1/customers/auth-token/{userId}`\n   - Customer authentication token generation\n\n6. **Payment Methods** - `/v1/banks`\n   - Supported banks and payment methods\n\n7. **JusPay Vault** - `/v1/juspay-vault`\n   - JusPay token vault configuration\n\n8. **Provider Configuration** - `/v1/provider-account`\n   - Provider account setup\n\n9. **Downtime** - `/v1/downtime`\n   - Service downtime management\n\n10. **Reversal Operations** - `/v1/reversals`\n    - Payment reversal endpoints\n\n11. **Metadata Base Controllers** - Metadata CRUD operations\n    - Generic metadata management endpoints\n\n**Request/Response Handling:**\n- Validation using `@Valid` annotations\n- DTOs for data transfer objects (location: `/dto/` directories)\n- MapStruct for object mapping (`mapstruct:1.4.2.Final`)\n- ModelMapper for complex object mapping (`modelmapper:3.1.1`)\n\n---\n\n## 7. AUTHENTICATION & AUTHORIZATION\n\n**Authentication Filters:**\n\n1. **ApplicationContextBuilderFilter** (`/commons/spring/filters/ApplicationContextBuilderFilter.java`)\n   - Builds application context from request headers\n   - Validates Client ID or Merchant ID\n   - Enriches context with device info (Device ID, OS, OS Version, App Version)\n   - Clears context after request completion\n\n2. **PAMerchantAuthenticationFilter** (`/commons/spring/filters/PAMerchantAuthenticationFilter.java`)\n   - Partner (PA) merchant authentication via token\n   - Validates merchant access token with Syndicate service\n   - Header: `${PA_MERCHANT_ACCESS_TOKEN}`\n   - Extracts merchant ID from auth response\n\n3. **PAPartnerAuthorizationFilter** (`/commons/spring/filters/PAPartnerAuthorizationFilter.java`)\n   - Partner authorization validation\n   - Checks merchant-partner associations\n\n4. **SkipContextBuildAwareFilter** (`/commons/spring/filters/SkipContextBuildAwareFilter.java`)\n   - Base filter with skip capability\n   - Allows selective context building via `@SkipContextBuild` annotation\n\n**Authorization Mechanism:**\n\n**Token-Based Authorization:**\n- Application-level tokens defined in configuration\n- Authorized applications (from application.properties, lines 1001-1018):\n  - DARWIN - Main application\n  - ACCESS_TOKEN - API access\n  - SUPER_ADMIN - Administrative access\n  - MANDATE_SERVICE - Mandate service\n  - HEART_BEAT - Health check\n  - DARWIN_WORKER - Background worker\n- Each token has configurable status (active/inactive)\n\n**Request Header Requirements:**\n- `${CLIENT_HEADER_KEY}` - Client identifier (External ID)\n- `${MERCHANT_HEADER_KEY}` - Merchant identifier\n- `${PA_MERCHANT_ACCESS_TOKEN}` - Partner merchant token (optional)\n- Device info headers: DEVICE_ID, OS, OS_VERSION, APP_VERSION\n\n**Security Components:**\n- Spring Security Core: `spring-security-core:5.2.1.RELEASE`\n- Custom context injection via ApplicationContext singleton\n- Per-request authentication context with thread-local storage\n- Rate limiting via `in.dreamplug.payments:rate-limiter:1.0.5`\n\n**Client Rate Limiting:**\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/configuration/ClientRateLimiter.java`\n- Redisson-based distributed rate limiting\n- Configuration stored in database via ProviderRateLimitConfigRepository\n\n---\n\n## 8. ADDITIONAL DATA STORAGE\n\n**DynamoDB (AWS NoSQL):**\n- Configuration: application.properties (lines 158-163)\n- DAOs for specialized data:\n  - `/darwin/dynamo/dao/DarwinPaymentAttemptMetadataAuditEntityDAO.java` - Audit logs\n  - `/darwin/dynamo/dao/PaymentAttemptNativeOTPDetailEntityDAO.java` - OTP details\n  - `/darwin/dynamo/dao/PaymentAttemptWorkflowContextDAO.java` - Workflow state\n  - `/darwin/dynamo/dao/DarwinPaymentAttemptRedirectionDetailDAO.java` - Redirection data\n- Mapper library: `com.amazonaws:aws-java-sdk-dynamodb` via SDK\n- Codec: Kryo5 for serialization\n\n**DynamoDB Entities:**\n- `DarwinPaymentAttemptMetadataAuditEntity.java` - Full audit trail\n- `PaymentAttemptNativeOTPDetailEntity.java` - OTP authentication details\n- `PaymentAttemptWorkflowContextEntity.java` - Workflow execution context\n- `DarwinPaymentAttemptRedirectionDetailEntity.java` - Redirect URLs and forms\n\n---\n\n## SUMMARY TABLE\n\n| Component | Technology | Details |\n|-----------|-----------|---------|\n| **Primary DB** | MySQL | Master-Replica with HikariCP |\n| **Secondary Storage** | DynamoDB | AWS NoSQL for audit/state |\n| **Cache** | Caffeine + Redisson | In-memory + Redis |\n| **Message Queues** | Kafka + AWS SQS + Eventi | Event streaming and task processing |\n| **API Format** | REST | JSON-based endpoints |\n| **Authentication** | Token-based | Header-based with context injection |\n| **Framework** | Spring Boot 2.7.14 | Java 17, JPA + Hibernate |\n| **ORM** | JPA + Hibernate 5 | Standard ORM with custom configs |\n\n---\n\n**Key Files for Reference:**\n- Configuration: `/src/main/resources/application.properties`\n- Database: `/src/main/java/in/dreamplug/darwin/configuration/database/`\n- Entities: `/src/main/java/in/dreamplug/darwin/entity/` (v2 for main models)\n- Repositories: `/src/main/java/in/dreamplug/darwin/repository/`\n- Services: `/src/main/java/in/dreamplug/darwin/service/`\n- Caching: `/src/main/java/in/dreamplug/darwin/cache/`\n- Messaging: `/src/main/java/in/dreamplug/darwin/kafka/` and `/darwin/sqs/`\n- Controllers: `/src/main/java/in/dreamplug/darwin/controller/`\n- Security: `/src/main/java/in/dreamplug/darwin/commons/spring/filters/`"}],"totalDurationMs":129120,"totalTokens":108991,"totalToolUseCount":51,"usage":{"input_tokens":216,"cache_creation_input_tokens":1897,"cache_read_input_tokens":100852,"cache_creation":{"ephemeral_5m_input_tokens":1897,"ephemeral_1h_input_tokens":0},"output_tokens":6026}}}
{"parentUuid":"4e3e1433-4244-4e6d-92de-b40b2c8bbe0b","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01YYsY7p9LfFb1pkScPMojna","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Excellent! I've gathered comprehensive information from all three exploration agents. Let me now compile a comprehensive study guide for the user to understand this payment-service repository. I'll write this to the plan file as a structured learning guide.","signature":"EqwDCkgICxABGAIqQCYDpcYv5dyBlv7EEIRQVbzKgEqUVrYqCdoXMOqT/GPtN6RgPV97fzVLkwHD//7eb8NHh/ZkzrXW9x5qXeU8/M8SDOYoU9xr3ilnmZ8C9BoM5f+zuoC8Csy2W+rkIjBt3zmdVpUiSPBr96Uo3Beoy96JAXfNGSnm/vTyLYzkPs+C5xzei00A6DxUepOfSXAqkQJlPxm4v+uXgR/W18PjTSwg6gWwAI2Yr9dmUFA7rkGeyaA2NE1KQMW7z4OBi8VHKUUeQDOzSrj1RhMEbqEccVBvfubSdCzwP0E4TGPObNT2vdarSJlMcDF+bs6jIvn3hRozxhhTd86S4sHt0RzmBoYHmACQjNwLDrhfHvNSi82LJKglXDvkbnC5upP3WNXIADxLd8AztcsYkg4eWtMm++75qBsNKvhoMxbjaJASCy6yCQJNmFopKOZC78/E8JCkqJgjt41UMjbOqlIZZuTxhLujD21jjXYfyX97KzzYGbjxkMLTihuIseDp2Vy1KXHWhbBx/0dBBah4UMT/Pn4P0ia/m8YVBdsoVW8QEusKI8U4jv0YAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":13245,"cache_read_input_tokens":24013,"cache_creation":{"ephemeral_5m_input_tokens":13245,"ephemeral_1h_input_tokens":0},"output_tokens":6}},"type":"assistant","uuid":"4a795c38-15a0-446d-b7de-aa7dee98feb0","timestamp":"2025-12-31T09:29:00.856Z"}
{"parentUuid":"4a795c38-15a0-446d-b7de-aa7dee98feb0","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01YYsY7p9LfFb1pkScPMojna","type":"message","role":"assistant","content":[{"type":"text","text":"I've completed a comprehensive exploration of the payment-service repository. Let me compile a structured study guide for you to become an expert on this codebase."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":13245,"cache_read_input_tokens":24013,"cache_creation":{"ephemeral_5m_input_tokens":13245,"ephemeral_1h_input_tokens":0},"output_tokens":6}},"type":"assistant","uuid":"7bfea6ee-f00e-4144-aa0a-2c45fd569060","timestamp":"2025-12-31T09:29:01.425Z"}
{"parentUuid":"7bfea6ee-f00e-4144-aa0a-2c45fd569060","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01YYsY7p9LfFb1pkScPMojna","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_bdrk_0157oS2tD3dyYqnY6dXgSzFk","name":"Write","input":{"file_path":"/Users/kiranbiliyawala/.claude/plans/distributed-marinating-mango.md","content":"# Payment Service (Darwin) - Expert Study Guide\n\nA comprehensive guide to understanding the payment-service repository.\n\n---\n\n## 1. OVERVIEW & TECH STACK\n\n**Project Name:** Darwin (internal name for payment-service)\n**Purpose:** Enterprise-grade payment processing microservice handling multi-provider payment orchestration\n\n| Technology | Version | Purpose |\n|------------|---------|---------|\n| Java | 17 | Runtime |\n| Spring Boot | 2.7.14 | Framework |\n| Gradle | 7.6 | Build |\n| MySQL | - | Primary Database (Master-Replica) |\n| DynamoDB | - | Audit/State Storage |\n| Redis (Redisson) | 3.19.1 | Distributed Cache |\n| Kafka | - | Event Streaming |\n| AWS SQS | - | Task Processing |\n\n**Server:** Port 9010, Context Path: `/payments`\n\n---\n\n## 2. PROJECT STRUCTURE\n\n```\npayment-service/\n├── src/main/java/in/dreamplug/darwin/\n│   ├── controller/         # REST API endpoints\n│   │   └── v2/             # V2 API controllers (primary)\n│   ├── service/            # Business logic services\n│   ├── v2/\n│   │   ├── service/        # V2 services\n│   │   └── workflow/       # Payment workflows (CRITICAL)\n│   │       └── create/\n│   │           ├── payments/       # Payment creation\n│   │           ├── paymentattempts/ # Payment attempt creation\n│   │           └── providers/      # Provider adapters (24+)\n│   ├── entity/             # JPA entities\n│   │   └── v2/             # V2 entities (primary)\n│   ├── repository/         # Data access layer\n│   ├── statemachine/       # Payment/Order state machines\n│   ├── planner/            # Decision tree routing\n│   ├── cache/              # Caching layer (Caffeine)\n│   ├── client/             # External service clients\n│   ├── provider/           # Legacy provider implementations\n│   ├── configuration/      # Spring configs\n│   │   └── database/       # DB configs (Master/Replica)\n│   ├── kafka/              # Kafka producers/consumers\n│   ├── sqs/                # SQS message processors\n│   ├── dynamo/             # DynamoDB DAOs\n│   ├── error/              # Error handling\n│   ├── dto/                # Data transfer objects\n│   └── commons/spring/filters/  # Auth/Context filters\n├── src/main/resources/\n│   └── application.properties  # Main config (1300+ lines)\n├── codepipeline/           # CI/CD configurations\n├── build.gradle            # Dependencies\n└── Dockerfile              # Container setup\n```\n\n---\n\n## 3. CORE PAYMENT FLOW (CRITICAL)\n\n### 3.1 Payment Lifecycle\n\n```\nOrder Created → Payments Created → Payment Attempt Created → Provider API Call → Webhook/Status Update\n```\n\n**Key Steps:**\n\n1. **Order Creation** - Client creates an order with amount, currency, metadata\n2. **Bulk Payment Creation** - Multiple payment records created for the order\n   - File: `v2/workflow/create/payments/bulk/BulkPaymentCreateWorkflow.java`\n3. **Payment Attempt Creation** - Actual payment attempt with provider routing\n   - File: `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java`\n4. **Provider Processing** - Provider adapter calls external payment gateway\n5. **State Machine Updates** - Events trigger state transitions\n\n### 3.2 Workflow Execution Pipeline\n\n```java\n// Base workflow pattern (Workflow.java)\n1. validateAndEnrichContext()  // Validate inputs, enrich data\n2. persistIntent()             // Save entities to MySQL\n3. persistNonRelationalIntent() // Save to DynamoDB\n4. process()                   // Call provider API\n5. postProcess()               // Transform results\n6. publishEntityChangeEvents() // Trigger state machines\n7. throwErrorIfRequired()      // Handle errors\n```\n\n### 3.3 Payment Attempt Data Enrichment\n\n1. **Instrument Validation** - `InstrumentTypeProcessorManager`\n2. **Provider Routing** - `ProviderDeciderRouter` → Decision Tree\n3. **Auth Type Decision** - `AuthTypeDeciderFactory` (3DS, OTP, None)\n4. **Settlement Validation** - `SettlementRouteValidator`\n\n---\n\n## 4. STATE MACHINES\n\n### 4.1 Payment State Machine\n**File:** `statemachine/payment/PaymentStateMachine.java`\n\n```\nCREATED → PROCESSING → AUTHORIZED → COMPLETED\n                   ↘ FAILED\n                   ↘ BLOCKED\n```\n\n**Terminal States:** COMPLETED, FAILED, FORCE_FAILED, DISCARDED\n\n### 4.2 Order State Machine\n**File:** `statemachine/order/OrderStateMachine.java`\n\n- Reacts to payment events\n- Updates order status based on payment outcomes\n\n### 4.3 Events (EventBus - Guava)\n- `PaymentAttemptCreatedEvent`\n- `PaymentAttemptCompletedEvent`\n- `PaymentAttemptFailedEvent`\n- `PaymentAttemptProcessingEvent`\n- `PaymentAttemptAuthorizedEvent`\n\n---\n\n## 5. PROVIDER INTEGRATIONS (24+ Providers)\n\n**Location:** `v2/workflow/create/providers/`\n\n| Provider | Adapter File | Payment Types |\n|----------|-------------|---------------|\n| Cybersource | `CybersourceProviderAdapter.java` | Cards, 3DS, E-Mandates |\n| Cashfree | `CashfreeProviderAdapter.java` + variants | Cards, UPI, NetBanking |\n| PayU | `PayuProviderAdapter.java` + variants | Cards, NetBanking |\n| Pine Labs | `PineLabsEdgeProviderAdapter.java` | Multiple modes |\n| Razorpay | Via webhooks | All payment types |\n| Juspay | Via webhooks | Orchestration |\n| ICICI UPI | `icici-upi-client` | UPI |\n| Axis UPI | `axis-upi-client` | UPI |\n| YBL UPI | `ybl-upi-client` | UPI |\n| RBL UPI | `rbl-upi-client` | UPI |\n| Digio | `DigioMandateRegisterProviderAdapter.java` | E-Mandates |\n| Cred Points | `CredPointsProviderAdapter.java` | Reward redemption |\n\n### Provider Selection Flow\n\n```\nRequest → ProviderDeciderRouter → LCM (if enabled) → Decision Tree → Provider Adapter\n```\n\n**Decision Tree:** JSON-based rules cached in `DecisionTreeObjectCache`\n\n---\n\n## 6. KEY ENTITIES (V2 Schema)\n\n### Core Entities\n| Entity | File | Purpose |\n|--------|------|---------|\n| OrderEntity | `entity/OrderEntity.java` | Order records |\n| PaymentV2Entity | `entity/v2/PaymentV2Entity.java` | Payment records |\n| PaymentAttemptV2Entity | `entity/v2/PaymentAttemptV2Entity.java` | Payment attempts |\n| RefundEntity | `entity/v2/RefundEntity.java` | Refunds |\n| FeeEntity | `entity/v2/FeeEntity.java` | Fee tracking |\n\n### Configuration Entities\n| Entity | Purpose |\n|--------|---------|\n| ClientEntity | Application clients |\n| ProviderAccountEntity | Provider accounts |\n| PaymentProviderEntity | Provider configs |\n| MasterConfigurationEntity | System configs |\n\n---\n\n## 7. DATABASE ARCHITECTURE\n\n### Master-Replica Pattern\n\n**Master:** Write operations\n**Replica:** Read operations (via `@ReplicaRepository`)\n\n**Configuration Files:**\n- `configuration/database/MasterDataSourceConfiguration.java`\n- `configuration/database/ReplicaDataSourceConfiguration.java`\n\n**Database:** `payments_multi_tenancy`\n**Connection Pool:** HikariCP\n**ORM:** JPA + Hibernate\n\n---\n\n## 8. CACHING LAYER\n\n### Caffeine (In-Memory)\n| Cache | Purpose |\n|-------|---------|\n| `ClientConfigurationCache` | Client settings |\n| `PaymentProviderCache` | Provider configs |\n| `ProviderAccountCache` | Provider accounts |\n| `DecisionTreeObjectCache` | Routing rules |\n| `CardBinCache` | Card BIN data |\n| `MerchantCache` | Merchant data |\n| `FeeCache` | Fee calculations |\n\n### Redis (Distributed)\n- **Client:** Redisson with Kryo5Codec\n- **Use:** Distributed locks, rate limiting, shared state\n\n---\n\n## 9. ASYNC PROCESSING\n\n### Kafka Topics\n- `payment-attempt-platform-metrics-pinot-out-new-1` (Analytics)\n- Events: `PaymentAttemptAnalyticsEvent`, `CardPaymentAttemptAnalyticsEvent`, etc.\n\n### SQS Queues\n| Queue | Purpose |\n|-------|---------|\n| `FORCE_PAYMENT_FAILURE_QUEUE` | Manual failure forcing |\n| `MANDATE_EXPIRY_CRON_QUEUE` | Mandate expiry |\n| `REFUND_RESCHEDULE_QUEUE` | Refund scheduling |\n| `ORDER_EXPIRY_QUEUE` | Order expiration |\n| `PENDENCY_AUTOMATION_QUEUE` | Pending transactions |\n\n### Eventi (Internal Events)\n- Internal event framework for system events\n- Async worker threads (4-16 configurable)\n\n---\n\n## 10. API ENDPOINTS\n\n### Primary Controllers (v2)\n| Endpoint | Controller | Purpose |\n|----------|------------|---------|\n| `/v2/orders/{orderId}/payments` | `PaymentV2Controller` | Bulk payment creation |\n| `/v2/payments/{paymentId}/attempts` | `PaymentAttemptV2Controller` | Payment attempts |\n| `/v1/webhooks` | `WebhookController` | Provider webhooks |\n\n### Webhook Controllers\n- `RazorpayWebhookController`\n- `JuspayWebhookController`\n- `ICICIWebhookController`\n- `YBLWebhookController`\n- `RBLUpiWebhookController`\n- `DigioWebhookController`\n\n---\n\n## 11. AUTHENTICATION & SECURITY\n\n### Request Filters (Order of Execution)\n1. `ApplicationContextBuilderFilter` - Build context from headers\n2. `PAMerchantAuthenticationFilter` - Partner merchant auth\n3. `PAPartnerAuthorizationFilter` - Partner authorization\n\n### Headers Required\n- Client ID (`${CLIENT_HEADER_KEY}`)\n- Merchant ID (`${MERCHANT_HEADER_KEY}`)\n- Device info (DEVICE_ID, OS, OS_VERSION, APP_VERSION)\n\n### Rate Limiting\n- Redisson-based distributed rate limiting\n- Config in `ClientRateLimiter.java`\n\n---\n\n## 12. KEY FILES TO STUDY\n\n### Must-Read Files (Priority Order)\n\n1. **Entry Point:**\n   - `DarwinApplication.java`\n\n2. **Core Workflows:**\n   - `v2/workflow/create/Workflow.java` (base pattern)\n   - `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java`\n   - `v2/workflow/create/payments/bulk/BulkPaymentCreateWorkflow.java`\n\n3. **State Machines:**\n   - `statemachine/payment/PaymentStateMachine.java`\n   - `statemachine/order/OrderStateMachine.java`\n\n4. **Provider Routing:**\n   - `planner/ProviderDeciderRouter.java`\n   - `planner/decisiontree/DecisionTreeWorkflow.java`\n\n5. **Provider Adapters:**\n   - `v2/workflow/create/providers/` (pick any adapter)\n\n6. **Entities:**\n   - `entity/OrderEntity.java`\n   - `entity/v2/PaymentV2Entity.java`\n   - `entity/v2/PaymentAttemptV2Entity.java`\n\n7. **Configuration:**\n   - `application.properties` (1300+ lines - scan for context)\n\n8. **Webhooks:**\n   - `controller/WebhookController.java`\n\n---\n\n## 13. INTERNAL SERVICE DEPENDENCIES\n\n| Service | Client Library | Purpose |\n|---------|---------------|---------|\n| User Service | `user-service-client:4.0.1` | User data |\n| Merchant Service | `merchant-service-client:1.0.3` | Merchant info |\n| Mandate Service | `mandate-java-client:1.0.4` | Recurring payments |\n| Arsenal | - | Instrument vault |\n| Falcon | - | Offers/promotions |\n| Genie | `genie-java-client` | Configuration |\n| Syndicate | - | Authentication |\n| LCM | - | Terminal resolution |\n| Fee Service | `fees:0.18.0` | Fee calculation |\n\n---\n\n## 14. STUDY PATH RECOMMENDATION\n\n### Week 1: Foundation\n- [ ] Understand project structure\n- [ ] Read `DarwinApplication.java`\n- [ ] Study `application.properties` (key sections)\n- [ ] Understand entity relationships\n\n### Week 2: Core Flow\n- [ ] Master `PaymentAttemptCreateWorkflow.java`\n- [ ] Study state machines\n- [ ] Understand provider routing\n\n### Week 3: Integrations\n- [ ] Study 2-3 provider adapters\n- [ ] Understand webhook handling\n- [ ] Learn caching patterns\n\n### Week 4: Advanced\n- [ ] Decision tree engine\n- [ ] Async processing (Kafka, SQS)\n- [ ] Error handling patterns\n\n---\n\n## 15. KEY CONCEPTS\n\n1. **Multi-Provider Orchestration** - Route to optimal provider based on rules\n2. **Decision Trees** - JSON-based routing logic\n3. **State Machines** - Event-driven entity lifecycle\n4. **Master-Replica DB** - Read/write separation\n5. **Workflow Pattern** - 7-step execution pipeline\n6. **Event-Driven Architecture** - Guava EventBus + Kafka\n"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":13245,"cache_read_input_tokens":24013,"cache_creation":{"ephemeral_5m_input_tokens":13245,"ephemeral_1h_input_tokens":0},"output_tokens":3716}},"type":"assistant","uuid":"a9c23f2b-5e04-45ab-b0ef-012fef3dd7a3","timestamp":"2025-12-31T09:30:00.778Z"}
{"type":"file-history-snapshot","messageId":"a9c23f2b-5e04-45ab-b0ef-012fef3dd7a3","snapshot":{"messageId":"9ae2a85d-d090-4d6a-b924-d8f0216b466a","trackedFileBackups":{"/Users/kiranbiliyawala/.claude/plans/distributed-marinating-mango.md":{"backupFileName":null,"version":1,"backupTime":"2025-12-31T09:30:00.850Z"}},"timestamp":"2025-12-31T09:26:28.134Z"},"isSnapshotUpdate":true}
{"parentUuid":"a9c23f2b-5e04-45ab-b0ef-012fef3dd7a3","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_0157oS2tD3dyYqnY6dXgSzFk","type":"tool_result","content":"File created successfully at: /Users/kiranbiliyawala/.claude/plans/distributed-marinating-mango.md"}]},"uuid":"a0962c41-1660-4ded-9fe2-4b54a93eb397","timestamp":"2025-12-31T09:30:00.919Z","toolUseResult":{"type":"create","filePath":"/Users/kiranbiliyawala/.claude/plans/distributed-marinating-mango.md","content":"# Payment Service (Darwin) - Expert Study Guide\n\nA comprehensive guide to understanding the payment-service repository.\n\n---\n\n## 1. OVERVIEW & TECH STACK\n\n**Project Name:** Darwin (internal name for payment-service)\n**Purpose:** Enterprise-grade payment processing microservice handling multi-provider payment orchestration\n\n| Technology | Version | Purpose |\n|------------|---------|---------|\n| Java | 17 | Runtime |\n| Spring Boot | 2.7.14 | Framework |\n| Gradle | 7.6 | Build |\n| MySQL | - | Primary Database (Master-Replica) |\n| DynamoDB | - | Audit/State Storage |\n| Redis (Redisson) | 3.19.1 | Distributed Cache |\n| Kafka | - | Event Streaming |\n| AWS SQS | - | Task Processing |\n\n**Server:** Port 9010, Context Path: `/payments`\n\n---\n\n## 2. PROJECT STRUCTURE\n\n```\npayment-service/\n├── src/main/java/in/dreamplug/darwin/\n│   ├── controller/         # REST API endpoints\n│   │   └── v2/             # V2 API controllers (primary)\n│   ├── service/            # Business logic services\n│   ├── v2/\n│   │   ├── service/        # V2 services\n│   │   └── workflow/       # Payment workflows (CRITICAL)\n│   │       └── create/\n│   │           ├── payments/       # Payment creation\n│   │           ├── paymentattempts/ # Payment attempt creation\n│   │           └── providers/      # Provider adapters (24+)\n│   ├── entity/             # JPA entities\n│   │   └── v2/             # V2 entities (primary)\n│   ├── repository/         # Data access layer\n│   ├── statemachine/       # Payment/Order state machines\n│   ├── planner/            # Decision tree routing\n│   ├── cache/              # Caching layer (Caffeine)\n│   ├── client/             # External service clients\n│   ├── provider/           # Legacy provider implementations\n│   ├── configuration/      # Spring configs\n│   │   └── database/       # DB configs (Master/Replica)\n│   ├── kafka/              # Kafka producers/consumers\n│   ├── sqs/                # SQS message processors\n│   ├── dynamo/             # DynamoDB DAOs\n│   ├── error/              # Error handling\n│   ├── dto/                # Data transfer objects\n│   └── commons/spring/filters/  # Auth/Context filters\n├── src/main/resources/\n│   └── application.properties  # Main config (1300+ lines)\n├── codepipeline/           # CI/CD configurations\n├── build.gradle            # Dependencies\n└── Dockerfile              # Container setup\n```\n\n---\n\n## 3. CORE PAYMENT FLOW (CRITICAL)\n\n### 3.1 Payment Lifecycle\n\n```\nOrder Created → Payments Created → Payment Attempt Created → Provider API Call → Webhook/Status Update\n```\n\n**Key Steps:**\n\n1. **Order Creation** - Client creates an order with amount, currency, metadata\n2. **Bulk Payment Creation** - Multiple payment records created for the order\n   - File: `v2/workflow/create/payments/bulk/BulkPaymentCreateWorkflow.java`\n3. **Payment Attempt Creation** - Actual payment attempt with provider routing\n   - File: `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java`\n4. **Provider Processing** - Provider adapter calls external payment gateway\n5. **State Machine Updates** - Events trigger state transitions\n\n### 3.2 Workflow Execution Pipeline\n\n```java\n// Base workflow pattern (Workflow.java)\n1. validateAndEnrichContext()  // Validate inputs, enrich data\n2. persistIntent()             // Save entities to MySQL\n3. persistNonRelationalIntent() // Save to DynamoDB\n4. process()                   // Call provider API\n5. postProcess()               // Transform results\n6. publishEntityChangeEvents() // Trigger state machines\n7. throwErrorIfRequired()      // Handle errors\n```\n\n### 3.3 Payment Attempt Data Enrichment\n\n1. **Instrument Validation** - `InstrumentTypeProcessorManager`\n2. **Provider Routing** - `ProviderDeciderRouter` → Decision Tree\n3. **Auth Type Decision** - `AuthTypeDeciderFactory` (3DS, OTP, None)\n4. **Settlement Validation** - `SettlementRouteValidator`\n\n---\n\n## 4. STATE MACHINES\n\n### 4.1 Payment State Machine\n**File:** `statemachine/payment/PaymentStateMachine.java`\n\n```\nCREATED → PROCESSING → AUTHORIZED → COMPLETED\n                   ↘ FAILED\n                   ↘ BLOCKED\n```\n\n**Terminal States:** COMPLETED, FAILED, FORCE_FAILED, DISCARDED\n\n### 4.2 Order State Machine\n**File:** `statemachine/order/OrderStateMachine.java`\n\n- Reacts to payment events\n- Updates order status based on payment outcomes\n\n### 4.3 Events (EventBus - Guava)\n- `PaymentAttemptCreatedEvent`\n- `PaymentAttemptCompletedEvent`\n- `PaymentAttemptFailedEvent`\n- `PaymentAttemptProcessingEvent`\n- `PaymentAttemptAuthorizedEvent`\n\n---\n\n## 5. PROVIDER INTEGRATIONS (24+ Providers)\n\n**Location:** `v2/workflow/create/providers/`\n\n| Provider | Adapter File | Payment Types |\n|----------|-------------|---------------|\n| Cybersource | `CybersourceProviderAdapter.java` | Cards, 3DS, E-Mandates |\n| Cashfree | `CashfreeProviderAdapter.java` + variants | Cards, UPI, NetBanking |\n| PayU | `PayuProviderAdapter.java` + variants | Cards, NetBanking |\n| Pine Labs | `PineLabsEdgeProviderAdapter.java` | Multiple modes |\n| Razorpay | Via webhooks | All payment types |\n| Juspay | Via webhooks | Orchestration |\n| ICICI UPI | `icici-upi-client` | UPI |\n| Axis UPI | `axis-upi-client` | UPI |\n| YBL UPI | `ybl-upi-client` | UPI |\n| RBL UPI | `rbl-upi-client` | UPI |\n| Digio | `DigioMandateRegisterProviderAdapter.java` | E-Mandates |\n| Cred Points | `CredPointsProviderAdapter.java` | Reward redemption |\n\n### Provider Selection Flow\n\n```\nRequest → ProviderDeciderRouter → LCM (if enabled) → Decision Tree → Provider Adapter\n```\n\n**Decision Tree:** JSON-based rules cached in `DecisionTreeObjectCache`\n\n---\n\n## 6. KEY ENTITIES (V2 Schema)\n\n### Core Entities\n| Entity | File | Purpose |\n|--------|------|---------|\n| OrderEntity | `entity/OrderEntity.java` | Order records |\n| PaymentV2Entity | `entity/v2/PaymentV2Entity.java` | Payment records |\n| PaymentAttemptV2Entity | `entity/v2/PaymentAttemptV2Entity.java` | Payment attempts |\n| RefundEntity | `entity/v2/RefundEntity.java` | Refunds |\n| FeeEntity | `entity/v2/FeeEntity.java` | Fee tracking |\n\n### Configuration Entities\n| Entity | Purpose |\n|--------|---------|\n| ClientEntity | Application clients |\n| ProviderAccountEntity | Provider accounts |\n| PaymentProviderEntity | Provider configs |\n| MasterConfigurationEntity | System configs |\n\n---\n\n## 7. DATABASE ARCHITECTURE\n\n### Master-Replica Pattern\n\n**Master:** Write operations\n**Replica:** Read operations (via `@ReplicaRepository`)\n\n**Configuration Files:**\n- `configuration/database/MasterDataSourceConfiguration.java`\n- `configuration/database/ReplicaDataSourceConfiguration.java`\n\n**Database:** `payments_multi_tenancy`\n**Connection Pool:** HikariCP\n**ORM:** JPA + Hibernate\n\n---\n\n## 8. CACHING LAYER\n\n### Caffeine (In-Memory)\n| Cache | Purpose |\n|-------|---------|\n| `ClientConfigurationCache` | Client settings |\n| `PaymentProviderCache` | Provider configs |\n| `ProviderAccountCache` | Provider accounts |\n| `DecisionTreeObjectCache` | Routing rules |\n| `CardBinCache` | Card BIN data |\n| `MerchantCache` | Merchant data |\n| `FeeCache` | Fee calculations |\n\n### Redis (Distributed)\n- **Client:** Redisson with Kryo5Codec\n- **Use:** Distributed locks, rate limiting, shared state\n\n---\n\n## 9. ASYNC PROCESSING\n\n### Kafka Topics\n- `payment-attempt-platform-metrics-pinot-out-new-1` (Analytics)\n- Events: `PaymentAttemptAnalyticsEvent`, `CardPaymentAttemptAnalyticsEvent`, etc.\n\n### SQS Queues\n| Queue | Purpose |\n|-------|---------|\n| `FORCE_PAYMENT_FAILURE_QUEUE` | Manual failure forcing |\n| `MANDATE_EXPIRY_CRON_QUEUE` | Mandate expiry |\n| `REFUND_RESCHEDULE_QUEUE` | Refund scheduling |\n| `ORDER_EXPIRY_QUEUE` | Order expiration |\n| `PENDENCY_AUTOMATION_QUEUE` | Pending transactions |\n\n### Eventi (Internal Events)\n- Internal event framework for system events\n- Async worker threads (4-16 configurable)\n\n---\n\n## 10. API ENDPOINTS\n\n### Primary Controllers (v2)\n| Endpoint | Controller | Purpose |\n|----------|------------|---------|\n| `/v2/orders/{orderId}/payments` | `PaymentV2Controller` | Bulk payment creation |\n| `/v2/payments/{paymentId}/attempts` | `PaymentAttemptV2Controller` | Payment attempts |\n| `/v1/webhooks` | `WebhookController` | Provider webhooks |\n\n### Webhook Controllers\n- `RazorpayWebhookController`\n- `JuspayWebhookController`\n- `ICICIWebhookController`\n- `YBLWebhookController`\n- `RBLUpiWebhookController`\n- `DigioWebhookController`\n\n---\n\n## 11. AUTHENTICATION & SECURITY\n\n### Request Filters (Order of Execution)\n1. `ApplicationContextBuilderFilter` - Build context from headers\n2. `PAMerchantAuthenticationFilter` - Partner merchant auth\n3. `PAPartnerAuthorizationFilter` - Partner authorization\n\n### Headers Required\n- Client ID (`${CLIENT_HEADER_KEY}`)\n- Merchant ID (`${MERCHANT_HEADER_KEY}`)\n- Device info (DEVICE_ID, OS, OS_VERSION, APP_VERSION)\n\n### Rate Limiting\n- Redisson-based distributed rate limiting\n- Config in `ClientRateLimiter.java`\n\n---\n\n## 12. KEY FILES TO STUDY\n\n### Must-Read Files (Priority Order)\n\n1. **Entry Point:**\n   - `DarwinApplication.java`\n\n2. **Core Workflows:**\n   - `v2/workflow/create/Workflow.java` (base pattern)\n   - `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java`\n   - `v2/workflow/create/payments/bulk/BulkPaymentCreateWorkflow.java`\n\n3. **State Machines:**\n   - `statemachine/payment/PaymentStateMachine.java`\n   - `statemachine/order/OrderStateMachine.java`\n\n4. **Provider Routing:**\n   - `planner/ProviderDeciderRouter.java`\n   - `planner/decisiontree/DecisionTreeWorkflow.java`\n\n5. **Provider Adapters:**\n   - `v2/workflow/create/providers/` (pick any adapter)\n\n6. **Entities:**\n   - `entity/OrderEntity.java`\n   - `entity/v2/PaymentV2Entity.java`\n   - `entity/v2/PaymentAttemptV2Entity.java`\n\n7. **Configuration:**\n   - `application.properties` (1300+ lines - scan for context)\n\n8. **Webhooks:**\n   - `controller/WebhookController.java`\n\n---\n\n## 13. INTERNAL SERVICE DEPENDENCIES\n\n| Service | Client Library | Purpose |\n|---------|---------------|---------|\n| User Service | `user-service-client:4.0.1` | User data |\n| Merchant Service | `merchant-service-client:1.0.3` | Merchant info |\n| Mandate Service | `mandate-java-client:1.0.4` | Recurring payments |\n| Arsenal | - | Instrument vault |\n| Falcon | - | Offers/promotions |\n| Genie | `genie-java-client` | Configuration |\n| Syndicate | - | Authentication |\n| LCM | - | Terminal resolution |\n| Fee Service | `fees:0.18.0` | Fee calculation |\n\n---\n\n## 14. STUDY PATH RECOMMENDATION\n\n### Week 1: Foundation\n- [ ] Understand project structure\n- [ ] Read `DarwinApplication.java`\n- [ ] Study `application.properties` (key sections)\n- [ ] Understand entity relationships\n\n### Week 2: Core Flow\n- [ ] Master `PaymentAttemptCreateWorkflow.java`\n- [ ] Study state machines\n- [ ] Understand provider routing\n\n### Week 3: Integrations\n- [ ] Study 2-3 provider adapters\n- [ ] Understand webhook handling\n- [ ] Learn caching patterns\n\n### Week 4: Advanced\n- [ ] Decision tree engine\n- [ ] Async processing (Kafka, SQS)\n- [ ] Error handling patterns\n\n---\n\n## 15. KEY CONCEPTS\n\n1. **Multi-Provider Orchestration** - Route to optimal provider based on rules\n2. **Decision Trees** - JSON-based routing logic\n3. **State Machines** - Event-driven entity lifecycle\n4. **Master-Replica DB** - Read/write separation\n5. **Workflow Pattern** - 7-step execution pipeline\n6. **Event-Driven Architecture** - Guava EventBus + Kafka\n","structuredPatch":[],"originalFile":null}}
{"parentUuid":"a0962c41-1660-4ded-9fe2-4b54a93eb397","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_014rCVWSovSYdo83S12XJBzG","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"I've created a comprehensive study guide for the payment-service repository. This is a research/exploration task, not an implementation task, so I should ask the user if they'd like to dive deeper into any specific areas before exiting plan mode.\n\nLet me ask them if they have specific areas they want to explore further or if this study guide is sufficient.","signature":"EpEECkgICxABGAIqQDaxi3APdVRT3QdP3iBWvxzls4QDJSYThA2k/FbkuCwmzh+nC1++cIzsKrmtzNLn80k0+PTVp+n05sMJdgS56mESDFZlT+UgnHD5BhTSNBoMHrPyBSUdlUzh1SikIjBLa6XWFpnCbzI+x+/QYYXFZZzGnf+9YZOsONHNuMyPDayfOZcYbzXKpDiZjBq+ar8q9gI1TTDW5Ttfg79w+4IE0yWvOf+mGcBip02J/BFrwLnJXvEYn9Sl7Rzpn3v24/0g4rjsAm/LAxUQxn7RocxJvY3NQbYxz8pDhmY/Fp/XPALC5oqHp5iTV+UR2qLu2VJit3qxaX7JU5+/oZcqMVv1cROprxKkdP+iYh7jY1DLW/biXUlRCaAGi7cGdPdNadmjhnv9nmve7x4etHZTARsAHefdAjcXCF/tj5GsR5CK678DowxwmDA6htdOiKKwj4YRpMeV0KVbGLko1in7dXilduzUxRKYtxfDl6KsrMXnPOGzY7osDqpmia4GXUYyLgwMN7UPz3yCwcOZHUbRt7ERX6WNUSYlREci5fFam4wi7fhyXKZOZFIRTFtLEpgm2CBm//+oRoEwmZ+2DUFH0Pr7pBKxZbrZYan4AcKaTwapytsXqkU6lpzdUCpuIkv/bU/rUOuA5mPqrkYJ4j1UU6z8KVk9B/NhLYXyIWK/xHX5b6zgE+1g3nHV7RgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":4658,"cache_read_input_tokens":37258,"cache_creation":{"ephemeral_5m_input_tokens":4658,"ephemeral_1h_input_tokens":0},"output_tokens":1}},"type":"assistant","uuid":"aa7dc243-8518-4889-931f-6a4a78e537b1","timestamp":"2025-12-31T09:30:07.241Z"}
{"parentUuid":"aa7dc243-8518-4889-931f-6a4a78e537b1","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_014rCVWSovSYdo83S12XJBzG","type":"message","role":"assistant","content":[{"type":"text","text":"I've compiled a comprehensive study guide for the payment-service (Darwin) repository. Here's a summary of what I discovered:\n\n## Key Highlights\n\n### Technology Stack\n- **Java 17 + Spring Boot 2.7.14** microservice running on port 9010\n- **MySQL** with Master-Replica architecture for read/write separation\n- **DynamoDB** for audit trails and workflow state\n- **Redis (Redisson)** for distributed caching\n- **Kafka + AWS SQS** for async processing\n\n### Core Architecture\n- **24+ Payment Provider Integrations** (Razorpay, Cybersource, Cashfree, PayU, Juspay, UPI providers, etc.)\n- **Event-Driven State Machines** for payment lifecycle (using Guava EventBus)\n- **Decision Tree Engine** for dynamic provider routing\n- **7-Step Workflow Pattern** for payment processing\n\n### Critical Files to Study\n1. `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java` - Core payment flow\n2. `statemachine/payment/PaymentStateMachine.java` - Payment state transitions\n3. `planner/ProviderDeciderRouter.java` - Provider routing logic\n4. `v2/workflow/create/providers/` - Provider adapter implementations\n\nThe full study guide is in the plan file with a recommended 4-week learning path."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":4658,"cache_read_input_tokens":37258,"cache_creation":{"ephemeral_5m_input_tokens":4658,"ephemeral_1h_input_tokens":0},"output_tokens":1}},"type":"assistant","uuid":"f7023792-7f46-48bf-8ef6-4dd43fa6fab9","timestamp":"2025-12-31T09:30:12.694Z"}
{"parentUuid":"f7023792-7f46-48bf-8ef6-4dd43fa6fab9","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_014rCVWSovSYdo83S12XJBzG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_bdrk_01E7S9xvkLhh92fQMo28MiPY","name":"AskUserQuestion","input":{"questions":[{"question":"Which area would you like to deep-dive into first for your expert study?","header":"Focus Area","options":[{"label":"Payment Flow","description":"Deep-dive into PaymentAttemptCreateWorkflow, state machines, and end-to-end payment processing"},{"label":"Provider Integration","description":"Study how provider adapters work, webhook handling, and decision tree routing"},{"label":"Data Layer","description":"Explore entities, repositories, database architecture, and caching patterns"},{"label":"Study Guide OK","description":"The overview is sufficient - I'll study the guide and come back with specific questions"}],"multiSelect":false}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":4658,"cache_read_input_tokens":37258,"cache_creation":{"ephemeral_5m_input_tokens":4658,"ephemeral_1h_input_tokens":0},"output_tokens":623}},"type":"assistant","uuid":"18600387-75dc-4f20-b48a-3499f1f7a676","timestamp":"2025-12-31T09:30:16.445Z"}
{"parentUuid":"18600387-75dc-4f20-b48a-3499f1f7a676","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"User has answered your questions: \"Which area would you like to deep-dive into first for your expert study?\"=\"Data Layer\". You can now continue with the user's answers in mind.","tool_use_id":"toolu_bdrk_01E7S9xvkLhh92fQMo28MiPY"}]},"uuid":"e77c7554-af2f-4c54-97f9-56f400c142d9","timestamp":"2025-12-31T09:31:50.159Z","toolUseResult":{"questions":[{"question":"Which area would you like to deep-dive into first for your expert study?","header":"Focus Area","options":[{"label":"Payment Flow","description":"Deep-dive into PaymentAttemptCreateWorkflow, state machines, and end-to-end payment processing"},{"label":"Provider Integration","description":"Study how provider adapters work, webhook handling, and decision tree routing"},{"label":"Data Layer","description":"Explore entities, repositories, database architecture, and caching patterns"},{"label":"Study Guide OK","description":"The overview is sufficient - I'll study the guide and come back with specific questions"}],"multiSelect":false}],"answers":{"Which area would you like to deep-dive into first for your expert study?":"Data Layer"}}}
{"parentUuid":"e77c7554-af2f-4c54-97f9-56f400c142d9","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_012CumBrvEP23PaTPQYC1xfA","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user wants to deep-dive into the Data Layer. Let me launch an exploration agent to provide a comprehensive analysis of the data layer - entities, repositories, database architecture, and caching patterns.","signature":"EvsCCkgICxABGAIqQPb2JPtJ8pIlgWBXhJDV+awk85hAVvDiCQ/fnPjsyK2RjSnS05dS3OWLY+IrFJzRMMP/vnn5oCBDFYh75FJwQLESDEwQxTO1GphR/eTFsxoMSSmG9IN8yxlo1q+4IjC8KwTZ4+j8AyU3y7NYxsVCWQt9OJE3S7QLc3+Uo8m5bxAaAxAFmNUsG0oS68EEoVwq4AHh8D1P/qk5te4m3ltZyFRikJBYjDUmKiOIJVntyCQAlpJbrB1ZO+jMjWRmnxhD9cbF2Hc7hxIHlBCUhNR9cg21ro8kLkBHPlPYd1f40UQV4LsZEhF5fU5QYX9w9nR+AA7+WKWIVUtHIQ3PEqoZFrYrnPBKMza4HuNdKBGVG9WFZFD8WjP0YY2hyGWzZf2fFNSMU2nqTsYNbmxWYT6YS2/axzPA8vlmp94t3pO3+EKBi4UIRaxI/oci8plvYCNOUwnIT4DbiHamHI66iw+gGQlF5Dd5MjVHyU8YYtWHMVDhUxgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":784,"cache_read_input_tokens":41916,"cache_creation":{"ephemeral_5m_input_tokens":784,"ephemeral_1h_input_tokens":0},"output_tokens":1}},"type":"assistant","uuid":"065515f7-0996-41c7-9b35-139337698591","timestamp":"2025-12-31T09:31:56.507Z"}
{"parentUuid":"065515f7-0996-41c7-9b35-139337698591","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_012CumBrvEP23PaTPQYC1xfA","type":"message","role":"assistant","content":[{"type":"text","text":"Let me provide a deep-dive into the Data Layer architecture."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":784,"cache_read_input_tokens":41916,"cache_creation":{"ephemeral_5m_input_tokens":784,"ephemeral_1h_input_tokens":0},"output_tokens":1}},"type":"assistant","uuid":"0c649aae-9cb9-48f1-8310-b66407422777","timestamp":"2025-12-31T09:31:58.031Z"}
{"parentUuid":"0c649aae-9cb9-48f1-8310-b66407422777","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_012CumBrvEP23PaTPQYC1xfA","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_bdrk_01FgvXDWsvcQvv7uzreHegN4","name":"Task","input":{"description":"Deep-dive data layer architecture","prompt":"Provide an extremely detailed analysis of the payment-service Data Layer for expert study. Cover:\n\n1. **Entity Hierarchy & Relationships:**\n   - Base entity classes and inheritance patterns\n   - All major entities (Order, Payment, PaymentAttempt, Refund, etc.)\n   - Entity relationships (OneToMany, ManyToOne)\n   - How entities reference each other (foreign keys, external IDs)\n\n2. **Repository Patterns:**\n   - Standard JPA repositories vs custom implementations\n   - How Master/Replica routing works (@ReplicaRepository annotation)\n   - Custom query methods and naming conventions\n   - Pagination and projection patterns\n\n3. **Database Schema Design:**\n   - Key tables and their purposes\n   - Audit columns (created_at, updated_at, etc.)\n   - Soft delete patterns if any\n   - JSON columns for flexible attributes\n\n4. **Caching Architecture:**\n   - Each cache class and what it caches\n   - Cache loading strategies (eager vs lazy)\n   - Cache refresh mechanisms\n   - Cache invalidation patterns\n\n5. **DynamoDB Usage:**\n   - What data goes to DynamoDB vs MySQL\n   - DAO patterns for DynamoDB\n   - Entity design for NoSQL\n\n6. **Data Access Patterns:**\n   - How services access data (via repositories vs DAOs)\n   - Transaction management\n   - Connection pooling details\n\nProvide specific file paths, code examples, and architectural insights. This is for expert-level understanding.","subagent_type":"Explore"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":784,"cache_read_input_tokens":41916,"cache_creation":{"ephemeral_5m_input_tokens":784,"ephemeral_1h_input_tokens":0},"output_tokens":490}},"type":"assistant","uuid":"1d832931-2d5c-4259-b3d2-067129083963","timestamp":"2025-12-31T09:32:04.430Z"}
{"parentUuid":"1d832931-2d5c-4259-b3d2-067129083963","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01FgvXDWsvcQvv7uzreHegN4","type":"tool_result","content":[{"type":"text","text":"Perfect! Now I have comprehensive information. Let me create a detailed analysis document. Since I cannot write files, I'll provide the complete analysis as a detailed response:\n\n---\n\n## PAYMENT-SERVICE DATA LAYER - COMPREHENSIVE ARCHITECTURAL ANALYSIS\n\n### 1. ENTITY HIERARCHY & RELATIONSHIPS\n\n#### Base Entity Classes and Inheritance Patterns\n\nThe payment service uses a sophisticated multi-tiered entity hierarchy:\n\n**File: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/commons/BaseEntity.java`**\n\n```java\n@Getter @Setter @MappedSuperclass\npublic class BaseEntity {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @CreationTimestamp\n    @Column(name = \"created_at\")\n    private LocalDateTime createAt = LocalDateTime.now();\n    \n    @UpdateTimestamp\n    @Column(name = \"updated_at\")\n    private LocalDateTime updatedAt = LocalDateTime.now();\n    \n    @Column(name = \"created_by\")\n    private String createdBy;\n    \n    @Column(name = \"updated_by\")\n    private String updatedBy;\n    \n    @PrePersist public void onCreate() { /* audit tracking */ }\n    @PreUpdate public void onUpdate() { /* audit tracking */ }\n}\n```\n\n**File: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/provider/BaseExternalEntity.java`**\n\nExtends BaseEntity with external ID management:\n```java\n@MappedSuperclass\npublic class BaseExternalEntity extends BaseEntity {\n    @Column(name = \"external_id\", length = 36)\n    private String externalId;\n    \n    @Version\n    @Column(name = \"version\")\n    private Integer version;\n    \n    @PrePersist\n    public void onCreate() {\n        super.onCreate();\n        externalId = UUID.randomUUID().toString();\n    }\n}\n```\n\n**Hierarchy Structure:**\n```\nBaseEntity (audit columns: created_at, updated_at, created_by, updated_by, deleted flag)\n    ├── BaseExternalEntity (adds external_id, version for optimistic locking)\n    │   ├── OrderEntity\n    │   ├── PaymentV2Entity\n    │   ├── PaymentAttemptV2Entity\n    │   ├── RefundEntity\n    │   ├── ClientEntity\n    │   ├── CustomerEntity\n    │   ├── PaymentProviderEntity\n    │   ├── FeeEntity\n    │   └── (other external entities)\n    │\n    └── Non-External Entities (extends BaseEntity directly)\n        ├── ProviderAccountEntity\n        ├── ClientRefundRequestEntity\n        └── (configuration entities)\n```\n\n#### Key Entity Classes\n\n**1. OrderEntity**\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/OrderEntity.java`\n\n```java\n@Entity @Table(name = \"orders\")\npublic class OrderEntity extends BaseExternalEntity {\n    @Column(name = \"client_reference_id\")\n    private String clientReferenceId;\n    \n    @Column(name = \"amount\")\n    private BigDecimal amount;\n    \n    @Column(name = \"intent_amount\")\n    private BigDecimal intentAmount;\n    \n    @Column(name = \"type\")\n    @Enumerated(value = EnumType.STRING)\n    private OrderType type;\n    \n    @ManyToOne\n    @JoinColumn(name = \"client_id\")\n    private ClientEntity clientEntity;\n    \n    @Column(name = \"status\")\n    @Enumerated(value = EnumType.STRING)\n    private OrderStatus status;\n    \n    @ManyToOne(fetch = FetchType.EAGER)\n    @JoinColumn(name = \"customer_id\", updatable = false, insertable = false)\n    private CustomerEntity customerEntity;\n    \n    @Column(name = \"metadata\")\n    @Convert(converter = ObjectMetadataMapConverter.class)\n    private Map<String, String> metaData;\n    \n    @OneToMany(cascade = {CascadeType.MERGE, CascadeType.PERSIST})\n    @JoinColumn(name = \"order_id\")\n    private Set<OrderAttributeEntity> attributeEntities = new HashSet<>();\n    \n    @OneToOne(fetch = FetchType.LAZY, mappedBy = \"orderEntity\")\n    private OrderUdfEntity orderUdfEntity;\n}\n```\n\n**Relationships:**\n- Many-to-One with ClientEntity (foreign key: client_id)\n- Many-to-One with CustomerEntity (foreign key: customer_id, eager loaded)\n- One-to-Many with OrderAttributeEntity (cascade: MERGE, PERSIST)\n- One-to-One with OrderUdfEntity (lazy loaded)\n\n**2. PaymentV2Entity**\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/v2/PaymentV2Entity.java`\n\n```java\n@Entity @Table(name = \"payments\")\n@Inheritance(strategy = InheritanceType.JOINED)\npublic class PaymentV2Entity extends BaseExternalEntity {\n    @ManyToOne\n    @JoinColumn(name = \"order_id\")\n    private OrderEntity orderEntity;\n    \n    @Column(name = \"amount\")\n    private BigDecimal amount;\n    \n    @Column(name = \"status\")\n    @Enumerated(EnumType.STRING)\n    private PaymentStatus status;\n    \n    @Column(name = \"currency_value\")\n    private BigDecimal currencyValue;\n    \n    @Column(name = \"client_reference_id\")\n    private String clientReferenceId;\n    \n    @Column(name = \"currency\")\n    @Enumerated(EnumType.STRING)\n    private CurrencyName currency;\n    \n    @Column(name = \"conversion_rate\")\n    private BigDecimal conversionRate;\n    \n    @Column(name = \"instrument_detail\")\n    @Convert(converter = PaymentInstrumentConverter.class)\n    private PaymentInstrument instrumentDetail;\n    \n    @Convert(converter = PaymentSpecificDetailConverter.class)\n    @Column(name = \"payment_specific_detail\")\n    private PaymentSpecificDetail paymentSpecificDetail;\n    \n    @Column(name = \"payment_mode\")\n    @Enumerated(EnumType.STRING)\n    private PaymentMode paymentMode;\n}\n```\n\n**Note:** Uses JOINED inheritance strategy for polymorphic queries on payments table.\n\n**3. PaymentAttemptV2Entity**\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/v2/PaymentAttemptV2Entity.java`\n\n```java\n@Entity @Table(name = \"payment_attempts\")\n@Inheritance(strategy = InheritanceType.JOINED)\npublic class PaymentAttemptV2Entity extends BaseExternalEntity {\n    @Column(name = \"order_id\")\n    private Long orderId;\n    \n    @Column(name = \"external_id\", length = 36)\n    private String externalId;\n    \n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"order_id\", updatable = false, insertable = false)\n    private OrderEntity orderEntity;\n    \n    @ManyToOne\n    @JoinColumn(name = \"payment_id\")\n    private PaymentV2Entity paymentEntity;\n    \n    @Column(name = \"provider_reference_id\")\n    private String providerReferenceId;\n    \n    @Column(name = \"gateway_reference_id\")\n    private String gatewayReferenceId;\n    \n    @ManyToOne\n    @JoinColumn(name = \"payment_provider_id\")\n    private PaymentProviderEntity paymentProviderEntity;\n    \n    @ManyToOne\n    @JoinColumn(name = \"provider_account_id\")\n    private ProviderAccountEntity providerAccountEntity;\n    \n    @Column(name = \"payment_method\")\n    @Enumerated(EnumType.STRING)\n    private PaymentInstrumentGroup paymentMethod;\n    \n    @Column(name = \"payment_status\")\n    @Enumerated(EnumType.STRING)\n    private PaymentAttemptStatus status;\n    \n    @Column(name = \"error_code\")\n    private String errorCode;\n    \n    @Column(name = \"error_message\")\n    private String errorMessage;\n    \n    @Column(name = \"instrument_detail\")\n    @Convert(converter = EnrichedPaymentInstrumentConverter.class)\n    private EnrichedPaymentInstrument instrumentDetail;\n    \n    @OneToMany(cascade = {CascadeType.MERGE, CascadeType.PERSIST})\n    @JoinColumn(name = \"payment_attempt_id\")\n    private Set<PaymentAttemptAttributeEntity> attributeEntities = new HashSet<>();\n    \n    @Column(name = \"routes\")\n    @Convert(converter = RoutesBreakupConverter.class)\n    private RoutesBreakup routesBreakup;\n    \n    @PrePersist\n    public void onCreate() {\n        super.onCreate();\n        if (StringUtils.isEmpty(externalId)) {\n            externalId = PaymentAttemptUUIdGenerator.generate();\n        }\n    }\n}\n```\n\n**Relationships:**\n- Many-to-One with OrderEntity (orderId: non-updatable, non-insertable duplicate)\n- Many-to-One with PaymentV2Entity (payment_id)\n- Many-to-One with PaymentProviderEntity\n- Many-to-One with ProviderAccountEntity\n- One-to-Many with PaymentAttemptAttributeEntity\n\n**4. RefundEntity & RefundAttemptEntity**\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/v2/RefundEntity.java`\n\n```java\n@Entity @Table(name = \"refunds\") @Builder\npublic class RefundEntity extends BaseExternalEntity {\n    @ManyToOne(fetch = FetchType.EAGER)\n    @JoinColumn(name = \"order_id\")\n    private OrderEntity orderEntity;\n    \n    @ManyToOne(fetch = FetchType.EAGER)\n    @JoinColumn(name = \"payment_attempt_id\")\n    private PaymentAttemptV2Entity paymentAttempt;\n    \n    @Column(name = \"refund_type\")\n    @Enumerated(EnumType.STRING)\n    private RefundType refundType;\n    \n    @Column(name = \"refund_value\")\n    @DecimalMin(value = \"0.0\", inclusive = true)\n    private BigDecimal refundValue;\n    \n    @Column(name = \"refund_status\")\n    @Enumerated(EnumType.STRING)\n    private RefundStatus refundStatus;\n    \n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"client_refund_request_id\")\n    private ClientRefundRequestEntity clientRefundRequestEntity;\n    \n    @Column(name = \"scheduled_at\")\n    private LocalDateTime scheduledAt;\n    \n    @Transient\n    @Default\n    private Boolean canReorganize = Boolean.TRUE;\n}\n```\n\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/v2/RefundAttemptEntity.java`\n\n```java\n@Entity @Table(name = \"refund_attempts\") @Builder\npublic class RefundAttemptEntity extends BaseExternalEntity {\n    @ManyToOne(fetch = FetchType.EAGER)\n    @JoinColumn(name = \"refund_id\")\n    private RefundEntity refund;\n    \n    @ManyToOne(fetch = FetchType.EAGER)\n    @JoinColumn(name = \"payment_attempt_id\")\n    private PaymentAttemptV2Entity paymentAttempt;\n    \n    @ManyToOne(fetch = FetchType.EAGER)\n    @JoinColumn(name = \"provider_account_id\")\n    private ProviderAccountEntity providerAccountEntity;\n    \n    @Column(name = \"error_code\")\n    private String errorCode;\n    \n    @Column(name = \"provider_reference_id\")\n    private String providerReferenceId;\n    \n    @Column(name = \"refund_status\")\n    @Enumerated(EnumType.STRING)\n    private RefundStatus refundStatus;\n    \n    @Column(name = \"previous_status\")\n    @Enumerated(EnumType.STRING)\n    private RefundStatus previousStatus;\n    \n    @Column(name = \"refund_channel\")\n    @Enumerated(EnumType.STRING)\n    private RefundChannel refundChannel;\n    \n    @Column(name = \"request_status\")\n    @Enumerated(EnumType.STRING)\n    private ProviderRequestStatus requestStatus;\n    \n    @OneToMany(cascade = {CascadeType.MERGE, CascadeType.PERSIST})\n    @JoinColumn(name = \"refund_attempt_id\")\n    private Set<RefundAttemptAttributeEntity> attributeEntities = new HashSet<>();\n}\n```\n\n**5. ClientEntity & CustomerEntity**\n\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/ClientEntity.java`\n\n```java\n@Entity @Table(name = \"clients\")\npublic class ClientEntity extends BaseExternalEntity {\n    @Column(name = \"name\")\n    private String name;\n    \n    @Column(name = \"merchant_id\")\n    private String merchantId;\n    \n    @Column(name = \"is_deleted\")\n    private Boolean deleted = Boolean.FALSE;\n    \n    @OneToMany(cascade = {CascadeType.MERGE, CascadeType.PERSIST}, fetch = FetchType.EAGER)\n    @JoinColumn(name = \"client_id\")\n    private Set<ClientSettingsEntity> settings = new HashSet<>();\n}\n```\n\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/CustomerEntity.java`\n\n```java\n@Entity @Table(name = \"customers\")\npublic class CustomerEntity extends BaseExternalEntity {\n    @Column(name = \"name\")\n    private String name;\n    \n    @Column(name = \"email\")\n    private String email;\n    \n    @Column(name = \"contact_number\")\n    private String contactNumber;\n    \n    @Column(name = \"is_deleted\")\n    private Boolean deleted = Boolean.FALSE;\n}\n```\n\n**6. Provider-Related Entities**\n\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/PaymentProviderEntity.java`\n\n```java\n@Entity @Table(name = \"payment_providers\") @Builder\npublic class PaymentProviderEntity extends BaseExternalEntity {\n    @Column(name = \"name\")\n    private String name;\n    \n    @Column(name = \"provider_key\")\n    private String key;\n    \n    @Column(name = \"active\")\n    @Builder.Default\n    private Boolean active = true;\n    \n    @Column(name = \"is_customer_required\")\n    @Builder.Default\n    private Boolean customerRequired = false;\n    \n    @OneToMany(cascade = {CascadeType.MERGE, CascadeType.PERSIST})\n    @JoinColumn(name = \"payment_provider_id\")\n    private Set<PaymentProviderSettingsEntity> settings = new HashSet<>();\n}\n```\n\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/ProviderAccountEntity.java`\n\n```java\n@Entity @Table(name = \"provider_accounts\") @Builder\npublic class ProviderAccountEntity extends BaseEntity {\n    @ManyToOne\n    @JoinColumn(name = \"payment_provider_id\")\n    private PaymentProviderEntity paymentProvider;\n    \n    @Column(name = \"provider_account_id\")\n    private String providerAccountId;\n    \n    @Column(name = \"access_token\") @Lob\n    private byte[] accessToken;\n    \n    @Column(name = \"endpoint\")\n    private String endpoint;\n    \n    @Column(name = \"is_prod\")\n    private Boolean isProd;\n    \n    @Column(name = \"active\")\n    @Builder.Default\n    private Boolean active = true;\n    \n    @Column(name = \"provider_mid\")\n    private String providerMid;\n    \n    @Column(name = \"settlement_category\")\n    private String settlementCategory;\n}\n```\n\n**7. Fee Entity**\n\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/v2/FeeEntity.java`\n\n```java\n@Entity @Table(name = \"fees\")\npublic class FeeEntity extends BaseExternalEntity {\n    @Column(name = \"fee_id\")\n    private String feeId;\n    \n    @Column(name = \"amount\")\n    private BigDecimal amount;\n    \n    @Column(name = \"type\")\n    private String type;\n    \n    @Column(name = \"base_entity_type\")\n    @Enumerated(value = EnumType.STRING)\n    private FeeBaseEntityType baseEntityType;\n    \n    @Column(name = \"base_entity_id\")\n    private String baseEntityId;\n}\n```\n\n**8. ClientRefundRequestEntity**\n\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/v2/ClientRefundRequestEntity.java`\n\n```java\n@Entity @Table(name = \"client_refund_requests\")\npublic class ClientRefundRequestEntity extends BaseEntity {\n    @Column(name = \"external_id\", length = 36)\n    private String externalId;\n    \n    @ManyToOne\n    @JoinColumn(name = \"client_id\")\n    private ClientEntity clientEntity;\n    \n    @ManyToOne\n    @JoinColumn(name = \"order_id\")\n    private OrderEntity orderEntity;\n    \n    @Column(name = \"amount\")\n    private BigDecimal amount;\n    \n    @Column(name = \"request_status\")\n    @Enumerated(EnumType.STRING)\n    private RefundRequestStatus requestStatus;\n    \n    @Column(name = \"additional_info\")\n    @Convert(converter = ClientRefundAdditionalInfoConverter.class)\n    private ClientRefundAdditionalInfo additionalInfo;\n    \n    @Version\n    @Column(name = \"version\")\n    private Integer version;\n    \n    @Column(name = \"reserved_udfs\")\n    @Convert(converter = ReservedUdfsMapConverter.class)\n    private Map<String, Object> reservedUdfs;\n    \n    @Column(name = \"merchant_udfs\")\n    @Convert(converter = ReservedUdfsMapConverter.class)\n    private Map<String, String> merchantUdfs;\n}\n```\n\n#### Entity Relationship Diagram (ERD) Summary\n\n```\n┌─────────────────┐\n│   ClientEntity  │\n└────────┬────────┘\n         │ 1\n         │\n    ┌────┴─────────────────────┐\n    │                          │ M\n    │                     ┌────▼──────────┐\n    │                     │    OrderEntity │\n    │                     └────┬──────────┘\n    │                          │ 1\n    │                          │\n    │                 ┌────────┼─────────┐\n    │                 │        │         │\n    │            ┌────▼─┐  ┌──▼──┐  ┌───▼────────────┐\n    │            │Pyment│  │Refnd│  │ClientRefund    │\n    │            │Entity│  │Entity  │RequestEntity   │\n    │            └────┬─┘  └──┬──┘  └───────────────┘\n    │                 │       │\n    │            ┌────▼────────▼─────────┐\n    │            │ PaymentAttemptEntity  │\n    │            └────┬──────────────┬───┘\n    │                 │              │\n    │            ┌────▼──┐      ┌────▼─────────────┐\n    │            │Provider│     │RefundAttemptEntity\n    │            │Account │     └───────────────────┘\n    │            └────────┘\n\n   M\n    │\n    │ 1\n┌───▼──────────┐\n│CustomerEntity│\n└──────────────┘\n```\n\n---\n\n### 2. REPOSITORY PATTERNS\n\n#### Base Repository Architecture\n\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/repository/commons/BaseRepository.java`\n\n```java\n@NoRepositoryBean\ninterface BaseRepository<T> extends JpaRepository<T, Long> {}\n```\n\n#### Key Repository Implementations\n\n**1. OrderRepository**\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/repository/OrderRepository.java`\n\n```java\n@Repository\npublic interface OrderRepository extends JpaRepository<OrderEntity, Long> {\n    @Query(\"SELECT o FROM OrderEntity o \"\n            + \"JOIN FETCH o.customerEntity as cust \"\n            + \"JOIN FETCH o.clientEntity as client \"\n            + \"LEFT JOIN FETCH o.orderUdfEntity as udfs \"\n            + \"WHERE o.externalId = :externalId\")\n    Optional<OrderEntity> findByExternalId(@Param(\"externalId\") String externalId);\n    \n    @Query(\"SELECT o FROM OrderEntity o \"\n            + \"JOIN FETCH o.customerEntity as cust \"\n            + \"JOIN FETCH o.clientEntity as client \"\n            + \"LEFT JOIN FETCH o.orderUdfEntity as udfs \"\n            + \"WHERE o.clientReferenceId = :clientReferenceId \"\n            + \"AND o.clientEntity.externalId = :externalId\")\n    Optional<OrderEntity> findByClientReferenceIdAndClientEntity_ExternalId(\n            @Param(\"clientReferenceId\") String clientReferenceId, \n            @Param(\"externalId\") String externalId);\n    \n    @Query(\"SELECT o FROM OrderEntity o \"\n            + \"JOIN FETCH o.customerEntity as cust \"\n            + \"JOIN FETCH o.clientEntity as client \"\n            + \"LEFT JOIN FETCH o.orderUdfEntity as udfs \"\n            + \"WHERE o.tagId = :tagId\")\n    List<OrderEntity> findByTagId(@Param(\"tagId\") String tagId);\n}\n```\n\n**Query Pattern Notes:**\n- Uses explicit FETCH JOINs to eagerly load related entities\n- Prevents N+1 query problems\n- LEFT JOIN FETCH for optional relationships\n\n**2. PaymentRepository**\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/repository/PaymentRepository.java`\n\n```java\n@Repository\npublic interface PaymentRepository extends JpaRepository<PaymentV2Entity, Long> {\n    Optional<PaymentV2Entity> findByExternalId(String externalId);\n    \n    List<PaymentV2Entity> findByOrderEntity_ExternalId(String externalId);\n    \n    List<PaymentV2Entity> findByOrderEntity_Id(Long orderId);\n    \n    List<PaymentV2Entity> findByOrderEntity_ExternalIdAndStatusIn(\n            String externalId, List<PaymentStatus> statuses);\n    \n    @Query(\"select p from PaymentV2Entity as p where p.orderEntity.externalId = :externalId \n            and p.status not in :excludedStatusList\")\n    List<PaymentV2Entity> findPaymentsForOrderExcludingPaymentsWithStatus(\n            @Param(\"externalId\") String externalId,\n            @Param(\"excludedStatusList\") List<PaymentStatus> excludedStatusList);\n}\n```\n\n**3. PaymentAttemptRepository**\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/repository/PaymentAttemptRepository.java`\n\n```java\n@Repository\npublic interface PaymentAttemptRepository extends JpaRepository<PaymentAttemptV2Entity, Long> {\n    \n    @Query(\"SELECT pa FROM PaymentAttemptV2Entity pa \"\n            + \"JOIN FETCH pa.paymentEntity as payment \"\n            + \"JOIN FETCH pa.paymentProviderEntity as paymentProvider \"\n            + \"JOIN FETCH pa.providerAccountEntity as providerAccount \"\n            + \"WHERE payment.externalId = :paymentId\")\n    List<PaymentAttemptV2Entity> findByPaymentEntity_ExternalId(@Param(\"paymentId\") String paymentId);\n    \n    Optional<PaymentAttemptV2Entity> findByProviderReferenceId(String provideReferenceId);\n    \n    @Query(\"SELECT pa FROM PaymentAttemptV2Entity pa \"\n            + \"JOIN FETCH pa.paymentEntity as payment \"\n            + \"JOIN FETCH pa.paymentProviderEntity as paymentProvider \"\n            + \"JOIN FETCH pa.providerAccountEntity as providerAccount \"\n            + \"WHERE pa.externalId = :externalId\")\n    Optional<PaymentAttemptV2Entity> findByExternalId(@Param(\"externalId\") String externalId);\n}\n```\n\n**4. Refund Repository (Read-Only)**\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/repository/read_only_repository/RefundRepository.java`\n\n```java\n@Repository\npublic interface RefundRepository extends JpaRepository<RefundEntity, Long> {\n    List<RefundEntity> findByClientRefundRequestEntity_Id(Long id);\n    \n    List<RefundEntity> findByOrderEntity_Id(Long orderId);\n    \n    List<RefundEntity> findByOrderEntity_ExternalId(String orderId);\n}\n```\n\n#### Master/Replica Routing Architecture\n\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/configuration/database/annotation/ReplicaRepository.java`\n\n```java\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE})\n@Documented\npublic @interface ReplicaRepository {}\n```\n\n**Configuration: MasterDataSourceConfiguration**\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/configuration/database/MasterDataSourceConfiguration.java`\n\n```java\n@Configuration\n@EnableJpaRepositories(\n    basePackages = {REPO_PATH, DAO_PATH},\n    excludeFilters = @ComponentScan.Filter(ReplicaRepository.class),\n    entityManagerFactoryRef = MASTER_ENTITY_MANAGER_FACTORY,\n    transactionManagerRef = MASTER_TRANSACTION_MANAGER)\npublic class MasterDataSourceConfiguration {\n    @Bean(name = MASTER_DATA_SOURCE)\n    @Primary\n    public DataSource dataSource(MaintenanceManager maintenanceManager) throws Exception {\n        HikariConfig hikariConfig = new HikariConfig();\n        hikariConfig.setIdleTimeout(hikariIdleTimeout);\n        hikariConfig.setMinimumIdle(masterMinimumIdle.intValue());\n        hikariConfig.setMaximumPoolSize(masterMaximumPoolSize.intValue());\n        hikariConfig.setPoolName(\"hikari_master\");\n        hikariConfig.setJdbcUrl(url);\n        // ... configuration for write operations\n        HikariDataSource masterDataSource = new HikariDataSource(hikariConfig);\n        maintenanceManager.registerHandler(new HikariMaintenanceHandler(masterDataSource));\n        return masterDataSource;\n    }\n}\n```\n\n**Configuration: ReplicaDataSourceConfiguration**\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/configuration/database/ReplicaDataSourceConfiguration.java`\n\n```java\n@Configuration\n@EnableJpaRepositories(\n    basePackages = {REPO_PATH, DAO_PATH},\n    includeFilters = @ComponentScan.Filter(ReplicaRepository.class),\n    entityManagerFactoryRef = REPLICA_ENTITY_MANAGER_FACTORY,\n    transactionManagerRef = REPLICA_TRANSACTION_MANAGER)\npublic class ReplicaDataSourceConfiguration {\n    @Bean(name = REPLICA_DATA_SOURCE)\n    public DataSource dataSource(MaintenanceManager maintenanceManager) {\n        HikariConfig hikariConfig = new HikariConfig();\n        hikariConfig.setReadOnly(true);  // KEY: Read-only mode\n        hikariConfig.setMinimumIdle(replicaMinimumIdle.intValue());\n        hikariConfig.setMaximumPoolSize(replicaMaximumPoolSize.intValue());\n        hikariConfig.setPoolName(\"hikari_replica\");\n        // Separate datasource URL for replica\n        hikariConfig.setJdbcUrl(replicaDatasourceUrl);\n        HikariDataSource replicaDataSource = new HikariDataSource(hikariConfig);\n        maintenanceManager.registerHandler(new HikariMaintenanceHandler(replicaDataSource));\n        return replicaDataSource;\n    }\n}\n```\n\n**Replica Read DAOs Pattern**\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/dao/read_only_dao/impl/AbstractReplicaDAOImpl.java`\n\n```java\n@ReplicaRepository  // Annotation routes to replica datasource\npublic abstract class AbstractReplicaDAOImpl<T extends BaseExternalEntity, R> \n        extends AbstractDAOImpl<T, R> implements AbstractExternalDAO<T, R> {\n    // Uses replica EntityManager through @ReplicaRepository annotation\n}\n```\n\nExamples of Replica DAOs:\n- `RefundEntityReplicaDAOImpl` - @ReplicaRepository\n- `PaymentAttemptReplicaReadDAO` - @ReplicaRepository\n- `RefundAttemptReplicaReadDAO` - @ReplicaRepository\n- `OrderReplicaReadDAO` - @ReplicaRepository\n\n**How It Works:**\n1. Component scan in MasterDataSourceConfiguration excludes @ReplicaRepository beans\n2. Component scan in ReplicaDataSourceConfiguration includes only @ReplicaRepository beans\n3. Both configurations use separate EntityManagerFactory instances\n4. Read queries are routed to replica datasource via separate EntityManager\n5. Connection pooling is managed separately with HikariCP\n6. Read-only flag set on replica connection pool prevents accidental writes\n\n#### Pagination and Projection Patterns\n\nRepositories extend JpaRepository, inheriting built-in pagination:\n- `Page<T> findAll(Pageable pageable)`\n- `findAll(Specification<T> spec, Pageable pageable)`\n\nCustom naming convention examples:\n- `findByOrderEntity_ExternalId()` - navigates relationships\n- `findByOrderEntity_ExternalIdAndStatusIn()` - compound conditions\n- `findByClientRefundRequestEntity_Id()` - nested foreign key lookups\n\n---\n\n### 3. DATABASE SCHEMA DESIGN\n\n#### Key Tables and Purposes\n\n**Core Transaction Tables:**\n1. **orders** - Main order entity\n   - Columns: id (PK), external_id (UUID), client_id (FK), customer_id (FK), status, amount, intent_amount, metadata, created_at, updated_at, created_by, updated_by\n\n2. **payments** - Payment records linked to orders\n   - Columns: id (PK), external_id (UUID), order_id (FK), status, amount, currency, payment_mode, instrument_detail (JSON), payment_specific_detail (JSON), created_at, updated_at\n\n3. **payment_attempts** - Individual payment gateway attempts\n   - Columns: id (PK), external_id (UUID), order_id, payment_id (FK), payment_provider_id (FK), provider_account_id (FK), payment_method, provider_reference_id, gateway_reference_id, provider_status, payment_status, error_code, error_message, instrument_detail (JSON), routes (JSON), created_at, updated_at\n\n4. **refunds** - Refund master records\n   - Columns: id (PK), external_id (UUID), order_id (FK), payment_attempt_id (FK), refund_type, refund_status, refund_value, currency_value, scheduled_at, created_at, updated_at\n\n5. **refund_attempts** - Individual refund gateway attempts\n   - Columns: id (PK), external_id (UUID), refund_id (FK), payment_attempt_id (FK), provider_account_id (FK), refund_status, previous_status, provider_reference_id, refund_channel, request_status, created_at, updated_at\n\n#### Audit Columns Pattern\n\nAll entities implement audit tracking:\n```\ncreated_at: LocalDateTime (auto-populated on insert via @CreationTimestamp)\nupdated_at: LocalDateTime (auto-updated on every modification via @UpdateTimestamp)\ncreated_by: String (application/client name)\nupdated_by: String (application/client name)\nversion: Integer (optimistic locking in BaseExternalEntity)\n```\n\n#### Soft Delete Pattern\n\nSome entities implement soft deletes:\n```java\n@Column(name = \"is_deleted\")\nprivate Boolean deleted = Boolean.FALSE;\n```\n\nUsed in:\n- ClientEntity\n- CustomerEntity\n- ProviderAccountEntity (may be used)\n\n#### JSON Columns for Flexible Attributes\n\nCustom Hibernate converters allow storing complex objects as JSON:\n\n1. **ObjectMetadataMapConverter** - Stores OrderEntity.metaData (Map<String, String>)\n2. **PaymentInstrumentConverter** - PaymentV2Entity.instrumentDetail\n3. **PaymentSpecificDetailConverter** - PaymentV2Entity.paymentSpecificDetail\n4. **EnrichedPaymentInstrumentConverter** - PaymentAttemptV2Entity.instrumentDetail\n5. **PaymentSubMethodDetailConverter** - PaymentAttemptV2Entity.paymentSubMethod\n6. **RoutesBreakupConverter** - PaymentAttemptV2Entity.routesBreakup\n7. **ClientRefundAdditionalInfoConverter** - ClientRefundRequestEntity.additionalInfo\n8. **ReservedUdfsMapConverter** - ClientRefundRequestEntity.reservedUdfs & merchantUdfs\n\nThese use Hibernate @Convert annotation for transparent serialization/deserialization.\n\n#### Relationship Pattern - Duplicate Foreign Keys\n\nPaymentAttemptV2Entity uses a pattern to avoid JOIN in many queries:\n```java\n@Column(name = \"order_id\")\nprivate Long orderId;\n\n@ManyToOne(fetch = FetchType.LAZY)\n@JoinColumn(name = \"order_id\", updatable = false, insertable = false)\nprivate OrderEntity orderEntity;\n```\n\nBenefits:\n- Can query by orderId without joining OrderEntity\n- Avoids cascade load of full OrderEntity when not needed\n- Non-updatable/non-insertable prevents Hibernate from trying to manage the relationship\n\n---\n\n### 4. CACHING ARCHITECTURE\n\n#### Cache Classes and What They Cache\n\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/cache/`\n\n**1. ClientConfigurationCache**\n\n```java\n@Component @RequiredArgsConstructor\npublic class ClientConfigurationCache extends AbstractDPManagedCache implements IDPManagedCache {\n    private final CacheConfig cacheConfig;\n    private final ClientRepository clientRepository;\n    \n    @DPCache(cacheName = \"client_configuration_cache\")\n    private LoadingCache<Long, Map<ClientSettingKey, String>> idCache;\n    \n    @DPCache(cacheName = \"client_by_id_cache\")\n    private LoadingCache<Long, ClientEntity> clientByIdCache;\n    \n    @DPCache(cacheName = \"client_by_external_id_cache\")\n    private LoadingCache<String, ClientEntity> clientByExternalIdCache;\n    \n    @DPCache(cacheName = \"client_by_merchant_id_cache\")\n    private LoadingCache<String, ClientEntity> clientByMerchantId;\n    \n    @Override\n    public void buildCache() {\n        idCache = DPCacheBuilder.getBuilder()\n                .refreshAfterWrite(10-20 mins, MINUTES)\n                .build(this::loadClientSettings);\n        // ... other caches\n    }\n}\n```\n\n**Caches:**\n- Client settings by client ID (Map of setting keys to values)\n- Client entity by ID\n- Client entity by external ID\n- Client entity by merchant ID\n\n**TTL:** 10-20 minutes (with random jitter for staggered refreshes)\n\n**2. PaymentProviderCache**\n\nCaches payment provider configurations:\n- Providers by ID\n- Provider settings\n- TTL: 15-25 minutes\n\n**3. ProviderAccountCache**\n\n```java\n@Component @RequiredArgsConstructor\npublic class ProviderAccountCache extends AbstractDPManagedCache implements IDPManagedCache {\n    \n    @DPCache(cacheName = \"provider_account_by_id_cache\")\n    private LoadingCache<Long, ProviderAccountEntity> providerAccountByIdCache;\n    \n    @DPCache(cacheName = \"provider_account_by_provider_id_cache\")\n    private LoadingCache<String, List<ProviderAccountEntity>> providerAccountsByProviderCache;\n    \n    // ... TTL: 15-25 minutes\n}\n```\n\n**4. FeeCache**\n\n```java\n@Component @RequiredArgsConstructor\npublic class FeeCache extends AbstractDPManagedCache implements IDPManagedCache {\n    \n    @DPCache(cacheName = \"fee_by_id_cache\")\n    private LoadingCache<String, FeeDto> cache;\n    \n    @Override\n    public void buildCache() {\n        cache = DPCacheBuilder.getBuilder()\n                .refreshAfterWrite(1, DAYS)\n                .maximumSize(500)\n                .build(feeId -> feeService.getFeeByFeeId(feeId)\n                        .map(feeCampaign -> FeeDto.builder()\n                                .isRefundable(feeCampaign.getRefundable())\n                                .feeId(feeCampaign.getFeeId())\n                                .feeType(feeCampaign.getFeeType())\n                                .build())\n                        .orElse(null));\n    }\n}\n```\n\n**TTL:** 1 day, Max size: 500 entries\n\n**5. IssuerCache**\n\nCaches bank issuer information from arsenal service (card BIN details):\n- Issuer by ISIN\n- TTL: Configured via CacheConfig\n\n**6. CardBinCache & CardHashedBinCache**\n\n```java\n@Component @RequiredArgsConstructor\npublic class CardBinCache extends AbstractDPManagedCache implements IDPManagedCache {\n    \n    @DPCache(cacheName = \"card_bin_cache\")\n    private LoadingCache<String, CardBinDetail> cardBinCache;\n    \n    @Override\n    public void buildCache() {\n        cardBinCache = DPCacheBuilder.getBuilder()\n                .refreshAfterWrite(cacheConfig.getCardBinCacheTTL(), HOURS)\n                .build(this::loadCardBinDetails);\n    }\n}\n```\n\n**7. MasterConfigurationCache**\n\nCaches system-wide master configurations:\n- Feature flags\n- System settings\n- TTL: 10-20 minutes\n\n**8. ClientPaymentProviderConfigCache**\n\nClient-specific payment provider configurations:\n```java\n@DPCache(cacheName = \"client_payment_provider_config_cache\")\nprivate LoadingCache<String, ClientPaymentProviderConfigCache.CacheKey, List<ClientPaymentProviderConfigEntity>> cache;\n```\nTTL: 10-20 minutes\n\n**9. DecisionTreeObjectCache**\n\n```java\n@Component @RequiredArgsConstructor\npublic class DecisionTreeObjectCache extends AbstractDPManagedCache implements IDPManagedCache {\n    \n    @DPCache(cacheName = \"decision_tree_object_cache\")\n    private LoadingCache<String, DecisionTreeObjectEntity> decisionTreeObjectCache;\n    \n    // TTL: 180-190 minutes\n}\n```\n\n**10. PaymentErrorMessageMappingCache**\n\nMaps payment error codes to user-friendly messages\n\n**11. NativeOTPSupportedProviderCache**\n\nCaches providers supporting native OTP\n\n**12. NetBankingProviderConfigCache**\n\nNet banking provider-specific configurations\n\n**13. ClientRateLimitConfigCache**\n\nRate limiting configurations per client:\n```java\n@DPCache(cacheName = \"client_rate_limit_config_cache\")\nprivate LoadingCache<Long, ClientRateLimitConfigEntity> clientRateLimitConfigCache;\n```\nTTL: 15-25 minutes\n\n**14. MerchantCache**\n\nMerchant information cache:\nTTL: 1 day\n\n**15. UpiTerminalDetailCache**\n\nUPI terminal details for UPI payments:\nTTL: 7-17 days\n\n#### Cache Loading Strategies\n\n**Eager vs Lazy Loading:**\n\nAll caches use **lazy loading** with `LoadingCache<K, V>`:\n- Cache entries are loaded on-demand (first access)\n- No bulk pre-loading at startup\n- Uses `CacheLoader` function to fetch from repository\n\n**Example:**\n```java\nloadClientSettings = (clientId) -> {\n    ClientEntity clientEntity = clientRepository.findById(clientId)\n            .orElseThrow(() -> Error.invalid_client_id.getBuilder().build());\n    \n    return clientEntity.getSettings().stream()\n            .collect(Collectors.toMap(ClientSettingsEntity::getSettingKey, \n                                     ClientSettingsEntity::getSettingValue));\n}\n```\n\n#### Cache Refresh Mechanisms\n\n**Refresh Strategy:** `refreshAfterWrite(duration, TimeUnit)`\n\nUses Caffeine cache:\n- After specified duration of no access, cache entry is refreshed asynchronously\n- Old value returned while new value loads\n- Prevents cache stampede\n\n**Configuration Example:**\n```java\nidCache = DPCacheBuilder.getBuilder()\n        .refreshAfterWrite(cacheConfig.getMasterConfigurationTTL(), MINUTES)\n        .build(this::loadClientSettings);\n```\n\n**Jittered TTLs:**\n```java\nprivate Long generateRandomCacheRefreshInterval(int source) {\n    int min = 1;\n    int max = 10;\n    SecureRandom random = new SecureRandom();\n    return Long.valueOf(source + random.nextInt(max - min + 1) + min);\n}\n// Usage: generateRandomCacheRefreshInterval(15) returns 16-25 minutes\n```\n\nPrevents thundering herd problem where all caches refresh simultaneously.\n\n#### Cache Invalidation Patterns\n\n**No explicit invalidation found.** Cache invalidation relies on:\n\n1. **TTL-based expiration** - Primary mechanism\n2. **Manual refresh** - Services can manually call refresh if needed\n3. **Application restart** - Caches are rebuilt on startup\n\nPattern seen in ClientConfigurationCache:\n```java\npublic Optional<ClientEntity> getActiveClientByExternalId(String clientId) {\n    ClientEntity clientEntity = getClientByExternalId(clientId);\n    return isClientActive(clientEntity) ? Optional.of(clientEntity) : Optional.empty();\n}\n```\n\nClients check active status each time rather than caching state.\n\n#### Cache Infrastructure\n\n**Caffeine Cache Framework:**\n- Thread-safe, high-performance in-memory cache\n- Automatic expiration and refresh\n- Built-in metrics and monitoring\n\n**DPCacheBuilder Pattern:**\n```java\nDPCacheBuilder.getBuilder()\n    .refreshAfterWrite(ttl, timeUnit)\n    .maximumSize(size)  // Optional size limit\n    .build(loaderFunction)  // CacheLoader implementation\n```\n\n---\n\n### 5. DYNAMODB USAGE\n\n#### What Data Goes to DynamoDB vs MySQL\n\n**MySQL (Primary Data):**\n- All transactional data: Orders, Payments, PaymentAttempts, Refunds, RefundAttempts\n- Master data: Clients, Customers, PaymentProviders, ProviderAccounts\n- Configuration: ClientSettings, PaymentProviderSettings\n- Fees and adjustments\n\n**DynamoDB (NoSQL/Temporary State):**\n- Workflow context for payments (TTL-based, temporary)\n- Native OTP authentication details\n- Payment attempt redirects\n- Metadata audit trails\n- Native OTP attempt tracking\n\n#### DAO Patterns for DynamoDB\n\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/dynamo/dao/AbstractDynamoDBDAO.java`\n\n```java\n@RequiredArgsConstructor\npublic abstract class AbstractDynamoDBDAO<T> {\n    private final Class<T> tClass;\n    private final DynamoDBMapper dynamoDBMapper;\n    \n    public void save(T entity) {\n        dynamoDBMapper.save(entity);\n    }\n    \n    public void saveIfNotExists(T entity, List<String> uniqueKeys) {\n        if (CollectionUtils.isEmpty(uniqueKeys)) {\n            save(entity);\n        }\n        DynamoDBSaveExpression saveExpression = new DynamoDBSaveExpression();\n        Map<String, ExpectedAttributeValue> expected = new HashMap<>();\n        uniqueKeys.forEach(key -> {\n            expected.put(key, new ExpectedAttributeValue().withExists(false));\n        });\n        saveExpression.setExpected(expected);\n        dynamoDBMapper.save(entity, saveExpression);\n    }\n    \n    public T findByHashKey(Object hashKey) {\n        return dynamoDBMapper.load(tClass, hashKey);\n    }\n}\n```\n\n**Key Methods:**\n- `save(T entity)` - Put/update item\n- `saveIfNotExists(T entity, uniqueKeys)` - Conditional put (atomic check-and-set)\n- `findByHashKey(Object hashKey)` - Get by partition key\n\n#### DynamoDB Entity Designs\n\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/dynamo/domain/PaymentAttemptWorkflowContextEntity.java`\n\n```java\n@Data @Builder @NoArgsConstructor @AllArgsConstructor\n@DynamoDBTable(tableName = \"darwin_payment_attempt_workflow_context\")\npublic class PaymentAttemptWorkflowContextEntity {\n    \n    @DynamoDBHashKey(attributeName = \"payment_attempt_external_id\")\n    private String paymentAttemptExternalId;\n    \n    @Builder.Default\n    @DynamoDBAttribute\n    private long ttl = LocalDateTime.now().plusDays(1).toEpochSecond(ZoneOffset.UTC);\n    \n    @DynamoDBRangeKey\n    @DynamoDBTypeConvertedEnum\n    @DynamoDBAttribute(attributeName = \"workflow_step\")\n    private WorkflowStep workflowStep;\n    \n    @DynamoDBAttribute(attributeName = \"data\")\n    private String data;\n    \n    @DynamoDBTypeConverted(converter = LocalDateTimeConverter.class)\n    @DynamoDBAttribute(attributeName = \"event_at\")\n    private LocalDateTime eventAt;\n}\n```\n\n**Design Pattern:**\n- **Partition Key (Hash Key):** `payment_attempt_external_id` - Groups all workflow steps for a payment attempt\n- **Sort Key (Range Key):** `workflow_step` - Allows querying workflow history in order\n- **TTL:** Automatic expiration after 1 day\n- **Converters:** LocalDateTime to/from DynamoDB format\n\n#### DynamoDB DAOs\n\n**PaymentAttemptWorkflowContextDAO**\n- Stores workflow step progression\n- TTL-based auto-cleanup\n- Enables workflow replay and debugging\n\n**PaymentAttemptNativeOTPDetailEntityDAO**\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/dynamo/domain/nativeotp/PaymentAttemptNativeOTPDetailEntity.java`\n\n```java\n@Data @Builder\n@DynamoDBTable(tableName = \"darwin_payment_attempt_native_otp_detail\")\npublic class PaymentAttemptNativeOTPDetailEntity {\n    \n    @DynamoDBHashKey(attributeName = \"payment_attempt_external_id\")\n    private String paymentAttemptExternalId;\n    \n    @Builder.Default\n    private long ttl = LocalDateTime.now().plusDays(1).toEpochSecond(ZoneOffset.UTC);\n    \n    @DynamoDBAttribute\n    private SentOTPDetail sentOTPDetail;\n    \n    @DynamoDBAttribute\n    private AuthenticateOTPDetail authenticateOTPDetail;\n}\n```\n\n**DarwinPaymentAttemptMetadataAuditEntityDAO**\n- Stores payment attempt metadata changes\n- Audit trail for compliance\n\n**DarwinPaymentAttemptRedirectionDetailDAO**\n- Tracks redirect flows (3DS, netbanking)\n- Stores redirect URLs and return states\n\n---\n\n### 6. DATA ACCESS PATTERNS\n\n#### How Services Access Data (Repositories vs DAOs)\n\n**Repository Pattern (JPA):**\n- Used for primary MySQL operations\n- Declarative query methods\n- Automatic transaction management\n- Example: `PaymentAttemptRepository.findByExternalId(id)`\n\n**DAO Pattern (Manual EntityManager):**\n- Used for complex queries requiring JPQL\n- Custom query building\n- Finer control over fetching strategies\n- Example: `RefundEntityDAOImpl.findByOrderId(orderId)` with JOIN FETCH\n\n**DynamoDB DAO Pattern:**\n- Used for NoSQL operations\n- DynamoDBMapper abstractions\n- Different from JPA/EntityManager\n\n**Service Access Pattern Example:**\n\nA typical service would use:\n```java\n@Service\npublic class PaymentAttemptService {\n    @Autowired\n    private PaymentAttemptRepository paymentAttemptRepository;  // Repository\n    \n    @Autowired\n    private PaymentAttemptDAOV2Impl paymentAttemptDAO;  // DAO\n    \n    @Autowired\n    private PaymentAttemptWorkflowContextDAO workflowContextDAO;  // DynamoDB\n    \n    public PaymentAttemptV2Entity getPaymentAttempt(String externalId) {\n        // Use repository for simple lookups\n        return paymentAttemptRepository.findByExternalId(externalId)\n                .orElseThrow(() -> new NotFoundException(...));\n    }\n    \n    public List<PaymentAttemptV2Entity> getAttemptsByOrder(String orderId) {\n        // Use DAO for complex queries with JOINs\n        return paymentAttemptDAO.findByOrderId(orderId);\n    }\n    \n    public void storeWorkflowContext(String paymentAttemptId, WorkflowStep step, String data) {\n        // Use DynamoDB DAO for temporary state\n        PaymentAttemptWorkflowContextEntity context = \n            PaymentAttemptWorkflowContextEntity.builder()\n                .paymentAttemptExternalId(paymentAttemptId)\n                .workflowStep(step)\n                .data(data)\n                .build();\n        workflowContextDAO.save(context);\n    }\n}\n```\n\n#### Transaction Management\n\n**Master/Primary Database (Write Operations):**\n```java\n@Transactional(transactionManager = \"MasterTransactionManager\")\npublic PaymentAttemptV2Entity updatePaymentAttempt(PaymentAttemptV2Entity entity) {\n    return paymentAttemptDAO.update(entity);\n}\n```\n\n**Replica Database (Read Operations):**\n```java\n@Transactional(transactionManager = \"ReplicaTransactionManager\", readOnly = true)\npublic List<PaymentAttemptEntity> getPaymentAttempts(String orderId) {\n    return paymentAttemptReplicaDAO.findByOrderId(orderId);\n}\n```\n\n**Configuration:**\n- Master: Default timeout (configured via `master.transactionTimeout`)\n- Replica: Separate timeout (configured via `replica.transactionTimeout`)\n\n**Transaction Isolation:**\n- Separate EntityManagers for master and replica\n- Replica marked as read-only in Hikari config\n- Automatic transaction routing based on @ReplicaRepository annotation\n\n#### Connection Pooling Details\n\n**Hikari Configuration - Master**\n\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/configuration/database/MasterDataSourceConfiguration.java`\n\n```java\nHikariConfig hikariConfig = new HikariConfig();\nhikariConfig.setIdleTimeout(hikariIdleTimeout);                    // Idle timeout\nhikariConfig.setConnectionTimeout(hikariConnectionTimeout);        // Connection acquisition timeout\nhikariConfig.setMinimumIdle(masterMinimumIdle);                   // Min idle connections\nhikariConfig.setMaximumPoolSize(masterMaximumPoolSize);           // Max pool size\nhikariConfig.setMaxLifetime(maxLifeTime);                         // Max connection lifetime\nhikariConfig.setPoolName(\"hikari_master\");\nhikariConfig.setLeakDetectionThreshold(leakDetectionThreshold);   // Leak detection\nhikariConfig.setJdbcUrl(url);\nhikariConfig.setUsername(username);\nhikariConfig.setPassword(password);\nhikariConfig.setDriverClassName(driverClassName);\n\nHikariDataSource masterDataSource = new HikariDataSource(hikariConfig);\nmaintenanceManager.registerHandler(new HikariMaintenanceHandler(masterDataSource));\n```\n\n**Hikari Configuration - Replica**\n\n```java\nHikariConfig hikariConfig = new HikariConfig();\nhikariConfig.setReadOnly(true);                                   // Read-only mode\nhikariConfig.setIdleTimeout(hikariIdleTimeout);\nhikariConfig.setConnectionTimeout(hikariConnectionTimeout);\nhikariConfig.setMinimumIdle(replicaMinimumIdle);                 // Separate pool config\nhikariConfig.setMaximumPoolSize(replicaMaximumPoolSize);\nhikariConfig.setMaxLifetime(maxLifeTime);\nhikariConfig.setPoolName(\"hikari_replica\");\nhikariConfig.setLeakDetectionThreshold(leakDetectionThreshold);\nhikariConfig.setJdbcUrl(replicaDatasourceUrl);                   // Separate replica URL\n// ... credentials for replica\n```\n\n**Key Differences:**\n1. **Separate URLs:** Master and replica point to different database instances\n2. **Read-Only Flag:** Replica pool set to read-only mode\n3. **Separate Pool Sizing:** Master and replica have independent pool size configs\n4. **Pool Names:** Distinct Hikari pool names for monitoring/debugging\n5. **Leak Detection:** Both monitor for connection leaks\n\n**Connection Lifecycle:**\n- Connections idle for `hikariIdleTimeout` are closed\n- New connection requests wait max `hikariConnectionTimeout` before failing\n- Long-lived connections recycled after `maxLifeTime`\n- Leaked connections detected after `leakDetectionThreshold`\n\n**Maintenance Integration:**\nBoth master and replica register with `MaintenanceManager`:\n```java\nmaintenanceManager.registerHandler(new HikariMaintenanceHandler(dataSource));\n```\n\nAllows graceful shutdown and connection cleanup during maintenance windows.\n\n#### Query Patterns\n\n**N+1 Query Prevention:**\n```java\n// Good: Explicit FETCH JOINs\n@Query(\"SELECT o FROM OrderEntity o \"\n    + \"JOIN FETCH o.customerEntity as cust \"\n    + \"JOIN FETCH o.clientEntity as client \"\n    + \"LEFT JOIN FETCH o.orderUdfEntity as udfs \"\n    + \"WHERE o.externalId = :externalId\")\nOptional<OrderEntity> findByExternalId(@Param(\"externalId\") String externalId);\n```\n\n**Compound Conditions:**\n```java\n// Named query using property path\nList<PaymentV2Entity> findByOrderEntity_ExternalIdAndStatusIn(\n    String externalId, List<PaymentStatus> statuses);\n\n// Custom JPQL for complex logic\n@Query(\"select p from PaymentV2Entity as p where p.orderEntity.externalId = :externalId \n        and p.status not in :excludedStatusList\")\nList<PaymentV2Entity> findPaymentsForOrderExcludingPaymentsWithStatus(\n    @Param(\"externalId\") String externalId,\n    @Param(\"excludedStatusList\") List<PaymentStatus> excludedStatusList);\n```\n\n**External ID as Primary Lookup:**\n- Most queries use external_id (UUID) rather than database ID\n- External IDs are client-facing identifiers\n- Database IDs used only internally for relationships\n\n---\n\n## ARCHITECTURE SUMMARY\n\n### Data Layer Stack\n```\n┌─────────────────────────────────────────────────────────┐\n│                    Service Layer                        │\n├─────────────────────────────────────────────────────────┤\n│ JPA Repositories      │ Custom DAOs      │ DynamoDB DAOs │\n├─────────────────────────────────────────────────────────┤\n│     Spring Data JPA with Hibernate ORM                  │\n├──────────────────────┬──────────────────────────────────┤\n│   Master DataSource  │      Replica DataSource          │\n│   (Write)            │      (Read-Only)                 │\n├──────────────────────┼──────────────────────────────────┤\n│ Hikari Connection    │   Hikari Connection             │\n│ Pool (Master)        │   Pool (Replica)                │\n├──────────────────────┼──────────────────────────────────┤\n│    MySQL Master      │      MySQL Replica              │\n└──────────────────────┴──────────────────────────────────┘\n         │\n         └──────────────────────┬────────────────────────┐\n                                │                        │\n                        ┌───────▼────────┐    ┌──────────▼─────┐\n                        │   DynamoDB     │    │   Caffeine     │\n                        │   (Workflow)   │    │   Caches       │\n                        └────────────────┘    └────────────────┘\n```\n\n### Key Features\n\n1. **Master-Replica Separation:**\n   - Automatic routing via @ReplicaRepository annotation\n   - Prevents read bottlenecks on primary database\n   - Transaction managers per datasource\n\n2. **Optimistic Locking:**\n   - @Version column on all BaseExternalEntity classes\n   - Prevents concurrent modification conflicts\n\n3. **Audit Trail:**\n   - created_at, updated_at (auto-managed)\n   - created_by, updated_by (context-aware)\n   - Soft deletes via is_deleted flag\n\n4. **Polymorphic Queries:**\n   - JOINED inheritance for Payment and PaymentAttempt\n   - Allows querying payment types together\n\n5. **Flexible Attributes:**\n   - JSON converters for complex objects\n   - Attributes stored directly in columns\n   - Separate OrderAttributeEntity for key-value pairs\n\n6. **Performance Caching:**\n   - Multi-layer Caffeine caches\n   - Jittered TTLs to prevent thundering herd\n   - Lazy loading with refresh-after-write\n\n7. **Workflow State Management:**\n   - DynamoDB for temporary, TTL-based workflow context\n   - Separate from primary transaction data\n   - Enables event sourcing patterns\n\n8. **Connection Management:**\n   - HikariCP for efficient pooling\n   - Leak detection and monitoring\n   - Integration with maintenance manager\n\nThis architecture provides high performance, scalability, and maintainability for a complex payment processing system with multiple data sources and access patterns."},{"type":"text","text":"agentId: af60422 (for resuming to continue this agent's work if needed)"}]}]},"uuid":"90cc8748-5648-471d-a780-25421bca301c","timestamp":"2025-12-31T09:34:51.573Z","toolUseResult":{"status":"completed","prompt":"Provide an extremely detailed analysis of the payment-service Data Layer for expert study. Cover:\n\n1. **Entity Hierarchy & Relationships:**\n   - Base entity classes and inheritance patterns\n   - All major entities (Order, Payment, PaymentAttempt, Refund, etc.)\n   - Entity relationships (OneToMany, ManyToOne)\n   - How entities reference each other (foreign keys, external IDs)\n\n2. **Repository Patterns:**\n   - Standard JPA repositories vs custom implementations\n   - How Master/Replica routing works (@ReplicaRepository annotation)\n   - Custom query methods and naming conventions\n   - Pagination and projection patterns\n\n3. **Database Schema Design:**\n   - Key tables and their purposes\n   - Audit columns (created_at, updated_at, etc.)\n   - Soft delete patterns if any\n   - JSON columns for flexible attributes\n\n4. **Caching Architecture:**\n   - Each cache class and what it caches\n   - Cache loading strategies (eager vs lazy)\n   - Cache refresh mechanisms\n   - Cache invalidation patterns\n\n5. **DynamoDB Usage:**\n   - What data goes to DynamoDB vs MySQL\n   - DAO patterns for DynamoDB\n   - Entity design for NoSQL\n\n6. **Data Access Patterns:**\n   - How services access data (via repositories vs DAOs)\n   - Transaction management\n   - Connection pooling details\n\nProvide specific file paths, code examples, and architectural insights. This is for expert-level understanding.","agentId":"af60422","content":[{"type":"text","text":"Perfect! Now I have comprehensive information. Let me create a detailed analysis document. Since I cannot write files, I'll provide the complete analysis as a detailed response:\n\n---\n\n## PAYMENT-SERVICE DATA LAYER - COMPREHENSIVE ARCHITECTURAL ANALYSIS\n\n### 1. ENTITY HIERARCHY & RELATIONSHIPS\n\n#### Base Entity Classes and Inheritance Patterns\n\nThe payment service uses a sophisticated multi-tiered entity hierarchy:\n\n**File: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/commons/BaseEntity.java`**\n\n```java\n@Getter @Setter @MappedSuperclass\npublic class BaseEntity {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @CreationTimestamp\n    @Column(name = \"created_at\")\n    private LocalDateTime createAt = LocalDateTime.now();\n    \n    @UpdateTimestamp\n    @Column(name = \"updated_at\")\n    private LocalDateTime updatedAt = LocalDateTime.now();\n    \n    @Column(name = \"created_by\")\n    private String createdBy;\n    \n    @Column(name = \"updated_by\")\n    private String updatedBy;\n    \n    @PrePersist public void onCreate() { /* audit tracking */ }\n    @PreUpdate public void onUpdate() { /* audit tracking */ }\n}\n```\n\n**File: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/provider/BaseExternalEntity.java`**\n\nExtends BaseEntity with external ID management:\n```java\n@MappedSuperclass\npublic class BaseExternalEntity extends BaseEntity {\n    @Column(name = \"external_id\", length = 36)\n    private String externalId;\n    \n    @Version\n    @Column(name = \"version\")\n    private Integer version;\n    \n    @PrePersist\n    public void onCreate() {\n        super.onCreate();\n        externalId = UUID.randomUUID().toString();\n    }\n}\n```\n\n**Hierarchy Structure:**\n```\nBaseEntity (audit columns: created_at, updated_at, created_by, updated_by, deleted flag)\n    ├── BaseExternalEntity (adds external_id, version for optimistic locking)\n    │   ├── OrderEntity\n    │   ├── PaymentV2Entity\n    │   ├── PaymentAttemptV2Entity\n    │   ├── RefundEntity\n    │   ├── ClientEntity\n    │   ├── CustomerEntity\n    │   ├── PaymentProviderEntity\n    │   ├── FeeEntity\n    │   └── (other external entities)\n    │\n    └── Non-External Entities (extends BaseEntity directly)\n        ├── ProviderAccountEntity\n        ├── ClientRefundRequestEntity\n        └── (configuration entities)\n```\n\n#### Key Entity Classes\n\n**1. OrderEntity**\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/OrderEntity.java`\n\n```java\n@Entity @Table(name = \"orders\")\npublic class OrderEntity extends BaseExternalEntity {\n    @Column(name = \"client_reference_id\")\n    private String clientReferenceId;\n    \n    @Column(name = \"amount\")\n    private BigDecimal amount;\n    \n    @Column(name = \"intent_amount\")\n    private BigDecimal intentAmount;\n    \n    @Column(name = \"type\")\n    @Enumerated(value = EnumType.STRING)\n    private OrderType type;\n    \n    @ManyToOne\n    @JoinColumn(name = \"client_id\")\n    private ClientEntity clientEntity;\n    \n    @Column(name = \"status\")\n    @Enumerated(value = EnumType.STRING)\n    private OrderStatus status;\n    \n    @ManyToOne(fetch = FetchType.EAGER)\n    @JoinColumn(name = \"customer_id\", updatable = false, insertable = false)\n    private CustomerEntity customerEntity;\n    \n    @Column(name = \"metadata\")\n    @Convert(converter = ObjectMetadataMapConverter.class)\n    private Map<String, String> metaData;\n    \n    @OneToMany(cascade = {CascadeType.MERGE, CascadeType.PERSIST})\n    @JoinColumn(name = \"order_id\")\n    private Set<OrderAttributeEntity> attributeEntities = new HashSet<>();\n    \n    @OneToOne(fetch = FetchType.LAZY, mappedBy = \"orderEntity\")\n    private OrderUdfEntity orderUdfEntity;\n}\n```\n\n**Relationships:**\n- Many-to-One with ClientEntity (foreign key: client_id)\n- Many-to-One with CustomerEntity (foreign key: customer_id, eager loaded)\n- One-to-Many with OrderAttributeEntity (cascade: MERGE, PERSIST)\n- One-to-One with OrderUdfEntity (lazy loaded)\n\n**2. PaymentV2Entity**\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/v2/PaymentV2Entity.java`\n\n```java\n@Entity @Table(name = \"payments\")\n@Inheritance(strategy = InheritanceType.JOINED)\npublic class PaymentV2Entity extends BaseExternalEntity {\n    @ManyToOne\n    @JoinColumn(name = \"order_id\")\n    private OrderEntity orderEntity;\n    \n    @Column(name = \"amount\")\n    private BigDecimal amount;\n    \n    @Column(name = \"status\")\n    @Enumerated(EnumType.STRING)\n    private PaymentStatus status;\n    \n    @Column(name = \"currency_value\")\n    private BigDecimal currencyValue;\n    \n    @Column(name = \"client_reference_id\")\n    private String clientReferenceId;\n    \n    @Column(name = \"currency\")\n    @Enumerated(EnumType.STRING)\n    private CurrencyName currency;\n    \n    @Column(name = \"conversion_rate\")\n    private BigDecimal conversionRate;\n    \n    @Column(name = \"instrument_detail\")\n    @Convert(converter = PaymentInstrumentConverter.class)\n    private PaymentInstrument instrumentDetail;\n    \n    @Convert(converter = PaymentSpecificDetailConverter.class)\n    @Column(name = \"payment_specific_detail\")\n    private PaymentSpecificDetail paymentSpecificDetail;\n    \n    @Column(name = \"payment_mode\")\n    @Enumerated(EnumType.STRING)\n    private PaymentMode paymentMode;\n}\n```\n\n**Note:** Uses JOINED inheritance strategy for polymorphic queries on payments table.\n\n**3. PaymentAttemptV2Entity**\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/v2/PaymentAttemptV2Entity.java`\n\n```java\n@Entity @Table(name = \"payment_attempts\")\n@Inheritance(strategy = InheritanceType.JOINED)\npublic class PaymentAttemptV2Entity extends BaseExternalEntity {\n    @Column(name = \"order_id\")\n    private Long orderId;\n    \n    @Column(name = \"external_id\", length = 36)\n    private String externalId;\n    \n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"order_id\", updatable = false, insertable = false)\n    private OrderEntity orderEntity;\n    \n    @ManyToOne\n    @JoinColumn(name = \"payment_id\")\n    private PaymentV2Entity paymentEntity;\n    \n    @Column(name = \"provider_reference_id\")\n    private String providerReferenceId;\n    \n    @Column(name = \"gateway_reference_id\")\n    private String gatewayReferenceId;\n    \n    @ManyToOne\n    @JoinColumn(name = \"payment_provider_id\")\n    private PaymentProviderEntity paymentProviderEntity;\n    \n    @ManyToOne\n    @JoinColumn(name = \"provider_account_id\")\n    private ProviderAccountEntity providerAccountEntity;\n    \n    @Column(name = \"payment_method\")\n    @Enumerated(EnumType.STRING)\n    private PaymentInstrumentGroup paymentMethod;\n    \n    @Column(name = \"payment_status\")\n    @Enumerated(EnumType.STRING)\n    private PaymentAttemptStatus status;\n    \n    @Column(name = \"error_code\")\n    private String errorCode;\n    \n    @Column(name = \"error_message\")\n    private String errorMessage;\n    \n    @Column(name = \"instrument_detail\")\n    @Convert(converter = EnrichedPaymentInstrumentConverter.class)\n    private EnrichedPaymentInstrument instrumentDetail;\n    \n    @OneToMany(cascade = {CascadeType.MERGE, CascadeType.PERSIST})\n    @JoinColumn(name = \"payment_attempt_id\")\n    private Set<PaymentAttemptAttributeEntity> attributeEntities = new HashSet<>();\n    \n    @Column(name = \"routes\")\n    @Convert(converter = RoutesBreakupConverter.class)\n    private RoutesBreakup routesBreakup;\n    \n    @PrePersist\n    public void onCreate() {\n        super.onCreate();\n        if (StringUtils.isEmpty(externalId)) {\n            externalId = PaymentAttemptUUIdGenerator.generate();\n        }\n    }\n}\n```\n\n**Relationships:**\n- Many-to-One with OrderEntity (orderId: non-updatable, non-insertable duplicate)\n- Many-to-One with PaymentV2Entity (payment_id)\n- Many-to-One with PaymentProviderEntity\n- Many-to-One with ProviderAccountEntity\n- One-to-Many with PaymentAttemptAttributeEntity\n\n**4. RefundEntity & RefundAttemptEntity**\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/v2/RefundEntity.java`\n\n```java\n@Entity @Table(name = \"refunds\") @Builder\npublic class RefundEntity extends BaseExternalEntity {\n    @ManyToOne(fetch = FetchType.EAGER)\n    @JoinColumn(name = \"order_id\")\n    private OrderEntity orderEntity;\n    \n    @ManyToOne(fetch = FetchType.EAGER)\n    @JoinColumn(name = \"payment_attempt_id\")\n    private PaymentAttemptV2Entity paymentAttempt;\n    \n    @Column(name = \"refund_type\")\n    @Enumerated(EnumType.STRING)\n    private RefundType refundType;\n    \n    @Column(name = \"refund_value\")\n    @DecimalMin(value = \"0.0\", inclusive = true)\n    private BigDecimal refundValue;\n    \n    @Column(name = \"refund_status\")\n    @Enumerated(EnumType.STRING)\n    private RefundStatus refundStatus;\n    \n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"client_refund_request_id\")\n    private ClientRefundRequestEntity clientRefundRequestEntity;\n    \n    @Column(name = \"scheduled_at\")\n    private LocalDateTime scheduledAt;\n    \n    @Transient\n    @Default\n    private Boolean canReorganize = Boolean.TRUE;\n}\n```\n\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/v2/RefundAttemptEntity.java`\n\n```java\n@Entity @Table(name = \"refund_attempts\") @Builder\npublic class RefundAttemptEntity extends BaseExternalEntity {\n    @ManyToOne(fetch = FetchType.EAGER)\n    @JoinColumn(name = \"refund_id\")\n    private RefundEntity refund;\n    \n    @ManyToOne(fetch = FetchType.EAGER)\n    @JoinColumn(name = \"payment_attempt_id\")\n    private PaymentAttemptV2Entity paymentAttempt;\n    \n    @ManyToOne(fetch = FetchType.EAGER)\n    @JoinColumn(name = \"provider_account_id\")\n    private ProviderAccountEntity providerAccountEntity;\n    \n    @Column(name = \"error_code\")\n    private String errorCode;\n    \n    @Column(name = \"provider_reference_id\")\n    private String providerReferenceId;\n    \n    @Column(name = \"refund_status\")\n    @Enumerated(EnumType.STRING)\n    private RefundStatus refundStatus;\n    \n    @Column(name = \"previous_status\")\n    @Enumerated(EnumType.STRING)\n    private RefundStatus previousStatus;\n    \n    @Column(name = \"refund_channel\")\n    @Enumerated(EnumType.STRING)\n    private RefundChannel refundChannel;\n    \n    @Column(name = \"request_status\")\n    @Enumerated(EnumType.STRING)\n    private ProviderRequestStatus requestStatus;\n    \n    @OneToMany(cascade = {CascadeType.MERGE, CascadeType.PERSIST})\n    @JoinColumn(name = \"refund_attempt_id\")\n    private Set<RefundAttemptAttributeEntity> attributeEntities = new HashSet<>();\n}\n```\n\n**5. ClientEntity & CustomerEntity**\n\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/ClientEntity.java`\n\n```java\n@Entity @Table(name = \"clients\")\npublic class ClientEntity extends BaseExternalEntity {\n    @Column(name = \"name\")\n    private String name;\n    \n    @Column(name = \"merchant_id\")\n    private String merchantId;\n    \n    @Column(name = \"is_deleted\")\n    private Boolean deleted = Boolean.FALSE;\n    \n    @OneToMany(cascade = {CascadeType.MERGE, CascadeType.PERSIST}, fetch = FetchType.EAGER)\n    @JoinColumn(name = \"client_id\")\n    private Set<ClientSettingsEntity> settings = new HashSet<>();\n}\n```\n\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/CustomerEntity.java`\n\n```java\n@Entity @Table(name = \"customers\")\npublic class CustomerEntity extends BaseExternalEntity {\n    @Column(name = \"name\")\n    private String name;\n    \n    @Column(name = \"email\")\n    private String email;\n    \n    @Column(name = \"contact_number\")\n    private String contactNumber;\n    \n    @Column(name = \"is_deleted\")\n    private Boolean deleted = Boolean.FALSE;\n}\n```\n\n**6. Provider-Related Entities**\n\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/PaymentProviderEntity.java`\n\n```java\n@Entity @Table(name = \"payment_providers\") @Builder\npublic class PaymentProviderEntity extends BaseExternalEntity {\n    @Column(name = \"name\")\n    private String name;\n    \n    @Column(name = \"provider_key\")\n    private String key;\n    \n    @Column(name = \"active\")\n    @Builder.Default\n    private Boolean active = true;\n    \n    @Column(name = \"is_customer_required\")\n    @Builder.Default\n    private Boolean customerRequired = false;\n    \n    @OneToMany(cascade = {CascadeType.MERGE, CascadeType.PERSIST})\n    @JoinColumn(name = \"payment_provider_id\")\n    private Set<PaymentProviderSettingsEntity> settings = new HashSet<>();\n}\n```\n\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/ProviderAccountEntity.java`\n\n```java\n@Entity @Table(name = \"provider_accounts\") @Builder\npublic class ProviderAccountEntity extends BaseEntity {\n    @ManyToOne\n    @JoinColumn(name = \"payment_provider_id\")\n    private PaymentProviderEntity paymentProvider;\n    \n    @Column(name = \"provider_account_id\")\n    private String providerAccountId;\n    \n    @Column(name = \"access_token\") @Lob\n    private byte[] accessToken;\n    \n    @Column(name = \"endpoint\")\n    private String endpoint;\n    \n    @Column(name = \"is_prod\")\n    private Boolean isProd;\n    \n    @Column(name = \"active\")\n    @Builder.Default\n    private Boolean active = true;\n    \n    @Column(name = \"provider_mid\")\n    private String providerMid;\n    \n    @Column(name = \"settlement_category\")\n    private String settlementCategory;\n}\n```\n\n**7. Fee Entity**\n\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/v2/FeeEntity.java`\n\n```java\n@Entity @Table(name = \"fees\")\npublic class FeeEntity extends BaseExternalEntity {\n    @Column(name = \"fee_id\")\n    private String feeId;\n    \n    @Column(name = \"amount\")\n    private BigDecimal amount;\n    \n    @Column(name = \"type\")\n    private String type;\n    \n    @Column(name = \"base_entity_type\")\n    @Enumerated(value = EnumType.STRING)\n    private FeeBaseEntityType baseEntityType;\n    \n    @Column(name = \"base_entity_id\")\n    private String baseEntityId;\n}\n```\n\n**8. ClientRefundRequestEntity**\n\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/v2/ClientRefundRequestEntity.java`\n\n```java\n@Entity @Table(name = \"client_refund_requests\")\npublic class ClientRefundRequestEntity extends BaseEntity {\n    @Column(name = \"external_id\", length = 36)\n    private String externalId;\n    \n    @ManyToOne\n    @JoinColumn(name = \"client_id\")\n    private ClientEntity clientEntity;\n    \n    @ManyToOne\n    @JoinColumn(name = \"order_id\")\n    private OrderEntity orderEntity;\n    \n    @Column(name = \"amount\")\n    private BigDecimal amount;\n    \n    @Column(name = \"request_status\")\n    @Enumerated(EnumType.STRING)\n    private RefundRequestStatus requestStatus;\n    \n    @Column(name = \"additional_info\")\n    @Convert(converter = ClientRefundAdditionalInfoConverter.class)\n    private ClientRefundAdditionalInfo additionalInfo;\n    \n    @Version\n    @Column(name = \"version\")\n    private Integer version;\n    \n    @Column(name = \"reserved_udfs\")\n    @Convert(converter = ReservedUdfsMapConverter.class)\n    private Map<String, Object> reservedUdfs;\n    \n    @Column(name = \"merchant_udfs\")\n    @Convert(converter = ReservedUdfsMapConverter.class)\n    private Map<String, String> merchantUdfs;\n}\n```\n\n#### Entity Relationship Diagram (ERD) Summary\n\n```\n┌─────────────────┐\n│   ClientEntity  │\n└────────┬────────┘\n         │ 1\n         │\n    ┌────┴─────────────────────┐\n    │                          │ M\n    │                     ┌────▼──────────┐\n    │                     │    OrderEntity │\n    │                     └────┬──────────┘\n    │                          │ 1\n    │                          │\n    │                 ┌────────┼─────────┐\n    │                 │        │         │\n    │            ┌────▼─┐  ┌──▼──┐  ┌───▼────────────┐\n    │            │Pyment│  │Refnd│  │ClientRefund    │\n    │            │Entity│  │Entity  │RequestEntity   │\n    │            └────┬─┘  └──┬──┘  └───────────────┘\n    │                 │       │\n    │            ┌────▼────────▼─────────┐\n    │            │ PaymentAttemptEntity  │\n    │            └────┬──────────────┬───┘\n    │                 │              │\n    │            ┌────▼──┐      ┌────▼─────────────┐\n    │            │Provider│     │RefundAttemptEntity\n    │            │Account │     └───────────────────┘\n    │            └────────┘\n\n   M\n    │\n    │ 1\n┌───▼──────────┐\n│CustomerEntity│\n└──────────────┘\n```\n\n---\n\n### 2. REPOSITORY PATTERNS\n\n#### Base Repository Architecture\n\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/repository/commons/BaseRepository.java`\n\n```java\n@NoRepositoryBean\ninterface BaseRepository<T> extends JpaRepository<T, Long> {}\n```\n\n#### Key Repository Implementations\n\n**1. OrderRepository**\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/repository/OrderRepository.java`\n\n```java\n@Repository\npublic interface OrderRepository extends JpaRepository<OrderEntity, Long> {\n    @Query(\"SELECT o FROM OrderEntity o \"\n            + \"JOIN FETCH o.customerEntity as cust \"\n            + \"JOIN FETCH o.clientEntity as client \"\n            + \"LEFT JOIN FETCH o.orderUdfEntity as udfs \"\n            + \"WHERE o.externalId = :externalId\")\n    Optional<OrderEntity> findByExternalId(@Param(\"externalId\") String externalId);\n    \n    @Query(\"SELECT o FROM OrderEntity o \"\n            + \"JOIN FETCH o.customerEntity as cust \"\n            + \"JOIN FETCH o.clientEntity as client \"\n            + \"LEFT JOIN FETCH o.orderUdfEntity as udfs \"\n            + \"WHERE o.clientReferenceId = :clientReferenceId \"\n            + \"AND o.clientEntity.externalId = :externalId\")\n    Optional<OrderEntity> findByClientReferenceIdAndClientEntity_ExternalId(\n            @Param(\"clientReferenceId\") String clientReferenceId, \n            @Param(\"externalId\") String externalId);\n    \n    @Query(\"SELECT o FROM OrderEntity o \"\n            + \"JOIN FETCH o.customerEntity as cust \"\n            + \"JOIN FETCH o.clientEntity as client \"\n            + \"LEFT JOIN FETCH o.orderUdfEntity as udfs \"\n            + \"WHERE o.tagId = :tagId\")\n    List<OrderEntity> findByTagId(@Param(\"tagId\") String tagId);\n}\n```\n\n**Query Pattern Notes:**\n- Uses explicit FETCH JOINs to eagerly load related entities\n- Prevents N+1 query problems\n- LEFT JOIN FETCH for optional relationships\n\n**2. PaymentRepository**\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/repository/PaymentRepository.java`\n\n```java\n@Repository\npublic interface PaymentRepository extends JpaRepository<PaymentV2Entity, Long> {\n    Optional<PaymentV2Entity> findByExternalId(String externalId);\n    \n    List<PaymentV2Entity> findByOrderEntity_ExternalId(String externalId);\n    \n    List<PaymentV2Entity> findByOrderEntity_Id(Long orderId);\n    \n    List<PaymentV2Entity> findByOrderEntity_ExternalIdAndStatusIn(\n            String externalId, List<PaymentStatus> statuses);\n    \n    @Query(\"select p from PaymentV2Entity as p where p.orderEntity.externalId = :externalId \n            and p.status not in :excludedStatusList\")\n    List<PaymentV2Entity> findPaymentsForOrderExcludingPaymentsWithStatus(\n            @Param(\"externalId\") String externalId,\n            @Param(\"excludedStatusList\") List<PaymentStatus> excludedStatusList);\n}\n```\n\n**3. PaymentAttemptRepository**\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/repository/PaymentAttemptRepository.java`\n\n```java\n@Repository\npublic interface PaymentAttemptRepository extends JpaRepository<PaymentAttemptV2Entity, Long> {\n    \n    @Query(\"SELECT pa FROM PaymentAttemptV2Entity pa \"\n            + \"JOIN FETCH pa.paymentEntity as payment \"\n            + \"JOIN FETCH pa.paymentProviderEntity as paymentProvider \"\n            + \"JOIN FETCH pa.providerAccountEntity as providerAccount \"\n            + \"WHERE payment.externalId = :paymentId\")\n    List<PaymentAttemptV2Entity> findByPaymentEntity_ExternalId(@Param(\"paymentId\") String paymentId);\n    \n    Optional<PaymentAttemptV2Entity> findByProviderReferenceId(String provideReferenceId);\n    \n    @Query(\"SELECT pa FROM PaymentAttemptV2Entity pa \"\n            + \"JOIN FETCH pa.paymentEntity as payment \"\n            + \"JOIN FETCH pa.paymentProviderEntity as paymentProvider \"\n            + \"JOIN FETCH pa.providerAccountEntity as providerAccount \"\n            + \"WHERE pa.externalId = :externalId\")\n    Optional<PaymentAttemptV2Entity> findByExternalId(@Param(\"externalId\") String externalId);\n}\n```\n\n**4. Refund Repository (Read-Only)**\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/repository/read_only_repository/RefundRepository.java`\n\n```java\n@Repository\npublic interface RefundRepository extends JpaRepository<RefundEntity, Long> {\n    List<RefundEntity> findByClientRefundRequestEntity_Id(Long id);\n    \n    List<RefundEntity> findByOrderEntity_Id(Long orderId);\n    \n    List<RefundEntity> findByOrderEntity_ExternalId(String orderId);\n}\n```\n\n#### Master/Replica Routing Architecture\n\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/configuration/database/annotation/ReplicaRepository.java`\n\n```java\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE})\n@Documented\npublic @interface ReplicaRepository {}\n```\n\n**Configuration: MasterDataSourceConfiguration**\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/configuration/database/MasterDataSourceConfiguration.java`\n\n```java\n@Configuration\n@EnableJpaRepositories(\n    basePackages = {REPO_PATH, DAO_PATH},\n    excludeFilters = @ComponentScan.Filter(ReplicaRepository.class),\n    entityManagerFactoryRef = MASTER_ENTITY_MANAGER_FACTORY,\n    transactionManagerRef = MASTER_TRANSACTION_MANAGER)\npublic class MasterDataSourceConfiguration {\n    @Bean(name = MASTER_DATA_SOURCE)\n    @Primary\n    public DataSource dataSource(MaintenanceManager maintenanceManager) throws Exception {\n        HikariConfig hikariConfig = new HikariConfig();\n        hikariConfig.setIdleTimeout(hikariIdleTimeout);\n        hikariConfig.setMinimumIdle(masterMinimumIdle.intValue());\n        hikariConfig.setMaximumPoolSize(masterMaximumPoolSize.intValue());\n        hikariConfig.setPoolName(\"hikari_master\");\n        hikariConfig.setJdbcUrl(url);\n        // ... configuration for write operations\n        HikariDataSource masterDataSource = new HikariDataSource(hikariConfig);\n        maintenanceManager.registerHandler(new HikariMaintenanceHandler(masterDataSource));\n        return masterDataSource;\n    }\n}\n```\n\n**Configuration: ReplicaDataSourceConfiguration**\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/configuration/database/ReplicaDataSourceConfiguration.java`\n\n```java\n@Configuration\n@EnableJpaRepositories(\n    basePackages = {REPO_PATH, DAO_PATH},\n    includeFilters = @ComponentScan.Filter(ReplicaRepository.class),\n    entityManagerFactoryRef = REPLICA_ENTITY_MANAGER_FACTORY,\n    transactionManagerRef = REPLICA_TRANSACTION_MANAGER)\npublic class ReplicaDataSourceConfiguration {\n    @Bean(name = REPLICA_DATA_SOURCE)\n    public DataSource dataSource(MaintenanceManager maintenanceManager) {\n        HikariConfig hikariConfig = new HikariConfig();\n        hikariConfig.setReadOnly(true);  // KEY: Read-only mode\n        hikariConfig.setMinimumIdle(replicaMinimumIdle.intValue());\n        hikariConfig.setMaximumPoolSize(replicaMaximumPoolSize.intValue());\n        hikariConfig.setPoolName(\"hikari_replica\");\n        // Separate datasource URL for replica\n        hikariConfig.setJdbcUrl(replicaDatasourceUrl);\n        HikariDataSource replicaDataSource = new HikariDataSource(hikariConfig);\n        maintenanceManager.registerHandler(new HikariMaintenanceHandler(replicaDataSource));\n        return replicaDataSource;\n    }\n}\n```\n\n**Replica Read DAOs Pattern**\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/dao/read_only_dao/impl/AbstractReplicaDAOImpl.java`\n\n```java\n@ReplicaRepository  // Annotation routes to replica datasource\npublic abstract class AbstractReplicaDAOImpl<T extends BaseExternalEntity, R> \n        extends AbstractDAOImpl<T, R> implements AbstractExternalDAO<T, R> {\n    // Uses replica EntityManager through @ReplicaRepository annotation\n}\n```\n\nExamples of Replica DAOs:\n- `RefundEntityReplicaDAOImpl` - @ReplicaRepository\n- `PaymentAttemptReplicaReadDAO` - @ReplicaRepository\n- `RefundAttemptReplicaReadDAO` - @ReplicaRepository\n- `OrderReplicaReadDAO` - @ReplicaRepository\n\n**How It Works:**\n1. Component scan in MasterDataSourceConfiguration excludes @ReplicaRepository beans\n2. Component scan in ReplicaDataSourceConfiguration includes only @ReplicaRepository beans\n3. Both configurations use separate EntityManagerFactory instances\n4. Read queries are routed to replica datasource via separate EntityManager\n5. Connection pooling is managed separately with HikariCP\n6. Read-only flag set on replica connection pool prevents accidental writes\n\n#### Pagination and Projection Patterns\n\nRepositories extend JpaRepository, inheriting built-in pagination:\n- `Page<T> findAll(Pageable pageable)`\n- `findAll(Specification<T> spec, Pageable pageable)`\n\nCustom naming convention examples:\n- `findByOrderEntity_ExternalId()` - navigates relationships\n- `findByOrderEntity_ExternalIdAndStatusIn()` - compound conditions\n- `findByClientRefundRequestEntity_Id()` - nested foreign key lookups\n\n---\n\n### 3. DATABASE SCHEMA DESIGN\n\n#### Key Tables and Purposes\n\n**Core Transaction Tables:**\n1. **orders** - Main order entity\n   - Columns: id (PK), external_id (UUID), client_id (FK), customer_id (FK), status, amount, intent_amount, metadata, created_at, updated_at, created_by, updated_by\n\n2. **payments** - Payment records linked to orders\n   - Columns: id (PK), external_id (UUID), order_id (FK), status, amount, currency, payment_mode, instrument_detail (JSON), payment_specific_detail (JSON), created_at, updated_at\n\n3. **payment_attempts** - Individual payment gateway attempts\n   - Columns: id (PK), external_id (UUID), order_id, payment_id (FK), payment_provider_id (FK), provider_account_id (FK), payment_method, provider_reference_id, gateway_reference_id, provider_status, payment_status, error_code, error_message, instrument_detail (JSON), routes (JSON), created_at, updated_at\n\n4. **refunds** - Refund master records\n   - Columns: id (PK), external_id (UUID), order_id (FK), payment_attempt_id (FK), refund_type, refund_status, refund_value, currency_value, scheduled_at, created_at, updated_at\n\n5. **refund_attempts** - Individual refund gateway attempts\n   - Columns: id (PK), external_id (UUID), refund_id (FK), payment_attempt_id (FK), provider_account_id (FK), refund_status, previous_status, provider_reference_id, refund_channel, request_status, created_at, updated_at\n\n#### Audit Columns Pattern\n\nAll entities implement audit tracking:\n```\ncreated_at: LocalDateTime (auto-populated on insert via @CreationTimestamp)\nupdated_at: LocalDateTime (auto-updated on every modification via @UpdateTimestamp)\ncreated_by: String (application/client name)\nupdated_by: String (application/client name)\nversion: Integer (optimistic locking in BaseExternalEntity)\n```\n\n#### Soft Delete Pattern\n\nSome entities implement soft deletes:\n```java\n@Column(name = \"is_deleted\")\nprivate Boolean deleted = Boolean.FALSE;\n```\n\nUsed in:\n- ClientEntity\n- CustomerEntity\n- ProviderAccountEntity (may be used)\n\n#### JSON Columns for Flexible Attributes\n\nCustom Hibernate converters allow storing complex objects as JSON:\n\n1. **ObjectMetadataMapConverter** - Stores OrderEntity.metaData (Map<String, String>)\n2. **PaymentInstrumentConverter** - PaymentV2Entity.instrumentDetail\n3. **PaymentSpecificDetailConverter** - PaymentV2Entity.paymentSpecificDetail\n4. **EnrichedPaymentInstrumentConverter** - PaymentAttemptV2Entity.instrumentDetail\n5. **PaymentSubMethodDetailConverter** - PaymentAttemptV2Entity.paymentSubMethod\n6. **RoutesBreakupConverter** - PaymentAttemptV2Entity.routesBreakup\n7. **ClientRefundAdditionalInfoConverter** - ClientRefundRequestEntity.additionalInfo\n8. **ReservedUdfsMapConverter** - ClientRefundRequestEntity.reservedUdfs & merchantUdfs\n\nThese use Hibernate @Convert annotation for transparent serialization/deserialization.\n\n#### Relationship Pattern - Duplicate Foreign Keys\n\nPaymentAttemptV2Entity uses a pattern to avoid JOIN in many queries:\n```java\n@Column(name = \"order_id\")\nprivate Long orderId;\n\n@ManyToOne(fetch = FetchType.LAZY)\n@JoinColumn(name = \"order_id\", updatable = false, insertable = false)\nprivate OrderEntity orderEntity;\n```\n\nBenefits:\n- Can query by orderId without joining OrderEntity\n- Avoids cascade load of full OrderEntity when not needed\n- Non-updatable/non-insertable prevents Hibernate from trying to manage the relationship\n\n---\n\n### 4. CACHING ARCHITECTURE\n\n#### Cache Classes and What They Cache\n\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/cache/`\n\n**1. ClientConfigurationCache**\n\n```java\n@Component @RequiredArgsConstructor\npublic class ClientConfigurationCache extends AbstractDPManagedCache implements IDPManagedCache {\n    private final CacheConfig cacheConfig;\n    private final ClientRepository clientRepository;\n    \n    @DPCache(cacheName = \"client_configuration_cache\")\n    private LoadingCache<Long, Map<ClientSettingKey, String>> idCache;\n    \n    @DPCache(cacheName = \"client_by_id_cache\")\n    private LoadingCache<Long, ClientEntity> clientByIdCache;\n    \n    @DPCache(cacheName = \"client_by_external_id_cache\")\n    private LoadingCache<String, ClientEntity> clientByExternalIdCache;\n    \n    @DPCache(cacheName = \"client_by_merchant_id_cache\")\n    private LoadingCache<String, ClientEntity> clientByMerchantId;\n    \n    @Override\n    public void buildCache() {\n        idCache = DPCacheBuilder.getBuilder()\n                .refreshAfterWrite(10-20 mins, MINUTES)\n                .build(this::loadClientSettings);\n        // ... other caches\n    }\n}\n```\n\n**Caches:**\n- Client settings by client ID (Map of setting keys to values)\n- Client entity by ID\n- Client entity by external ID\n- Client entity by merchant ID\n\n**TTL:** 10-20 minutes (with random jitter for staggered refreshes)\n\n**2. PaymentProviderCache**\n\nCaches payment provider configurations:\n- Providers by ID\n- Provider settings\n- TTL: 15-25 minutes\n\n**3. ProviderAccountCache**\n\n```java\n@Component @RequiredArgsConstructor\npublic class ProviderAccountCache extends AbstractDPManagedCache implements IDPManagedCache {\n    \n    @DPCache(cacheName = \"provider_account_by_id_cache\")\n    private LoadingCache<Long, ProviderAccountEntity> providerAccountByIdCache;\n    \n    @DPCache(cacheName = \"provider_account_by_provider_id_cache\")\n    private LoadingCache<String, List<ProviderAccountEntity>> providerAccountsByProviderCache;\n    \n    // ... TTL: 15-25 minutes\n}\n```\n\n**4. FeeCache**\n\n```java\n@Component @RequiredArgsConstructor\npublic class FeeCache extends AbstractDPManagedCache implements IDPManagedCache {\n    \n    @DPCache(cacheName = \"fee_by_id_cache\")\n    private LoadingCache<String, FeeDto> cache;\n    \n    @Override\n    public void buildCache() {\n        cache = DPCacheBuilder.getBuilder()\n                .refreshAfterWrite(1, DAYS)\n                .maximumSize(500)\n                .build(feeId -> feeService.getFeeByFeeId(feeId)\n                        .map(feeCampaign -> FeeDto.builder()\n                                .isRefundable(feeCampaign.getRefundable())\n                                .feeId(feeCampaign.getFeeId())\n                                .feeType(feeCampaign.getFeeType())\n                                .build())\n                        .orElse(null));\n    }\n}\n```\n\n**TTL:** 1 day, Max size: 500 entries\n\n**5. IssuerCache**\n\nCaches bank issuer information from arsenal service (card BIN details):\n- Issuer by ISIN\n- TTL: Configured via CacheConfig\n\n**6. CardBinCache & CardHashedBinCache**\n\n```java\n@Component @RequiredArgsConstructor\npublic class CardBinCache extends AbstractDPManagedCache implements IDPManagedCache {\n    \n    @DPCache(cacheName = \"card_bin_cache\")\n    private LoadingCache<String, CardBinDetail> cardBinCache;\n    \n    @Override\n    public void buildCache() {\n        cardBinCache = DPCacheBuilder.getBuilder()\n                .refreshAfterWrite(cacheConfig.getCardBinCacheTTL(), HOURS)\n                .build(this::loadCardBinDetails);\n    }\n}\n```\n\n**7. MasterConfigurationCache**\n\nCaches system-wide master configurations:\n- Feature flags\n- System settings\n- TTL: 10-20 minutes\n\n**8. ClientPaymentProviderConfigCache**\n\nClient-specific payment provider configurations:\n```java\n@DPCache(cacheName = \"client_payment_provider_config_cache\")\nprivate LoadingCache<String, ClientPaymentProviderConfigCache.CacheKey, List<ClientPaymentProviderConfigEntity>> cache;\n```\nTTL: 10-20 minutes\n\n**9. DecisionTreeObjectCache**\n\n```java\n@Component @RequiredArgsConstructor\npublic class DecisionTreeObjectCache extends AbstractDPManagedCache implements IDPManagedCache {\n    \n    @DPCache(cacheName = \"decision_tree_object_cache\")\n    private LoadingCache<String, DecisionTreeObjectEntity> decisionTreeObjectCache;\n    \n    // TTL: 180-190 minutes\n}\n```\n\n**10. PaymentErrorMessageMappingCache**\n\nMaps payment error codes to user-friendly messages\n\n**11. NativeOTPSupportedProviderCache**\n\nCaches providers supporting native OTP\n\n**12. NetBankingProviderConfigCache**\n\nNet banking provider-specific configurations\n\n**13. ClientRateLimitConfigCache**\n\nRate limiting configurations per client:\n```java\n@DPCache(cacheName = \"client_rate_limit_config_cache\")\nprivate LoadingCache<Long, ClientRateLimitConfigEntity> clientRateLimitConfigCache;\n```\nTTL: 15-25 minutes\n\n**14. MerchantCache**\n\nMerchant information cache:\nTTL: 1 day\n\n**15. UpiTerminalDetailCache**\n\nUPI terminal details for UPI payments:\nTTL: 7-17 days\n\n#### Cache Loading Strategies\n\n**Eager vs Lazy Loading:**\n\nAll caches use **lazy loading** with `LoadingCache<K, V>`:\n- Cache entries are loaded on-demand (first access)\n- No bulk pre-loading at startup\n- Uses `CacheLoader` function to fetch from repository\n\n**Example:**\n```java\nloadClientSettings = (clientId) -> {\n    ClientEntity clientEntity = clientRepository.findById(clientId)\n            .orElseThrow(() -> Error.invalid_client_id.getBuilder().build());\n    \n    return clientEntity.getSettings().stream()\n            .collect(Collectors.toMap(ClientSettingsEntity::getSettingKey, \n                                     ClientSettingsEntity::getSettingValue));\n}\n```\n\n#### Cache Refresh Mechanisms\n\n**Refresh Strategy:** `refreshAfterWrite(duration, TimeUnit)`\n\nUses Caffeine cache:\n- After specified duration of no access, cache entry is refreshed asynchronously\n- Old value returned while new value loads\n- Prevents cache stampede\n\n**Configuration Example:**\n```java\nidCache = DPCacheBuilder.getBuilder()\n        .refreshAfterWrite(cacheConfig.getMasterConfigurationTTL(), MINUTES)\n        .build(this::loadClientSettings);\n```\n\n**Jittered TTLs:**\n```java\nprivate Long generateRandomCacheRefreshInterval(int source) {\n    int min = 1;\n    int max = 10;\n    SecureRandom random = new SecureRandom();\n    return Long.valueOf(source + random.nextInt(max - min + 1) + min);\n}\n// Usage: generateRandomCacheRefreshInterval(15) returns 16-25 minutes\n```\n\nPrevents thundering herd problem where all caches refresh simultaneously.\n\n#### Cache Invalidation Patterns\n\n**No explicit invalidation found.** Cache invalidation relies on:\n\n1. **TTL-based expiration** - Primary mechanism\n2. **Manual refresh** - Services can manually call refresh if needed\n3. **Application restart** - Caches are rebuilt on startup\n\nPattern seen in ClientConfigurationCache:\n```java\npublic Optional<ClientEntity> getActiveClientByExternalId(String clientId) {\n    ClientEntity clientEntity = getClientByExternalId(clientId);\n    return isClientActive(clientEntity) ? Optional.of(clientEntity) : Optional.empty();\n}\n```\n\nClients check active status each time rather than caching state.\n\n#### Cache Infrastructure\n\n**Caffeine Cache Framework:**\n- Thread-safe, high-performance in-memory cache\n- Automatic expiration and refresh\n- Built-in metrics and monitoring\n\n**DPCacheBuilder Pattern:**\n```java\nDPCacheBuilder.getBuilder()\n    .refreshAfterWrite(ttl, timeUnit)\n    .maximumSize(size)  // Optional size limit\n    .build(loaderFunction)  // CacheLoader implementation\n```\n\n---\n\n### 5. DYNAMODB USAGE\n\n#### What Data Goes to DynamoDB vs MySQL\n\n**MySQL (Primary Data):**\n- All transactional data: Orders, Payments, PaymentAttempts, Refunds, RefundAttempts\n- Master data: Clients, Customers, PaymentProviders, ProviderAccounts\n- Configuration: ClientSettings, PaymentProviderSettings\n- Fees and adjustments\n\n**DynamoDB (NoSQL/Temporary State):**\n- Workflow context for payments (TTL-based, temporary)\n- Native OTP authentication details\n- Payment attempt redirects\n- Metadata audit trails\n- Native OTP attempt tracking\n\n#### DAO Patterns for DynamoDB\n\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/dynamo/dao/AbstractDynamoDBDAO.java`\n\n```java\n@RequiredArgsConstructor\npublic abstract class AbstractDynamoDBDAO<T> {\n    private final Class<T> tClass;\n    private final DynamoDBMapper dynamoDBMapper;\n    \n    public void save(T entity) {\n        dynamoDBMapper.save(entity);\n    }\n    \n    public void saveIfNotExists(T entity, List<String> uniqueKeys) {\n        if (CollectionUtils.isEmpty(uniqueKeys)) {\n            save(entity);\n        }\n        DynamoDBSaveExpression saveExpression = new DynamoDBSaveExpression();\n        Map<String, ExpectedAttributeValue> expected = new HashMap<>();\n        uniqueKeys.forEach(key -> {\n            expected.put(key, new ExpectedAttributeValue().withExists(false));\n        });\n        saveExpression.setExpected(expected);\n        dynamoDBMapper.save(entity, saveExpression);\n    }\n    \n    public T findByHashKey(Object hashKey) {\n        return dynamoDBMapper.load(tClass, hashKey);\n    }\n}\n```\n\n**Key Methods:**\n- `save(T entity)` - Put/update item\n- `saveIfNotExists(T entity, uniqueKeys)` - Conditional put (atomic check-and-set)\n- `findByHashKey(Object hashKey)` - Get by partition key\n\n#### DynamoDB Entity Designs\n\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/dynamo/domain/PaymentAttemptWorkflowContextEntity.java`\n\n```java\n@Data @Builder @NoArgsConstructor @AllArgsConstructor\n@DynamoDBTable(tableName = \"darwin_payment_attempt_workflow_context\")\npublic class PaymentAttemptWorkflowContextEntity {\n    \n    @DynamoDBHashKey(attributeName = \"payment_attempt_external_id\")\n    private String paymentAttemptExternalId;\n    \n    @Builder.Default\n    @DynamoDBAttribute\n    private long ttl = LocalDateTime.now().plusDays(1).toEpochSecond(ZoneOffset.UTC);\n    \n    @DynamoDBRangeKey\n    @DynamoDBTypeConvertedEnum\n    @DynamoDBAttribute(attributeName = \"workflow_step\")\n    private WorkflowStep workflowStep;\n    \n    @DynamoDBAttribute(attributeName = \"data\")\n    private String data;\n    \n    @DynamoDBTypeConverted(converter = LocalDateTimeConverter.class)\n    @DynamoDBAttribute(attributeName = \"event_at\")\n    private LocalDateTime eventAt;\n}\n```\n\n**Design Pattern:**\n- **Partition Key (Hash Key):** `payment_attempt_external_id` - Groups all workflow steps for a payment attempt\n- **Sort Key (Range Key):** `workflow_step` - Allows querying workflow history in order\n- **TTL:** Automatic expiration after 1 day\n- **Converters:** LocalDateTime to/from DynamoDB format\n\n#### DynamoDB DAOs\n\n**PaymentAttemptWorkflowContextDAO**\n- Stores workflow step progression\n- TTL-based auto-cleanup\n- Enables workflow replay and debugging\n\n**PaymentAttemptNativeOTPDetailEntityDAO**\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/dynamo/domain/nativeotp/PaymentAttemptNativeOTPDetailEntity.java`\n\n```java\n@Data @Builder\n@DynamoDBTable(tableName = \"darwin_payment_attempt_native_otp_detail\")\npublic class PaymentAttemptNativeOTPDetailEntity {\n    \n    @DynamoDBHashKey(attributeName = \"payment_attempt_external_id\")\n    private String paymentAttemptExternalId;\n    \n    @Builder.Default\n    private long ttl = LocalDateTime.now().plusDays(1).toEpochSecond(ZoneOffset.UTC);\n    \n    @DynamoDBAttribute\n    private SentOTPDetail sentOTPDetail;\n    \n    @DynamoDBAttribute\n    private AuthenticateOTPDetail authenticateOTPDetail;\n}\n```\n\n**DarwinPaymentAttemptMetadataAuditEntityDAO**\n- Stores payment attempt metadata changes\n- Audit trail for compliance\n\n**DarwinPaymentAttemptRedirectionDetailDAO**\n- Tracks redirect flows (3DS, netbanking)\n- Stores redirect URLs and return states\n\n---\n\n### 6. DATA ACCESS PATTERNS\n\n#### How Services Access Data (Repositories vs DAOs)\n\n**Repository Pattern (JPA):**\n- Used for primary MySQL operations\n- Declarative query methods\n- Automatic transaction management\n- Example: `PaymentAttemptRepository.findByExternalId(id)`\n\n**DAO Pattern (Manual EntityManager):**\n- Used for complex queries requiring JPQL\n- Custom query building\n- Finer control over fetching strategies\n- Example: `RefundEntityDAOImpl.findByOrderId(orderId)` with JOIN FETCH\n\n**DynamoDB DAO Pattern:**\n- Used for NoSQL operations\n- DynamoDBMapper abstractions\n- Different from JPA/EntityManager\n\n**Service Access Pattern Example:**\n\nA typical service would use:\n```java\n@Service\npublic class PaymentAttemptService {\n    @Autowired\n    private PaymentAttemptRepository paymentAttemptRepository;  // Repository\n    \n    @Autowired\n    private PaymentAttemptDAOV2Impl paymentAttemptDAO;  // DAO\n    \n    @Autowired\n    private PaymentAttemptWorkflowContextDAO workflowContextDAO;  // DynamoDB\n    \n    public PaymentAttemptV2Entity getPaymentAttempt(String externalId) {\n        // Use repository for simple lookups\n        return paymentAttemptRepository.findByExternalId(externalId)\n                .orElseThrow(() -> new NotFoundException(...));\n    }\n    \n    public List<PaymentAttemptV2Entity> getAttemptsByOrder(String orderId) {\n        // Use DAO for complex queries with JOINs\n        return paymentAttemptDAO.findByOrderId(orderId);\n    }\n    \n    public void storeWorkflowContext(String paymentAttemptId, WorkflowStep step, String data) {\n        // Use DynamoDB DAO for temporary state\n        PaymentAttemptWorkflowContextEntity context = \n            PaymentAttemptWorkflowContextEntity.builder()\n                .paymentAttemptExternalId(paymentAttemptId)\n                .workflowStep(step)\n                .data(data)\n                .build();\n        workflowContextDAO.save(context);\n    }\n}\n```\n\n#### Transaction Management\n\n**Master/Primary Database (Write Operations):**\n```java\n@Transactional(transactionManager = \"MasterTransactionManager\")\npublic PaymentAttemptV2Entity updatePaymentAttempt(PaymentAttemptV2Entity entity) {\n    return paymentAttemptDAO.update(entity);\n}\n```\n\n**Replica Database (Read Operations):**\n```java\n@Transactional(transactionManager = \"ReplicaTransactionManager\", readOnly = true)\npublic List<PaymentAttemptEntity> getPaymentAttempts(String orderId) {\n    return paymentAttemptReplicaDAO.findByOrderId(orderId);\n}\n```\n\n**Configuration:**\n- Master: Default timeout (configured via `master.transactionTimeout`)\n- Replica: Separate timeout (configured via `replica.transactionTimeout`)\n\n**Transaction Isolation:**\n- Separate EntityManagers for master and replica\n- Replica marked as read-only in Hikari config\n- Automatic transaction routing based on @ReplicaRepository annotation\n\n#### Connection Pooling Details\n\n**Hikari Configuration - Master**\n\nFile: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/configuration/database/MasterDataSourceConfiguration.java`\n\n```java\nHikariConfig hikariConfig = new HikariConfig();\nhikariConfig.setIdleTimeout(hikariIdleTimeout);                    // Idle timeout\nhikariConfig.setConnectionTimeout(hikariConnectionTimeout);        // Connection acquisition timeout\nhikariConfig.setMinimumIdle(masterMinimumIdle);                   // Min idle connections\nhikariConfig.setMaximumPoolSize(masterMaximumPoolSize);           // Max pool size\nhikariConfig.setMaxLifetime(maxLifeTime);                         // Max connection lifetime\nhikariConfig.setPoolName(\"hikari_master\");\nhikariConfig.setLeakDetectionThreshold(leakDetectionThreshold);   // Leak detection\nhikariConfig.setJdbcUrl(url);\nhikariConfig.setUsername(username);\nhikariConfig.setPassword(password);\nhikariConfig.setDriverClassName(driverClassName);\n\nHikariDataSource masterDataSource = new HikariDataSource(hikariConfig);\nmaintenanceManager.registerHandler(new HikariMaintenanceHandler(masterDataSource));\n```\n\n**Hikari Configuration - Replica**\n\n```java\nHikariConfig hikariConfig = new HikariConfig();\nhikariConfig.setReadOnly(true);                                   // Read-only mode\nhikariConfig.setIdleTimeout(hikariIdleTimeout);\nhikariConfig.setConnectionTimeout(hikariConnectionTimeout);\nhikariConfig.setMinimumIdle(replicaMinimumIdle);                 // Separate pool config\nhikariConfig.setMaximumPoolSize(replicaMaximumPoolSize);\nhikariConfig.setMaxLifetime(maxLifeTime);\nhikariConfig.setPoolName(\"hikari_replica\");\nhikariConfig.setLeakDetectionThreshold(leakDetectionThreshold);\nhikariConfig.setJdbcUrl(replicaDatasourceUrl);                   // Separate replica URL\n// ... credentials for replica\n```\n\n**Key Differences:**\n1. **Separate URLs:** Master and replica point to different database instances\n2. **Read-Only Flag:** Replica pool set to read-only mode\n3. **Separate Pool Sizing:** Master and replica have independent pool size configs\n4. **Pool Names:** Distinct Hikari pool names for monitoring/debugging\n5. **Leak Detection:** Both monitor for connection leaks\n\n**Connection Lifecycle:**\n- Connections idle for `hikariIdleTimeout` are closed\n- New connection requests wait max `hikariConnectionTimeout` before failing\n- Long-lived connections recycled after `maxLifeTime`\n- Leaked connections detected after `leakDetectionThreshold`\n\n**Maintenance Integration:**\nBoth master and replica register with `MaintenanceManager`:\n```java\nmaintenanceManager.registerHandler(new HikariMaintenanceHandler(dataSource));\n```\n\nAllows graceful shutdown and connection cleanup during maintenance windows.\n\n#### Query Patterns\n\n**N+1 Query Prevention:**\n```java\n// Good: Explicit FETCH JOINs\n@Query(\"SELECT o FROM OrderEntity o \"\n    + \"JOIN FETCH o.customerEntity as cust \"\n    + \"JOIN FETCH o.clientEntity as client \"\n    + \"LEFT JOIN FETCH o.orderUdfEntity as udfs \"\n    + \"WHERE o.externalId = :externalId\")\nOptional<OrderEntity> findByExternalId(@Param(\"externalId\") String externalId);\n```\n\n**Compound Conditions:**\n```java\n// Named query using property path\nList<PaymentV2Entity> findByOrderEntity_ExternalIdAndStatusIn(\n    String externalId, List<PaymentStatus> statuses);\n\n// Custom JPQL for complex logic\n@Query(\"select p from PaymentV2Entity as p where p.orderEntity.externalId = :externalId \n        and p.status not in :excludedStatusList\")\nList<PaymentV2Entity> findPaymentsForOrderExcludingPaymentsWithStatus(\n    @Param(\"externalId\") String externalId,\n    @Param(\"excludedStatusList\") List<PaymentStatus> excludedStatusList);\n```\n\n**External ID as Primary Lookup:**\n- Most queries use external_id (UUID) rather than database ID\n- External IDs are client-facing identifiers\n- Database IDs used only internally for relationships\n\n---\n\n## ARCHITECTURE SUMMARY\n\n### Data Layer Stack\n```\n┌─────────────────────────────────────────────────────────┐\n│                    Service Layer                        │\n├─────────────────────────────────────────────────────────┤\n│ JPA Repositories      │ Custom DAOs      │ DynamoDB DAOs │\n├─────────────────────────────────────────────────────────┤\n│     Spring Data JPA with Hibernate ORM                  │\n├──────────────────────┬──────────────────────────────────┤\n│   Master DataSource  │      Replica DataSource          │\n│   (Write)            │      (Read-Only)                 │\n├──────────────────────┼──────────────────────────────────┤\n│ Hikari Connection    │   Hikari Connection             │\n│ Pool (Master)        │   Pool (Replica)                │\n├──────────────────────┼──────────────────────────────────┤\n│    MySQL Master      │      MySQL Replica              │\n└──────────────────────┴──────────────────────────────────┘\n         │\n         └──────────────────────┬────────────────────────┐\n                                │                        │\n                        ┌───────▼────────┐    ┌──────────▼─────┐\n                        │   DynamoDB     │    │   Caffeine     │\n                        │   (Workflow)   │    │   Caches       │\n                        └────────────────┘    └────────────────┘\n```\n\n### Key Features\n\n1. **Master-Replica Separation:**\n   - Automatic routing via @ReplicaRepository annotation\n   - Prevents read bottlenecks on primary database\n   - Transaction managers per datasource\n\n2. **Optimistic Locking:**\n   - @Version column on all BaseExternalEntity classes\n   - Prevents concurrent modification conflicts\n\n3. **Audit Trail:**\n   - created_at, updated_at (auto-managed)\n   - created_by, updated_by (context-aware)\n   - Soft deletes via is_deleted flag\n\n4. **Polymorphic Queries:**\n   - JOINED inheritance for Payment and PaymentAttempt\n   - Allows querying payment types together\n\n5. **Flexible Attributes:**\n   - JSON converters for complex objects\n   - Attributes stored directly in columns\n   - Separate OrderAttributeEntity for key-value pairs\n\n6. **Performance Caching:**\n   - Multi-layer Caffeine caches\n   - Jittered TTLs to prevent thundering herd\n   - Lazy loading with refresh-after-write\n\n7. **Workflow State Management:**\n   - DynamoDB for temporary, TTL-based workflow context\n   - Separate from primary transaction data\n   - Enables event sourcing patterns\n\n8. **Connection Management:**\n   - HikariCP for efficient pooling\n   - Leak detection and monitoring\n   - Integration with maintenance manager\n\nThis architecture provides high performance, scalability, and maintainability for a complex payment processing system with multiple data sources and access patterns."}],"totalDurationMs":167116,"totalTokens":84515,"totalToolUseCount":55,"usage":{"input_tokens":7,"cache_creation_input_tokens":3084,"cache_read_input_tokens":66209,"cache_creation":{"ephemeral_5m_input_tokens":3084,"ephemeral_1h_input_tokens":0},"output_tokens":15215}}}
{"parentUuid":"90cc8748-5648-471d-a780-25421bca301c","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01Dy6sYTKfe24qumK2Pj9dv4","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Excellent! The exploration agent provided a comprehensive deep-dive into the data layer. Let me update the plan file with this detailed information and summarize for the user.","signature":"EtoCCkgICxABGAIqQGd4gpMtY03RYclIhDCHtItM8dEPG/kpF6KPUgDLqdEbBeBO77cJDRxR0huY/14gAW1+IEQwBlvyTKXgOdwwJ7oSDKzddxvpW/bfF9f9/xoMvCZF4FvH/eq/6WqFIjBH1mhfInXEzbR2+XvnTBe7UBM8H7IFCjKFLErCz5BiXeC8Vd/Z6iJ1E6/J8z2IMmQqvwHi+IOEc28vP60QP4JgJ4JNcNVJBVInapk2WseewSFqBdOMPoCyLJSrG+4IAWcuXqDrccAflgiOFqunKnaVZn0fByQ2twoK4rYxl+CB30Q5+mj1o1v7utWeJyLZgEbKACNlMpa7YKECI4LHYgPFKmncI/NOBytfhDqOylXgZiTM22rS0hf4x+/E2glWLds5o6/hxjtFlggqeevyVoBeQboc1wvdPfBupFmWtiLiOqvTP5HFJkIIkWIX8/wzgjga5hgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":15741,"cache_read_input_tokens":42700,"cache_creation":{"ephemeral_5m_input_tokens":15741,"ephemeral_1h_input_tokens":0},"output_tokens":4}},"type":"assistant","uuid":"246959e2-5d46-495b-bbca-6f5f5516e0d1","timestamp":"2025-12-31T09:34:58.115Z"}
{"parentUuid":"246959e2-5d46-495b-bbca-6f5f5516e0d1","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01Dy6sYTKfe24qumK2Pj9dv4","type":"message","role":"assistant","content":[{"type":"text","text":"Excellent! Let me update your study guide with this comprehensive Data Layer deep-dive."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":15741,"cache_read_input_tokens":42700,"cache_creation":{"ephemeral_5m_input_tokens":15741,"ephemeral_1h_input_tokens":0},"output_tokens":4}},"type":"assistant","uuid":"f6065ef7-0567-48b7-b74a-6619f32499ef","timestamp":"2025-12-31T09:34:59.672Z"}
{"parentUuid":"f6065ef7-0567-48b7-b74a-6619f32499ef","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01Dy6sYTKfe24qumK2Pj9dv4","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_bdrk_01JageWNEG2AhP772Hytscfc","name":"Edit","input":{"file_path":"/Users/kiranbiliyawala/.claude/plans/distributed-marinating-mango.md","old_string":"## 15. KEY CONCEPTS\n\n1. **Multi-Provider Orchestration** - Route to optimal provider based on rules\n2. **Decision Trees** - JSON-based routing logic\n3. **State Machines** - Event-driven entity lifecycle\n4. **Master-Replica DB** - Read/write separation\n5. **Workflow Pattern** - 7-step execution pipeline\n6. **Event-Driven Architecture** - Guava EventBus + Kafka","new_string":"## 15. KEY CONCEPTS\n\n1. **Multi-Provider Orchestration** - Route to optimal provider based on rules\n2. **Decision Trees** - JSON-based routing logic\n3. **State Machines** - Event-driven entity lifecycle\n4. **Master-Replica DB** - Read/write separation\n5. **Workflow Pattern** - 7-step execution pipeline\n6. **Event-Driven Architecture** - Guava EventBus + Kafka\n\n---\n\n# DATA LAYER DEEP-DIVE\n\n## 16. ENTITY HIERARCHY & INHERITANCE\n\n### Base Classes\n```\nBaseEntity (id, created_at, updated_at, created_by, updated_by)\n    └── BaseExternalEntity (+ external_id UUID, version for optimistic locking)\n            ├── OrderEntity\n            ├── PaymentV2Entity\n            ├── PaymentAttemptV2Entity\n            ├── RefundEntity\n            ├── ClientEntity\n            └── CustomerEntity\n```\n\n### Key Entity Files\n| Entity | File | Key Fields |\n|--------|------|------------|\n| OrderEntity | `entity/OrderEntity.java` | clientReferenceId, amount, status, metadata (JSON) |\n| PaymentV2Entity | `entity/v2/PaymentV2Entity.java` | orderId, amount, paymentMode, instrumentDetail (JSON) |\n| PaymentAttemptV2Entity | `entity/v2/PaymentAttemptV2Entity.java` | paymentId, providerReferenceId, gatewayReferenceId, status |\n| RefundEntity | `entity/v2/RefundEntity.java` | orderId, paymentAttemptId, refundType, refundStatus |\n| ClientEntity | `entity/ClientEntity.java` | name, merchantId, settings (OneToMany) |\n\n### Entity Relationships\n```\nClientEntity (1) ──> (M) OrderEntity\nOrderEntity (1) ──> (M) PaymentV2Entity\nPaymentV2Entity (1) ──> (M) PaymentAttemptV2Entity\nPaymentAttemptV2Entity ──> PaymentProviderEntity\nPaymentAttemptV2Entity ──> ProviderAccountEntity\nOrderEntity (1) ──> (M) RefundEntity\nRefundEntity (1) ──> (M) RefundAttemptEntity\n```\n\n---\n\n## 17. MASTER-REPLICA DATABASE ARCHITECTURE\n\n### How Routing Works\n\n**Master (Writes):** `MasterDataSourceConfiguration.java`\n- EntityManagerFactory: `MasterEntityManagerFactory`\n- TransactionManager: `MasterTransactionManager`\n- Excludes beans with `@ReplicaRepository`\n\n**Replica (Reads):** `ReplicaDataSourceConfiguration.java`\n- EntityManagerFactory: `ReplicaEntityManagerFactory`\n- TransactionManager: `ReplicaTransactionManager`\n- Includes ONLY beans with `@ReplicaRepository`\n- Connection pool set to `readOnly=true`\n\n### Usage Pattern\n```java\n// Write to master (default)\n@Repository\npublic interface PaymentRepository extends JpaRepository<...> {}\n\n// Read from replica\n@Repository\n@ReplicaRepository  // <-- Annotation routes to replica\npublic class RefundEntityReplicaDAOImpl extends AbstractReplicaDAOImpl<...> {}\n```\n\n### HikariCP Connection Pools\n| Pool | Config | Purpose |\n|------|--------|---------|\n| hikari_master | masterMinimumIdle, masterMaximumPoolSize | Write operations |\n| hikari_replica | replicaMinimumIdle, replicaMaximumPoolSize, readOnly=true | Read operations |\n\nBoth pools have:\n- idleTimeout, connectionTimeout, maxLifetime\n- leakDetectionThreshold for debugging\n- MaintenanceManager integration for graceful shutdown\n\n---\n\n## 18. REPOSITORY & DAO PATTERNS\n\n### JPA Repository Pattern\n```java\n@Repository\npublic interface OrderRepository extends JpaRepository<OrderEntity, Long> {\n    // FETCH JOIN to prevent N+1 queries\n    @Query(\"SELECT o FROM OrderEntity o \"\n            + \"JOIN FETCH o.customerEntity \"\n            + \"JOIN FETCH o.clientEntity \"\n            + \"WHERE o.externalId = :externalId\")\n    Optional<OrderEntity> findByExternalId(@Param(\"externalId\") String externalId);\n\n    // Property path navigation\n    Optional<OrderEntity> findByClientReferenceIdAndClientEntity_ExternalId(\n            String clientReferenceId, String externalId);\n}\n```\n\n### DAO Pattern (Custom EntityManager)\n```java\n@Repository\npublic class PaymentAttemptDAOV2Impl {\n    @PersistenceContext\n    private EntityManager entityManager;\n\n    public List<PaymentAttemptV2Entity> findByOrderId(Long orderId) {\n        // Complex JPQL with manual EntityManager\n    }\n}\n```\n\n### DynamoDB DAO Pattern\n```java\n@RequiredArgsConstructor\npublic abstract class AbstractDynamoDBDAO<T> {\n    private final DynamoDBMapper dynamoDBMapper;\n\n    public void save(T entity) { dynamoDBMapper.save(entity); }\n    public T findByHashKey(Object hashKey) { return dynamoDBMapper.load(tClass, hashKey); }\n}\n```\n\n---\n\n## 19. JSON COLUMNS & CONVERTERS\n\n**Flexible Attribute Storage:**\n| Column | Converter | Entity |\n|--------|-----------|--------|\n| metadata | ObjectMetadataMapConverter | OrderEntity |\n| instrument_detail | PaymentInstrumentConverter | PaymentV2Entity |\n| instrument_detail | EnrichedPaymentInstrumentConverter | PaymentAttemptV2Entity |\n| routes | RoutesBreakupConverter | PaymentAttemptV2Entity |\n| payment_specific_detail | PaymentSpecificDetailConverter | PaymentV2Entity |\n\n```java\n@Column(name = \"metadata\")\n@Convert(converter = ObjectMetadataMapConverter.class)\nprivate Map<String, String> metaData;\n```\n\n---\n\n## 20. CACHING ARCHITECTURE\n\n### Caffeine Caches (In-Memory)\n| Cache Class | What It Caches | TTL |\n|-------------|----------------|-----|\n| ClientConfigurationCache | Client settings by ID, by externalId, by merchantId | 10-20 min |\n| PaymentProviderCache | Provider configurations | 15-25 min |\n| ProviderAccountCache | Provider account entities | 15-25 min |\n| DecisionTreeObjectCache | Routing decision trees | 180-190 min |\n| FeeCache | Fee configurations | 1 day |\n| CardBinCache | Card BIN details | Configurable |\n| MasterConfigurationCache | Feature flags, system settings | 10-20 min |\n| PaymentErrorMessageMappingCache | Error code to message mappings | Long |\n\n### Cache Pattern\n```java\n@DPCache(cacheName = \"client_configuration_cache\")\nprivate LoadingCache<Long, Map<ClientSettingKey, String>> idCache;\n\n@Override\npublic void buildCache() {\n    idCache = DPCacheBuilder.getBuilder()\n        .refreshAfterWrite(10, MINUTES)  // Lazy refresh\n        .build(this::loadClientSettings);  // Loader function\n}\n```\n\n### Jittered TTLs (Prevent Thundering Herd)\n```java\n// Returns 15-25 instead of fixed 15\nprivate Long generateRandomCacheRefreshInterval(int base) {\n    return base + random.nextInt(10) + 1;\n}\n```\n\n---\n\n## 21. DYNAMODB USAGE\n\n### What Goes Where\n| MySQL | DynamoDB |\n|-------|----------|\n| Orders, Payments, Attempts | Workflow context (TTL-based) |\n| Refunds, Fees | Native OTP details |\n| Clients, Customers | Redirect tracking |\n| Provider configs | Metadata audit trails |\n\n### DynamoDB Entity Example\n```java\n@DynamoDBTable(tableName = \"darwin_payment_attempt_workflow_context\")\npublic class PaymentAttemptWorkflowContextEntity {\n    @DynamoDBHashKey(attributeName = \"payment_attempt_external_id\")\n    private String paymentAttemptExternalId;\n\n    @DynamoDBRangeKey\n    @DynamoDBAttribute(attributeName = \"workflow_step\")\n    private WorkflowStep workflowStep;\n\n    @Builder.Default\n    private long ttl = LocalDateTime.now().plusDays(1).toEpochSecond(ZoneOffset.UTC);\n}\n```\n\n### DynamoDB Tables\n| Table | Partition Key | Sort Key | Purpose |\n|-------|---------------|----------|---------|\n| darwin_payment_attempt_workflow_context | payment_attempt_external_id | workflow_step | Workflow state |\n| darwin_payment_attempt_native_otp_detail | payment_attempt_external_id | - | OTP auth details |\n| darwin_payment_attempt_redirection_detail | payment_attempt_external_id | - | 3DS redirects |\n| darwin_payment_attempt_metadata_audit | payment_attempt_external_id | - | Audit trail |\n\n---\n\n## 22. OPTIMISTIC LOCKING & AUDIT\n\n### @Version for Optimistic Locking\n```java\n@Version\n@Column(name = \"version\")\nprivate Integer version;  // Auto-incremented on each update\n```\n\nPrevents concurrent modification - throws `OptimisticLockException` on conflict.\n\n### Audit Columns (Auto-Managed)\n```java\n@CreationTimestamp\n@Column(name = \"created_at\")\nprivate LocalDateTime createAt;\n\n@UpdateTimestamp\n@Column(name = \"updated_at\")\nprivate LocalDateTime updatedAt;\n\n@PrePersist\npublic void onCreate() {\n    createdBy = ApplicationContext.getApplicationName();\n}\n\n@PreUpdate\npublic void onUpdate() {\n    updatedBy = ApplicationContext.getApplicationName();\n}\n```\n\n---\n\n## 23. DATA LAYER ARCHITECTURE DIAGRAM\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                    Service Layer                        │\n├─────────────────────────────────────────────────────────┤\n│ JPA Repositories      │ Custom DAOs      │ DynamoDB DAOs │\n├─────────────────────────────────────────────────────────┤\n│     Spring Data JPA + Hibernate ORM                     │\n├──────────────────────┬──────────────────────────────────┤\n│   Master DataSource  │      Replica DataSource          │\n│   (Writes)           │      (Reads - @ReplicaRepository)│\n├──────────────────────┼──────────────────────────────────┤\n│ HikariCP Master Pool │   HikariCP Replica Pool          │\n├──────────────────────┴──────────────────────────────────┤\n│         MySQL (payments_multi_tenancy)                  │\n└─────────────────────────────────────────────────────────┘\n         │                              │\n┌────────▼────────┐          ┌──────────▼─────────┐\n│    DynamoDB     │          │  Caffeine Caches   │\n│ (Workflow/Audit)│          │  (Client/Provider) │\n└─────────────────┘          └────────────────────┘\n```\n\n---\n\n## 24. KEY DATA LAYER FILES TO STUDY\n\n### Entity Classes (Priority)\n1. `entity/commons/BaseEntity.java` - Base class pattern\n2. `entity/provider/BaseExternalEntity.java` - External ID + versioning\n3. `entity/OrderEntity.java` - Main order entity\n4. `entity/v2/PaymentAttemptV2Entity.java` - Payment attempt (most complex)\n\n### Database Configuration\n1. `configuration/database/MasterDataSourceConfiguration.java`\n2. `configuration/database/ReplicaDataSourceConfiguration.java`\n3. `configuration/database/annotation/ReplicaRepository.java`\n\n### Repositories\n1. `repository/OrderRepository.java` - FETCH JOIN examples\n2. `repository/PaymentAttemptRepository.java` - Complex queries\n\n### Caches\n1. `cache/ClientConfigurationCache.java` - Cache pattern example\n2. `configuration/CacheConfig.java` - Cache configuration\n\n### DynamoDB\n1. `dynamo/dao/AbstractDynamoDBDAO.java` - Base DAO pattern\n2. `dynamo/domain/PaymentAttemptWorkflowContextEntity.java` - DynamoDB entity"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":15741,"cache_read_input_tokens":42700,"cache_creation":{"ephemeral_5m_input_tokens":15741,"ephemeral_1h_input_tokens":0},"output_tokens":3361}},"type":"assistant","uuid":"9f018c43-c6ef-42d5-a918-1826ee6d4c0b","timestamp":"2025-12-31T09:35:46.179Z"}
{"parentUuid":"9f018c43-c6ef-42d5-a918-1826ee6d4c0b","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01JageWNEG2AhP772Hytscfc","type":"tool_result","content":"The file /Users/kiranbiliyawala/.claude/plans/distributed-marinating-mango.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   352→- [ ] Error handling patterns\n   353→\n   354→---\n   355→\n   356→## 15. KEY CONCEPTS\n   357→\n   358→1. **Multi-Provider Orchestration** - Route to optimal provider based on rules\n   359→2. **Decision Trees** - JSON-based routing logic\n   360→3. **State Machines** - Event-driven entity lifecycle\n   361→4. **Master-Replica DB** - Read/write separation\n   362→5. **Workflow Pattern** - 7-step execution pipeline\n   363→6. **Event-Driven Architecture** - Guava EventBus + Kafka\n   364→\n   365→---\n   366→\n   367→# DATA LAYER DEEP-DIVE\n   368→\n   369→## 16. ENTITY HIERARCHY & INHERITANCE\n   370→\n   371→### Base Classes\n   372→```\n   373→BaseEntity (id, created_at, updated_at, created_by, updated_by)\n   374→    └── BaseExternalEntity (+ external_id UUID, version for optimistic locking)\n   375→            ├── OrderEntity\n   376→            ├── PaymentV2Entity\n   377→            ├── PaymentAttemptV2Entity\n   378→            ├── RefundEntity\n   379→            ├── ClientEntity\n   380→            └── CustomerEntity\n   381→```\n   382→\n   383→### Key Entity Files\n   384→| Entity | File | Key Fields |\n   385→|--------|------|------------|\n   386→| OrderEntity | `entity/OrderEntity.java` | clientReferenceId, amount, status, metadata (JSON) |\n   387→| PaymentV2Entity | `entity/v2/PaymentV2Entity.java` | orderId, amount, paymentMode, instrumentDetail (JSON) |\n   388→| PaymentAttemptV2Entity | `entity/v2/PaymentAttemptV2Entity.java` | paymentId, providerReferenceId, gatewayReferenceId, status |\n   389→| RefundEntity | `entity/v2/RefundEntity.java` | orderId, paymentAttemptId, refundType, refundStatus |\n   390→| ClientEntity | `entity/ClientEntity.java` | name, merchantId, settings (OneToMany) |\n   391→\n   392→### Entity Relationships\n   393→```\n   394→ClientEntity (1) ──> (M) OrderEntity\n   395→OrderEntity (1) ──> (M) PaymentV2Entity\n   396→PaymentV2Entity (1) ──> (M) PaymentAttemptV2Entity\n   397→PaymentAttemptV2Entity ──> PaymentProviderEntity\n   398→PaymentAttemptV2Entity ──> ProviderAccountEntity\n   399→OrderEntity (1) ──> (M) RefundEntity\n   400→RefundEntity (1) ──> (M) RefundAttemptEntity\n   401→```\n   402→\n   403→---\n   404→\n   405→## 17. MASTER-REPLICA DATABASE ARCHITECTURE\n   406→\n   407→### How Routing Works\n   408→\n   409→**Master (Writes):** `MasterDataSourceConfiguration.java`\n   410→- EntityManagerFactory: `MasterEntityManagerFactory`\n   411→- TransactionManager: `MasterTransactionManager`\n   412→- Excludes beans with `@ReplicaRepository`\n   413→\n   414→**Replica (Reads):** `ReplicaDataSourceConfiguration.java`\n   415→- EntityManagerFactory: `ReplicaEntityManagerFactory`\n   416→- TransactionManager: `ReplicaTransactionManager`\n   417→- Includes ONLY beans with `@ReplicaRepository`\n   418→- Connection pool set to `readOnly=true`\n   419→\n   420→### Usage Pattern\n   421→```java\n   422→// Write to master (default)\n   423→@Repository\n   424→public interface PaymentRepository extends JpaRepository<...> {}\n   425→\n   426→// Read from replica\n   427→@Repository\n   428→@ReplicaRepository  // <-- Annotation routes to replica\n   429→public class RefundEntityReplicaDAOImpl extends AbstractReplicaDAOImpl<...> {}\n   430→```\n   431→\n   432→### HikariCP Connection Pools\n   433→| Pool | Config | Purpose |\n   434→|------|--------|---------|\n   435→| hikari_master | masterMinimumIdle, masterMaximumPoolSize | Write operations |\n   436→| hikari_replica | replicaMinimumIdle, replicaMaximumPoolSize, readOnly=true | Read operations |\n   437→\n   438→Both pools have:\n   439→- idleTimeout, connectionTimeout, maxLifetime\n   440→- leakDetectionThreshold for debugging\n   441→- MaintenanceManager integration for graceful shutdown\n   442→\n   443→---\n   444→\n   445→## 18. REPOSITORY & DAO PATTERNS\n   446→\n   447→### JPA Repository Pattern\n   448→```java\n   449→@Repository\n   450→public interface OrderRepository extends JpaRepository<OrderEntity, Long> {\n   451→    // FETCH JOIN to prevent N+1 queries\n   452→    @Query(\"SELECT o FROM OrderEntity o \"\n   453→            + \"JOIN FETCH o.customerEntity \"\n   454→            + \"JOIN FETCH o.clientEntity \"\n   455→            + \"WHERE o.externalId = :externalId\")\n   456→    Optional<OrderEntity> findByExternalId(@Param(\"externalId\") String externalId);\n   457→\n   458→    // Property path navigation\n   459→    Optional<OrderEntity> findByClientReferenceIdAndClientEntity_ExternalId(\n   460→            String clientReferenceId, String externalId);\n   461→}\n   462→```\n   463→\n   464→### DAO Pattern (Custom EntityManager)\n   465→```java\n   466→@Repository\n   467→public class PaymentAttemptDAOV2Impl {\n   468→    @PersistenceContext\n   469→    private EntityManager entityManager;\n   470→\n   471→    public List<PaymentAttemptV2Entity> findByOrderId(Long orderId) {\n   472→        // Complex JPQL with manual EntityManager\n   473→    }\n   474→}\n   475→```\n   476→\n   477→### DynamoDB DAO Pattern\n   478→```java\n   479→@RequiredArgsConstructor\n   480→public abstract class AbstractDynamoDBDAO<T> {\n   481→    private final DynamoDBMapper dynamoDBMapper;\n   482→\n   483→    public void save(T entity) { dynamoDBMapper.save(entity); }\n   484→    public T findByHashKey(Object hashKey) { return dynamoDBMapper.load(tClass, hashKey); }\n   485→}\n   486→```\n   487→\n   488→---\n   489→\n   490→## 19. JSON COLUMNS & CONVERTERS\n   491→\n   492→**Flexible Attribute Storage:**\n   493→| Column | Converter | Entity |\n   494→|--------|-----------|--------|\n   495→| metadata | ObjectMetadataMapConverter | OrderEntity |\n   496→| instrument_detail | PaymentInstrumentConverter | PaymentV2Entity |\n   497→| instrument_detail | EnrichedPaymentInstrumentConverter | PaymentAttemptV2Entity |\n   498→| routes | RoutesBreakupConverter | PaymentAttemptV2Entity |\n   499→| payment_specific_detail | PaymentSpecificDetailConverter | PaymentV2Entity |\n   500→\n   501→```java\n   502→@Column(name = \"metadata\")\n   503→@Convert(converter = ObjectMetadataMapConverter.class)\n   504→private Map<String, String> metaData;\n   505→```\n   506→\n   507→---\n   508→\n   509→## 20. CACHING ARCHITECTURE\n   510→\n   511→### Caffeine Caches (In-Memory)\n   512→| Cache Class | What It Caches | TTL |\n   513→|-------------|----------------|-----|\n   514→| ClientConfigurationCache | Client settings by ID, by externalId, by merchantId | 10-20 min |\n   515→| PaymentProviderCache | Provider configurations | 15-25 min |\n   516→| ProviderAccountCache | Provider account entities | 15-25 min |\n   517→| DecisionTreeObjectCache | Routing decision trees | 180-190 min |\n   518→| FeeCache | Fee configurations | 1 day |\n   519→| CardBinCache | Card BIN details | Configurable |\n   520→| MasterConfigurationCache | Feature flags, system settings | 10-20 min |\n   521→| PaymentErrorMessageMappingCache | Error code to message mappings | Long |\n   522→\n   523→### Cache Pattern\n   524→```java\n   525→@DPCache(cacheName = \"client_configuration_cache\")\n   526→private LoadingCache<Long, Map<ClientSettingKey, String>> idCache;\n   527→\n   528→@Override\n   529→public void buildCache() {\n   530→    idCache = DPCacheBuilder.getBuilder()\n   531→        .refreshAfterWrite(10, MINUTES)  // Lazy refresh\n   532→        .build(this::loadClientSettings);  // Loader function\n   533→}\n   534→```\n   535→\n   536→### Jittered TTLs (Prevent Thundering Herd)\n   537→```java\n   538→// Returns 15-25 instead of fixed 15\n   539→private Long generateRandomCacheRefreshInterval(int base) {\n   540→    return base + random.nextInt(10) + 1;\n   541→}\n   542→```\n   543→\n   544→---\n   545→\n   546→## 21. DYNAMODB USAGE\n   547→\n   548→### What Goes Where\n   549→| MySQL | DynamoDB |\n   550→|-------|----------|\n   551→| Orders, Payments, Attempts | Workflow context (TTL-based) |\n   552→| Refunds, Fees | Native OTP details |\n   553→| Clients, Customers | Redirect tracking |\n   554→| Provider configs | Metadata audit trails |\n   555→\n   556→### DynamoDB Entity Example\n   557→```java\n   558→@DynamoDBTable(tableName = \"darwin_payment_attempt_workflow_context\")\n   559→public class PaymentAttemptWorkflowContextEntity {\n   560→    @DynamoDBHashKey(attributeName = \"payment_attempt_external_id\")\n   561→    private String paymentAttemptExternalId;\n   562→\n   563→    @DynamoDBRangeKey\n   564→    @DynamoDBAttribute(attributeName = \"workflow_step\")\n   565→    private WorkflowStep workflowStep;\n   566→\n   567→    @Builder.Default\n   568→    private long ttl = LocalDateTime.now().plusDays(1).toEpochSecond(ZoneOffset.UTC);\n   569→}\n   570→```\n   571→\n   572→### DynamoDB Tables\n   573→| Table | Partition Key | Sort Key | Purpose |\n   574→|-------|---------------|----------|---------|\n   575→| darwin_payment_attempt_workflow_context | payment_attempt_external_id | workflow_step | Workflow state |\n   576→| darwin_payment_attempt_native_otp_detail | payment_attempt_external_id | - | OTP auth details |\n   577→| darwin_payment_attempt_redirection_detail | payment_attempt_external_id | - | 3DS redirects |\n   578→| darwin_payment_attempt_metadata_audit | payment_attempt_external_id | - | Audit trail |\n   579→\n   580→---\n   581→\n   582→## 22. OPTIMISTIC LOCKING & AUDIT\n   583→\n   584→### @Version for Optimistic Locking\n   585→```java\n   586→@Version\n   587→@Column(name = \"version\")\n   588→private Integer version;  // Auto-incremented on each update\n   589→```\n   590→\n   591→Prevents concurrent modification - throws `OptimisticLockException` on conflict.\n   592→\n   593→### Audit Columns (Auto-Managed)\n   594→```java\n   595→@CreationTimestamp\n   596→@Column(name = \"created_at\")\n   597→private LocalDateTime createAt;\n   598→\n   599→@UpdateTimestamp\n   600→@Column(name = \"updated_at\")\n   601→private LocalDateTime updatedAt;\n   602→\n   603→@PrePersist\n   604→public void onCreate() {\n   605→    createdBy = ApplicationContext.getApplicationName();\n   606→}\n   607→\n   608→@PreUpdate\n   609→public void onUpdate() {\n   610→    updatedBy = ApplicationContext.getApplicationName();\n   611→}\n   612→```\n   613→\n   614→---\n   615→\n   616→## 23. DATA LAYER ARCHITECTURE DIAGRAM\n   617→\n   618→```\n   619→┌─────────────────────────────────────────────────────────┐\n   620→│                    Service Layer                        │\n   621→├─────────────────────────────────────────────────────────┤\n   622→│ JPA Repositories      │ Custom DAOs      │ DynamoDB DAOs │\n   623→├─────────────────────────────────────────────────────────┤\n   624→│     Spring Data JPA + Hibernate ORM                     │\n   625→├──────────────────────┬──────────────────────────────────┤\n   626→│   Master DataSource  │      Replica DataSource          │\n   627→│   (Writes)           │      (Reads - @ReplicaRepository)│\n   628→├──────────────────────┼──────────────────────────────────┤\n   629→│ HikariCP Master Pool │   HikariCP Replica Pool          │\n   630→├──────────────────────┴──────────────────────────────────┤\n   631→│         MySQL (payments_multi_tenancy)                  │\n   632→└─────────────────────────────────────────────────────────┘\n   633→         │                              │\n   634→┌────────▼────────┐          ┌──────────▼─────────┐\n   635→│    DynamoDB     │          │  Caffeine Caches   │\n   636→│ (Workflow/Audit)│          │  (Client/Provider) │\n   637→└─────────────────┘          └────────────────────┘\n   638→```\n   639→\n   640→---\n   641→\n   642→## 24. KEY DATA LAYER FILES TO STUDY\n   643→\n   644→### Entity Classes (Priority)\n   645→1. `entity/commons/BaseEntity.java` - Base class pattern\n   646→2. `entity/provider/BaseExternalEntity.java` - External ID + versioning\n   647→3. `entity/OrderEntity.java` - Main order entity\n   648→4. `entity/v2/PaymentAttemptV2Entity.java` - Payment attempt (most complex)\n   649→\n   650→### Database Configuration\n   651→1. `configuration/database/MasterDataSourceConfiguration.java`\n   652→2. `configuration/database/ReplicaDataSourceConfiguration.java`\n   653→3. `configuration/database/annotation/ReplicaRepository.java`\n   654→\n   655→### Repositories\n   656→1. `repository/OrderRepository.java` - FETCH JOIN examples\n   657→2. `repository/PaymentAttemptRepository.java` - Complex queries\n   658→\n   659→### Caches\n   660→1. `cache/ClientConfigurationCache.java` - Cache pattern example\n   661→2. `configuration/CacheConfig.java` - Cache configuration\n   662→\n   663→### DynamoDB\n   664→1. `dynamo/dao/AbstractDynamoDBDAO.java` - Base DAO pattern\n   665→2. `dynamo/domain/PaymentAttemptWorkflowContextEntity.java` - DynamoDB entity\n   666→"}]},"uuid":"94c49606-b151-47d1-9a33-1124126f8c2c","timestamp":"2025-12-31T09:35:46.680Z","toolUseResult":{"filePath":"/Users/kiranbiliyawala/.claude/plans/distributed-marinating-mango.md","oldString":"## 15. KEY CONCEPTS\n\n1. **Multi-Provider Orchestration** - Route to optimal provider based on rules\n2. **Decision Trees** - JSON-based routing logic\n3. **State Machines** - Event-driven entity lifecycle\n4. **Master-Replica DB** - Read/write separation\n5. **Workflow Pattern** - 7-step execution pipeline\n6. **Event-Driven Architecture** - Guava EventBus + Kafka","newString":"## 15. KEY CONCEPTS\n\n1. **Multi-Provider Orchestration** - Route to optimal provider based on rules\n2. **Decision Trees** - JSON-based routing logic\n3. **State Machines** - Event-driven entity lifecycle\n4. **Master-Replica DB** - Read/write separation\n5. **Workflow Pattern** - 7-step execution pipeline\n6. **Event-Driven Architecture** - Guava EventBus + Kafka\n\n---\n\n# DATA LAYER DEEP-DIVE\n\n## 16. ENTITY HIERARCHY & INHERITANCE\n\n### Base Classes\n```\nBaseEntity (id, created_at, updated_at, created_by, updated_by)\n    └── BaseExternalEntity (+ external_id UUID, version for optimistic locking)\n            ├── OrderEntity\n            ├── PaymentV2Entity\n            ├── PaymentAttemptV2Entity\n            ├── RefundEntity\n            ├── ClientEntity\n            └── CustomerEntity\n```\n\n### Key Entity Files\n| Entity | File | Key Fields |\n|--------|------|------------|\n| OrderEntity | `entity/OrderEntity.java` | clientReferenceId, amount, status, metadata (JSON) |\n| PaymentV2Entity | `entity/v2/PaymentV2Entity.java` | orderId, amount, paymentMode, instrumentDetail (JSON) |\n| PaymentAttemptV2Entity | `entity/v2/PaymentAttemptV2Entity.java` | paymentId, providerReferenceId, gatewayReferenceId, status |\n| RefundEntity | `entity/v2/RefundEntity.java` | orderId, paymentAttemptId, refundType, refundStatus |\n| ClientEntity | `entity/ClientEntity.java` | name, merchantId, settings (OneToMany) |\n\n### Entity Relationships\n```\nClientEntity (1) ──> (M) OrderEntity\nOrderEntity (1) ──> (M) PaymentV2Entity\nPaymentV2Entity (1) ──> (M) PaymentAttemptV2Entity\nPaymentAttemptV2Entity ──> PaymentProviderEntity\nPaymentAttemptV2Entity ──> ProviderAccountEntity\nOrderEntity (1) ──> (M) RefundEntity\nRefundEntity (1) ──> (M) RefundAttemptEntity\n```\n\n---\n\n## 17. MASTER-REPLICA DATABASE ARCHITECTURE\n\n### How Routing Works\n\n**Master (Writes):** `MasterDataSourceConfiguration.java`\n- EntityManagerFactory: `MasterEntityManagerFactory`\n- TransactionManager: `MasterTransactionManager`\n- Excludes beans with `@ReplicaRepository`\n\n**Replica (Reads):** `ReplicaDataSourceConfiguration.java`\n- EntityManagerFactory: `ReplicaEntityManagerFactory`\n- TransactionManager: `ReplicaTransactionManager`\n- Includes ONLY beans with `@ReplicaRepository`\n- Connection pool set to `readOnly=true`\n\n### Usage Pattern\n```java\n// Write to master (default)\n@Repository\npublic interface PaymentRepository extends JpaRepository<...> {}\n\n// Read from replica\n@Repository\n@ReplicaRepository  // <-- Annotation routes to replica\npublic class RefundEntityReplicaDAOImpl extends AbstractReplicaDAOImpl<...> {}\n```\n\n### HikariCP Connection Pools\n| Pool | Config | Purpose |\n|------|--------|---------|\n| hikari_master | masterMinimumIdle, masterMaximumPoolSize | Write operations |\n| hikari_replica | replicaMinimumIdle, replicaMaximumPoolSize, readOnly=true | Read operations |\n\nBoth pools have:\n- idleTimeout, connectionTimeout, maxLifetime\n- leakDetectionThreshold for debugging\n- MaintenanceManager integration for graceful shutdown\n\n---\n\n## 18. REPOSITORY & DAO PATTERNS\n\n### JPA Repository Pattern\n```java\n@Repository\npublic interface OrderRepository extends JpaRepository<OrderEntity, Long> {\n    // FETCH JOIN to prevent N+1 queries\n    @Query(\"SELECT o FROM OrderEntity o \"\n            + \"JOIN FETCH o.customerEntity \"\n            + \"JOIN FETCH o.clientEntity \"\n            + \"WHERE o.externalId = :externalId\")\n    Optional<OrderEntity> findByExternalId(@Param(\"externalId\") String externalId);\n\n    // Property path navigation\n    Optional<OrderEntity> findByClientReferenceIdAndClientEntity_ExternalId(\n            String clientReferenceId, String externalId);\n}\n```\n\n### DAO Pattern (Custom EntityManager)\n```java\n@Repository\npublic class PaymentAttemptDAOV2Impl {\n    @PersistenceContext\n    private EntityManager entityManager;\n\n    public List<PaymentAttemptV2Entity> findByOrderId(Long orderId) {\n        // Complex JPQL with manual EntityManager\n    }\n}\n```\n\n### DynamoDB DAO Pattern\n```java\n@RequiredArgsConstructor\npublic abstract class AbstractDynamoDBDAO<T> {\n    private final DynamoDBMapper dynamoDBMapper;\n\n    public void save(T entity) { dynamoDBMapper.save(entity); }\n    public T findByHashKey(Object hashKey) { return dynamoDBMapper.load(tClass, hashKey); }\n}\n```\n\n---\n\n## 19. JSON COLUMNS & CONVERTERS\n\n**Flexible Attribute Storage:**\n| Column | Converter | Entity |\n|--------|-----------|--------|\n| metadata | ObjectMetadataMapConverter | OrderEntity |\n| instrument_detail | PaymentInstrumentConverter | PaymentV2Entity |\n| instrument_detail | EnrichedPaymentInstrumentConverter | PaymentAttemptV2Entity |\n| routes | RoutesBreakupConverter | PaymentAttemptV2Entity |\n| payment_specific_detail | PaymentSpecificDetailConverter | PaymentV2Entity |\n\n```java\n@Column(name = \"metadata\")\n@Convert(converter = ObjectMetadataMapConverter.class)\nprivate Map<String, String> metaData;\n```\n\n---\n\n## 20. CACHING ARCHITECTURE\n\n### Caffeine Caches (In-Memory)\n| Cache Class | What It Caches | TTL |\n|-------------|----------------|-----|\n| ClientConfigurationCache | Client settings by ID, by externalId, by merchantId | 10-20 min |\n| PaymentProviderCache | Provider configurations | 15-25 min |\n| ProviderAccountCache | Provider account entities | 15-25 min |\n| DecisionTreeObjectCache | Routing decision trees | 180-190 min |\n| FeeCache | Fee configurations | 1 day |\n| CardBinCache | Card BIN details | Configurable |\n| MasterConfigurationCache | Feature flags, system settings | 10-20 min |\n| PaymentErrorMessageMappingCache | Error code to message mappings | Long |\n\n### Cache Pattern\n```java\n@DPCache(cacheName = \"client_configuration_cache\")\nprivate LoadingCache<Long, Map<ClientSettingKey, String>> idCache;\n\n@Override\npublic void buildCache() {\n    idCache = DPCacheBuilder.getBuilder()\n        .refreshAfterWrite(10, MINUTES)  // Lazy refresh\n        .build(this::loadClientSettings);  // Loader function\n}\n```\n\n### Jittered TTLs (Prevent Thundering Herd)\n```java\n// Returns 15-25 instead of fixed 15\nprivate Long generateRandomCacheRefreshInterval(int base) {\n    return base + random.nextInt(10) + 1;\n}\n```\n\n---\n\n## 21. DYNAMODB USAGE\n\n### What Goes Where\n| MySQL | DynamoDB |\n|-------|----------|\n| Orders, Payments, Attempts | Workflow context (TTL-based) |\n| Refunds, Fees | Native OTP details |\n| Clients, Customers | Redirect tracking |\n| Provider configs | Metadata audit trails |\n\n### DynamoDB Entity Example\n```java\n@DynamoDBTable(tableName = \"darwin_payment_attempt_workflow_context\")\npublic class PaymentAttemptWorkflowContextEntity {\n    @DynamoDBHashKey(attributeName = \"payment_attempt_external_id\")\n    private String paymentAttemptExternalId;\n\n    @DynamoDBRangeKey\n    @DynamoDBAttribute(attributeName = \"workflow_step\")\n    private WorkflowStep workflowStep;\n\n    @Builder.Default\n    private long ttl = LocalDateTime.now().plusDays(1).toEpochSecond(ZoneOffset.UTC);\n}\n```\n\n### DynamoDB Tables\n| Table | Partition Key | Sort Key | Purpose |\n|-------|---------------|----------|---------|\n| darwin_payment_attempt_workflow_context | payment_attempt_external_id | workflow_step | Workflow state |\n| darwin_payment_attempt_native_otp_detail | payment_attempt_external_id | - | OTP auth details |\n| darwin_payment_attempt_redirection_detail | payment_attempt_external_id | - | 3DS redirects |\n| darwin_payment_attempt_metadata_audit | payment_attempt_external_id | - | Audit trail |\n\n---\n\n## 22. OPTIMISTIC LOCKING & AUDIT\n\n### @Version for Optimistic Locking\n```java\n@Version\n@Column(name = \"version\")\nprivate Integer version;  // Auto-incremented on each update\n```\n\nPrevents concurrent modification - throws `OptimisticLockException` on conflict.\n\n### Audit Columns (Auto-Managed)\n```java\n@CreationTimestamp\n@Column(name = \"created_at\")\nprivate LocalDateTime createAt;\n\n@UpdateTimestamp\n@Column(name = \"updated_at\")\nprivate LocalDateTime updatedAt;\n\n@PrePersist\npublic void onCreate() {\n    createdBy = ApplicationContext.getApplicationName();\n}\n\n@PreUpdate\npublic void onUpdate() {\n    updatedBy = ApplicationContext.getApplicationName();\n}\n```\n\n---\n\n## 23. DATA LAYER ARCHITECTURE DIAGRAM\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                    Service Layer                        │\n├─────────────────────────────────────────────────────────┤\n│ JPA Repositories      │ Custom DAOs      │ DynamoDB DAOs │\n├─────────────────────────────────────────────────────────┤\n│     Spring Data JPA + Hibernate ORM                     │\n├──────────────────────┬──────────────────────────────────┤\n│   Master DataSource  │      Replica DataSource          │\n│   (Writes)           │      (Reads - @ReplicaRepository)│\n├──────────────────────┼──────────────────────────────────┤\n│ HikariCP Master Pool │   HikariCP Replica Pool          │\n├──────────────────────┴──────────────────────────────────┤\n│         MySQL (payments_multi_tenancy)                  │\n└─────────────────────────────────────────────────────────┘\n         │                              │\n┌────────▼────────┐          ┌──────────▼─────────┐\n│    DynamoDB     │          │  Caffeine Caches   │\n│ (Workflow/Audit)│          │  (Client/Provider) │\n└─────────────────┘          └────────────────────┘\n```\n\n---\n\n## 24. KEY DATA LAYER FILES TO STUDY\n\n### Entity Classes (Priority)\n1. `entity/commons/BaseEntity.java` - Base class pattern\n2. `entity/provider/BaseExternalEntity.java` - External ID + versioning\n3. `entity/OrderEntity.java` - Main order entity\n4. `entity/v2/PaymentAttemptV2Entity.java` - Payment attempt (most complex)\n\n### Database Configuration\n1. `configuration/database/MasterDataSourceConfiguration.java`\n2. `configuration/database/ReplicaDataSourceConfiguration.java`\n3. `configuration/database/annotation/ReplicaRepository.java`\n\n### Repositories\n1. `repository/OrderRepository.java` - FETCH JOIN examples\n2. `repository/PaymentAttemptRepository.java` - Complex queries\n\n### Caches\n1. `cache/ClientConfigurationCache.java` - Cache pattern example\n2. `configuration/CacheConfig.java` - Cache configuration\n\n### DynamoDB\n1. `dynamo/dao/AbstractDynamoDBDAO.java` - Base DAO pattern\n2. `dynamo/domain/PaymentAttemptWorkflowContextEntity.java` - DynamoDB entity","originalFile":"# Payment Service (Darwin) - Expert Study Guide\n\nA comprehensive guide to understanding the payment-service repository.\n\n---\n\n## 1. OVERVIEW & TECH STACK\n\n**Project Name:** Darwin (internal name for payment-service)\n**Purpose:** Enterprise-grade payment processing microservice handling multi-provider payment orchestration\n\n| Technology | Version | Purpose |\n|------------|---------|---------|\n| Java | 17 | Runtime |\n| Spring Boot | 2.7.14 | Framework |\n| Gradle | 7.6 | Build |\n| MySQL | - | Primary Database (Master-Replica) |\n| DynamoDB | - | Audit/State Storage |\n| Redis (Redisson) | 3.19.1 | Distributed Cache |\n| Kafka | - | Event Streaming |\n| AWS SQS | - | Task Processing |\n\n**Server:** Port 9010, Context Path: `/payments`\n\n---\n\n## 2. PROJECT STRUCTURE\n\n```\npayment-service/\n├── src/main/java/in/dreamplug/darwin/\n│   ├── controller/         # REST API endpoints\n│   │   └── v2/             # V2 API controllers (primary)\n│   ├── service/            # Business logic services\n│   ├── v2/\n│   │   ├── service/        # V2 services\n│   │   └── workflow/       # Payment workflows (CRITICAL)\n│   │       └── create/\n│   │           ├── payments/       # Payment creation\n│   │           ├── paymentattempts/ # Payment attempt creation\n│   │           └── providers/      # Provider adapters (24+)\n│   ├── entity/             # JPA entities\n│   │   └── v2/             # V2 entities (primary)\n│   ├── repository/         # Data access layer\n│   ├── statemachine/       # Payment/Order state machines\n│   ├── planner/            # Decision tree routing\n│   ├── cache/              # Caching layer (Caffeine)\n│   ├── client/             # External service clients\n│   ├── provider/           # Legacy provider implementations\n│   ├── configuration/      # Spring configs\n│   │   └── database/       # DB configs (Master/Replica)\n│   ├── kafka/              # Kafka producers/consumers\n│   ├── sqs/                # SQS message processors\n│   ├── dynamo/             # DynamoDB DAOs\n│   ├── error/              # Error handling\n│   ├── dto/                # Data transfer objects\n│   └── commons/spring/filters/  # Auth/Context filters\n├── src/main/resources/\n│   └── application.properties  # Main config (1300+ lines)\n├── codepipeline/           # CI/CD configurations\n├── build.gradle            # Dependencies\n└── Dockerfile              # Container setup\n```\n\n---\n\n## 3. CORE PAYMENT FLOW (CRITICAL)\n\n### 3.1 Payment Lifecycle\n\n```\nOrder Created → Payments Created → Payment Attempt Created → Provider API Call → Webhook/Status Update\n```\n\n**Key Steps:**\n\n1. **Order Creation** - Client creates an order with amount, currency, metadata\n2. **Bulk Payment Creation** - Multiple payment records created for the order\n   - File: `v2/workflow/create/payments/bulk/BulkPaymentCreateWorkflow.java`\n3. **Payment Attempt Creation** - Actual payment attempt with provider routing\n   - File: `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java`\n4. **Provider Processing** - Provider adapter calls external payment gateway\n5. **State Machine Updates** - Events trigger state transitions\n\n### 3.2 Workflow Execution Pipeline\n\n```java\n// Base workflow pattern (Workflow.java)\n1. validateAndEnrichContext()  // Validate inputs, enrich data\n2. persistIntent()             // Save entities to MySQL\n3. persistNonRelationalIntent() // Save to DynamoDB\n4. process()                   // Call provider API\n5. postProcess()               // Transform results\n6. publishEntityChangeEvents() // Trigger state machines\n7. throwErrorIfRequired()      // Handle errors\n```\n\n### 3.3 Payment Attempt Data Enrichment\n\n1. **Instrument Validation** - `InstrumentTypeProcessorManager`\n2. **Provider Routing** - `ProviderDeciderRouter` → Decision Tree\n3. **Auth Type Decision** - `AuthTypeDeciderFactory` (3DS, OTP, None)\n4. **Settlement Validation** - `SettlementRouteValidator`\n\n---\n\n## 4. STATE MACHINES\n\n### 4.1 Payment State Machine\n**File:** `statemachine/payment/PaymentStateMachine.java`\n\n```\nCREATED → PROCESSING → AUTHORIZED → COMPLETED\n                   ↘ FAILED\n                   ↘ BLOCKED\n```\n\n**Terminal States:** COMPLETED, FAILED, FORCE_FAILED, DISCARDED\n\n### 4.2 Order State Machine\n**File:** `statemachine/order/OrderStateMachine.java`\n\n- Reacts to payment events\n- Updates order status based on payment outcomes\n\n### 4.3 Events (EventBus - Guava)\n- `PaymentAttemptCreatedEvent`\n- `PaymentAttemptCompletedEvent`\n- `PaymentAttemptFailedEvent`\n- `PaymentAttemptProcessingEvent`\n- `PaymentAttemptAuthorizedEvent`\n\n---\n\n## 5. PROVIDER INTEGRATIONS (24+ Providers)\n\n**Location:** `v2/workflow/create/providers/`\n\n| Provider | Adapter File | Payment Types |\n|----------|-------------|---------------|\n| Cybersource | `CybersourceProviderAdapter.java` | Cards, 3DS, E-Mandates |\n| Cashfree | `CashfreeProviderAdapter.java` + variants | Cards, UPI, NetBanking |\n| PayU | `PayuProviderAdapter.java` + variants | Cards, NetBanking |\n| Pine Labs | `PineLabsEdgeProviderAdapter.java` | Multiple modes |\n| Razorpay | Via webhooks | All payment types |\n| Juspay | Via webhooks | Orchestration |\n| ICICI UPI | `icici-upi-client` | UPI |\n| Axis UPI | `axis-upi-client` | UPI |\n| YBL UPI | `ybl-upi-client` | UPI |\n| RBL UPI | `rbl-upi-client` | UPI |\n| Digio | `DigioMandateRegisterProviderAdapter.java` | E-Mandates |\n| Cred Points | `CredPointsProviderAdapter.java` | Reward redemption |\n\n### Provider Selection Flow\n\n```\nRequest → ProviderDeciderRouter → LCM (if enabled) → Decision Tree → Provider Adapter\n```\n\n**Decision Tree:** JSON-based rules cached in `DecisionTreeObjectCache`\n\n---\n\n## 6. KEY ENTITIES (V2 Schema)\n\n### Core Entities\n| Entity | File | Purpose |\n|--------|------|---------|\n| OrderEntity | `entity/OrderEntity.java` | Order records |\n| PaymentV2Entity | `entity/v2/PaymentV2Entity.java` | Payment records |\n| PaymentAttemptV2Entity | `entity/v2/PaymentAttemptV2Entity.java` | Payment attempts |\n| RefundEntity | `entity/v2/RefundEntity.java` | Refunds |\n| FeeEntity | `entity/v2/FeeEntity.java` | Fee tracking |\n\n### Configuration Entities\n| Entity | Purpose |\n|--------|---------|\n| ClientEntity | Application clients |\n| ProviderAccountEntity | Provider accounts |\n| PaymentProviderEntity | Provider configs |\n| MasterConfigurationEntity | System configs |\n\n---\n\n## 7. DATABASE ARCHITECTURE\n\n### Master-Replica Pattern\n\n**Master:** Write operations\n**Replica:** Read operations (via `@ReplicaRepository`)\n\n**Configuration Files:**\n- `configuration/database/MasterDataSourceConfiguration.java`\n- `configuration/database/ReplicaDataSourceConfiguration.java`\n\n**Database:** `payments_multi_tenancy`\n**Connection Pool:** HikariCP\n**ORM:** JPA + Hibernate\n\n---\n\n## 8. CACHING LAYER\n\n### Caffeine (In-Memory)\n| Cache | Purpose |\n|-------|---------|\n| `ClientConfigurationCache` | Client settings |\n| `PaymentProviderCache` | Provider configs |\n| `ProviderAccountCache` | Provider accounts |\n| `DecisionTreeObjectCache` | Routing rules |\n| `CardBinCache` | Card BIN data |\n| `MerchantCache` | Merchant data |\n| `FeeCache` | Fee calculations |\n\n### Redis (Distributed)\n- **Client:** Redisson with Kryo5Codec\n- **Use:** Distributed locks, rate limiting, shared state\n\n---\n\n## 9. ASYNC PROCESSING\n\n### Kafka Topics\n- `payment-attempt-platform-metrics-pinot-out-new-1` (Analytics)\n- Events: `PaymentAttemptAnalyticsEvent`, `CardPaymentAttemptAnalyticsEvent`, etc.\n\n### SQS Queues\n| Queue | Purpose |\n|-------|---------|\n| `FORCE_PAYMENT_FAILURE_QUEUE` | Manual failure forcing |\n| `MANDATE_EXPIRY_CRON_QUEUE` | Mandate expiry |\n| `REFUND_RESCHEDULE_QUEUE` | Refund scheduling |\n| `ORDER_EXPIRY_QUEUE` | Order expiration |\n| `PENDENCY_AUTOMATION_QUEUE` | Pending transactions |\n\n### Eventi (Internal Events)\n- Internal event framework for system events\n- Async worker threads (4-16 configurable)\n\n---\n\n## 10. API ENDPOINTS\n\n### Primary Controllers (v2)\n| Endpoint | Controller | Purpose |\n|----------|------------|---------|\n| `/v2/orders/{orderId}/payments` | `PaymentV2Controller` | Bulk payment creation |\n| `/v2/payments/{paymentId}/attempts` | `PaymentAttemptV2Controller` | Payment attempts |\n| `/v1/webhooks` | `WebhookController` | Provider webhooks |\n\n### Webhook Controllers\n- `RazorpayWebhookController`\n- `JuspayWebhookController`\n- `ICICIWebhookController`\n- `YBLWebhookController`\n- `RBLUpiWebhookController`\n- `DigioWebhookController`\n\n---\n\n## 11. AUTHENTICATION & SECURITY\n\n### Request Filters (Order of Execution)\n1. `ApplicationContextBuilderFilter` - Build context from headers\n2. `PAMerchantAuthenticationFilter` - Partner merchant auth\n3. `PAPartnerAuthorizationFilter` - Partner authorization\n\n### Headers Required\n- Client ID (`${CLIENT_HEADER_KEY}`)\n- Merchant ID (`${MERCHANT_HEADER_KEY}`)\n- Device info (DEVICE_ID, OS, OS_VERSION, APP_VERSION)\n\n### Rate Limiting\n- Redisson-based distributed rate limiting\n- Config in `ClientRateLimiter.java`\n\n---\n\n## 12. KEY FILES TO STUDY\n\n### Must-Read Files (Priority Order)\n\n1. **Entry Point:**\n   - `DarwinApplication.java`\n\n2. **Core Workflows:**\n   - `v2/workflow/create/Workflow.java` (base pattern)\n   - `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java`\n   - `v2/workflow/create/payments/bulk/BulkPaymentCreateWorkflow.java`\n\n3. **State Machines:**\n   - `statemachine/payment/PaymentStateMachine.java`\n   - `statemachine/order/OrderStateMachine.java`\n\n4. **Provider Routing:**\n   - `planner/ProviderDeciderRouter.java`\n   - `planner/decisiontree/DecisionTreeWorkflow.java`\n\n5. **Provider Adapters:**\n   - `v2/workflow/create/providers/` (pick any adapter)\n\n6. **Entities:**\n   - `entity/OrderEntity.java`\n   - `entity/v2/PaymentV2Entity.java`\n   - `entity/v2/PaymentAttemptV2Entity.java`\n\n7. **Configuration:**\n   - `application.properties` (1300+ lines - scan for context)\n\n8. **Webhooks:**\n   - `controller/WebhookController.java`\n\n---\n\n## 13. INTERNAL SERVICE DEPENDENCIES\n\n| Service | Client Library | Purpose |\n|---------|---------------|---------|\n| User Service | `user-service-client:4.0.1` | User data |\n| Merchant Service | `merchant-service-client:1.0.3` | Merchant info |\n| Mandate Service | `mandate-java-client:1.0.4` | Recurring payments |\n| Arsenal | - | Instrument vault |\n| Falcon | - | Offers/promotions |\n| Genie | `genie-java-client` | Configuration |\n| Syndicate | - | Authentication |\n| LCM | - | Terminal resolution |\n| Fee Service | `fees:0.18.0` | Fee calculation |\n\n---\n\n## 14. STUDY PATH RECOMMENDATION\n\n### Week 1: Foundation\n- [ ] Understand project structure\n- [ ] Read `DarwinApplication.java`\n- [ ] Study `application.properties` (key sections)\n- [ ] Understand entity relationships\n\n### Week 2: Core Flow\n- [ ] Master `PaymentAttemptCreateWorkflow.java`\n- [ ] Study state machines\n- [ ] Understand provider routing\n\n### Week 3: Integrations\n- [ ] Study 2-3 provider adapters\n- [ ] Understand webhook handling\n- [ ] Learn caching patterns\n\n### Week 4: Advanced\n- [ ] Decision tree engine\n- [ ] Async processing (Kafka, SQS)\n- [ ] Error handling patterns\n\n---\n\n## 15. KEY CONCEPTS\n\n1. **Multi-Provider Orchestration** - Route to optimal provider based on rules\n2. **Decision Trees** - JSON-based routing logic\n3. **State Machines** - Event-driven entity lifecycle\n4. **Master-Replica DB** - Read/write separation\n5. **Workflow Pattern** - 7-step execution pipeline\n6. **Event-Driven Architecture** - Guava EventBus + Kafka\n","structuredPatch":[{"oldStart":361,"oldLines":3,"newStart":361,"newLines":305,"lines":[" 4. **Master-Replica DB** - Read/write separation"," 5. **Workflow Pattern** - 7-step execution pipeline"," 6. **Event-Driven Architecture** - Guava EventBus + Kafka","+","+---","+","+# DATA LAYER DEEP-DIVE","+","+## 16. ENTITY HIERARCHY & INHERITANCE","+","+### Base Classes","+```","+BaseEntity (id, created_at, updated_at, created_by, updated_by)","+    └── BaseExternalEntity (+ external_id UUID, version for optimistic locking)","+            ├── OrderEntity","+            ├── PaymentV2Entity","+            ├── PaymentAttemptV2Entity","+            ├── RefundEntity","+            ├── ClientEntity","+            └── CustomerEntity","+```","+","+### Key Entity Files","+| Entity | File | Key Fields |","+|--------|------|------------|","+| OrderEntity | `entity/OrderEntity.java` | clientReferenceId, amount, status, metadata (JSON) |","+| PaymentV2Entity | `entity/v2/PaymentV2Entity.java` | orderId, amount, paymentMode, instrumentDetail (JSON) |","+| PaymentAttemptV2Entity | `entity/v2/PaymentAttemptV2Entity.java` | paymentId, providerReferenceId, gatewayReferenceId, status |","+| RefundEntity | `entity/v2/RefundEntity.java` | orderId, paymentAttemptId, refundType, refundStatus |","+| ClientEntity | `entity/ClientEntity.java` | name, merchantId, settings (OneToMany) |","+","+### Entity Relationships","+```","+ClientEntity (1) ──> (M) OrderEntity","+OrderEntity (1) ──> (M) PaymentV2Entity","+PaymentV2Entity (1) ──> (M) PaymentAttemptV2Entity","+PaymentAttemptV2Entity ──> PaymentProviderEntity","+PaymentAttemptV2Entity ──> ProviderAccountEntity","+OrderEntity (1) ──> (M) RefundEntity","+RefundEntity (1) ──> (M) RefundAttemptEntity","+```","+","+---","+","+## 17. MASTER-REPLICA DATABASE ARCHITECTURE","+","+### How Routing Works","+","+**Master (Writes):** `MasterDataSourceConfiguration.java`","+- EntityManagerFactory: `MasterEntityManagerFactory`","+- TransactionManager: `MasterTransactionManager`","+- Excludes beans with `@ReplicaRepository`","+","+**Replica (Reads):** `ReplicaDataSourceConfiguration.java`","+- EntityManagerFactory: `ReplicaEntityManagerFactory`","+- TransactionManager: `ReplicaTransactionManager`","+- Includes ONLY beans with `@ReplicaRepository`","+- Connection pool set to `readOnly=true`","+","+### Usage Pattern","+```java","+// Write to master (default)","+@Repository","+public interface PaymentRepository extends JpaRepository<...> {}","+","+// Read from replica","+@Repository","+@ReplicaRepository  // <-- Annotation routes to replica","+public class RefundEntityReplicaDAOImpl extends AbstractReplicaDAOImpl<...> {}","+```","+","+### HikariCP Connection Pools","+| Pool | Config | Purpose |","+|------|--------|---------|","+| hikari_master | masterMinimumIdle, masterMaximumPoolSize | Write operations |","+| hikari_replica | replicaMinimumIdle, replicaMaximumPoolSize, readOnly=true | Read operations |","+","+Both pools have:","+- idleTimeout, connectionTimeout, maxLifetime","+- leakDetectionThreshold for debugging","+- MaintenanceManager integration for graceful shutdown","+","+---","+","+## 18. REPOSITORY & DAO PATTERNS","+","+### JPA Repository Pattern","+```java","+@Repository","+public interface OrderRepository extends JpaRepository<OrderEntity, Long> {","+    // FETCH JOIN to prevent N+1 queries","+    @Query(\"SELECT o FROM OrderEntity o \"","+            + \"JOIN FETCH o.customerEntity \"","+            + \"JOIN FETCH o.clientEntity \"","+            + \"WHERE o.externalId = :externalId\")","+    Optional<OrderEntity> findByExternalId(@Param(\"externalId\") String externalId);","+","+    // Property path navigation","+    Optional<OrderEntity> findByClientReferenceIdAndClientEntity_ExternalId(","+            String clientReferenceId, String externalId);","+}","+```","+","+### DAO Pattern (Custom EntityManager)","+```java","+@Repository","+public class PaymentAttemptDAOV2Impl {","+    @PersistenceContext","+    private EntityManager entityManager;","+","+    public List<PaymentAttemptV2Entity> findByOrderId(Long orderId) {","+        // Complex JPQL with manual EntityManager","+    }","+}","+```","+","+### DynamoDB DAO Pattern","+```java","+@RequiredArgsConstructor","+public abstract class AbstractDynamoDBDAO<T> {","+    private final DynamoDBMapper dynamoDBMapper;","+","+    public void save(T entity) { dynamoDBMapper.save(entity); }","+    public T findByHashKey(Object hashKey) { return dynamoDBMapper.load(tClass, hashKey); }","+}","+```","+","+---","+","+## 19. JSON COLUMNS & CONVERTERS","+","+**Flexible Attribute Storage:**","+| Column | Converter | Entity |","+|--------|-----------|--------|","+| metadata | ObjectMetadataMapConverter | OrderEntity |","+| instrument_detail | PaymentInstrumentConverter | PaymentV2Entity |","+| instrument_detail | EnrichedPaymentInstrumentConverter | PaymentAttemptV2Entity |","+| routes | RoutesBreakupConverter | PaymentAttemptV2Entity |","+| payment_specific_detail | PaymentSpecificDetailConverter | PaymentV2Entity |","+","+```java","+@Column(name = \"metadata\")","+@Convert(converter = ObjectMetadataMapConverter.class)","+private Map<String, String> metaData;","+```","+","+---","+","+## 20. CACHING ARCHITECTURE","+","+### Caffeine Caches (In-Memory)","+| Cache Class | What It Caches | TTL |","+|-------------|----------------|-----|","+| ClientConfigurationCache | Client settings by ID, by externalId, by merchantId | 10-20 min |","+| PaymentProviderCache | Provider configurations | 15-25 min |","+| ProviderAccountCache | Provider account entities | 15-25 min |","+| DecisionTreeObjectCache | Routing decision trees | 180-190 min |","+| FeeCache | Fee configurations | 1 day |","+| CardBinCache | Card BIN details | Configurable |","+| MasterConfigurationCache | Feature flags, system settings | 10-20 min |","+| PaymentErrorMessageMappingCache | Error code to message mappings | Long |","+","+### Cache Pattern","+```java","+@DPCache(cacheName = \"client_configuration_cache\")","+private LoadingCache<Long, Map<ClientSettingKey, String>> idCache;","+","+@Override","+public void buildCache() {","+    idCache = DPCacheBuilder.getBuilder()","+        .refreshAfterWrite(10, MINUTES)  // Lazy refresh","+        .build(this::loadClientSettings);  // Loader function","+}","+```","+","+### Jittered TTLs (Prevent Thundering Herd)","+```java","+// Returns 15-25 instead of fixed 15","+private Long generateRandomCacheRefreshInterval(int base) {","+    return base + random.nextInt(10) + 1;","+}","+```","+","+---","+","+## 21. DYNAMODB USAGE","+","+### What Goes Where","+| MySQL | DynamoDB |","+|-------|----------|","+| Orders, Payments, Attempts | Workflow context (TTL-based) |","+| Refunds, Fees | Native OTP details |","+| Clients, Customers | Redirect tracking |","+| Provider configs | Metadata audit trails |","+","+### DynamoDB Entity Example","+```java","+@DynamoDBTable(tableName = \"darwin_payment_attempt_workflow_context\")","+public class PaymentAttemptWorkflowContextEntity {","+    @DynamoDBHashKey(attributeName = \"payment_attempt_external_id\")","+    private String paymentAttemptExternalId;","+","+    @DynamoDBRangeKey","+    @DynamoDBAttribute(attributeName = \"workflow_step\")","+    private WorkflowStep workflowStep;","+","+    @Builder.Default","+    private long ttl = LocalDateTime.now().plusDays(1).toEpochSecond(ZoneOffset.UTC);","+}","+```","+","+### DynamoDB Tables","+| Table | Partition Key | Sort Key | Purpose |","+|-------|---------------|----------|---------|","+| darwin_payment_attempt_workflow_context | payment_attempt_external_id | workflow_step | Workflow state |","+| darwin_payment_attempt_native_otp_detail | payment_attempt_external_id | - | OTP auth details |","+| darwin_payment_attempt_redirection_detail | payment_attempt_external_id | - | 3DS redirects |","+| darwin_payment_attempt_metadata_audit | payment_attempt_external_id | - | Audit trail |","+","+---","+","+## 22. OPTIMISTIC LOCKING & AUDIT","+","+### @Version for Optimistic Locking","+```java","+@Version","+@Column(name = \"version\")","+private Integer version;  // Auto-incremented on each update","+```","+","+Prevents concurrent modification - throws `OptimisticLockException` on conflict.","+","+### Audit Columns (Auto-Managed)","+```java","+@CreationTimestamp","+@Column(name = \"created_at\")","+private LocalDateTime createAt;","+","+@UpdateTimestamp","+@Column(name = \"updated_at\")","+private LocalDateTime updatedAt;","+","+@PrePersist","+public void onCreate() {","+    createdBy = ApplicationContext.getApplicationName();","+}","+","+@PreUpdate","+public void onUpdate() {","+    updatedBy = ApplicationContext.getApplicationName();","+}","+```","+","+---","+","+## 23. DATA LAYER ARCHITECTURE DIAGRAM","+","+```","+┌─────────────────────────────────────────────────────────┐","+│                    Service Layer                        │","+├─────────────────────────────────────────────────────────┤","+│ JPA Repositories      │ Custom DAOs      │ DynamoDB DAOs │","+├─────────────────────────────────────────────────────────┤","+│     Spring Data JPA + Hibernate ORM                     │","+├──────────────────────┬──────────────────────────────────┤","+│   Master DataSource  │      Replica DataSource          │","+│   (Writes)           │      (Reads - @ReplicaRepository)│","+├──────────────────────┼──────────────────────────────────┤","+│ HikariCP Master Pool │   HikariCP Replica Pool          │","+├──────────────────────┴──────────────────────────────────┤","+│         MySQL (payments_multi_tenancy)                  │","+└─────────────────────────────────────────────────────────┘","+         │                              │","+┌────────▼────────┐          ┌──────────▼─────────┐","+│    DynamoDB     │          │  Caffeine Caches   │","+│ (Workflow/Audit)│          │  (Client/Provider) │","+└─────────────────┘          └────────────────────┘","+```","+","+---","+","+## 24. KEY DATA LAYER FILES TO STUDY","+","+### Entity Classes (Priority)","+1. `entity/commons/BaseEntity.java` - Base class pattern","+2. `entity/provider/BaseExternalEntity.java` - External ID + versioning","+3. `entity/OrderEntity.java` - Main order entity","+4. `entity/v2/PaymentAttemptV2Entity.java` - Payment attempt (most complex)","+","+### Database Configuration","+1. `configuration/database/MasterDataSourceConfiguration.java`","+2. `configuration/database/ReplicaDataSourceConfiguration.java`","+3. `configuration/database/annotation/ReplicaRepository.java`","+","+### Repositories","+1. `repository/OrderRepository.java` - FETCH JOIN examples","+2. `repository/PaymentAttemptRepository.java` - Complex queries","+","+### Caches","+1. `cache/ClientConfigurationCache.java` - Cache pattern example","+2. `configuration/CacheConfig.java` - Cache configuration","+","+### DynamoDB","+1. `dynamo/dao/AbstractDynamoDBDAO.java` - Base DAO pattern","+2. `dynamo/domain/PaymentAttemptWorkflowContextEntity.java` - DynamoDB entity"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"94c49606-b151-47d1-9a33-1124126f8c2c","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_0182bk82cfQW4EK517kTe8Ya","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"I've updated the plan file with the comprehensive Data Layer deep-dive. Now let me provide a summary to the user and ask if they want to continue exploring other areas or if this study guide is complete.","signature":"EvYCCkgICxABGAIqQMbUSaEE7R9XuAchBdexds3TuUNdJWQjGzWbYttHbLR1E+Qy/Um1/yamMY4f0BWxcn1LAW7zlcFee/UkA92GhPQSDEsLV4en5ZXeLLZLdxoM238CYDOLyS793i6wIjCuWnfkcoVQjgzbkGJQI4tXenNdAgfEj8d2xxVrLU1hnJ7Yx3SE/p6PiPFfMu2ovVcq2wGiGUe4b3fb1v/Fp9td892f9Y3ac8h3Gx4cybo30CUs59WdGxx9L9HQopJjD2AkryvMZhWkR1Rh1hFoJ+SV85SSwm6ONUWqM00kSy+3WhmqkO4sadxon+8wR6NF5ItkxTCIwTLaZGs9HjQgrJ26uHTeU7S+11SInLbV3h25hZyYST8ckzhk76aCmEjpYFqsdN4rusHmrJSrUjY4i1DJmfnw4boeMU1BzWrMe+ZxGagnRmZAd/Xw/YBk2nj1pJdY6FUozL7z8O74bjd2RW78I1mOHQ7GcQmgwqujPBIYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":8514,"cache_read_input_tokens":58441,"cache_creation":{"ephemeral_5m_input_tokens":8514,"ephemeral_1h_input_tokens":0},"output_tokens":1}},"type":"assistant","uuid":"8377cff2-35ea-4728-8df7-794d888929cc","timestamp":"2025-12-31T09:35:53.656Z"}
{"parentUuid":"8377cff2-35ea-4728-8df7-794d888929cc","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_0182bk82cfQW4EK517kTe8Ya","type":"message","role":"assistant","content":[{"type":"text","text":"I've added a comprehensive Data Layer deep-dive to your study guide. Here's a summary of what you now have:\n\n## Data Layer Deep-Dive Summary\n\n### Key Architectural Patterns\n\n| Pattern | Implementation |\n|---------|----------------|\n| **Entity Hierarchy** | `BaseEntity` → `BaseExternalEntity` (adds UUID + optimistic locking) |\n| **Master-Replica** | `@ReplicaRepository` annotation routes reads to replica DB |\n| **Connection Pooling** | Separate HikariCP pools for master (writes) & replica (reads) |\n| **JSON Flexibility** | Custom Hibernate converters store complex objects in JSON columns |\n| **Caching** | Caffeine in-memory caches with jittered TTLs (10-180 min) |\n| **Workflow State** | DynamoDB for TTL-based temporary data (OTP, redirects, audit) |\n| **Optimistic Locking** | `@Version` column prevents concurrent modification conflicts |\n\n### Critical Files to Study First\n1. `entity/commons/BaseEntity.java` - Understand the base pattern\n2. `configuration/database/MasterDataSourceConfiguration.java` - Master routing\n3. `repository/OrderRepository.java` - FETCH JOIN query examples\n4. `cache/ClientConfigurationCache.java` - Caching pattern\n5. `dynamo/dao/AbstractDynamoDBDAO.java` - DynamoDB pattern\n\nYour study guide is now at `/Users/kiranbiliyawala/.claude/plans/distributed-marinating-mango.md` with 24 sections covering the entire codebase."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":8514,"cache_read_input_tokens":58441,"cache_creation":{"ephemeral_5m_input_tokens":8514,"ephemeral_1h_input_tokens":0},"output_tokens":1}},"type":"assistant","uuid":"023f5c4f-63c5-4981-a0e4-3a3c02820cfc","timestamp":"2025-12-31T09:36:04.267Z"}
{"parentUuid":"023f5c4f-63c5-4981-a0e4-3a3c02820cfc","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_0182bk82cfQW4EK517kTe8Ya","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_bdrk_01SN6A6NCjDP2XLNPHMRmWHv","name":"AskUserQuestion","input":{"questions":[{"question":"Would you like to continue with another deep-dive area, or is this study guide complete for now?","header":"Next Step","options":[{"label":"Payment Flow","description":"Deep-dive into PaymentAttemptCreateWorkflow, provider adapters, and end-to-end processing"},{"label":"Provider Integration","description":"Study how provider adapters work, webhook handling, and decision tree routing"},{"label":"Complete Guide","description":"The study guide is comprehensive enough - I'll start studying and come back with questions"}],"multiSelect":false}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":8514,"cache_read_input_tokens":58441,"cache_creation":{"ephemeral_5m_input_tokens":8514,"ephemeral_1h_input_tokens":0},"output_tokens":620}},"type":"assistant","uuid":"4335eab9-a3e6-40ae-b41d-11213d9607f7","timestamp":"2025-12-31T09:36:04.478Z"}
{"parentUuid":"4335eab9-a3e6-40ae-b41d-11213d9607f7","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"User has answered your questions: \"Would you like to continue with another deep-dive area, or is this study guide complete for now?\"=\"Provider Integration\". You can now continue with the user's answers in mind.","tool_use_id":"toolu_bdrk_01SN6A6NCjDP2XLNPHMRmWHv"}]},"uuid":"5d620b73-8ec9-4515-85be-8c300a7c8371","timestamp":"2025-12-31T09:45:04.666Z","toolUseResult":{"questions":[{"question":"Would you like to continue with another deep-dive area, or is this study guide complete for now?","header":"Next Step","options":[{"label":"Payment Flow","description":"Deep-dive into PaymentAttemptCreateWorkflow, provider adapters, and end-to-end processing"},{"label":"Provider Integration","description":"Study how provider adapters work, webhook handling, and decision tree routing"},{"label":"Complete Guide","description":"The study guide is comprehensive enough - I'll start studying and come back with questions"}],"multiSelect":false}],"answers":{"Would you like to continue with another deep-dive area, or is this study guide complete for now?":"Provider Integration"}}}
{"parentUuid":"5d620b73-8ec9-4515-85be-8c300a7c8371","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_012SnUPQrQURSPxgz8YBVh84","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user wants to deep-dive into Provider Integration. Let me launch an exploration agent to provide a comprehensive analysis of provider adapters, webhook handling, and decision tree routing.","signature":"EusCCkgICxABGAIqQCDs6VcKvy/lSa+gdWrHFPjIRi+39I6BVKGC4sU/7+gmysCxs+YybuMNuq/lcCJUm3J3llIPw0Ni6LmGuFW+kVwSDLgXIX0GES+lT44HUxoMfXvNkR0pyUGCACLbIjDS1tkFiWXckRL/mr2rtHXJCHCkx//3hFpSm8O9z0iRdxOJRJh7QavIjgz2SPjtJ8cq0AF3lodfYZ0M0nbW3fAdLj2609ORJw5Rh793fsFbMW7P9iBOJBLtdRP9JhqQhx94nQ21DCeXVhopDGk4Rb5H5edD62TXmiiD3uj3bTDSqRI8dORCHbutkrSQEUIYFPXra/9OYcciYQkTwA8IM22Gq1Y6BlJB5zchy9MM6UIor/Uw1uDn4UZwTmZxoJOR14Xdklv4Q8sqnU+LNSE59bFm5LVRoCzOPMIfn/IYgT/UlVeVj0zFE07cvXxI6k2Ioz7U0+3r3H/buE4J3pZLv48Hq6g8GAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":67637,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":67637,"ephemeral_1h_input_tokens":0},"output_tokens":1}},"type":"assistant","uuid":"1df5316e-5d20-4f36-86b4-d9dd0a72a49f","timestamp":"2025-12-31T09:45:13.051Z"}
{"parentUuid":"1df5316e-5d20-4f36-86b4-d9dd0a72a49f","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_012SnUPQrQURSPxgz8YBVh84","type":"message","role":"assistant","content":[{"type":"text","text":"Let me provide a deep-dive into Provider Integration - adapters, webhooks, and decision tree routing."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":67637,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":67637,"ephemeral_1h_input_tokens":0},"output_tokens":1}},"type":"assistant","uuid":"5f70691d-5dce-417b-b47f-399813af3362","timestamp":"2025-12-31T09:45:13.604Z"}
{"parentUuid":"5f70691d-5dce-417b-b47f-399813af3362","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_012SnUPQrQURSPxgz8YBVh84","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_bdrk_01Lu3TrAzKEnmfywW5wg3Wt2","name":"Task","input":{"description":"Deep-dive provider integration","prompt":"Provide an extremely detailed analysis of the payment-service Provider Integration architecture for expert study. Cover:\n\n1. **Provider Adapter Architecture:**\n   - Base adapter interface and abstract class patterns\n   - How adapters are registered and selected (factory pattern)\n   - Common adapter methods (create payment, capture, refund, status check)\n   - Request/Response transformation patterns\n   - Study 2-3 specific adapter implementations in detail (Cybersource, Cashfree, etc.)\n\n2. **Decision Tree Routing:**\n   - How decision trees work for provider selection\n   - DecisionTreeWorkflow and ProviderDeciderRouter implementation\n   - Decision tree JSON structure and caching\n   - LCM (Lending Cloud Manager) integration for routing\n   - How provider priority and fallback work\n\n3. **Webhook Handling:**\n   - WebhookController structure and endpoint handling\n   - How webhooks are routed to specific provider handlers\n   - Signature verification and authentication\n   - Webhook payload processing and state updates\n   - Idempotency handling for duplicate webhooks\n\n4. **Provider Configuration:**\n   - ProviderAccountEntity and PaymentProviderEntity setup\n   - Client-Provider configuration mapping\n   - Provider credentials management (AccessToken, endpoints)\n   - Provider-specific settings and feature flags\n\n5. **Error Handling:**\n   - Provider-specific error code mapping\n   - Retry logic and failure handling\n   - ProviderException and error response transformation\n\nProvide specific file paths, code examples, and architectural insights. This is for expert-level understanding.","subagent_type":"Explore"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":67637,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":67637,"ephemeral_1h_input_tokens":0},"output_tokens":509}},"type":"assistant","uuid":"a19e606a-bea8-4a67-b2a5-e8a2f9b3a8a9","timestamp":"2025-12-31T09:45:22.346Z"}
{"parentUuid":"a19e606a-bea8-4a67-b2a5-e8a2f9b3a8a9","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01Lu3TrAzKEnmfywW5wg3Wt2","type":"tool_result","content":[{"type":"text","text":"Now I have sufficient information to provide the comprehensive analysis. Let me compile it:\n\n## EXTREMELY DETAILED PAYMENT-SERVICE PROVIDER INTEGRATION ARCHITECTURE ANALYSIS\n\nBased on my thorough exploration of the codebase, here's an expert-level architectural analysis:\n\n---\n\n## 1. PROVIDER ADAPTER ARCHITECTURE\n\n### Base Adapter Interface and Abstract Class Patterns\n\n**File Path:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/providers/IPaymentProviderAdapter.java`\n\nThe architecture implements a sophisticated generic adapter pattern:\n\n```java\npublic abstract class IPaymentProviderAdapter<T, R> implements SelfReferencingBean {\n    protected IPaymentProviderAdapter<T, R> selfProxy;\n    protected final PaymentProviderKey paymentProviderKey;\n    private final InstrumentType instrumentType;\n    private final OrderType orderType;\n    \n    public IPaymentProviderAdapter(\n            PaymentProviderKey paymentProviderKey, \n            InstrumentType instrumentType, \n            OrderType orderType) {\n        // Initialization\n    }\n}\n```\n\n**Key Design Elements:**\n- **Generic Parameters:** `<T, R>` where T is the request type and R is the auth configuration type\n- **Self-Proxying:** Implements `SelfReferencingBean` to enable transactional proxying for methods like `@Transactional`\n- **Auto-Registration:** Uses `@PostConstruct` to register adapters with `PaymentProviderFactory` during bean initialization\n- **Lazy Loading:** Uses `ProviderAccountCache` to defer credential loading until needed\n\n### Adapter Registration and Factory Pattern\n\n**File Path:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/providers/PaymentProviderFactory.java`\n\nThe factory uses multi-dimensional lookup tables:\n\n```java\n@Component\npublic class PaymentProviderFactory {\n    // Primary map: OrderType + ProviderKey + InstrumentType → Adapter\n    private final Map<PaymentWorkflowKey, IPaymentProviderAdapter<?, ?>> paymentProviderMap;\n    \n    // Secondary map: OrderType + ProviderKey → First matching adapter\n    private final Table<OrderType, PaymentProviderKey, IPaymentProviderAdapter<?, ?>> \n            paymentProviderByKey;\n    \n    // 3DS adapter registry with versioning support\n    private ThreeDSType threeDSType (for 3DS1 vs 3DS2 variants)\n    \n    // Push payment adapters (webhooks from providers)\n    private Map<PaymentWorkflowKey, IPushPaymentProviderAdapter<?, ?>> \n            pushPaymentProviderAdapterMap;\n    \n    // eMandate fetch adapters\n    private Map<PaymentWorkflowKey, EMandateFetchProviderAdapter<?, ?>> \n            mandateProviderMap;\n}\n```\n\n**Lookup Resolution:**\n- Uses Guava's `HashBasedTable` for O(1) lookups by (OrderType, ProviderKey)\n- Supports variant resolution (3DS1 vs 3DS2) via `ThreeDSType` enum\n- Auto-detects adapter capabilities and registers in appropriate maps\n\n### Common Adapter Methods\n\nThe base adapter defines the lifecycle for payment attempts:\n\n```java\n// 1. Create payment flow\npublic abstract ProviderPaymentResponse createPaymentAttempt(\n    PaymentAttemptCreateContext context, \n    @Nullable ProviderCustomerEntity providerCustomerEntity);\n\n// 2. Synchronization flows\nprotected abstract Object syncPaymentAttemptWithProviderId(PaymentAttemptV2Entity);\nprotected Optional<Object> syncPaymentAttemptWithExternalId(PaymentAttemptV2Entity);\npublic void syncPaymentAttemptWithWebhook(PaymentAttemptV2Entity, Object webhook);\npublic void syncPaymentAttemptWithSerializedWebhook(PaymentAttemptV2Entity, String webhook);\n\n// 3. Refund flows\nprotected abstract ProviderRefundCreateResponse createRefund(\n    RefundAttemptEntity, \n    Map<RefundChannel, Object> additionalContext);\nprotected abstract Object syncRefund(RefundAttemptEntity);\npublic void syncRefundAttemptWithWebhook(RefundAttemptEntity, Object webhook);\n\n// 4. Utility methods\nprotected abstract R getAuthConfig(ProviderAccountEntity);\npublic abstract String createProviderCustomer(CustomerEntity, ProviderAccountEntity);\n```\n\n### Request/Response Transformation Patterns\n\n**Response Structure:**\n```java\n@Data\n@Builder\npublic class ProviderPaymentResponse {\n    private final Object providerResponseObject;           // Raw provider response\n    private String providerReferenceId;                   // Provider's transaction ID\n    private String gatewayReferenceId;                   // Gateway ID (if applicable)\n    private String providerStatus;                       // Raw provider status (e.g., \"SUCCESS\")\n    private PaymentAttemptStatus status;                // Mapped internal status\n    @Builder.Default\n    private ProviderRequestStatus providerRequestStatus = \n            ProviderRequestStatus.REQUEST_SUCCESS;       // Retry/failure classification\n    private ProviderError providerError;                // Error details\n    private PaymentAuthenticationDetails transactionResponse;\n    private String authCode;\n    private AuthTokenDetails authTokenDetails;\n}\n\n@Data\n@Builder\npublic class ProviderError {\n    private String message;\n    private String code;                                 // Provider error code\n    private Object providerResponse;                    // Raw error response\n    private Boolean retryable;                          // Retry classification\n}\n```\n\n### 2-3 Specific Adapter Implementations\n\n#### **1. CASHFREE ADAPTER** (File: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/providers/CashfreeProviderAdapter.java`)\n\n**Provider Architecture:**\n```java\n@Slf4j\n@Component\npublic abstract class CashfreeProviderAdapter \n        extends IPaymentProviderAdapter<String, CashfreeAuthConfig> {\n    \n    @Getter\n    private CashfreeClient cashfreeClient;\n    \n    @Getter\n    private ProviderAccountManager providerAccountManager;\n    \n    public CashfreeProviderAdapter(InstrumentType instrumentType) {\n        super(PaymentProviderKey.CASHFREE, instrumentType, OrderType.PAY);\n    }\n}\n```\n\n**Create Payment Flow (Two-Phase):**\n1. **Order Creation Phase:**\n   ```java\n   private Pair<BaseResponse<CreateOrderResponse>, ProviderError> createCFOrder(\n           PaymentAttemptCreateContext context, CashfreeAuthConfig authConfig) {\n       CreateOrderRequest createOrderRequest = getCreateOrderRequest(context);\n       BaseResponse<CreateOrderResponse> baseResponse = \n           cashfreeClient.createOrder(createOrderRequest, authConfig);\n       return Pair.of(baseResponse, evaluateAndReturnErrorIfAny(baseResponse).orElse(null));\n   }\n   ```\n\n2. **Payment Creation Phase:**\n   ```java\n   private Pair<BaseResponse<CreatePaymentResponse>, ProviderError> createCFPayment(\n           PaymentAttemptCreateContext context,\n           CreateOrderResponse createOrderResponse,\n           CashfreeAuthConfig authConfig) {\n       CreatePaymentRequest createPaymentRequest = \n           getCreatePaymentRequest(context, createOrderResponse);\n       BaseResponse<CreatePaymentResponse> baseResponse =\n           cashfreeClient.createPayment(createPaymentRequest, authConfig);\n       return Pair.of(baseResponse, evaluateAndReturnErrorIfAny(baseResponse).orElse(null));\n   }\n   ```\n\n**Status Synchronization:**\n```java\nprotected Object syncPaymentAttemptWithProviderId(PaymentAttemptV2Entity paymentAttemptEntity) {\n    CashfreeAuthConfig authConfig = getAuthConfigWrapper(paymentAttemptEntity.getProviderAccountEntity());\n    \n    BaseResponse<GetPaymentResponse> baseResponse = cashfreeClient.getPayment(\n        paymentAttemptEntity.getExternalId(), \n        paymentAttemptEntity.getProviderReferenceId(), \n        authConfig);\n    \n    GetPaymentResponse response = baseResponse.getResponse();\n    \n    // Validate amount consistency\n    if (paymentAttemptEntity.getAmount().compareTo(response.getPaymentAmount()) != 0) {\n        throw Error.internal_server_error.getBuilder()\n            .message(\"Payment amount and provider amount not matching\").build();\n    }\n    \n    // Map provider status to internal status\n    PaymentAttemptStatus internalStatus = fromProviderStatus(response.getPaymentStatus());\n    paymentAttemptEntity.setStatus(internalStatus);\n    paymentAttemptEntity.setProviderStatus(response.getPaymentStatus().name());\n    \n    return response;\n}\n```\n\n**Refund Creation:**\n```java\nprotected ProviderRefundCreateResponse createRefund(\n        RefundAttemptEntity refundAttemptEntity, \n        Map<RefundChannel, Object> additionalContext) {\n    \n    CashfreeAuthConfig authConfig = getAuthConfigWrapper(\n        refundAttemptEntity.getPaymentAttempt().getProviderAccountEntity());\n    \n    CreateRefundRequest createRefundRequest = CreateRefundRequest.builder()\n        .refundId(refundAttemptEntity.getExternalId())\n        .refundAmount(CommonUtils.setScale(refundAttemptEntity.getRefund().getRefundValue()))\n        .build();\n    \n    BaseResponse<CreateRefundResponse> baseResponse = cashfreeClient.createRefund(\n        refundAttemptEntity.getPaymentAttempt().getExternalId(), \n        createRefundRequest, \n        authConfig);\n    \n    return mapRefundResponseToProviderResponseEntity(baseResponse.getResponse());\n}\n```\n\n#### **2. CYBERSOURCE ADAPTER** (File: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/providers/cybersource/CybersourceProviderAdapter.java`)\n\n**3DS Support Architecture:**\n```java\n@Slf4j\n@Component\npublic abstract class CybersourceProviderAdapter \n        extends I3DSPaymentProviderAdapter<String, AuthConfig> {\n    \n    private static final List<String> FAILED_STATUES = Arrays.asList(\n        \"101\", \"102\", \"104\", \"150\", \"151\", \"152\", \"200\", \"201\", ... // 43 failure codes\n    );\n    \n    private static final List<String> PROCESSING_STATUSES = \n        Arrays.asList(\"110\", \"475\", \"480\");\n    \n    // State transition validation map\n    private static Map<PaymentAttemptStatus, List<PaymentAttemptStatus>> \n            invalidTransitionMap = new HashMap<>();\n    {\n        put(PaymentAttemptStatus.COMPLETED, Collections.emptyList());\n        put(PaymentAttemptStatus.AUTHORIZED, \n            Collections.singletonList(PaymentAttemptStatus.COMPLETED));\n        put(PaymentAttemptStatus.AUTHENTICATION_SUCCESSFUL,\n            Arrays.asList(...));  // Multiple invalid transitions\n    }\n}\n```\n\n**3DS Redirection Flow (3DS2):**\n```java\nprotected void createRedirectionHtml(\n        BaseResponse<CybersourceResponse> baseResponse, \n        PaymentAttemptV2Entity paymentAttemptV2Entity) {\n    \n    ConsumerAuthenticationInformation authInfo = \n        baseResponse.getResponse().getConsumerAuthenticationInformation();\n    \n    // Check 3DS version\n    if (authInfo.getSpecificationVersion().startsWith(\"2\")) {\n        // 3DS2 flow\n        Optional<CybersourceProviderAccountConfiguration> config =\n            providerAccountManager.getCybersourceProviderAccountConfiguration(\n                paymentAttemptV2Entity.getProviderAccountEntity());\n        \n        if (config.isPresent() && config.get().getEnableRedirectionFlow()) {\n            // Darwin proxy redirection (platform handles ACS communication)\n            html = authenticationService.createAuthenticationPageFor3ds2WithoutIframe(\n                authInfo.getAcsUrl(),\n                authInfo.getPareq(),\n                authInfo.getThreeDSServerTransactionId());\n        } else {\n            // Direct iframe redirection (iFrame loads ACS endpoint)\n            html = authenticationService.createAuthenticationPageFor3ds2(\n                authInfo.getStepUpUrl(),\n                authInfo.getAccessToken(),\n                paymentAttemptV2Entity.getExternalId());\n        }\n    } else {\n        // 3DS1 flow (deprecated)\n        html = authenticationService.createAuthenticationPageHTML(...);\n    }\n}\n```\n\n**Request Builder Pattern (Strategy Pattern):**\n```java\n// Abstract builder for all request types\npublic abstract class CybersourceRequestBuilder {\n    protected abstract CybersourceRequestType cybersourceRequestType();\n    public abstract ConsumerAuthenticationInformation consumerAuthenticationInformation(\n        CybersourceRequestContext context);\n    public abstract ProcessingInformation processingInformation(\n        CybersourceRequestContext context);\n    public abstract MerchantInformation merchantInformation(\n        CybersourceRequestContext context);\n}\n\n// Specific builder for authorization\n@Component\npublic class CybersourceAuthorizeRequestBuilder extends CybersourceRequestBuilder {\n    @Override\n    public ProcessingInformation processingInformation(CybersourceRequestContext context) {\n        return ProcessingInformation.builder()\n            .capture(context.getPaymentAttemptAuthorizeContext().isCapture())\n            .commerceIndicator(\n                CybersourceProviderAdapter.commerceIndicator(\n                    context.getCardDetails().getBrand()))\n            .build();\n    }\n}\n```\n\n---\n\n## 2. DECISION TREE ROUTING\n\n**File Path:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/planner/providerdecider/`\n\n### Router Strategy Pattern\n\n```java\n@Slf4j\n@Service\n@RequiredArgsConstructor(onConstructor_ = {@Autowired})\npublic class ProviderDeciderRouter {\n    \n    private final ProviderDeciderV2 providerDeciderV2;           // Decision tree strategy\n    private final ProviderDeciderViaLCM providerDeciderViaLCM;   // LCM strategy\n    private final ClientConfigurationManager configManager;\n    \n    public ProviderRoutingDecisionResult resolve(PaymentAttemptCreateContext context) {\n        // Priority 1: LCM routing for supported instruments\n        if (isInstrumentTypeSupportedInLCM(\n                context.getOrderEntity().getClientEntity().getId(),\n                context.getRequest().getPaymentInstrument().getType())) {\n            return providerDeciderViaLCM.decideProvider(context);\n        }\n        \n        // Priority 2: Decision tree routing\n        Boolean isDecisionTreeEnabled = \n            clientConfigurationManager.getConfigurationAsBooleanWithDefaultOnError(\n                context.getOrderEntity().getClientEntity().getId(), \n                ClientSettingKey.DECISION_TREE_ENABLED);\n        \n        if (isDecisionTreeEnabled) {\n            return providerDeciderV2.decideProvider(context);\n        }\n        \n        throw Error.invalid_decision_tree.getBuilder()\n            .message(\"Neither decision tree nor LCM enabled\").build();\n    }\n}\n```\n\n### DecisionTreeWorkflow Implementation\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/service/decision_tree/workflow/provider_account/ProviderAccountDTWorkflow.java`\n\n```java\n@Component\n@RequiredArgsConstructor(onConstructor_ = {@Autowired})\n@Slf4j\npublic class ProviderDeciderV2 {\n    private final DecisionTreeObjectCache decisionTreeObjectCache;\n    private final ProviderAccountCache providerAccountCache;\n    private final ProviderAccountDTContextCreatorFactory contextCreatorFactory;\n    private final NaradService naradService;  // Dynamic routing integration\n    \n    public ProviderRoutingDecisionResult decideProvider(PaymentAttemptCreateContext context) {\n        // 1. Fetch cached decision tree\n        Pair<DecisionTreeWorkflow, DecisionTreeEntity> cachedDT = \n            decisionTreeObjectCache\n                .getProviderDeciderDecisionTreeWorkflow(clientEntity.getName())\n                .orElseThrow(() -> Error.decision_tree_not_found.getBuilder().build());\n        \n        // 2. Create context for decision tree evaluation\n        ProviderAccountDTWorkflowContext dtWorkflowContext = \n            contextCreatorFactory.getContext(context);\n        \n        // 3. Execute decision tree (returns list of matching providers)\n        ProviderAccountDTResponse response =\n            (ProviderAccountDTResponse) cachedDT.getLeft().execute(dtWorkflowContext);\n        \n        // 4. Apply dynamic routing (provider priority, load balancing)\n        if (CollectionUtils.isNotEmpty(response.getProviderAccounts())) {\n            try {\n                DRDetails drResponse = naradService.processForDynamicRouting(\n                    context, \n                    response.getProviderAccounts());\n                providerAccount = drResponse.getProviderDetails();\n                providerAccountEntity = drResponse.getProviderAccountEntity();\n            } catch (Exception e) {\n                // Fallback to first provider\n                providerAccount = response.getProviderAccounts().get(0);\n            }\n        }\n        \n        return ProviderRoutingDecisionResult.builder()\n            .authType(providerAccount.getAuthType())\n            .browser(providerAccount.getBrowser())\n            .decisionTreeId(cachedDT.getRight().getId())\n            .evaluatedByDecisionTree(true)\n            .authSdk(providerAccount.getAuthSDK())\n            .providerAccountEntity(providerAccountEntity)\n            .cardPaymentMode(CardUtils.getCardPaymentModeForAttempt(\n                context, providerAccount.getCardPaymentMode()))\n            .isPlatformOtpEnabled(providerAccount.getIsPlatformOtpEnabled())\n            .allProviderAccounts(sanitizeProviderDetails(response.getProviderAccounts()))\n            .isDynamicRoutingSkipped(isDRSkipped)\n            .build();\n    }\n}\n```\n\n### Decision Tree JSON Structure and Caching\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/cache/DecisionTreeObjectCache.java`\n\n```java\n@Component\n@RequiredArgsConstructor(onConstructor_ = {@Autowired})\npublic class DecisionTreeObjectCache extends AbstractDPManagedCache {\n    private final DecisionTreeService decisionTreeService;\n    private final CacheConfig cacheConfig;\n    \n    @DPCache(cacheName = Constant.CacheName.DECISION_TREE_OBJECT_CACHE)\n    private LoadingCache<String, Pair<DecisionTreeWorkflow, DecisionTreeEntity>> cache;\n    \n    @Override\n    public void buildCache() {\n        // Caffeine cache with TTL refresh\n        cache = DPCacheBuilder.getBuilder()\n            .refreshAfterWrite(\n                cacheConfig.getDecisionTreeObjectCacheConfig(),  // e.g., 24 hours\n                cacheConfig.getDecisionTreeObjectCacheTTLType())\n            .build(key -> decisionTreeService.getProviderDeciderDecisionTreeWorkflow(key));\n    }\n    \n    public Optional<Pair<DecisionTreeWorkflow, DecisionTreeEntity>> \n            getProviderDeciderDecisionTreeWorkflow(String clientName) {\n        try {\n            return Optional.ofNullable(cache.get(clientName));\n        } catch (Exception e) {\n            log.error(\"Error fetching decision tree for client: {}\", clientName);\n            return Optional.empty();\n        }\n    }\n}\n```\n\n**Decision Tree Entity:**\n```java\n@Entity\n@Table(name = \"decision_trees\")\npublic class DecisionTreeEntity extends BaseEntity {\n    @Column(name = \"name\")\n    private String name;\n    \n    @Column(name = \"client_id\")\n    private Long clientId;\n    \n    @Column(name = \"state\")\n    @Enumerated(EnumType.STRING)\n    private DecisionTreeState state;  // DRAFT, ACTIVE, INACTIVE\n    \n    @Column(name = \"type\")\n    @Enumerated(EnumType.STRING)\n    private DecisionTreeType type;  // PROVIDER_DECIDER\n    \n    @Column(name = \"configuration\", columnDefinition = \"TEXT\")\n    @Type(type = \"text\")\n    private String configuration;  // JSON structure with nodes/edges\n}\n```\n\n### LCM Integration\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/planner/providerdecider/ProviderDeciderViaLCM.java`\n\n```java\n@Component\n@RequiredArgsConstructor(onConstructor_ = {@Autowired})\npublic class ProviderDeciderViaLCM {\n    private final LCMClient lcmClient;\n    private final ProviderAccountCache providerAccountCache;\n    private final NetBankingProviderConfigCache netBankingProviderConfigCache;\n    \n    public ProviderRoutingDecisionResult decideProvider(PaymentAttemptCreateContext context) {\n        // 1. Convert context to LCM request\n        PaymentMethodsResolveTerminalRequest lcmRequest = \n            convertPaymentAttemptContextToLCMRequest(context);\n        \n        // 2. Call LCM service for terminal resolution\n        Optional<PaymentMethodsResolveTerminalResponse> lcmResponse = \n            lcmClient.resolve(\n                context.getOrderEntity().getClientEntity().getMerchantId(),\n                context.getOrderEntity().getClientEntity().getName(),\n                lcmRequest);\n        \n        // 3. Convert LCM response to routing decision\n        return convertLCMResponseToProviderRoutingDecisionResult(context, lcmResponse.get());\n    }\n    \n    private PaymentMethodRequest getPaymentMethodRequest(PaymentAttemptCreateContext context) {\n        EnrichedPaymentInstrument enrichedPaymentInstrument =\n            context.getInstrumentProcessorResult().getEnrichedPaymentInstrument();\n        \n        return switch (enrichedPaymentInstrument.getType()) {\n            case CARD -> getCardPaymentMethodRequest(\n                (CardEnrichedPaymentInstrument) enrichedPaymentInstrument);\n            case UPI_CRED, UPI_APPS, UPI_COLLECT -> getUpiPaymentMethodRequest(...);\n            case NET_BANKING -> getNetBankingPaymentMethodRequest(...);\n            case CRED_BNPL, LAZY_PAY -> getBnplPaymentMethodRequest(...);\n            case CRED_WALLET, CRED_PPI -> getWalletPaymentMethodRequest(...);\n            case NET_BANKING_WITH_PI -> getEMandatePaymentMethodRequest(...);\n            default -> null;\n        };\n    }\n}\n```\n\n### Provider Priority and Fallback\n\n```java\npublic ProviderRoutingDecisionResult resolve(PaymentAttemptCreateContext context) {\n    try {\n        // Primary routing strategy\n        return providerDeciderViaLCM.decideProvider(context);\n    } catch (Exception lcmError) {\n        log.error(\"LCM routing failed, falling back to decision tree\", lcmError);\n        \n        // Fallback strategy\n        return providerDeciderV2.decideProvider(context);\n    }\n}\n```\n\n---\n\n## 3. WEBHOOK HANDLING\n\n**File Paths:**\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/controller/WebhookController.java`\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/controller/v2/CashfreeWebhookController.java`\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/service/WebhookService.java`\n\n### WebhookController Structure\n\n```java\n@Slf4j\n@RestController\n@RequestMapping(\"/v1/webhooks\")\n@RequiredArgsConstructor(onConstructor_ = {@Autowired})\npublic class WebhookController {\n    \n    private final WebhookService webhookService;\n    \n    @SkipContextBuild  // Skip ApplicationContext building (no client context)\n    @PostMapping\n    public Order processWebhook(@RequestBody @Valid WebhookRequest webhookRequest) {\n        return webhookService.processWebhook(webhookRequest);\n    }\n}\n```\n\n### Provider-Specific Webhook Controllers\n\n**Cashfree Webhook:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/controller/v2/CashfreeWebhookController.java`\n\n```java\n@Slf4j\n@RestController\n@SkipContextBuild\n@RequestMapping(\"/webhooks/v2/cashfree\")\n@RequiredArgsConstructor(onConstructor_ = {@Autowired})\npublic class CashfreeWebhookController {\n    \n    private final PaymentAttemptFetchWorkflow paymentAttemptFetchWorkflow;\n    private final RefundAttemptFetchWorkflow refundAttemptFetchWorkflow;\n    private final PaymentProviderEntityAuditService auditService;\n    \n    @PostMapping\n    public void onWebhookReceive(@RequestBody CashfreeWebhook webhookRequest) {\n        log.info(\"Webhook from Cashfree: {}\", webhookRequest);\n        \n        switch (webhookRequest.getType()) {\n            case PAYMENT_SUCCESS_WEBHOOK:\n            case PAYMENT_FAILED_WEBHOOK:\n            case PAYMENT_USER_DROPPED_WEBHOOK:\n                processPaymentAttempt(webhookRequest, \n                    (CashfreePaymentWebhook) webhookRequest);\n                break;\n            case REFUND_STATUS_WEBHOOK:\n                processRefundAttempt(webhookRequest, \n                    (CashfreeRefundWebhook) webhookRequest);\n                break;\n            default:\n                throw new UnsupportedOperationException(\n                    webhookRequest.getType() + \" not supported\");\n        }\n    }\n    \n    private void processPaymentAttempt(CashfreeWebhook webhookRequest, \n            CashfreePaymentWebhook paymentWebhook) {\n        try {\n            // Extract provider reference ID from webhook\n            String providerReferenceId = String.valueOf(\n                paymentWebhook.getData().getPaymentData().getCfPaymentId());\n            \n            // Fetch payment attempt using provider reference\n            PaymentAttempt attempt = paymentAttemptFetchWorkflow\n                .fetchByProviderReferenceId(providerReferenceId);\n            \n            // Audit provider data for forensics\n            auditService.auditProviderData(\n                webhookRequest,\n                attempt.getId(),\n                PaymentProviderKey.CASHFREE,\n                FlowType.WEB_HOOK,\n                EntityType.PAYMENT_ATTEMPT);\n        } catch (Exception ex) {\n            log.error(\"Error processing payment webhook: {}\", ex.getMessage(), ex);\n        }\n    }\n}\n```\n\n### Webhook Routing Strategy\n\n```java\n// Other webhook controllers for different providers:\n// - /webhooks/v2/razorpay → RazorpayWebhookController\n// - /webhooks/v2/payu → PayuWebhookController\n// - /webhooks/v2/pinelabs → PinelabsWebhookController\n// - /webhooks/v2/digio → DigioWebhookController\n// - /webhooks/v2/ybl → YBLWebhookController\n// - /webhooks/v2/icici → ICICIWebhookController\n// - /webhooks/v2/rbl-upi → RBLUpiWebhookController\n```\n\n### Webhook Payload Processing\n\n```java\n@Service\n@RequiredArgsConstructor(onConstructor_ = {@Autowired})\npublic class WebhookService {\n    \n    private final PushPaymentsOrderService pushPaymentsOrderService;\n    private final OrderEntityNewMapper orderEntityNewMapper;\n    private final PaymentAttemptService paymentAttemptService;\n    \n    public Order processWebhook(WebhookRequest webhook) {\n        // Check if payment attempt already exists\n        Optional<PaymentAttemptV2Entity> existingPaymentAttemptEntity =\n            paymentAttemptService.fetchPaymentAttemptIfPresent(\n                webhook.getFetchDetails());\n        \n        if (existingPaymentAttemptEntity.isPresent()) {\n            // Webhook for existing payment attempt - sync status\n            paymentAttemptService.syncPaymentAttemptWithSerializedWebhook(\n                webhook.getFetchDetails(), \n                webhook.getProviderData());\n            \n            Order order = new Order();\n            orderEntityNewMapper.copyToDomain(\n                existingPaymentAttemptEntity.get().getOrderEntity(), \n                order);\n            return order;\n        } else {\n            // Webhook for new payment (push payments) - create order\n            return pushPaymentsOrderService.processPushPayment(\n                buildPushPaymentRequest(webhook));\n        }\n    }\n}\n```\n\n### Signature Verification and Authentication\n\n**Handled via Provider-Specific Clients** (e.g., in `CashfreeClient`, `RazorpayClientWrapper`)\n\n```java\n// Pattern: Each provider client validates webhook signature\n// Signature validation typically includes:\n// 1. Extract signature from webhook headers\n// 2. Reconstruct payload signature using provider secret\n// 3. Constant-time comparison to prevent timing attacks\n// 4. Throw exception if signature invalid\n```\n\n### Idempotency Handling\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/ProviderAccountEntity.java`\n\n```java\n@Entity\n@Table(name = \"provider_accounts\")\npublic class ProviderAccountEntity extends BaseEntity {\n    \n    @Column(name = \"idempotence_key\")\n    private String idempotenceKey;  // Used for duplicate webhook detection\n    \n    // Idempotency pattern:\n    // 1. When webhook received, extract unique identifier (e.g., transaction ID)\n    // 2. Query for existing payment attempt with this provider reference ID\n    // 3. If found, return cached response instead of re-processing\n    // 4. If not found, process webhook and store result\n}\n```\n\n**In Base Adapter:**\n```java\npublic final void syncPaymentAttemptWithProvider(PaymentAttemptV2Entity paymentAttemptV2Entity) {\n    String currentStatus = paymentAttemptV2Entity.getProviderStatus();\n    \n    // Fetch provider response (either by ID or external ID)\n    Optional<Object> providerResponseExternalId = \n        syncPaymentAttemptWithExternalId(paymentAttemptV2Entity);\n    \n    if (providerResponseExternalId.isPresent()) {\n        providerResponse = providerResponseExternalId.get();\n    } else {\n        // Fetch by provider reference ID\n        providerResponse = syncPaymentAttemptWithProviderId(paymentAttemptV2Entity);\n    }\n    \n    // Only update if status changed (prevents duplicate processing)\n    if (Objects.nonNull(providerResponse) && \n            !Objects.equals(currentStatus, paymentAttemptV2Entity.getProviderStatus())) {\n        providerEntityAuditService.auditProviderData(\n            providerResponse,\n            paymentAttemptV2Entity.getExternalId(),\n            paymentProviderKey,\n            FlowType.STATUS_CHANGE_SYNC,\n            EntityType.PAYMENT_ATTEMPT);\n    }\n}\n```\n\n---\n\n## 4. PROVIDER CONFIGURATION\n\n### ProviderAccountEntity and PaymentProviderEntity Setup\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/ProviderAccountEntity.java`\n\n```java\n@Entity\n@Table(name = \"provider_accounts\")\npublic class ProviderAccountEntity extends BaseEntity {\n    \n    @ManyToOne\n    @JoinColumn(name = \"payment_provider_id\")\n    private PaymentProviderEntity paymentProvider;\n    \n    @Column(name = \"provider_account_id\")\n    private String providerAccountId;  // e.g., \"ACC_123456\"\n    \n    @Column(name = \"idempotence_key\")\n    private String idempotenceKey;\n    \n    @Column(name = \"access_token\")\n    @Lob\n    private byte[] accessToken;  // Encrypted credentials\n    \n    @Column(name = \"provider_account_reference_id\")\n    private String providerAccountReferenceId;  // Unique identifier\n    \n    @Transient\n    private String decryptedAccessToken;  // Decrypted on-demand\n    \n    @Column(name = \"endpoint\")\n    private String endpoint;  // Provider API endpoint\n    \n    @Column(name = \"is_prod\")\n    private Boolean isProd;  // Production vs Sandbox\n    \n    @Column(name = \"active\")\n    @Builder.Default\n    private Boolean active = true;\n    \n    @Column(name = \"additional_config\")\n    private String additionalConfig;  // JSON configuration\n    \n    @Column(name = \"provider_mid\")\n    private String providerMid;  // Merchant ID at provider\n    \n    @Column(name = \"config_decorator\")\n    @Enumerated(EnumType.STRING)\n    private ConfigValueDecoratoryKey decorator;  // Configuration strategy\n    \n    @Column(name = \"settlement_category\")\n    private String settlementCategory;  // Settlement routing\n}\n```\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/PaymentProviderEntity.java`\n\n```java\n@Entity\n@Table(name = \"payment_providers\")\npublic class PaymentProviderEntity extends BaseExternalEntity {\n    \n    @Column(name = \"name\")\n    private String name;  // e.g., \"Cashfree\", \"Cybersource\"\n    \n    @Column(name = \"provider_key\")\n    private String key;  // e.g., \"CASHFREE\", \"CYBERSOURCE\"\n    \n    @Column(name = \"active\")\n    @Builder.Default\n    private Boolean active = true;\n    \n    @Column(name = \"is_customer_required\")\n    @Builder.Default\n    private Boolean customerRequired = false;  // Does provider require customer registration?\n    \n    @OneToMany(cascade = {CascadeType.MERGE, CascadeType.PERSIST})\n    @JoinColumn(name = \"payment_provider_id\")\n    @Builder.Default\n    private Set<PaymentProviderSettingsEntity> settings = new HashSet<>();\n    \n    public void addSettings(PaymentProviderSettingsEntity settingsEntity) {\n        settingsEntity.setPaymentProviderEntity(this);\n        settings.add(settingsEntity);\n    }\n}\n```\n\n### Client-Provider Configuration Mapping\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/ClientPaymentProviderConfigEntity.java`\n\n```java\n@Entity\n@Table(name = \"client_payment_provider_config\")\npublic class ClientPaymentProviderConfigEntity extends BaseEntity {\n    \n    @ManyToOne\n    @JoinColumn(name = \"client_id\")\n    private ClientEntity client;\n    \n    @ManyToOne\n    @JoinColumn(name = \"payment_provider_id\")\n    private PaymentProviderEntity paymentProvider;\n    \n    @Column(name = \"provider_config\")\n    private String providerConfig;  // JSON configuration\n    \n    @Column(name = \"config_decorator\")\n    @Enumerated(EnumType.STRING)\n    private ConfigValueDecoratorKey decorator;  // Which decorator to use\n}\n```\n\n### Provider Credentials Management\n\n**Credential Encryption:**\n```java\n@Component\n@RequiredArgsConstructor(onConstructor_ = {@Autowired})\npublic class ProviderAccountEntityMapper {\n    \n    private final SensitiveKeyMapper sensitiveKeyMapper;\n    \n    public ProviderAccountEntity toEntity(ProviderAccount domain) {\n        // Encrypt access token during persistence\n        return ProviderAccountEntity.builder()\n            .paymentProvider(...)\n            .accessToken(\n                sensitiveKeyMapper.encryptAccessToken(domain.getAccessToken()))\n            .build();\n    }\n    \n    public ProviderAccount toDomain(ProviderAccountEntity entity) {\n        // Decrypt access token during retrieval\n        ProviderAccount account = ProviderAccount.builder()\n            .decryptedAccessToken(\n                sensitiveKeyMapper.decryptAccessToken(entity.getAccessToken()))\n            .build();\n        return account;\n    }\n}\n```\n\n**Credential Caching:**\n```java\n@Component\npublic class ProviderAccountCache extends AbstractDPManagedCache {\n    \n    @DPCache(cacheName = Constant.CacheName.PROVIDER_ACCOUNT_BY_ID_CACHE)\n    private LoadingCache<Long, Optional<ProviderAccountEntity>> providerAccountByIdCache;\n    \n    @DPCache(cacheName = Constant.CacheName.PROVIDER_ACCOUNT_BY_REFERENCE_ID_CACHE)\n    private LoadingCache<String, Optional<ProviderAccountEntity>> \n            providerAccountByPAReferenceIdCache;\n    \n    public Optional<ProviderAccountEntity> getProviderById(Long id) {\n        try {\n            // Cache with TTL refresh (typically 24 hours)\n            return providerAccountByIdCache.get(id);\n        } catch (Exception e) {\n            log.error(\"Error fetching provider: {}\", id, e);\n            return Optional.empty();\n        }\n    }\n}\n```\n\n### Provider-Specific Configurations\n\n**Cashfree Configuration:**\n```java\n@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class CashfreeProviderAccountConfiguration \n        extends BaseProviderAccountConfiguration {\n    \n    private String apiClientId;\n    private String apiVersion;\n    \n    @JsonInclude(JsonInclude.Include.NON_NULL)\n    private ShortCircuitConfiguration shortCircuitConfiguration;\n}\n```\n\n**Cybersource Configuration:**\n```java\n@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class CybersourceProviderAccountConfiguration \n        extends BaseProviderAccountConfiguration {\n    \n    private String apiKey;\n    private String merchantId;\n    \n    @Builder.Default\n    private Boolean enableRetries = false;\n    \n    @Builder.Default\n    private Boolean enableCaptureWithAuth = true;\n    \n    @Builder.Default\n    private Boolean enableTxnIdSync = false;\n    \n    @Builder.Default\n    private Boolean enableCvv = true;\n    \n    private String merchantName;\n    \n    @Builder.Default\n    private Boolean enable3DS2 = true;\n    \n    @Builder.Default\n    private Boolean enableRedirectionFlow = false;\n    \n    @Builder.Default\n    private String transactionFlowIndicator = \"08\";\n}\n```\n\n### Configuration Decorators (Strategy Pattern)\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/manager/decorator/CashfreeProviderAccountJSONConfigValueDecoratorImpl.java`\n\n```java\n@Component\npublic class CashfreeProviderAccountJSONConfigValueDecoratorImpl\n        extends AbstractJSONConfigValueDecorator<CashfreeProviderAccountConfiguration> {\n    \n    public CashfreeProviderAccountJSONConfigValueDecoratorImpl() {\n        super(CashfreeProviderAccountConfiguration.class);\n    }\n}\n\n// Pattern: Each provider has its own decorator\n// - CybersourceProviderAccountJSONConfigValueDecoratorImpl\n// - JusPayProviderAccountJSONConfigValueDecoratorImpl\n// - MPGSProviderAccountJSONConfigValueDecoratorImpl\n// - etc.\n```\n\n---\n\n## 5. ERROR HANDLING\n\n### Provider-Specific Error Code Mapping\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/providers/ProviderError.java`\n\n```java\n@Data\n@Builder\npublic class ProviderError {\n    private String message;           // Readable error message\n    private String code;              // Provider error code (e.g., \"10001\")\n    private Object providerResponse;  // Raw provider error response\n    private Boolean retryable;        // Is this error retryable?\n}\n```\n\n**Error Response Structure:**\n```java\n@Data\n@Builder\npublic class ProviderPaymentResponse {\n    // Success fields\n    private final Object providerResponseObject;\n    private String providerReferenceId;\n    private String gatewayReferenceId;\n    private String providerStatus;\n    private PaymentAttemptStatus status;\n    \n    // Error fields\n    private ProviderError providerError;\n    \n    @Builder.Default\n    private ProviderRequestStatus providerRequestStatus = \n            ProviderRequestStatus.REQUEST_SUCCESS;  // RETRY_ABLE_FAILURE or NON_RETRY_ABLE_FAILURE\n}\n```\n\n**Cashfree Error Mapping Example:**\n```java\n// In CashfreeProviderAdapter\nprivate ProviderRequestStatus mapToProviderRequestStatus(ResponseStatus responseStatus) {\n    switch (responseStatus) {\n        case SUCCESS:\n            return ProviderRequestStatus.REQUEST_SUCCESS;\n        case TIMEOUT:\n            return ProviderRequestStatus.RETRY_ABLE_FAILURE;\n        case NOT_FOUND:\n        case INVALID_REQUEST:\n            return ProviderRequestStatus.NON_RETRY_ABLE_FAILURE;\n        default:\n            return ProviderRequestStatus.RETRY_ABLE_FAILURE;\n    }\n}\n```\n\n**Cybersource Error Mapping:**\n```java\n// Failure status codes\nprivate static final List<String> FAILED_STATUES = Arrays.asList(\n    \"101\", \"102\", \"104\", \"150\", \"151\", \"152\", \"200\", \"201\", \"202\", \n    \"203\", \"204\", \"205\", \"207\", \"208\", \"209\", \"210\", \"211\", \"220\", \n    \"221\", \"222\", \"230\", \"231\", \"232\", \"233\", \"234\", \"235\", \"236\", \n    \"237\", \"238\", \"239\", \"240\", \"241\", \"242\", \"243\", \"246\", \"247\", \n    \"248\", \"250\", \"251\", \"254\", \"400\", \"450\", \"451\", \"452\", \"453\", \n    \"454\", \"455\", \"456\", \"457\", \"458\", \"459\", \"460\", \"461\", \"476\", \n    \"480\", \"481\", \"520\", \"700\", \"701\", \"702\", \"703\"\n);\n\n// Processing statuses (timeout, pending)\nprivate static final List<String> PROCESSING_STATUSES = Arrays.asList(\n    \"110\", \"475\", \"480\"\n);\n```\n\n### Retry Logic and Failure Handling\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/v2/ProviderRequestStatus.java`\n\n```java\npublic enum ProviderRequestStatus {\n    REQUEST_SUCCESS,          // No retry needed\n    RETRY_ABLE_FAILURE,       // Can retry (e.g., timeout)\n    NON_RETRY_ABLE_FAILURE    // Cannot retry (e.g., invalid request)\n}\n```\n\n**Retry Pattern in Base Adapter:**\n```java\npublic ProviderPaymentResponse executePaymentAttempt(\n        PaymentAttemptCreateContext context,\n        PilotMethodInterface<PaymentAttemptCreateContext, ProviderCustomerEntity, \n                ProviderPaymentResponse> pilotMethod,\n        FlowType flowType) {\n    \n    try {\n        ProviderPaymentResponse createResponse = pilotMethod.apply(context, providerCustomer);\n        providerEntityAuditService.auditProviderData(\n            createResponse.getProviderResponseObject(),\n            context.getPaymentAttemptEntity().getExternalId(),\n            paymentProviderKey,\n            flowType,\n            EntityType.PAYMENT_ATTEMPT);\n        return createResponse;\n    } catch (RateLimitException rle) {\n        // Rate limit → retryable\n        return ProviderPaymentResponse.builder()\n            .providerError(ProviderError.builder()\n                .message(rle.getMessage())\n                .code(rle.getErrorCode())\n                .retryable(true)\n                .build())\n            .providerRequestStatus(ProviderRequestStatus.RETRY_ABLE_FAILURE)\n            .build();\n    } catch (AppException ae) {\n        // App exception → check error type\n        return ProviderPaymentResponse.builder()\n            .providerError(ProviderError.builder()\n                .message(ae.getMessage())\n                .code(ae.getErrorCode())\n                .retryable(false)\n                .build())\n            .providerRequestStatus(ProviderRequestStatus.NON_RETRY_ABLE_FAILURE)\n            .build();\n    }\n}\n```\n\n### ProviderException and Error Response Transformation\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/error/ProviderException.java`\n\n```java\npublic class ProviderException extends AppException {\n    \n    public ProviderException(\n            final String message,\n            final HttpStatus statusCode,\n            final String errorCode,\n            final String header,\n            final Map<String, Object> information) {\n        super(message, statusCode, errorCode, header, information);\n    }\n}\n```\n\n**Error Response Transformation Pattern:**\n```java\n// In provider adapters\nprivate Optional<ProviderError> evaluateAndReturnErrorIfAny(\n        BaseResponse<?> baseResponse) {\n    if (Objects.nonNull(baseResponse.getError())) {\n        ErrorResponse error = baseResponse.getError();\n        return Optional.of(ProviderError.builder()\n            .message(error.getMessage())\n            .code(error.getCode())\n            .providerResponse(baseResponse)\n            .retryable(isRetryableErrorCode(error.getCode()))\n            .build());\n    }\n    return Optional.empty();\n}\n```\n\n---\n\n## ARCHITECTURAL PATTERNS SUMMARY\n\n### 1. **Factory Pattern** (PaymentProviderFactory)\n- Multi-dimensional lookup by (OrderType, ProviderKey, InstrumentType, ThreeDSType)\n- Support for variant registration (3DS1 vs 3DS2)\n\n### 2. **Strategy Pattern** (ProviderDeciderRouter)\n- Multiple routing strategies (LCM vs Decision Tree)\n- Fallback mechanism with priority ordering\n\n### 3. **Decorator Pattern** (Configuration Decorators)\n- Client-specific configuration decoration\n- Provider-specific JSON parsing strategies\n\n### 4. **Template Method Pattern** (IPaymentProviderAdapter)\n- Abstract base class defining payment lifecycle\n- Subclasses implement provider-specific logic\n\n### 5. **Builder Pattern** (Request Building)\n- Cybersource request builders for different operation types\n- Fluent interface for complex request construction\n\n### 6. **Caching Strategy** (Caffeine + LoadingCache)\n- TTL-based caching for decision trees and provider accounts\n- Automatic refresh-on-write mechanism\n\n### 7. **Provider Wrapping** (Provider Clients)\n- Each provider has a client wrapper (CashfreeClient, CybersourceClient)\n- Encapsulates provider API communication\n\n---\n\n## KEY FILE PATHS FOR EXPERT REFERENCE\n\n1. **Base Architecture:**\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/providers/IPaymentProviderAdapter.java`\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/providers/PaymentProviderFactory.java`\n\n2. **Decision Tree & Routing:**\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/planner/providerdecider/ProviderDeciderRouter.java`\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/planner/providerdecider/ProviderDeciderV2.java`\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/planner/providerdecider/ProviderDeciderViaLCM.java`\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/cache/DecisionTreeObjectCache.java`\n\n3. **Webhook Handling:**\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/controller/WebhookController.java`\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/controller/v2/CashfreeWebhookController.java`\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/service/WebhookService.java`\n\n4. **Configuration Management:**\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/ProviderAccountEntity.java`\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/PaymentProviderEntity.java`\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/ClientPaymentProviderConfigEntity.java`\n\n5. **Provider Implementations:**\n   - **Cashfree:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/providers/CashfreeProviderAdapter.java`\n   - **Cybersource:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/providers/cybersource/CybersourceProviderAdapter.java`\n\n6. **Error Handling:**\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/providers/ProviderError.java`\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/providers/ProviderPaymentResponse.java`\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/error/ProviderException.java`\n\n7. **Response Structures:**\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/providers/ProviderRefundCreateResponse.java`\n\nThis architecture demonstrates enterprise-grade payment processing with support for multiple payment providers, sophisticated routing logic, comprehensive error handling, and robust webhook integration. The design prioritizes extensibility, maintainability, and separation of concerns."},{"type":"text","text":"agentId: a19c63e (for resuming to continue this agent's work if needed)"}]}]},"uuid":"db4ccc12-e5a6-4d8a-98d8-05f5da6bb6bc","timestamp":"2025-12-31T09:48:01.388Z","toolUseResult":{"status":"completed","prompt":"Provide an extremely detailed analysis of the payment-service Provider Integration architecture for expert study. Cover:\n\n1. **Provider Adapter Architecture:**\n   - Base adapter interface and abstract class patterns\n   - How adapters are registered and selected (factory pattern)\n   - Common adapter methods (create payment, capture, refund, status check)\n   - Request/Response transformation patterns\n   - Study 2-3 specific adapter implementations in detail (Cybersource, Cashfree, etc.)\n\n2. **Decision Tree Routing:**\n   - How decision trees work for provider selection\n   - DecisionTreeWorkflow and ProviderDeciderRouter implementation\n   - Decision tree JSON structure and caching\n   - LCM (Lending Cloud Manager) integration for routing\n   - How provider priority and fallback work\n\n3. **Webhook Handling:**\n   - WebhookController structure and endpoint handling\n   - How webhooks are routed to specific provider handlers\n   - Signature verification and authentication\n   - Webhook payload processing and state updates\n   - Idempotency handling for duplicate webhooks\n\n4. **Provider Configuration:**\n   - ProviderAccountEntity and PaymentProviderEntity setup\n   - Client-Provider configuration mapping\n   - Provider credentials management (AccessToken, endpoints)\n   - Provider-specific settings and feature flags\n\n5. **Error Handling:**\n   - Provider-specific error code mapping\n   - Retry logic and failure handling\n   - ProviderException and error response transformation\n\nProvide specific file paths, code examples, and architectural insights. This is for expert-level understanding.","agentId":"a19c63e","content":[{"type":"text","text":"Now I have sufficient information to provide the comprehensive analysis. Let me compile it:\n\n## EXTREMELY DETAILED PAYMENT-SERVICE PROVIDER INTEGRATION ARCHITECTURE ANALYSIS\n\nBased on my thorough exploration of the codebase, here's an expert-level architectural analysis:\n\n---\n\n## 1. PROVIDER ADAPTER ARCHITECTURE\n\n### Base Adapter Interface and Abstract Class Patterns\n\n**File Path:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/providers/IPaymentProviderAdapter.java`\n\nThe architecture implements a sophisticated generic adapter pattern:\n\n```java\npublic abstract class IPaymentProviderAdapter<T, R> implements SelfReferencingBean {\n    protected IPaymentProviderAdapter<T, R> selfProxy;\n    protected final PaymentProviderKey paymentProviderKey;\n    private final InstrumentType instrumentType;\n    private final OrderType orderType;\n    \n    public IPaymentProviderAdapter(\n            PaymentProviderKey paymentProviderKey, \n            InstrumentType instrumentType, \n            OrderType orderType) {\n        // Initialization\n    }\n}\n```\n\n**Key Design Elements:**\n- **Generic Parameters:** `<T, R>` where T is the request type and R is the auth configuration type\n- **Self-Proxying:** Implements `SelfReferencingBean` to enable transactional proxying for methods like `@Transactional`\n- **Auto-Registration:** Uses `@PostConstruct` to register adapters with `PaymentProviderFactory` during bean initialization\n- **Lazy Loading:** Uses `ProviderAccountCache` to defer credential loading until needed\n\n### Adapter Registration and Factory Pattern\n\n**File Path:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/providers/PaymentProviderFactory.java`\n\nThe factory uses multi-dimensional lookup tables:\n\n```java\n@Component\npublic class PaymentProviderFactory {\n    // Primary map: OrderType + ProviderKey + InstrumentType → Adapter\n    private final Map<PaymentWorkflowKey, IPaymentProviderAdapter<?, ?>> paymentProviderMap;\n    \n    // Secondary map: OrderType + ProviderKey → First matching adapter\n    private final Table<OrderType, PaymentProviderKey, IPaymentProviderAdapter<?, ?>> \n            paymentProviderByKey;\n    \n    // 3DS adapter registry with versioning support\n    private ThreeDSType threeDSType (for 3DS1 vs 3DS2 variants)\n    \n    // Push payment adapters (webhooks from providers)\n    private Map<PaymentWorkflowKey, IPushPaymentProviderAdapter<?, ?>> \n            pushPaymentProviderAdapterMap;\n    \n    // eMandate fetch adapters\n    private Map<PaymentWorkflowKey, EMandateFetchProviderAdapter<?, ?>> \n            mandateProviderMap;\n}\n```\n\n**Lookup Resolution:**\n- Uses Guava's `HashBasedTable` for O(1) lookups by (OrderType, ProviderKey)\n- Supports variant resolution (3DS1 vs 3DS2) via `ThreeDSType` enum\n- Auto-detects adapter capabilities and registers in appropriate maps\n\n### Common Adapter Methods\n\nThe base adapter defines the lifecycle for payment attempts:\n\n```java\n// 1. Create payment flow\npublic abstract ProviderPaymentResponse createPaymentAttempt(\n    PaymentAttemptCreateContext context, \n    @Nullable ProviderCustomerEntity providerCustomerEntity);\n\n// 2. Synchronization flows\nprotected abstract Object syncPaymentAttemptWithProviderId(PaymentAttemptV2Entity);\nprotected Optional<Object> syncPaymentAttemptWithExternalId(PaymentAttemptV2Entity);\npublic void syncPaymentAttemptWithWebhook(PaymentAttemptV2Entity, Object webhook);\npublic void syncPaymentAttemptWithSerializedWebhook(PaymentAttemptV2Entity, String webhook);\n\n// 3. Refund flows\nprotected abstract ProviderRefundCreateResponse createRefund(\n    RefundAttemptEntity, \n    Map<RefundChannel, Object> additionalContext);\nprotected abstract Object syncRefund(RefundAttemptEntity);\npublic void syncRefundAttemptWithWebhook(RefundAttemptEntity, Object webhook);\n\n// 4. Utility methods\nprotected abstract R getAuthConfig(ProviderAccountEntity);\npublic abstract String createProviderCustomer(CustomerEntity, ProviderAccountEntity);\n```\n\n### Request/Response Transformation Patterns\n\n**Response Structure:**\n```java\n@Data\n@Builder\npublic class ProviderPaymentResponse {\n    private final Object providerResponseObject;           // Raw provider response\n    private String providerReferenceId;                   // Provider's transaction ID\n    private String gatewayReferenceId;                   // Gateway ID (if applicable)\n    private String providerStatus;                       // Raw provider status (e.g., \"SUCCESS\")\n    private PaymentAttemptStatus status;                // Mapped internal status\n    @Builder.Default\n    private ProviderRequestStatus providerRequestStatus = \n            ProviderRequestStatus.REQUEST_SUCCESS;       // Retry/failure classification\n    private ProviderError providerError;                // Error details\n    private PaymentAuthenticationDetails transactionResponse;\n    private String authCode;\n    private AuthTokenDetails authTokenDetails;\n}\n\n@Data\n@Builder\npublic class ProviderError {\n    private String message;\n    private String code;                                 // Provider error code\n    private Object providerResponse;                    // Raw error response\n    private Boolean retryable;                          // Retry classification\n}\n```\n\n### 2-3 Specific Adapter Implementations\n\n#### **1. CASHFREE ADAPTER** (File: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/providers/CashfreeProviderAdapter.java`)\n\n**Provider Architecture:**\n```java\n@Slf4j\n@Component\npublic abstract class CashfreeProviderAdapter \n        extends IPaymentProviderAdapter<String, CashfreeAuthConfig> {\n    \n    @Getter\n    private CashfreeClient cashfreeClient;\n    \n    @Getter\n    private ProviderAccountManager providerAccountManager;\n    \n    public CashfreeProviderAdapter(InstrumentType instrumentType) {\n        super(PaymentProviderKey.CASHFREE, instrumentType, OrderType.PAY);\n    }\n}\n```\n\n**Create Payment Flow (Two-Phase):**\n1. **Order Creation Phase:**\n   ```java\n   private Pair<BaseResponse<CreateOrderResponse>, ProviderError> createCFOrder(\n           PaymentAttemptCreateContext context, CashfreeAuthConfig authConfig) {\n       CreateOrderRequest createOrderRequest = getCreateOrderRequest(context);\n       BaseResponse<CreateOrderResponse> baseResponse = \n           cashfreeClient.createOrder(createOrderRequest, authConfig);\n       return Pair.of(baseResponse, evaluateAndReturnErrorIfAny(baseResponse).orElse(null));\n   }\n   ```\n\n2. **Payment Creation Phase:**\n   ```java\n   private Pair<BaseResponse<CreatePaymentResponse>, ProviderError> createCFPayment(\n           PaymentAttemptCreateContext context,\n           CreateOrderResponse createOrderResponse,\n           CashfreeAuthConfig authConfig) {\n       CreatePaymentRequest createPaymentRequest = \n           getCreatePaymentRequest(context, createOrderResponse);\n       BaseResponse<CreatePaymentResponse> baseResponse =\n           cashfreeClient.createPayment(createPaymentRequest, authConfig);\n       return Pair.of(baseResponse, evaluateAndReturnErrorIfAny(baseResponse).orElse(null));\n   }\n   ```\n\n**Status Synchronization:**\n```java\nprotected Object syncPaymentAttemptWithProviderId(PaymentAttemptV2Entity paymentAttemptEntity) {\n    CashfreeAuthConfig authConfig = getAuthConfigWrapper(paymentAttemptEntity.getProviderAccountEntity());\n    \n    BaseResponse<GetPaymentResponse> baseResponse = cashfreeClient.getPayment(\n        paymentAttemptEntity.getExternalId(), \n        paymentAttemptEntity.getProviderReferenceId(), \n        authConfig);\n    \n    GetPaymentResponse response = baseResponse.getResponse();\n    \n    // Validate amount consistency\n    if (paymentAttemptEntity.getAmount().compareTo(response.getPaymentAmount()) != 0) {\n        throw Error.internal_server_error.getBuilder()\n            .message(\"Payment amount and provider amount not matching\").build();\n    }\n    \n    // Map provider status to internal status\n    PaymentAttemptStatus internalStatus = fromProviderStatus(response.getPaymentStatus());\n    paymentAttemptEntity.setStatus(internalStatus);\n    paymentAttemptEntity.setProviderStatus(response.getPaymentStatus().name());\n    \n    return response;\n}\n```\n\n**Refund Creation:**\n```java\nprotected ProviderRefundCreateResponse createRefund(\n        RefundAttemptEntity refundAttemptEntity, \n        Map<RefundChannel, Object> additionalContext) {\n    \n    CashfreeAuthConfig authConfig = getAuthConfigWrapper(\n        refundAttemptEntity.getPaymentAttempt().getProviderAccountEntity());\n    \n    CreateRefundRequest createRefundRequest = CreateRefundRequest.builder()\n        .refundId(refundAttemptEntity.getExternalId())\n        .refundAmount(CommonUtils.setScale(refundAttemptEntity.getRefund().getRefundValue()))\n        .build();\n    \n    BaseResponse<CreateRefundResponse> baseResponse = cashfreeClient.createRefund(\n        refundAttemptEntity.getPaymentAttempt().getExternalId(), \n        createRefundRequest, \n        authConfig);\n    \n    return mapRefundResponseToProviderResponseEntity(baseResponse.getResponse());\n}\n```\n\n#### **2. CYBERSOURCE ADAPTER** (File: `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/providers/cybersource/CybersourceProviderAdapter.java`)\n\n**3DS Support Architecture:**\n```java\n@Slf4j\n@Component\npublic abstract class CybersourceProviderAdapter \n        extends I3DSPaymentProviderAdapter<String, AuthConfig> {\n    \n    private static final List<String> FAILED_STATUES = Arrays.asList(\n        \"101\", \"102\", \"104\", \"150\", \"151\", \"152\", \"200\", \"201\", ... // 43 failure codes\n    );\n    \n    private static final List<String> PROCESSING_STATUSES = \n        Arrays.asList(\"110\", \"475\", \"480\");\n    \n    // State transition validation map\n    private static Map<PaymentAttemptStatus, List<PaymentAttemptStatus>> \n            invalidTransitionMap = new HashMap<>();\n    {\n        put(PaymentAttemptStatus.COMPLETED, Collections.emptyList());\n        put(PaymentAttemptStatus.AUTHORIZED, \n            Collections.singletonList(PaymentAttemptStatus.COMPLETED));\n        put(PaymentAttemptStatus.AUTHENTICATION_SUCCESSFUL,\n            Arrays.asList(...));  // Multiple invalid transitions\n    }\n}\n```\n\n**3DS Redirection Flow (3DS2):**\n```java\nprotected void createRedirectionHtml(\n        BaseResponse<CybersourceResponse> baseResponse, \n        PaymentAttemptV2Entity paymentAttemptV2Entity) {\n    \n    ConsumerAuthenticationInformation authInfo = \n        baseResponse.getResponse().getConsumerAuthenticationInformation();\n    \n    // Check 3DS version\n    if (authInfo.getSpecificationVersion().startsWith(\"2\")) {\n        // 3DS2 flow\n        Optional<CybersourceProviderAccountConfiguration> config =\n            providerAccountManager.getCybersourceProviderAccountConfiguration(\n                paymentAttemptV2Entity.getProviderAccountEntity());\n        \n        if (config.isPresent() && config.get().getEnableRedirectionFlow()) {\n            // Darwin proxy redirection (platform handles ACS communication)\n            html = authenticationService.createAuthenticationPageFor3ds2WithoutIframe(\n                authInfo.getAcsUrl(),\n                authInfo.getPareq(),\n                authInfo.getThreeDSServerTransactionId());\n        } else {\n            // Direct iframe redirection (iFrame loads ACS endpoint)\n            html = authenticationService.createAuthenticationPageFor3ds2(\n                authInfo.getStepUpUrl(),\n                authInfo.getAccessToken(),\n                paymentAttemptV2Entity.getExternalId());\n        }\n    } else {\n        // 3DS1 flow (deprecated)\n        html = authenticationService.createAuthenticationPageHTML(...);\n    }\n}\n```\n\n**Request Builder Pattern (Strategy Pattern):**\n```java\n// Abstract builder for all request types\npublic abstract class CybersourceRequestBuilder {\n    protected abstract CybersourceRequestType cybersourceRequestType();\n    public abstract ConsumerAuthenticationInformation consumerAuthenticationInformation(\n        CybersourceRequestContext context);\n    public abstract ProcessingInformation processingInformation(\n        CybersourceRequestContext context);\n    public abstract MerchantInformation merchantInformation(\n        CybersourceRequestContext context);\n}\n\n// Specific builder for authorization\n@Component\npublic class CybersourceAuthorizeRequestBuilder extends CybersourceRequestBuilder {\n    @Override\n    public ProcessingInformation processingInformation(CybersourceRequestContext context) {\n        return ProcessingInformation.builder()\n            .capture(context.getPaymentAttemptAuthorizeContext().isCapture())\n            .commerceIndicator(\n                CybersourceProviderAdapter.commerceIndicator(\n                    context.getCardDetails().getBrand()))\n            .build();\n    }\n}\n```\n\n---\n\n## 2. DECISION TREE ROUTING\n\n**File Path:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/planner/providerdecider/`\n\n### Router Strategy Pattern\n\n```java\n@Slf4j\n@Service\n@RequiredArgsConstructor(onConstructor_ = {@Autowired})\npublic class ProviderDeciderRouter {\n    \n    private final ProviderDeciderV2 providerDeciderV2;           // Decision tree strategy\n    private final ProviderDeciderViaLCM providerDeciderViaLCM;   // LCM strategy\n    private final ClientConfigurationManager configManager;\n    \n    public ProviderRoutingDecisionResult resolve(PaymentAttemptCreateContext context) {\n        // Priority 1: LCM routing for supported instruments\n        if (isInstrumentTypeSupportedInLCM(\n                context.getOrderEntity().getClientEntity().getId(),\n                context.getRequest().getPaymentInstrument().getType())) {\n            return providerDeciderViaLCM.decideProvider(context);\n        }\n        \n        // Priority 2: Decision tree routing\n        Boolean isDecisionTreeEnabled = \n            clientConfigurationManager.getConfigurationAsBooleanWithDefaultOnError(\n                context.getOrderEntity().getClientEntity().getId(), \n                ClientSettingKey.DECISION_TREE_ENABLED);\n        \n        if (isDecisionTreeEnabled) {\n            return providerDeciderV2.decideProvider(context);\n        }\n        \n        throw Error.invalid_decision_tree.getBuilder()\n            .message(\"Neither decision tree nor LCM enabled\").build();\n    }\n}\n```\n\n### DecisionTreeWorkflow Implementation\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/service/decision_tree/workflow/provider_account/ProviderAccountDTWorkflow.java`\n\n```java\n@Component\n@RequiredArgsConstructor(onConstructor_ = {@Autowired})\n@Slf4j\npublic class ProviderDeciderV2 {\n    private final DecisionTreeObjectCache decisionTreeObjectCache;\n    private final ProviderAccountCache providerAccountCache;\n    private final ProviderAccountDTContextCreatorFactory contextCreatorFactory;\n    private final NaradService naradService;  // Dynamic routing integration\n    \n    public ProviderRoutingDecisionResult decideProvider(PaymentAttemptCreateContext context) {\n        // 1. Fetch cached decision tree\n        Pair<DecisionTreeWorkflow, DecisionTreeEntity> cachedDT = \n            decisionTreeObjectCache\n                .getProviderDeciderDecisionTreeWorkflow(clientEntity.getName())\n                .orElseThrow(() -> Error.decision_tree_not_found.getBuilder().build());\n        \n        // 2. Create context for decision tree evaluation\n        ProviderAccountDTWorkflowContext dtWorkflowContext = \n            contextCreatorFactory.getContext(context);\n        \n        // 3. Execute decision tree (returns list of matching providers)\n        ProviderAccountDTResponse response =\n            (ProviderAccountDTResponse) cachedDT.getLeft().execute(dtWorkflowContext);\n        \n        // 4. Apply dynamic routing (provider priority, load balancing)\n        if (CollectionUtils.isNotEmpty(response.getProviderAccounts())) {\n            try {\n                DRDetails drResponse = naradService.processForDynamicRouting(\n                    context, \n                    response.getProviderAccounts());\n                providerAccount = drResponse.getProviderDetails();\n                providerAccountEntity = drResponse.getProviderAccountEntity();\n            } catch (Exception e) {\n                // Fallback to first provider\n                providerAccount = response.getProviderAccounts().get(0);\n            }\n        }\n        \n        return ProviderRoutingDecisionResult.builder()\n            .authType(providerAccount.getAuthType())\n            .browser(providerAccount.getBrowser())\n            .decisionTreeId(cachedDT.getRight().getId())\n            .evaluatedByDecisionTree(true)\n            .authSdk(providerAccount.getAuthSDK())\n            .providerAccountEntity(providerAccountEntity)\n            .cardPaymentMode(CardUtils.getCardPaymentModeForAttempt(\n                context, providerAccount.getCardPaymentMode()))\n            .isPlatformOtpEnabled(providerAccount.getIsPlatformOtpEnabled())\n            .allProviderAccounts(sanitizeProviderDetails(response.getProviderAccounts()))\n            .isDynamicRoutingSkipped(isDRSkipped)\n            .build();\n    }\n}\n```\n\n### Decision Tree JSON Structure and Caching\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/cache/DecisionTreeObjectCache.java`\n\n```java\n@Component\n@RequiredArgsConstructor(onConstructor_ = {@Autowired})\npublic class DecisionTreeObjectCache extends AbstractDPManagedCache {\n    private final DecisionTreeService decisionTreeService;\n    private final CacheConfig cacheConfig;\n    \n    @DPCache(cacheName = Constant.CacheName.DECISION_TREE_OBJECT_CACHE)\n    private LoadingCache<String, Pair<DecisionTreeWorkflow, DecisionTreeEntity>> cache;\n    \n    @Override\n    public void buildCache() {\n        // Caffeine cache with TTL refresh\n        cache = DPCacheBuilder.getBuilder()\n            .refreshAfterWrite(\n                cacheConfig.getDecisionTreeObjectCacheConfig(),  // e.g., 24 hours\n                cacheConfig.getDecisionTreeObjectCacheTTLType())\n            .build(key -> decisionTreeService.getProviderDeciderDecisionTreeWorkflow(key));\n    }\n    \n    public Optional<Pair<DecisionTreeWorkflow, DecisionTreeEntity>> \n            getProviderDeciderDecisionTreeWorkflow(String clientName) {\n        try {\n            return Optional.ofNullable(cache.get(clientName));\n        } catch (Exception e) {\n            log.error(\"Error fetching decision tree for client: {}\", clientName);\n            return Optional.empty();\n        }\n    }\n}\n```\n\n**Decision Tree Entity:**\n```java\n@Entity\n@Table(name = \"decision_trees\")\npublic class DecisionTreeEntity extends BaseEntity {\n    @Column(name = \"name\")\n    private String name;\n    \n    @Column(name = \"client_id\")\n    private Long clientId;\n    \n    @Column(name = \"state\")\n    @Enumerated(EnumType.STRING)\n    private DecisionTreeState state;  // DRAFT, ACTIVE, INACTIVE\n    \n    @Column(name = \"type\")\n    @Enumerated(EnumType.STRING)\n    private DecisionTreeType type;  // PROVIDER_DECIDER\n    \n    @Column(name = \"configuration\", columnDefinition = \"TEXT\")\n    @Type(type = \"text\")\n    private String configuration;  // JSON structure with nodes/edges\n}\n```\n\n### LCM Integration\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/planner/providerdecider/ProviderDeciderViaLCM.java`\n\n```java\n@Component\n@RequiredArgsConstructor(onConstructor_ = {@Autowired})\npublic class ProviderDeciderViaLCM {\n    private final LCMClient lcmClient;\n    private final ProviderAccountCache providerAccountCache;\n    private final NetBankingProviderConfigCache netBankingProviderConfigCache;\n    \n    public ProviderRoutingDecisionResult decideProvider(PaymentAttemptCreateContext context) {\n        // 1. Convert context to LCM request\n        PaymentMethodsResolveTerminalRequest lcmRequest = \n            convertPaymentAttemptContextToLCMRequest(context);\n        \n        // 2. Call LCM service for terminal resolution\n        Optional<PaymentMethodsResolveTerminalResponse> lcmResponse = \n            lcmClient.resolve(\n                context.getOrderEntity().getClientEntity().getMerchantId(),\n                context.getOrderEntity().getClientEntity().getName(),\n                lcmRequest);\n        \n        // 3. Convert LCM response to routing decision\n        return convertLCMResponseToProviderRoutingDecisionResult(context, lcmResponse.get());\n    }\n    \n    private PaymentMethodRequest getPaymentMethodRequest(PaymentAttemptCreateContext context) {\n        EnrichedPaymentInstrument enrichedPaymentInstrument =\n            context.getInstrumentProcessorResult().getEnrichedPaymentInstrument();\n        \n        return switch (enrichedPaymentInstrument.getType()) {\n            case CARD -> getCardPaymentMethodRequest(\n                (CardEnrichedPaymentInstrument) enrichedPaymentInstrument);\n            case UPI_CRED, UPI_APPS, UPI_COLLECT -> getUpiPaymentMethodRequest(...);\n            case NET_BANKING -> getNetBankingPaymentMethodRequest(...);\n            case CRED_BNPL, LAZY_PAY -> getBnplPaymentMethodRequest(...);\n            case CRED_WALLET, CRED_PPI -> getWalletPaymentMethodRequest(...);\n            case NET_BANKING_WITH_PI -> getEMandatePaymentMethodRequest(...);\n            default -> null;\n        };\n    }\n}\n```\n\n### Provider Priority and Fallback\n\n```java\npublic ProviderRoutingDecisionResult resolve(PaymentAttemptCreateContext context) {\n    try {\n        // Primary routing strategy\n        return providerDeciderViaLCM.decideProvider(context);\n    } catch (Exception lcmError) {\n        log.error(\"LCM routing failed, falling back to decision tree\", lcmError);\n        \n        // Fallback strategy\n        return providerDeciderV2.decideProvider(context);\n    }\n}\n```\n\n---\n\n## 3. WEBHOOK HANDLING\n\n**File Paths:**\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/controller/WebhookController.java`\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/controller/v2/CashfreeWebhookController.java`\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/service/WebhookService.java`\n\n### WebhookController Structure\n\n```java\n@Slf4j\n@RestController\n@RequestMapping(\"/v1/webhooks\")\n@RequiredArgsConstructor(onConstructor_ = {@Autowired})\npublic class WebhookController {\n    \n    private final WebhookService webhookService;\n    \n    @SkipContextBuild  // Skip ApplicationContext building (no client context)\n    @PostMapping\n    public Order processWebhook(@RequestBody @Valid WebhookRequest webhookRequest) {\n        return webhookService.processWebhook(webhookRequest);\n    }\n}\n```\n\n### Provider-Specific Webhook Controllers\n\n**Cashfree Webhook:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/controller/v2/CashfreeWebhookController.java`\n\n```java\n@Slf4j\n@RestController\n@SkipContextBuild\n@RequestMapping(\"/webhooks/v2/cashfree\")\n@RequiredArgsConstructor(onConstructor_ = {@Autowired})\npublic class CashfreeWebhookController {\n    \n    private final PaymentAttemptFetchWorkflow paymentAttemptFetchWorkflow;\n    private final RefundAttemptFetchWorkflow refundAttemptFetchWorkflow;\n    private final PaymentProviderEntityAuditService auditService;\n    \n    @PostMapping\n    public void onWebhookReceive(@RequestBody CashfreeWebhook webhookRequest) {\n        log.info(\"Webhook from Cashfree: {}\", webhookRequest);\n        \n        switch (webhookRequest.getType()) {\n            case PAYMENT_SUCCESS_WEBHOOK:\n            case PAYMENT_FAILED_WEBHOOK:\n            case PAYMENT_USER_DROPPED_WEBHOOK:\n                processPaymentAttempt(webhookRequest, \n                    (CashfreePaymentWebhook) webhookRequest);\n                break;\n            case REFUND_STATUS_WEBHOOK:\n                processRefundAttempt(webhookRequest, \n                    (CashfreeRefundWebhook) webhookRequest);\n                break;\n            default:\n                throw new UnsupportedOperationException(\n                    webhookRequest.getType() + \" not supported\");\n        }\n    }\n    \n    private void processPaymentAttempt(CashfreeWebhook webhookRequest, \n            CashfreePaymentWebhook paymentWebhook) {\n        try {\n            // Extract provider reference ID from webhook\n            String providerReferenceId = String.valueOf(\n                paymentWebhook.getData().getPaymentData().getCfPaymentId());\n            \n            // Fetch payment attempt using provider reference\n            PaymentAttempt attempt = paymentAttemptFetchWorkflow\n                .fetchByProviderReferenceId(providerReferenceId);\n            \n            // Audit provider data for forensics\n            auditService.auditProviderData(\n                webhookRequest,\n                attempt.getId(),\n                PaymentProviderKey.CASHFREE,\n                FlowType.WEB_HOOK,\n                EntityType.PAYMENT_ATTEMPT);\n        } catch (Exception ex) {\n            log.error(\"Error processing payment webhook: {}\", ex.getMessage(), ex);\n        }\n    }\n}\n```\n\n### Webhook Routing Strategy\n\n```java\n// Other webhook controllers for different providers:\n// - /webhooks/v2/razorpay → RazorpayWebhookController\n// - /webhooks/v2/payu → PayuWebhookController\n// - /webhooks/v2/pinelabs → PinelabsWebhookController\n// - /webhooks/v2/digio → DigioWebhookController\n// - /webhooks/v2/ybl → YBLWebhookController\n// - /webhooks/v2/icici → ICICIWebhookController\n// - /webhooks/v2/rbl-upi → RBLUpiWebhookController\n```\n\n### Webhook Payload Processing\n\n```java\n@Service\n@RequiredArgsConstructor(onConstructor_ = {@Autowired})\npublic class WebhookService {\n    \n    private final PushPaymentsOrderService pushPaymentsOrderService;\n    private final OrderEntityNewMapper orderEntityNewMapper;\n    private final PaymentAttemptService paymentAttemptService;\n    \n    public Order processWebhook(WebhookRequest webhook) {\n        // Check if payment attempt already exists\n        Optional<PaymentAttemptV2Entity> existingPaymentAttemptEntity =\n            paymentAttemptService.fetchPaymentAttemptIfPresent(\n                webhook.getFetchDetails());\n        \n        if (existingPaymentAttemptEntity.isPresent()) {\n            // Webhook for existing payment attempt - sync status\n            paymentAttemptService.syncPaymentAttemptWithSerializedWebhook(\n                webhook.getFetchDetails(), \n                webhook.getProviderData());\n            \n            Order order = new Order();\n            orderEntityNewMapper.copyToDomain(\n                existingPaymentAttemptEntity.get().getOrderEntity(), \n                order);\n            return order;\n        } else {\n            // Webhook for new payment (push payments) - create order\n            return pushPaymentsOrderService.processPushPayment(\n                buildPushPaymentRequest(webhook));\n        }\n    }\n}\n```\n\n### Signature Verification and Authentication\n\n**Handled via Provider-Specific Clients** (e.g., in `CashfreeClient`, `RazorpayClientWrapper`)\n\n```java\n// Pattern: Each provider client validates webhook signature\n// Signature validation typically includes:\n// 1. Extract signature from webhook headers\n// 2. Reconstruct payload signature using provider secret\n// 3. Constant-time comparison to prevent timing attacks\n// 4. Throw exception if signature invalid\n```\n\n### Idempotency Handling\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/ProviderAccountEntity.java`\n\n```java\n@Entity\n@Table(name = \"provider_accounts\")\npublic class ProviderAccountEntity extends BaseEntity {\n    \n    @Column(name = \"idempotence_key\")\n    private String idempotenceKey;  // Used for duplicate webhook detection\n    \n    // Idempotency pattern:\n    // 1. When webhook received, extract unique identifier (e.g., transaction ID)\n    // 2. Query for existing payment attempt with this provider reference ID\n    // 3. If found, return cached response instead of re-processing\n    // 4. If not found, process webhook and store result\n}\n```\n\n**In Base Adapter:**\n```java\npublic final void syncPaymentAttemptWithProvider(PaymentAttemptV2Entity paymentAttemptV2Entity) {\n    String currentStatus = paymentAttemptV2Entity.getProviderStatus();\n    \n    // Fetch provider response (either by ID or external ID)\n    Optional<Object> providerResponseExternalId = \n        syncPaymentAttemptWithExternalId(paymentAttemptV2Entity);\n    \n    if (providerResponseExternalId.isPresent()) {\n        providerResponse = providerResponseExternalId.get();\n    } else {\n        // Fetch by provider reference ID\n        providerResponse = syncPaymentAttemptWithProviderId(paymentAttemptV2Entity);\n    }\n    \n    // Only update if status changed (prevents duplicate processing)\n    if (Objects.nonNull(providerResponse) && \n            !Objects.equals(currentStatus, paymentAttemptV2Entity.getProviderStatus())) {\n        providerEntityAuditService.auditProviderData(\n            providerResponse,\n            paymentAttemptV2Entity.getExternalId(),\n            paymentProviderKey,\n            FlowType.STATUS_CHANGE_SYNC,\n            EntityType.PAYMENT_ATTEMPT);\n    }\n}\n```\n\n---\n\n## 4. PROVIDER CONFIGURATION\n\n### ProviderAccountEntity and PaymentProviderEntity Setup\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/ProviderAccountEntity.java`\n\n```java\n@Entity\n@Table(name = \"provider_accounts\")\npublic class ProviderAccountEntity extends BaseEntity {\n    \n    @ManyToOne\n    @JoinColumn(name = \"payment_provider_id\")\n    private PaymentProviderEntity paymentProvider;\n    \n    @Column(name = \"provider_account_id\")\n    private String providerAccountId;  // e.g., \"ACC_123456\"\n    \n    @Column(name = \"idempotence_key\")\n    private String idempotenceKey;\n    \n    @Column(name = \"access_token\")\n    @Lob\n    private byte[] accessToken;  // Encrypted credentials\n    \n    @Column(name = \"provider_account_reference_id\")\n    private String providerAccountReferenceId;  // Unique identifier\n    \n    @Transient\n    private String decryptedAccessToken;  // Decrypted on-demand\n    \n    @Column(name = \"endpoint\")\n    private String endpoint;  // Provider API endpoint\n    \n    @Column(name = \"is_prod\")\n    private Boolean isProd;  // Production vs Sandbox\n    \n    @Column(name = \"active\")\n    @Builder.Default\n    private Boolean active = true;\n    \n    @Column(name = \"additional_config\")\n    private String additionalConfig;  // JSON configuration\n    \n    @Column(name = \"provider_mid\")\n    private String providerMid;  // Merchant ID at provider\n    \n    @Column(name = \"config_decorator\")\n    @Enumerated(EnumType.STRING)\n    private ConfigValueDecoratoryKey decorator;  // Configuration strategy\n    \n    @Column(name = \"settlement_category\")\n    private String settlementCategory;  // Settlement routing\n}\n```\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/PaymentProviderEntity.java`\n\n```java\n@Entity\n@Table(name = \"payment_providers\")\npublic class PaymentProviderEntity extends BaseExternalEntity {\n    \n    @Column(name = \"name\")\n    private String name;  // e.g., \"Cashfree\", \"Cybersource\"\n    \n    @Column(name = \"provider_key\")\n    private String key;  // e.g., \"CASHFREE\", \"CYBERSOURCE\"\n    \n    @Column(name = \"active\")\n    @Builder.Default\n    private Boolean active = true;\n    \n    @Column(name = \"is_customer_required\")\n    @Builder.Default\n    private Boolean customerRequired = false;  // Does provider require customer registration?\n    \n    @OneToMany(cascade = {CascadeType.MERGE, CascadeType.PERSIST})\n    @JoinColumn(name = \"payment_provider_id\")\n    @Builder.Default\n    private Set<PaymentProviderSettingsEntity> settings = new HashSet<>();\n    \n    public void addSettings(PaymentProviderSettingsEntity settingsEntity) {\n        settingsEntity.setPaymentProviderEntity(this);\n        settings.add(settingsEntity);\n    }\n}\n```\n\n### Client-Provider Configuration Mapping\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/ClientPaymentProviderConfigEntity.java`\n\n```java\n@Entity\n@Table(name = \"client_payment_provider_config\")\npublic class ClientPaymentProviderConfigEntity extends BaseEntity {\n    \n    @ManyToOne\n    @JoinColumn(name = \"client_id\")\n    private ClientEntity client;\n    \n    @ManyToOne\n    @JoinColumn(name = \"payment_provider_id\")\n    private PaymentProviderEntity paymentProvider;\n    \n    @Column(name = \"provider_config\")\n    private String providerConfig;  // JSON configuration\n    \n    @Column(name = \"config_decorator\")\n    @Enumerated(EnumType.STRING)\n    private ConfigValueDecoratorKey decorator;  // Which decorator to use\n}\n```\n\n### Provider Credentials Management\n\n**Credential Encryption:**\n```java\n@Component\n@RequiredArgsConstructor(onConstructor_ = {@Autowired})\npublic class ProviderAccountEntityMapper {\n    \n    private final SensitiveKeyMapper sensitiveKeyMapper;\n    \n    public ProviderAccountEntity toEntity(ProviderAccount domain) {\n        // Encrypt access token during persistence\n        return ProviderAccountEntity.builder()\n            .paymentProvider(...)\n            .accessToken(\n                sensitiveKeyMapper.encryptAccessToken(domain.getAccessToken()))\n            .build();\n    }\n    \n    public ProviderAccount toDomain(ProviderAccountEntity entity) {\n        // Decrypt access token during retrieval\n        ProviderAccount account = ProviderAccount.builder()\n            .decryptedAccessToken(\n                sensitiveKeyMapper.decryptAccessToken(entity.getAccessToken()))\n            .build();\n        return account;\n    }\n}\n```\n\n**Credential Caching:**\n```java\n@Component\npublic class ProviderAccountCache extends AbstractDPManagedCache {\n    \n    @DPCache(cacheName = Constant.CacheName.PROVIDER_ACCOUNT_BY_ID_CACHE)\n    private LoadingCache<Long, Optional<ProviderAccountEntity>> providerAccountByIdCache;\n    \n    @DPCache(cacheName = Constant.CacheName.PROVIDER_ACCOUNT_BY_REFERENCE_ID_CACHE)\n    private LoadingCache<String, Optional<ProviderAccountEntity>> \n            providerAccountByPAReferenceIdCache;\n    \n    public Optional<ProviderAccountEntity> getProviderById(Long id) {\n        try {\n            // Cache with TTL refresh (typically 24 hours)\n            return providerAccountByIdCache.get(id);\n        } catch (Exception e) {\n            log.error(\"Error fetching provider: {}\", id, e);\n            return Optional.empty();\n        }\n    }\n}\n```\n\n### Provider-Specific Configurations\n\n**Cashfree Configuration:**\n```java\n@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class CashfreeProviderAccountConfiguration \n        extends BaseProviderAccountConfiguration {\n    \n    private String apiClientId;\n    private String apiVersion;\n    \n    @JsonInclude(JsonInclude.Include.NON_NULL)\n    private ShortCircuitConfiguration shortCircuitConfiguration;\n}\n```\n\n**Cybersource Configuration:**\n```java\n@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class CybersourceProviderAccountConfiguration \n        extends BaseProviderAccountConfiguration {\n    \n    private String apiKey;\n    private String merchantId;\n    \n    @Builder.Default\n    private Boolean enableRetries = false;\n    \n    @Builder.Default\n    private Boolean enableCaptureWithAuth = true;\n    \n    @Builder.Default\n    private Boolean enableTxnIdSync = false;\n    \n    @Builder.Default\n    private Boolean enableCvv = true;\n    \n    private String merchantName;\n    \n    @Builder.Default\n    private Boolean enable3DS2 = true;\n    \n    @Builder.Default\n    private Boolean enableRedirectionFlow = false;\n    \n    @Builder.Default\n    private String transactionFlowIndicator = \"08\";\n}\n```\n\n### Configuration Decorators (Strategy Pattern)\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/manager/decorator/CashfreeProviderAccountJSONConfigValueDecoratorImpl.java`\n\n```java\n@Component\npublic class CashfreeProviderAccountJSONConfigValueDecoratorImpl\n        extends AbstractJSONConfigValueDecorator<CashfreeProviderAccountConfiguration> {\n    \n    public CashfreeProviderAccountJSONConfigValueDecoratorImpl() {\n        super(CashfreeProviderAccountConfiguration.class);\n    }\n}\n\n// Pattern: Each provider has its own decorator\n// - CybersourceProviderAccountJSONConfigValueDecoratorImpl\n// - JusPayProviderAccountJSONConfigValueDecoratorImpl\n// - MPGSProviderAccountJSONConfigValueDecoratorImpl\n// - etc.\n```\n\n---\n\n## 5. ERROR HANDLING\n\n### Provider-Specific Error Code Mapping\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/providers/ProviderError.java`\n\n```java\n@Data\n@Builder\npublic class ProviderError {\n    private String message;           // Readable error message\n    private String code;              // Provider error code (e.g., \"10001\")\n    private Object providerResponse;  // Raw provider error response\n    private Boolean retryable;        // Is this error retryable?\n}\n```\n\n**Error Response Structure:**\n```java\n@Data\n@Builder\npublic class ProviderPaymentResponse {\n    // Success fields\n    private final Object providerResponseObject;\n    private String providerReferenceId;\n    private String gatewayReferenceId;\n    private String providerStatus;\n    private PaymentAttemptStatus status;\n    \n    // Error fields\n    private ProviderError providerError;\n    \n    @Builder.Default\n    private ProviderRequestStatus providerRequestStatus = \n            ProviderRequestStatus.REQUEST_SUCCESS;  // RETRY_ABLE_FAILURE or NON_RETRY_ABLE_FAILURE\n}\n```\n\n**Cashfree Error Mapping Example:**\n```java\n// In CashfreeProviderAdapter\nprivate ProviderRequestStatus mapToProviderRequestStatus(ResponseStatus responseStatus) {\n    switch (responseStatus) {\n        case SUCCESS:\n            return ProviderRequestStatus.REQUEST_SUCCESS;\n        case TIMEOUT:\n            return ProviderRequestStatus.RETRY_ABLE_FAILURE;\n        case NOT_FOUND:\n        case INVALID_REQUEST:\n            return ProviderRequestStatus.NON_RETRY_ABLE_FAILURE;\n        default:\n            return ProviderRequestStatus.RETRY_ABLE_FAILURE;\n    }\n}\n```\n\n**Cybersource Error Mapping:**\n```java\n// Failure status codes\nprivate static final List<String> FAILED_STATUES = Arrays.asList(\n    \"101\", \"102\", \"104\", \"150\", \"151\", \"152\", \"200\", \"201\", \"202\", \n    \"203\", \"204\", \"205\", \"207\", \"208\", \"209\", \"210\", \"211\", \"220\", \n    \"221\", \"222\", \"230\", \"231\", \"232\", \"233\", \"234\", \"235\", \"236\", \n    \"237\", \"238\", \"239\", \"240\", \"241\", \"242\", \"243\", \"246\", \"247\", \n    \"248\", \"250\", \"251\", \"254\", \"400\", \"450\", \"451\", \"452\", \"453\", \n    \"454\", \"455\", \"456\", \"457\", \"458\", \"459\", \"460\", \"461\", \"476\", \n    \"480\", \"481\", \"520\", \"700\", \"701\", \"702\", \"703\"\n);\n\n// Processing statuses (timeout, pending)\nprivate static final List<String> PROCESSING_STATUSES = Arrays.asList(\n    \"110\", \"475\", \"480\"\n);\n```\n\n### Retry Logic and Failure Handling\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/v2/ProviderRequestStatus.java`\n\n```java\npublic enum ProviderRequestStatus {\n    REQUEST_SUCCESS,          // No retry needed\n    RETRY_ABLE_FAILURE,       // Can retry (e.g., timeout)\n    NON_RETRY_ABLE_FAILURE    // Cannot retry (e.g., invalid request)\n}\n```\n\n**Retry Pattern in Base Adapter:**\n```java\npublic ProviderPaymentResponse executePaymentAttempt(\n        PaymentAttemptCreateContext context,\n        PilotMethodInterface<PaymentAttemptCreateContext, ProviderCustomerEntity, \n                ProviderPaymentResponse> pilotMethod,\n        FlowType flowType) {\n    \n    try {\n        ProviderPaymentResponse createResponse = pilotMethod.apply(context, providerCustomer);\n        providerEntityAuditService.auditProviderData(\n            createResponse.getProviderResponseObject(),\n            context.getPaymentAttemptEntity().getExternalId(),\n            paymentProviderKey,\n            flowType,\n            EntityType.PAYMENT_ATTEMPT);\n        return createResponse;\n    } catch (RateLimitException rle) {\n        // Rate limit → retryable\n        return ProviderPaymentResponse.builder()\n            .providerError(ProviderError.builder()\n                .message(rle.getMessage())\n                .code(rle.getErrorCode())\n                .retryable(true)\n                .build())\n            .providerRequestStatus(ProviderRequestStatus.RETRY_ABLE_FAILURE)\n            .build();\n    } catch (AppException ae) {\n        // App exception → check error type\n        return ProviderPaymentResponse.builder()\n            .providerError(ProviderError.builder()\n                .message(ae.getMessage())\n                .code(ae.getErrorCode())\n                .retryable(false)\n                .build())\n            .providerRequestStatus(ProviderRequestStatus.NON_RETRY_ABLE_FAILURE)\n            .build();\n    }\n}\n```\n\n### ProviderException and Error Response Transformation\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/error/ProviderException.java`\n\n```java\npublic class ProviderException extends AppException {\n    \n    public ProviderException(\n            final String message,\n            final HttpStatus statusCode,\n            final String errorCode,\n            final String header,\n            final Map<String, Object> information) {\n        super(message, statusCode, errorCode, header, information);\n    }\n}\n```\n\n**Error Response Transformation Pattern:**\n```java\n// In provider adapters\nprivate Optional<ProviderError> evaluateAndReturnErrorIfAny(\n        BaseResponse<?> baseResponse) {\n    if (Objects.nonNull(baseResponse.getError())) {\n        ErrorResponse error = baseResponse.getError();\n        return Optional.of(ProviderError.builder()\n            .message(error.getMessage())\n            .code(error.getCode())\n            .providerResponse(baseResponse)\n            .retryable(isRetryableErrorCode(error.getCode()))\n            .build());\n    }\n    return Optional.empty();\n}\n```\n\n---\n\n## ARCHITECTURAL PATTERNS SUMMARY\n\n### 1. **Factory Pattern** (PaymentProviderFactory)\n- Multi-dimensional lookup by (OrderType, ProviderKey, InstrumentType, ThreeDSType)\n- Support for variant registration (3DS1 vs 3DS2)\n\n### 2. **Strategy Pattern** (ProviderDeciderRouter)\n- Multiple routing strategies (LCM vs Decision Tree)\n- Fallback mechanism with priority ordering\n\n### 3. **Decorator Pattern** (Configuration Decorators)\n- Client-specific configuration decoration\n- Provider-specific JSON parsing strategies\n\n### 4. **Template Method Pattern** (IPaymentProviderAdapter)\n- Abstract base class defining payment lifecycle\n- Subclasses implement provider-specific logic\n\n### 5. **Builder Pattern** (Request Building)\n- Cybersource request builders for different operation types\n- Fluent interface for complex request construction\n\n### 6. **Caching Strategy** (Caffeine + LoadingCache)\n- TTL-based caching for decision trees and provider accounts\n- Automatic refresh-on-write mechanism\n\n### 7. **Provider Wrapping** (Provider Clients)\n- Each provider has a client wrapper (CashfreeClient, CybersourceClient)\n- Encapsulates provider API communication\n\n---\n\n## KEY FILE PATHS FOR EXPERT REFERENCE\n\n1. **Base Architecture:**\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/providers/IPaymentProviderAdapter.java`\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/providers/PaymentProviderFactory.java`\n\n2. **Decision Tree & Routing:**\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/planner/providerdecider/ProviderDeciderRouter.java`\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/planner/providerdecider/ProviderDeciderV2.java`\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/planner/providerdecider/ProviderDeciderViaLCM.java`\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/cache/DecisionTreeObjectCache.java`\n\n3. **Webhook Handling:**\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/controller/WebhookController.java`\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/controller/v2/CashfreeWebhookController.java`\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/service/WebhookService.java`\n\n4. **Configuration Management:**\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/ProviderAccountEntity.java`\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/PaymentProviderEntity.java`\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/entity/ClientPaymentProviderConfigEntity.java`\n\n5. **Provider Implementations:**\n   - **Cashfree:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/providers/CashfreeProviderAdapter.java`\n   - **Cybersource:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/providers/cybersource/CybersourceProviderAdapter.java`\n\n6. **Error Handling:**\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/providers/ProviderError.java`\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/providers/ProviderPaymentResponse.java`\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/error/ProviderException.java`\n\n7. **Response Structures:**\n   - `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/providers/ProviderRefundCreateResponse.java`\n\nThis architecture demonstrates enterprise-grade payment processing with support for multiple payment providers, sophisticated routing logic, comprehensive error handling, and robust webhook integration. The design prioritizes extensibility, maintainability, and separation of concerns."}],"totalDurationMs":158999,"totalTokens":93000,"totalToolUseCount":48,"usage":{"input_tokens":7,"cache_creation_input_tokens":2414,"cache_read_input_tokens":77279,"cache_creation":{"ephemeral_5m_input_tokens":2414,"ephemeral_1h_input_tokens":0},"output_tokens":13300}}}
{"parentUuid":"db4ccc12-e5a6-4d8a-98d8-05f5da6bb6bc","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01S2oXB46eWzDePueCZFiKuk","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The exploration agent returned comprehensive information about the Provider Integration architecture. Let me update the plan file with this deep-dive information.","signature":"Es0CCkgICxABGAIqQLS27kn3BmYxO5brjO0/O9+UR2YIPP+fi59zsHEabDcmEcGVi8xSLsG+HpkrmWiSBY9MYRzYPLmyKG/XdEp8x5MSDDaXvi54A42VmhT3/xoM1iMfUr79UX+Id41aIjD4O7ejnHy7dDKGCHLn6wj5qIhIv3plDeAR9pI46PrBYDWNLnXLyIiFYJ0t2+IWtz8qsgHokQawNxrai815uAffPUY7Rftw8LGVO5S1V32vNid6p06Y/LdAssZFHZAxCX47hdXctQRh3ZmfPwJkfgwTG6R0d+DoVyLn6EccqBFbEOpje6Fwff5DBNvQAz9lHD859o51cDGnftlsjp2XRRUs4TjjhYS9kR1+wIYAvtZZXUTNkHbN9BwPNmt83laW0vaD/VNCAC745OFGAuAgf/LlW1ZUCjWkB0au0vBy082sRE5DKdeaGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":62126,"cache_read_input_tokens":19463,"cache_creation":{"ephemeral_5m_input_tokens":62126,"ephemeral_1h_input_tokens":0},"output_tokens":2}},"type":"assistant","uuid":"36c1b4b5-7a61-4d02-8f7b-b62a8d5ef88f","timestamp":"2025-12-31T09:48:11.250Z"}
{"parentUuid":"36c1b4b5-7a61-4d02-8f7b-b62a8d5ef88f","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01S2oXB46eWzDePueCZFiKuk","type":"message","role":"assistant","content":[{"type":"text","text":"Excellent! Let me add this comprehensive Provider Integration deep-dive to your study guide."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":62126,"cache_read_input_tokens":19463,"cache_creation":{"ephemeral_5m_input_tokens":62126,"ephemeral_1h_input_tokens":0},"output_tokens":2}},"type":"assistant","uuid":"28c7b58f-c427-4291-9895-bdd078e4495e","timestamp":"2025-12-31T09:48:12.494Z"}
{"parentUuid":"28c7b58f-c427-4291-9895-bdd078e4495e","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01S2oXB46eWzDePueCZFiKuk","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_bdrk_01Jjtx4P1TefyxwLGwyo67u7","name":"Edit","input":{"file_path":"/Users/kiranbiliyawala/.claude/plans/distributed-marinating-mango.md","old_string":"### DynamoDB\n1. `dynamo/dao/AbstractDynamoDBDAO.java` - Base DAO pattern\n2. `dynamo/domain/PaymentAttemptWorkflowContextEntity.java` - DynamoDB entity","new_string":"### DynamoDB\n1. `dynamo/dao/AbstractDynamoDBDAO.java` - Base DAO pattern\n2. `dynamo/domain/PaymentAttemptWorkflowContextEntity.java` - DynamoDB entity\n\n---\n\n# PROVIDER INTEGRATION DEEP-DIVE\n\n## 25. PROVIDER ADAPTER ARCHITECTURE\n\n### Base Adapter Pattern\n**File:** `v2/workflow/create/providers/IPaymentProviderAdapter.java`\n\n```java\npublic abstract class IPaymentProviderAdapter<T, R> implements SelfReferencingBean {\n    protected final PaymentProviderKey paymentProviderKey;  // e.g., CASHFREE, CYBERSOURCE\n    private final InstrumentType instrumentType;            // e.g., CARD, UPI_APPS\n    private final OrderType orderType;                      // e.g., PAY, REFUND\n\n    // Core lifecycle methods\n    public abstract ProviderPaymentResponse createPaymentAttempt(context, customerEntity);\n    protected abstract Object syncPaymentAttemptWithProviderId(paymentAttemptEntity);\n    protected abstract ProviderRefundCreateResponse createRefund(refundAttemptEntity, context);\n    protected abstract R getAuthConfig(providerAccountEntity);\n}\n```\n\n### Factory Pattern for Adapter Selection\n**File:** `v2/workflow/create/providers/PaymentProviderFactory.java`\n\n```java\n@Component\npublic class PaymentProviderFactory {\n    // Multi-dimensional lookup: OrderType + ProviderKey + InstrumentType → Adapter\n    private Map<PaymentWorkflowKey, IPaymentProviderAdapter<?, ?>> paymentProviderMap;\n\n    // Secondary lookup: OrderType + ProviderKey → First adapter\n    private Table<OrderType, PaymentProviderKey, IPaymentProviderAdapter<?, ?>> paymentProviderByKey;\n\n    // 3DS variant support\n    private ThreeDSType threeDSType;  // 3DS1 vs 3DS2\n}\n```\n\n### Provider Response Structure\n```java\n@Data @Builder\npublic class ProviderPaymentResponse {\n    private Object providerResponseObject;     // Raw provider response\n    private String providerReferenceId;        // Provider's transaction ID\n    private String gatewayReferenceId;         // Gateway ID\n    private String providerStatus;             // Raw status (\"SUCCESS\")\n    private PaymentAttemptStatus status;       // Mapped internal status\n    private ProviderRequestStatus providerRequestStatus;  // REQUEST_SUCCESS, RETRY_ABLE_FAILURE\n    private ProviderError providerError;       // Error details if failed\n}\n```\n\n---\n\n## 26. DECISION TREE ROUTING\n\n### Router Strategy Pattern\n**File:** `planner/providerdecider/ProviderDeciderRouter.java`\n\n```java\n@Service\npublic class ProviderDeciderRouter {\n    public ProviderRoutingDecisionResult resolve(PaymentAttemptCreateContext context) {\n        // Priority 1: LCM routing (if instrument supported)\n        if (isInstrumentTypeSupportedInLCM(clientId, instrumentType)) {\n            return providerDeciderViaLCM.decideProvider(context);\n        }\n\n        // Priority 2: Decision Tree routing\n        if (isDecisionTreeEnabled) {\n            return providerDeciderV2.decideProvider(context);\n        }\n    }\n}\n```\n\n### Decision Tree Workflow\n**File:** `planner/providerdecider/ProviderDeciderV2.java`\n\n```\nRequest → Fetch Cached Decision Tree → Create DT Context → Execute Tree → Apply Dynamic Routing → Return Provider\n```\n\n**Decision Tree Factors:**\n- Client configuration\n- Instrument type (Card, UPI, NetBanking)\n- Card brand/BIN\n- Customer attributes\n- Order amount\n- Provider availability/downtime\n\n### Decision Tree Caching\n**File:** `cache/DecisionTreeObjectCache.java`\n\n| Cache | TTL | Content |\n|-------|-----|---------|\n| decision_tree_object_cache | 180-190 min | Parsed decision tree JSON + workflow |\n\n---\n\n## 27. PROVIDER ADAPTERS (24+ Implementations)\n\n### Adapter Directory Structure\n```\nv2/workflow/create/providers/\n├── IPaymentProviderAdapter.java          # Base abstract class\n├── PaymentProviderFactory.java           # Factory for adapter selection\n├── CashfreeProviderAdapter.java          # Cashfree base\n├── CashfreeCardProviderAdapter.java      # Cashfree cards\n├── CashfreeNetBankingProviderAdapter.java\n├── CashfreeUPIProviderAdapter.java\n├── CashfreeUPIAppsProviderAdapter.java\n├── cybersource/\n│   ├── CybersourceProviderAdapter.java   # Cybersource base (3DS)\n│   ├── CybersourceRequestBuilder.java    # Request construction\n│   └── CybersourceAuthorizeRequestBuilder.java\n├── PayuProviderAdapter.java\n├── PayuCardProviderAdapter.java\n├── PineLabsEdgeProviderAdapter.java\n├── CredPointsProviderAdapter.java\n├── RewardPointsProviderAdapter.java\n└── AuthTokenNativeProviderAdapter.java\n```\n\n### Cashfree Adapter Example\n**File:** `v2/workflow/create/providers/CashfreeProviderAdapter.java`\n\n```java\n@Component\npublic abstract class CashfreeProviderAdapter\n        extends IPaymentProviderAdapter<String, CashfreeAuthConfig> {\n\n    // Two-phase payment creation:\n    // 1. Create order at Cashfree\n    // 2. Create payment for that order\n\n    @Override\n    public ProviderPaymentResponse createPaymentAttempt(context, customer) {\n        // Phase 1: Create CF Order\n        Pair<BaseResponse<CreateOrderResponse>, ProviderError> orderResponse =\n            createCFOrder(context, authConfig);\n\n        // Phase 2: Create CF Payment\n        Pair<BaseResponse<CreatePaymentResponse>, ProviderError> paymentResponse =\n            createCFPayment(context, orderResponse.getLeft().getResponse(), authConfig);\n\n        return mapToProviderPaymentResponse(paymentResponse);\n    }\n}\n```\n\n### Cybersource Adapter (3DS Support)\n**File:** `v2/workflow/create/providers/cybersource/CybersourceProviderAdapter.java`\n\n```java\n@Component\npublic abstract class CybersourceProviderAdapter\n        extends I3DSPaymentProviderAdapter<String, AuthConfig> {\n\n    // Status code mappings\n    private static final List<String> FAILED_STATUSES = Arrays.asList(\n        \"101\", \"102\", \"104\", \"150\", \"200\", \"201\", ...  // 43 codes\n    );\n    private static final List<String> PROCESSING_STATUSES = Arrays.asList(\n        \"110\", \"475\", \"480\"\n    );\n\n    // 3DS2 redirection flow\n    protected void createRedirectionHtml(response, paymentAttemptEntity) {\n        if (authInfo.getSpecificationVersion().startsWith(\"2\")) {\n            // 3DS2 flow with step-up URL\n            html = authenticationService.createAuthenticationPageFor3ds2(\n                authInfo.getStepUpUrl(),\n                authInfo.getAccessToken(),\n                paymentAttemptEntity.getExternalId());\n        }\n    }\n}\n```\n\n---\n\n## 28. WEBHOOK HANDLING\n\n### Webhook Architecture\n```\nProvider → /webhooks/v2/{provider} → Provider-Specific Controller → WebhookService → State Machine Update\n```\n\n### Provider Webhook Controllers\n| Endpoint | Controller | Provider |\n|----------|------------|----------|\n| `/webhooks/v2/cashfree` | CashfreeWebhookController | Cashfree |\n| `/webhooks/v2/razorpay` | RazorpayWebhookController | Razorpay |\n| `/webhooks/v2/payu` | PayuWebhookController | PayU |\n| `/webhooks/v2/cybersource` | CybersourceWebhookController | Cybersource |\n| `/webhooks/v2/juspay` | JuspayWebhookController | Juspay |\n| `/webhooks/v2/ybl` | YBLWebhookController | Yes Bank UPI |\n| `/webhooks/v2/icici` | ICICIWebhookController | ICICI UPI |\n| `/webhooks/v2/rbl-upi` | RBLUpiWebhookController | RBL UPI |\n| `/webhooks/v2/digio` | DigioWebhookController | Digio (eMandate) |\n\n### Webhook Processing Flow\n**File:** `controller/v2/CashfreeWebhookController.java`\n\n```java\n@PostMapping\npublic void onWebhookReceive(@RequestBody CashfreeWebhook webhookRequest) {\n    switch (webhookRequest.getType()) {\n        case PAYMENT_SUCCESS_WEBHOOK:\n        case PAYMENT_FAILED_WEBHOOK:\n            // 1. Extract provider reference ID\n            String providerRefId = paymentWebhook.getData().getCfPaymentId();\n\n            // 2. Fetch payment attempt\n            PaymentAttempt attempt = paymentAttemptFetchWorkflow\n                .fetchByProviderReferenceId(providerRefId);\n\n            // 3. Audit webhook data\n            auditService.auditProviderData(webhookRequest, attempt.getId(), ...);\n\n            // 4. Sync status (triggers state machine)\n            break;\n\n        case REFUND_STATUS_WEBHOOK:\n            processRefundAttempt(webhookRequest);\n            break;\n    }\n}\n```\n\n### Idempotency Handling\n```java\n// In base adapter - only update if status actually changed\npublic void syncPaymentAttemptWithProvider(PaymentAttemptV2Entity entity) {\n    String currentStatus = entity.getProviderStatus();\n\n    Object providerResponse = syncPaymentAttemptWithProviderId(entity);\n\n    // Only audit and process if status changed\n    if (!Objects.equals(currentStatus, entity.getProviderStatus())) {\n        auditService.auditProviderData(...);\n    }\n}\n```\n\n---\n\n## 29. PROVIDER CONFIGURATION\n\n### Configuration Entities\n**File:** `entity/ProviderAccountEntity.java`\n\n```java\n@Entity @Table(name = \"provider_accounts\")\npublic class ProviderAccountEntity extends BaseEntity {\n    @ManyToOne\n    private PaymentProviderEntity paymentProvider;\n\n    private String providerAccountId;     // e.g., \"ACC_123456\"\n\n    @Lob\n    private byte[] accessToken;           // Encrypted credentials\n\n    private String endpoint;              // Provider API endpoint\n    private Boolean isProd;               // Production vs Sandbox\n    private Boolean active;\n    private String additionalConfig;      // JSON configuration\n    private String providerMid;           // Merchant ID at provider\n    private String settlementCategory;    // Settlement routing\n}\n```\n\n### Provider-Specific Configurations\n```java\n// Cashfree\n@Data\npublic class CashfreeProviderAccountConfiguration {\n    private String apiClientId;\n    private String apiVersion;\n    private ShortCircuitConfiguration shortCircuitConfiguration;\n}\n\n// Cybersource\n@Data\npublic class CybersourceProviderAccountConfiguration {\n    private String apiKey;\n    private String merchantId;\n    private Boolean enableRetries = false;\n    private Boolean enableCaptureWithAuth = true;\n    private Boolean enable3DS2 = true;\n    private Boolean enableRedirectionFlow = false;\n}\n```\n\n### Client-Provider Mapping\n**File:** `entity/ClientPaymentProviderConfigEntity.java`\n\n```java\n@Entity @Table(name = \"client_payment_provider_config\")\npublic class ClientPaymentProviderConfigEntity extends BaseEntity {\n    @ManyToOne private ClientEntity client;\n    @ManyToOne private PaymentProviderEntity paymentProvider;\n    private String providerConfig;  // JSON configuration per client\n}\n```\n\n---\n\n## 30. ERROR HANDLING & RETRY LOGIC\n\n### Error Classification\n```java\npublic enum ProviderRequestStatus {\n    REQUEST_SUCCESS,          // Payment processed\n    RETRY_ABLE_FAILURE,       // Timeout, rate limit - can retry\n    NON_RETRY_ABLE_FAILURE    // Invalid request - cannot retry\n}\n```\n\n### Provider Error Structure\n```java\n@Data @Builder\npublic class ProviderError {\n    private String message;           // User-friendly message\n    private String code;              // Provider error code\n    private Object providerResponse;  // Raw error response\n    private Boolean retryable;        // Retry classification\n}\n```\n\n### Error Code Mapping (Cybersource Example)\n```java\n// Failure codes (43 codes)\n\"101\", \"102\", \"104\", \"150\", \"200\", \"201\", \"202\", \"203\", ...\n\n// Processing/Pending codes\n\"110\" (Pending), \"475\" (Timeout), \"480\" (Processing)\n```\n\n### Retry Pattern\n```java\npublic ProviderPaymentResponse executePaymentAttempt(...) {\n    try {\n        return pilotMethod.apply(context, providerCustomer);\n    } catch (RateLimitException rle) {\n        return ProviderPaymentResponse.builder()\n            .providerRequestStatus(ProviderRequestStatus.RETRY_ABLE_FAILURE)\n            .providerError(ProviderError.builder()\n                .retryable(true).build())\n            .build();\n    } catch (AppException ae) {\n        return ProviderPaymentResponse.builder()\n            .providerRequestStatus(ProviderRequestStatus.NON_RETRY_ABLE_FAILURE)\n            .build();\n    }\n}\n```\n\n---\n\n## 31. ARCHITECTURAL PATTERNS SUMMARY\n\n| Pattern | Usage | File |\n|---------|-------|------|\n| **Factory** | Adapter selection by (OrderType, Provider, Instrument) | PaymentProviderFactory.java |\n| **Strategy** | LCM vs Decision Tree routing | ProviderDeciderRouter.java |\n| **Template Method** | Base adapter lifecycle | IPaymentProviderAdapter.java |\n| **Builder** | Complex request construction | CybersourceRequestBuilder.java |\n| **Decorator** | Provider-specific configuration | *ConfigValueDecoratorImpl.java |\n\n---\n\n## 32. KEY PROVIDER INTEGRATION FILES\n\n### Core Architecture\n1. `v2/workflow/create/providers/IPaymentProviderAdapter.java` - Base adapter\n2. `v2/workflow/create/providers/PaymentProviderFactory.java` - Factory\n3. `planner/providerdecider/ProviderDeciderRouter.java` - Routing strategy\n\n### Decision Tree\n1. `planner/providerdecider/ProviderDeciderV2.java` - DT workflow\n2. `planner/providerdecider/ProviderDeciderViaLCM.java` - LCM routing\n3. `cache/DecisionTreeObjectCache.java` - DT caching\n\n### Webhooks\n1. `controller/WebhookController.java` - Generic webhook endpoint\n2. `controller/v2/CashfreeWebhookController.java` - Cashfree webhooks\n3. `service/WebhookService.java` - Webhook processing\n\n### Provider Implementations\n1. `v2/workflow/create/providers/CashfreeProviderAdapter.java`\n2. `v2/workflow/create/providers/cybersource/CybersourceProviderAdapter.java`\n3. `v2/workflow/create/providers/PayuProviderAdapter.java`\n\n### Configuration\n1. `entity/ProviderAccountEntity.java` - Provider credentials\n2. `entity/PaymentProviderEntity.java` - Provider definition\n3. `entity/ClientPaymentProviderConfigEntity.java` - Client-provider mapping"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":62126,"cache_read_input_tokens":19463,"cache_creation":{"ephemeral_5m_input_tokens":62126,"ephemeral_1h_input_tokens":0},"output_tokens":4176}},"type":"assistant","uuid":"b9f78ed5-5832-4c35-89e6-faba195b6955","timestamp":"2025-12-31T09:49:05.746Z"}
{"parentUuid":"b9f78ed5-5832-4c35-89e6-faba195b6955","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01Jjtx4P1TefyxwLGwyo67u7","type":"tool_result","content":"The file /Users/kiranbiliyawala/.claude/plans/distributed-marinating-mango.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   659→### Caches\n   660→1. `cache/ClientConfigurationCache.java` - Cache pattern example\n   661→2. `configuration/CacheConfig.java` - Cache configuration\n   662→\n   663→### DynamoDB\n   664→1. `dynamo/dao/AbstractDynamoDBDAO.java` - Base DAO pattern\n   665→2. `dynamo/domain/PaymentAttemptWorkflowContextEntity.java` - DynamoDB entity\n   666→\n   667→---\n   668→\n   669→# PROVIDER INTEGRATION DEEP-DIVE\n   670→\n   671→## 25. PROVIDER ADAPTER ARCHITECTURE\n   672→\n   673→### Base Adapter Pattern\n   674→**File:** `v2/workflow/create/providers/IPaymentProviderAdapter.java`\n   675→\n   676→```java\n   677→public abstract class IPaymentProviderAdapter<T, R> implements SelfReferencingBean {\n   678→    protected final PaymentProviderKey paymentProviderKey;  // e.g., CASHFREE, CYBERSOURCE\n   679→    private final InstrumentType instrumentType;            // e.g., CARD, UPI_APPS\n   680→    private final OrderType orderType;                      // e.g., PAY, REFUND\n   681→\n   682→    // Core lifecycle methods\n   683→    public abstract ProviderPaymentResponse createPaymentAttempt(context, customerEntity);\n   684→    protected abstract Object syncPaymentAttemptWithProviderId(paymentAttemptEntity);\n   685→    protected abstract ProviderRefundCreateResponse createRefund(refundAttemptEntity, context);\n   686→    protected abstract R getAuthConfig(providerAccountEntity);\n   687→}\n   688→```\n   689→\n   690→### Factory Pattern for Adapter Selection\n   691→**File:** `v2/workflow/create/providers/PaymentProviderFactory.java`\n   692→\n   693→```java\n   694→@Component\n   695→public class PaymentProviderFactory {\n   696→    // Multi-dimensional lookup: OrderType + ProviderKey + InstrumentType → Adapter\n   697→    private Map<PaymentWorkflowKey, IPaymentProviderAdapter<?, ?>> paymentProviderMap;\n   698→\n   699→    // Secondary lookup: OrderType + ProviderKey → First adapter\n   700→    private Table<OrderType, PaymentProviderKey, IPaymentProviderAdapter<?, ?>> paymentProviderByKey;\n   701→\n   702→    // 3DS variant support\n   703→    private ThreeDSType threeDSType;  // 3DS1 vs 3DS2\n   704→}\n   705→```\n   706→\n   707→### Provider Response Structure\n   708→```java\n   709→@Data @Builder\n   710→public class ProviderPaymentResponse {\n   711→    private Object providerResponseObject;     // Raw provider response\n   712→    private String providerReferenceId;        // Provider's transaction ID\n   713→    private String gatewayReferenceId;         // Gateway ID\n   714→    private String providerStatus;             // Raw status (\"SUCCESS\")\n   715→    private PaymentAttemptStatus status;       // Mapped internal status\n   716→    private ProviderRequestStatus providerRequestStatus;  // REQUEST_SUCCESS, RETRY_ABLE_FAILURE\n   717→    private ProviderError providerError;       // Error details if failed\n   718→}\n   719→```\n   720→\n   721→---\n   722→\n   723→## 26. DECISION TREE ROUTING\n   724→\n   725→### Router Strategy Pattern\n   726→**File:** `planner/providerdecider/ProviderDeciderRouter.java`\n   727→\n   728→```java\n   729→@Service\n   730→public class ProviderDeciderRouter {\n   731→    public ProviderRoutingDecisionResult resolve(PaymentAttemptCreateContext context) {\n   732→        // Priority 1: LCM routing (if instrument supported)\n   733→        if (isInstrumentTypeSupportedInLCM(clientId, instrumentType)) {\n   734→            return providerDeciderViaLCM.decideProvider(context);\n   735→        }\n   736→\n   737→        // Priority 2: Decision Tree routing\n   738→        if (isDecisionTreeEnabled) {\n   739→            return providerDeciderV2.decideProvider(context);\n   740→        }\n   741→    }\n   742→}\n   743→```\n   744→\n   745→### Decision Tree Workflow\n   746→**File:** `planner/providerdecider/ProviderDeciderV2.java`\n   747→\n   748→```\n   749→Request → Fetch Cached Decision Tree → Create DT Context → Execute Tree → Apply Dynamic Routing → Return Provider\n   750→```\n   751→\n   752→**Decision Tree Factors:**\n   753→- Client configuration\n   754→- Instrument type (Card, UPI, NetBanking)\n   755→- Card brand/BIN\n   756→- Customer attributes\n   757→- Order amount\n   758→- Provider availability/downtime\n   759→\n   760→### Decision Tree Caching\n   761→**File:** `cache/DecisionTreeObjectCache.java`\n   762→\n   763→| Cache | TTL | Content |\n   764→|-------|-----|---------|\n   765→| decision_tree_object_cache | 180-190 min | Parsed decision tree JSON + workflow |\n   766→\n   767→---\n   768→\n   769→## 27. PROVIDER ADAPTERS (24+ Implementations)\n   770→\n   771→### Adapter Directory Structure\n   772→```\n   773→v2/workflow/create/providers/\n   774→├── IPaymentProviderAdapter.java          # Base abstract class\n   775→├── PaymentProviderFactory.java           # Factory for adapter selection\n   776→├── CashfreeProviderAdapter.java          # Cashfree base\n   777→├── CashfreeCardProviderAdapter.java      # Cashfree cards\n   778→├── CashfreeNetBankingProviderAdapter.java\n   779→├── CashfreeUPIProviderAdapter.java\n   780→├── CashfreeUPIAppsProviderAdapter.java\n   781→├── cybersource/\n   782→│   ├── CybersourceProviderAdapter.java   # Cybersource base (3DS)\n   783→│   ├── CybersourceRequestBuilder.java    # Request construction\n   784→│   └── CybersourceAuthorizeRequestBuilder.java\n   785→├── PayuProviderAdapter.java\n   786→├── PayuCardProviderAdapter.java\n   787→├── PineLabsEdgeProviderAdapter.java\n   788→├── CredPointsProviderAdapter.java\n   789→├── RewardPointsProviderAdapter.java\n   790→└── AuthTokenNativeProviderAdapter.java\n   791→```\n   792→\n   793→### Cashfree Adapter Example\n   794→**File:** `v2/workflow/create/providers/CashfreeProviderAdapter.java`\n   795→\n   796→```java\n   797→@Component\n   798→public abstract class CashfreeProviderAdapter\n   799→        extends IPaymentProviderAdapter<String, CashfreeAuthConfig> {\n   800→\n   801→    // Two-phase payment creation:\n   802→    // 1. Create order at Cashfree\n   803→    // 2. Create payment for that order\n   804→\n   805→    @Override\n   806→    public ProviderPaymentResponse createPaymentAttempt(context, customer) {\n   807→        // Phase 1: Create CF Order\n   808→        Pair<BaseResponse<CreateOrderResponse>, ProviderError> orderResponse =\n   809→            createCFOrder(context, authConfig);\n   810→\n   811→        // Phase 2: Create CF Payment\n   812→        Pair<BaseResponse<CreatePaymentResponse>, ProviderError> paymentResponse =\n   813→            createCFPayment(context, orderResponse.getLeft().getResponse(), authConfig);\n   814→\n   815→        return mapToProviderPaymentResponse(paymentResponse);\n   816→    }\n   817→}\n   818→```\n   819→\n   820→### Cybersource Adapter (3DS Support)\n   821→**File:** `v2/workflow/create/providers/cybersource/CybersourceProviderAdapter.java`\n   822→\n   823→```java\n   824→@Component\n   825→public abstract class CybersourceProviderAdapter\n   826→        extends I3DSPaymentProviderAdapter<String, AuthConfig> {\n   827→\n   828→    // Status code mappings\n   829→    private static final List<String> FAILED_STATUSES = Arrays.asList(\n   830→        \"101\", \"102\", \"104\", \"150\", \"200\", \"201\", ...  // 43 codes\n   831→    );\n   832→    private static final List<String> PROCESSING_STATUSES = Arrays.asList(\n   833→        \"110\", \"475\", \"480\"\n   834→    );\n   835→\n   836→    // 3DS2 redirection flow\n   837→    protected void createRedirectionHtml(response, paymentAttemptEntity) {\n   838→        if (authInfo.getSpecificationVersion().startsWith(\"2\")) {\n   839→            // 3DS2 flow with step-up URL\n   840→            html = authenticationService.createAuthenticationPageFor3ds2(\n   841→                authInfo.getStepUpUrl(),\n   842→                authInfo.getAccessToken(),\n   843→                paymentAttemptEntity.getExternalId());\n   844→        }\n   845→    }\n   846→}\n   847→```\n   848→\n   849→---\n   850→\n   851→## 28. WEBHOOK HANDLING\n   852→\n   853→### Webhook Architecture\n   854→```\n   855→Provider → /webhooks/v2/{provider} → Provider-Specific Controller → WebhookService → State Machine Update\n   856→```\n   857→\n   858→### Provider Webhook Controllers\n   859→| Endpoint | Controller | Provider |\n   860→|----------|------------|----------|\n   861→| `/webhooks/v2/cashfree` | CashfreeWebhookController | Cashfree |\n   862→| `/webhooks/v2/razorpay` | RazorpayWebhookController | Razorpay |\n   863→| `/webhooks/v2/payu` | PayuWebhookController | PayU |\n   864→| `/webhooks/v2/cybersource` | CybersourceWebhookController | Cybersource |\n   865→| `/webhooks/v2/juspay` | JuspayWebhookController | Juspay |\n   866→| `/webhooks/v2/ybl` | YBLWebhookController | Yes Bank UPI |\n   867→| `/webhooks/v2/icici` | ICICIWebhookController | ICICI UPI |\n   868→| `/webhooks/v2/rbl-upi` | RBLUpiWebhookController | RBL UPI |\n   869→| `/webhooks/v2/digio` | DigioWebhookController | Digio (eMandate) |\n   870→\n   871→### Webhook Processing Flow\n   872→**File:** `controller/v2/CashfreeWebhookController.java`\n   873→\n   874→```java\n   875→@PostMapping\n   876→public void onWebhookReceive(@RequestBody CashfreeWebhook webhookRequest) {\n   877→    switch (webhookRequest.getType()) {\n   878→        case PAYMENT_SUCCESS_WEBHOOK:\n   879→        case PAYMENT_FAILED_WEBHOOK:\n   880→            // 1. Extract provider reference ID\n   881→            String providerRefId = paymentWebhook.getData().getCfPaymentId();\n   882→\n   883→            // 2. Fetch payment attempt\n   884→            PaymentAttempt attempt = paymentAttemptFetchWorkflow\n   885→                .fetchByProviderReferenceId(providerRefId);\n   886→\n   887→            // 3. Audit webhook data\n   888→            auditService.auditProviderData(webhookRequest, attempt.getId(), ...);\n   889→\n   890→            // 4. Sync status (triggers state machine)\n   891→            break;\n   892→\n   893→        case REFUND_STATUS_WEBHOOK:\n   894→            processRefundAttempt(webhookRequest);\n   895→            break;\n   896→    }\n   897→}\n   898→```\n   899→\n   900→### Idempotency Handling\n   901→```java\n   902→// In base adapter - only update if status actually changed\n   903→public void syncPaymentAttemptWithProvider(PaymentAttemptV2Entity entity) {\n   904→    String currentStatus = entity.getProviderStatus();\n   905→\n   906→    Object providerResponse = syncPaymentAttemptWithProviderId(entity);\n   907→\n   908→    // Only audit and process if status changed\n   909→    if (!Objects.equals(currentStatus, entity.getProviderStatus())) {\n   910→        auditService.auditProviderData(...);\n   911→    }\n   912→}\n   913→```\n   914→\n   915→---\n   916→\n   917→## 29. PROVIDER CONFIGURATION\n   918→\n   919→### Configuration Entities\n   920→**File:** `entity/ProviderAccountEntity.java`\n   921→\n   922→```java\n   923→@Entity @Table(name = \"provider_accounts\")\n   924→public class ProviderAccountEntity extends BaseEntity {\n   925→    @ManyToOne\n   926→    private PaymentProviderEntity paymentProvider;\n   927→\n   928→    private String providerAccountId;     // e.g., \"ACC_123456\"\n   929→\n   930→    @Lob\n   931→    private byte[] accessToken;           // Encrypted credentials\n   932→\n   933→    private String endpoint;              // Provider API endpoint\n   934→    private Boolean isProd;               // Production vs Sandbox\n   935→    private Boolean active;\n   936→    private String additionalConfig;      // JSON configuration\n   937→    private String providerMid;           // Merchant ID at provider\n   938→    private String settlementCategory;    // Settlement routing\n   939→}\n   940→```\n   941→\n   942→### Provider-Specific Configurations\n   943→```java\n   944→// Cashfree\n   945→@Data\n   946→public class CashfreeProviderAccountConfiguration {\n   947→    private String apiClientId;\n   948→    private String apiVersion;\n   949→    private ShortCircuitConfiguration shortCircuitConfiguration;\n   950→}\n   951→\n   952→// Cybersource\n   953→@Data\n   954→public class CybersourceProviderAccountConfiguration {\n   955→    private String apiKey;\n   956→    private String merchantId;\n   957→    private Boolean enableRetries = false;\n   958→    private Boolean enableCaptureWithAuth = true;\n   959→    private Boolean enable3DS2 = true;\n   960→    private Boolean enableRedirectionFlow = false;\n   961→}\n   962→```\n   963→\n   964→### Client-Provider Mapping\n   965→**File:** `entity/ClientPaymentProviderConfigEntity.java`\n   966→\n   967→```java\n   968→@Entity @Table(name = \"client_payment_provider_config\")\n   969→public class ClientPaymentProviderConfigEntity extends BaseEntity {\n   970→    @ManyToOne private ClientEntity client;\n   971→    @ManyToOne private PaymentProviderEntity paymentProvider;\n   972→    private String providerConfig;  // JSON configuration per client\n   973→}\n   974→```\n   975→\n   976→---\n   977→\n   978→## 30. ERROR HANDLING & RETRY LOGIC\n   979→\n   980→### Error Classification\n   981→```java\n   982→public enum ProviderRequestStatus {\n   983→    REQUEST_SUCCESS,          // Payment processed\n   984→    RETRY_ABLE_FAILURE,       // Timeout, rate limit - can retry\n   985→    NON_RETRY_ABLE_FAILURE    // Invalid request - cannot retry\n   986→}\n   987→```\n   988→\n   989→### Provider Error Structure\n   990→```java\n   991→@Data @Builder\n   992→public class ProviderError {\n   993→    private String message;           // User-friendly message\n   994→    private String code;              // Provider error code\n   995→    private Object providerResponse;  // Raw error response\n   996→    private Boolean retryable;        // Retry classification\n   997→}\n   998→```\n   999→\n  1000→### Error Code Mapping (Cybersource Example)\n  1001→```java\n  1002→// Failure codes (43 codes)\n  1003→\"101\", \"102\", \"104\", \"150\", \"200\", \"201\", \"202\", \"203\", ...\n  1004→\n  1005→// Processing/Pending codes\n  1006→\"110\" (Pending), \"475\" (Timeout), \"480\" (Processing)\n  1007→```\n  1008→\n  1009→### Retry Pattern\n  1010→```java\n  1011→public ProviderPaymentResponse executePaymentAttempt(...) {\n  1012→    try {\n  1013→        return pilotMethod.apply(context, providerCustomer);\n  1014→    } catch (RateLimitException rle) {\n  1015→        return ProviderPaymentResponse.builder()\n  1016→            .providerRequestStatus(ProviderRequestStatus.RETRY_ABLE_FAILURE)\n  1017→            .providerError(ProviderError.builder()\n  1018→                .retryable(true).build())\n  1019→            .build();\n  1020→    } catch (AppException ae) {\n  1021→        return ProviderPaymentResponse.builder()\n  1022→            .providerRequestStatus(ProviderRequestStatus.NON_RETRY_ABLE_FAILURE)\n  1023→            .build();\n  1024→    }\n  1025→}\n  1026→```\n  1027→\n  1028→---\n  1029→\n  1030→## 31. ARCHITECTURAL PATTERNS SUMMARY\n  1031→\n  1032→| Pattern | Usage | File |\n  1033→|---------|-------|------|\n  1034→| **Factory** | Adapter selection by (OrderType, Provider, Instrument) | PaymentProviderFactory.java |\n  1035→| **Strategy** | LCM vs Decision Tree routing | ProviderDeciderRouter.java |\n  1036→| **Template Method** | Base adapter lifecycle | IPaymentProviderAdapter.java |\n  1037→| **Builder** | Complex request construction | CybersourceRequestBuilder.java |\n  1038→| **Decorator** | Provider-specific configuration | *ConfigValueDecoratorImpl.java |\n  1039→\n  1040→---\n  1041→\n  1042→## 32. KEY PROVIDER INTEGRATION FILES\n  1043→\n  1044→### Core Architecture\n  1045→1. `v2/workflow/create/providers/IPaymentProviderAdapter.java` - Base adapter\n  1046→2. `v2/workflow/create/providers/PaymentProviderFactory.java` - Factory\n  1047→3. `planner/providerdecider/ProviderDeciderRouter.java` - Routing strategy\n  1048→\n  1049→### Decision Tree\n  1050→1. `planner/providerdecider/ProviderDeciderV2.java` - DT workflow\n  1051→2. `planner/providerdecider/ProviderDeciderViaLCM.java` - LCM routing\n  1052→3. `cache/DecisionTreeObjectCache.java` - DT caching\n  1053→\n  1054→### Webhooks\n  1055→1. `controller/WebhookController.java` - Generic webhook endpoint\n  1056→2. `controller/v2/CashfreeWebhookController.java` - Cashfree webhooks\n  1057→3. `service/WebhookService.java` - Webhook processing\n  1058→\n  1059→### Provider Implementations\n  1060→1. `v2/workflow/create/providers/CashfreeProviderAdapter.java`\n  1061→2. `v2/workflow/create/providers/cybersource/CybersourceProviderAdapter.java`\n  1062→3. `v2/workflow/create/providers/PayuProviderAdapter.java`\n  1063→\n  1064→### Configuration\n  1065→1. `entity/ProviderAccountEntity.java` - Provider credentials\n  1066→2. `entity/PaymentProviderEntity.java` - Provider definition\n  1067→3. `entity/ClientPaymentProviderConfigEntity.java` - Client-provider mapping\n  1068→"}]},"uuid":"6b40b5ca-190e-4487-b7b6-f83953a79fa3","timestamp":"2025-12-31T09:49:06.231Z","toolUseResult":{"filePath":"/Users/kiranbiliyawala/.claude/plans/distributed-marinating-mango.md","oldString":"### DynamoDB\n1. `dynamo/dao/AbstractDynamoDBDAO.java` - Base DAO pattern\n2. `dynamo/domain/PaymentAttemptWorkflowContextEntity.java` - DynamoDB entity","newString":"### DynamoDB\n1. `dynamo/dao/AbstractDynamoDBDAO.java` - Base DAO pattern\n2. `dynamo/domain/PaymentAttemptWorkflowContextEntity.java` - DynamoDB entity\n\n---\n\n# PROVIDER INTEGRATION DEEP-DIVE\n\n## 25. PROVIDER ADAPTER ARCHITECTURE\n\n### Base Adapter Pattern\n**File:** `v2/workflow/create/providers/IPaymentProviderAdapter.java`\n\n```java\npublic abstract class IPaymentProviderAdapter<T, R> implements SelfReferencingBean {\n    protected final PaymentProviderKey paymentProviderKey;  // e.g., CASHFREE, CYBERSOURCE\n    private final InstrumentType instrumentType;            // e.g., CARD, UPI_APPS\n    private final OrderType orderType;                      // e.g., PAY, REFUND\n\n    // Core lifecycle methods\n    public abstract ProviderPaymentResponse createPaymentAttempt(context, customerEntity);\n    protected abstract Object syncPaymentAttemptWithProviderId(paymentAttemptEntity);\n    protected abstract ProviderRefundCreateResponse createRefund(refundAttemptEntity, context);\n    protected abstract R getAuthConfig(providerAccountEntity);\n}\n```\n\n### Factory Pattern for Adapter Selection\n**File:** `v2/workflow/create/providers/PaymentProviderFactory.java`\n\n```java\n@Component\npublic class PaymentProviderFactory {\n    // Multi-dimensional lookup: OrderType + ProviderKey + InstrumentType → Adapter\n    private Map<PaymentWorkflowKey, IPaymentProviderAdapter<?, ?>> paymentProviderMap;\n\n    // Secondary lookup: OrderType + ProviderKey → First adapter\n    private Table<OrderType, PaymentProviderKey, IPaymentProviderAdapter<?, ?>> paymentProviderByKey;\n\n    // 3DS variant support\n    private ThreeDSType threeDSType;  // 3DS1 vs 3DS2\n}\n```\n\n### Provider Response Structure\n```java\n@Data @Builder\npublic class ProviderPaymentResponse {\n    private Object providerResponseObject;     // Raw provider response\n    private String providerReferenceId;        // Provider's transaction ID\n    private String gatewayReferenceId;         // Gateway ID\n    private String providerStatus;             // Raw status (\"SUCCESS\")\n    private PaymentAttemptStatus status;       // Mapped internal status\n    private ProviderRequestStatus providerRequestStatus;  // REQUEST_SUCCESS, RETRY_ABLE_FAILURE\n    private ProviderError providerError;       // Error details if failed\n}\n```\n\n---\n\n## 26. DECISION TREE ROUTING\n\n### Router Strategy Pattern\n**File:** `planner/providerdecider/ProviderDeciderRouter.java`\n\n```java\n@Service\npublic class ProviderDeciderRouter {\n    public ProviderRoutingDecisionResult resolve(PaymentAttemptCreateContext context) {\n        // Priority 1: LCM routing (if instrument supported)\n        if (isInstrumentTypeSupportedInLCM(clientId, instrumentType)) {\n            return providerDeciderViaLCM.decideProvider(context);\n        }\n\n        // Priority 2: Decision Tree routing\n        if (isDecisionTreeEnabled) {\n            return providerDeciderV2.decideProvider(context);\n        }\n    }\n}\n```\n\n### Decision Tree Workflow\n**File:** `planner/providerdecider/ProviderDeciderV2.java`\n\n```\nRequest → Fetch Cached Decision Tree → Create DT Context → Execute Tree → Apply Dynamic Routing → Return Provider\n```\n\n**Decision Tree Factors:**\n- Client configuration\n- Instrument type (Card, UPI, NetBanking)\n- Card brand/BIN\n- Customer attributes\n- Order amount\n- Provider availability/downtime\n\n### Decision Tree Caching\n**File:** `cache/DecisionTreeObjectCache.java`\n\n| Cache | TTL | Content |\n|-------|-----|---------|\n| decision_tree_object_cache | 180-190 min | Parsed decision tree JSON + workflow |\n\n---\n\n## 27. PROVIDER ADAPTERS (24+ Implementations)\n\n### Adapter Directory Structure\n```\nv2/workflow/create/providers/\n├── IPaymentProviderAdapter.java          # Base abstract class\n├── PaymentProviderFactory.java           # Factory for adapter selection\n├── CashfreeProviderAdapter.java          # Cashfree base\n├── CashfreeCardProviderAdapter.java      # Cashfree cards\n├── CashfreeNetBankingProviderAdapter.java\n├── CashfreeUPIProviderAdapter.java\n├── CashfreeUPIAppsProviderAdapter.java\n├── cybersource/\n│   ├── CybersourceProviderAdapter.java   # Cybersource base (3DS)\n│   ├── CybersourceRequestBuilder.java    # Request construction\n│   └── CybersourceAuthorizeRequestBuilder.java\n├── PayuProviderAdapter.java\n├── PayuCardProviderAdapter.java\n├── PineLabsEdgeProviderAdapter.java\n├── CredPointsProviderAdapter.java\n├── RewardPointsProviderAdapter.java\n└── AuthTokenNativeProviderAdapter.java\n```\n\n### Cashfree Adapter Example\n**File:** `v2/workflow/create/providers/CashfreeProviderAdapter.java`\n\n```java\n@Component\npublic abstract class CashfreeProviderAdapter\n        extends IPaymentProviderAdapter<String, CashfreeAuthConfig> {\n\n    // Two-phase payment creation:\n    // 1. Create order at Cashfree\n    // 2. Create payment for that order\n\n    @Override\n    public ProviderPaymentResponse createPaymentAttempt(context, customer) {\n        // Phase 1: Create CF Order\n        Pair<BaseResponse<CreateOrderResponse>, ProviderError> orderResponse =\n            createCFOrder(context, authConfig);\n\n        // Phase 2: Create CF Payment\n        Pair<BaseResponse<CreatePaymentResponse>, ProviderError> paymentResponse =\n            createCFPayment(context, orderResponse.getLeft().getResponse(), authConfig);\n\n        return mapToProviderPaymentResponse(paymentResponse);\n    }\n}\n```\n\n### Cybersource Adapter (3DS Support)\n**File:** `v2/workflow/create/providers/cybersource/CybersourceProviderAdapter.java`\n\n```java\n@Component\npublic abstract class CybersourceProviderAdapter\n        extends I3DSPaymentProviderAdapter<String, AuthConfig> {\n\n    // Status code mappings\n    private static final List<String> FAILED_STATUSES = Arrays.asList(\n        \"101\", \"102\", \"104\", \"150\", \"200\", \"201\", ...  // 43 codes\n    );\n    private static final List<String> PROCESSING_STATUSES = Arrays.asList(\n        \"110\", \"475\", \"480\"\n    );\n\n    // 3DS2 redirection flow\n    protected void createRedirectionHtml(response, paymentAttemptEntity) {\n        if (authInfo.getSpecificationVersion().startsWith(\"2\")) {\n            // 3DS2 flow with step-up URL\n            html = authenticationService.createAuthenticationPageFor3ds2(\n                authInfo.getStepUpUrl(),\n                authInfo.getAccessToken(),\n                paymentAttemptEntity.getExternalId());\n        }\n    }\n}\n```\n\n---\n\n## 28. WEBHOOK HANDLING\n\n### Webhook Architecture\n```\nProvider → /webhooks/v2/{provider} → Provider-Specific Controller → WebhookService → State Machine Update\n```\n\n### Provider Webhook Controllers\n| Endpoint | Controller | Provider |\n|----------|------------|----------|\n| `/webhooks/v2/cashfree` | CashfreeWebhookController | Cashfree |\n| `/webhooks/v2/razorpay` | RazorpayWebhookController | Razorpay |\n| `/webhooks/v2/payu` | PayuWebhookController | PayU |\n| `/webhooks/v2/cybersource` | CybersourceWebhookController | Cybersource |\n| `/webhooks/v2/juspay` | JuspayWebhookController | Juspay |\n| `/webhooks/v2/ybl` | YBLWebhookController | Yes Bank UPI |\n| `/webhooks/v2/icici` | ICICIWebhookController | ICICI UPI |\n| `/webhooks/v2/rbl-upi` | RBLUpiWebhookController | RBL UPI |\n| `/webhooks/v2/digio` | DigioWebhookController | Digio (eMandate) |\n\n### Webhook Processing Flow\n**File:** `controller/v2/CashfreeWebhookController.java`\n\n```java\n@PostMapping\npublic void onWebhookReceive(@RequestBody CashfreeWebhook webhookRequest) {\n    switch (webhookRequest.getType()) {\n        case PAYMENT_SUCCESS_WEBHOOK:\n        case PAYMENT_FAILED_WEBHOOK:\n            // 1. Extract provider reference ID\n            String providerRefId = paymentWebhook.getData().getCfPaymentId();\n\n            // 2. Fetch payment attempt\n            PaymentAttempt attempt = paymentAttemptFetchWorkflow\n                .fetchByProviderReferenceId(providerRefId);\n\n            // 3. Audit webhook data\n            auditService.auditProviderData(webhookRequest, attempt.getId(), ...);\n\n            // 4. Sync status (triggers state machine)\n            break;\n\n        case REFUND_STATUS_WEBHOOK:\n            processRefundAttempt(webhookRequest);\n            break;\n    }\n}\n```\n\n### Idempotency Handling\n```java\n// In base adapter - only update if status actually changed\npublic void syncPaymentAttemptWithProvider(PaymentAttemptV2Entity entity) {\n    String currentStatus = entity.getProviderStatus();\n\n    Object providerResponse = syncPaymentAttemptWithProviderId(entity);\n\n    // Only audit and process if status changed\n    if (!Objects.equals(currentStatus, entity.getProviderStatus())) {\n        auditService.auditProviderData(...);\n    }\n}\n```\n\n---\n\n## 29. PROVIDER CONFIGURATION\n\n### Configuration Entities\n**File:** `entity/ProviderAccountEntity.java`\n\n```java\n@Entity @Table(name = \"provider_accounts\")\npublic class ProviderAccountEntity extends BaseEntity {\n    @ManyToOne\n    private PaymentProviderEntity paymentProvider;\n\n    private String providerAccountId;     // e.g., \"ACC_123456\"\n\n    @Lob\n    private byte[] accessToken;           // Encrypted credentials\n\n    private String endpoint;              // Provider API endpoint\n    private Boolean isProd;               // Production vs Sandbox\n    private Boolean active;\n    private String additionalConfig;      // JSON configuration\n    private String providerMid;           // Merchant ID at provider\n    private String settlementCategory;    // Settlement routing\n}\n```\n\n### Provider-Specific Configurations\n```java\n// Cashfree\n@Data\npublic class CashfreeProviderAccountConfiguration {\n    private String apiClientId;\n    private String apiVersion;\n    private ShortCircuitConfiguration shortCircuitConfiguration;\n}\n\n// Cybersource\n@Data\npublic class CybersourceProviderAccountConfiguration {\n    private String apiKey;\n    private String merchantId;\n    private Boolean enableRetries = false;\n    private Boolean enableCaptureWithAuth = true;\n    private Boolean enable3DS2 = true;\n    private Boolean enableRedirectionFlow = false;\n}\n```\n\n### Client-Provider Mapping\n**File:** `entity/ClientPaymentProviderConfigEntity.java`\n\n```java\n@Entity @Table(name = \"client_payment_provider_config\")\npublic class ClientPaymentProviderConfigEntity extends BaseEntity {\n    @ManyToOne private ClientEntity client;\n    @ManyToOne private PaymentProviderEntity paymentProvider;\n    private String providerConfig;  // JSON configuration per client\n}\n```\n\n---\n\n## 30. ERROR HANDLING & RETRY LOGIC\n\n### Error Classification\n```java\npublic enum ProviderRequestStatus {\n    REQUEST_SUCCESS,          // Payment processed\n    RETRY_ABLE_FAILURE,       // Timeout, rate limit - can retry\n    NON_RETRY_ABLE_FAILURE    // Invalid request - cannot retry\n}\n```\n\n### Provider Error Structure\n```java\n@Data @Builder\npublic class ProviderError {\n    private String message;           // User-friendly message\n    private String code;              // Provider error code\n    private Object providerResponse;  // Raw error response\n    private Boolean retryable;        // Retry classification\n}\n```\n\n### Error Code Mapping (Cybersource Example)\n```java\n// Failure codes (43 codes)\n\"101\", \"102\", \"104\", \"150\", \"200\", \"201\", \"202\", \"203\", ...\n\n// Processing/Pending codes\n\"110\" (Pending), \"475\" (Timeout), \"480\" (Processing)\n```\n\n### Retry Pattern\n```java\npublic ProviderPaymentResponse executePaymentAttempt(...) {\n    try {\n        return pilotMethod.apply(context, providerCustomer);\n    } catch (RateLimitException rle) {\n        return ProviderPaymentResponse.builder()\n            .providerRequestStatus(ProviderRequestStatus.RETRY_ABLE_FAILURE)\n            .providerError(ProviderError.builder()\n                .retryable(true).build())\n            .build();\n    } catch (AppException ae) {\n        return ProviderPaymentResponse.builder()\n            .providerRequestStatus(ProviderRequestStatus.NON_RETRY_ABLE_FAILURE)\n            .build();\n    }\n}\n```\n\n---\n\n## 31. ARCHITECTURAL PATTERNS SUMMARY\n\n| Pattern | Usage | File |\n|---------|-------|------|\n| **Factory** | Adapter selection by (OrderType, Provider, Instrument) | PaymentProviderFactory.java |\n| **Strategy** | LCM vs Decision Tree routing | ProviderDeciderRouter.java |\n| **Template Method** | Base adapter lifecycle | IPaymentProviderAdapter.java |\n| **Builder** | Complex request construction | CybersourceRequestBuilder.java |\n| **Decorator** | Provider-specific configuration | *ConfigValueDecoratorImpl.java |\n\n---\n\n## 32. KEY PROVIDER INTEGRATION FILES\n\n### Core Architecture\n1. `v2/workflow/create/providers/IPaymentProviderAdapter.java` - Base adapter\n2. `v2/workflow/create/providers/PaymentProviderFactory.java` - Factory\n3. `planner/providerdecider/ProviderDeciderRouter.java` - Routing strategy\n\n### Decision Tree\n1. `planner/providerdecider/ProviderDeciderV2.java` - DT workflow\n2. `planner/providerdecider/ProviderDeciderViaLCM.java` - LCM routing\n3. `cache/DecisionTreeObjectCache.java` - DT caching\n\n### Webhooks\n1. `controller/WebhookController.java` - Generic webhook endpoint\n2. `controller/v2/CashfreeWebhookController.java` - Cashfree webhooks\n3. `service/WebhookService.java` - Webhook processing\n\n### Provider Implementations\n1. `v2/workflow/create/providers/CashfreeProviderAdapter.java`\n2. `v2/workflow/create/providers/cybersource/CybersourceProviderAdapter.java`\n3. `v2/workflow/create/providers/PayuProviderAdapter.java`\n\n### Configuration\n1. `entity/ProviderAccountEntity.java` - Provider credentials\n2. `entity/PaymentProviderEntity.java` - Provider definition\n3. `entity/ClientPaymentProviderConfigEntity.java` - Client-provider mapping","originalFile":"# Payment Service (Darwin) - Expert Study Guide\n\nA comprehensive guide to understanding the payment-service repository.\n\n---\n\n## 1. OVERVIEW & TECH STACK\n\n**Project Name:** Darwin (internal name for payment-service)\n**Purpose:** Enterprise-grade payment processing microservice handling multi-provider payment orchestration\n\n| Technology | Version | Purpose |\n|------------|---------|---------|\n| Java | 17 | Runtime |\n| Spring Boot | 2.7.14 | Framework |\n| Gradle | 7.6 | Build |\n| MySQL | - | Primary Database (Master-Replica) |\n| DynamoDB | - | Audit/State Storage |\n| Redis (Redisson) | 3.19.1 | Distributed Cache |\n| Kafka | - | Event Streaming |\n| AWS SQS | - | Task Processing |\n\n**Server:** Port 9010, Context Path: `/payments`\n\n---\n\n## 2. PROJECT STRUCTURE\n\n```\npayment-service/\n├── src/main/java/in/dreamplug/darwin/\n│   ├── controller/         # REST API endpoints\n│   │   └── v2/             # V2 API controllers (primary)\n│   ├── service/            # Business logic services\n│   ├── v2/\n│   │   ├── service/        # V2 services\n│   │   └── workflow/       # Payment workflows (CRITICAL)\n│   │       └── create/\n│   │           ├── payments/       # Payment creation\n│   │           ├── paymentattempts/ # Payment attempt creation\n│   │           └── providers/      # Provider adapters (24+)\n│   ├── entity/             # JPA entities\n│   │   └── v2/             # V2 entities (primary)\n│   ├── repository/         # Data access layer\n│   ├── statemachine/       # Payment/Order state machines\n│   ├── planner/            # Decision tree routing\n│   ├── cache/              # Caching layer (Caffeine)\n│   ├── client/             # External service clients\n│   ├── provider/           # Legacy provider implementations\n│   ├── configuration/      # Spring configs\n│   │   └── database/       # DB configs (Master/Replica)\n│   ├── kafka/              # Kafka producers/consumers\n│   ├── sqs/                # SQS message processors\n│   ├── dynamo/             # DynamoDB DAOs\n│   ├── error/              # Error handling\n│   ├── dto/                # Data transfer objects\n│   └── commons/spring/filters/  # Auth/Context filters\n├── src/main/resources/\n│   └── application.properties  # Main config (1300+ lines)\n├── codepipeline/           # CI/CD configurations\n├── build.gradle            # Dependencies\n└── Dockerfile              # Container setup\n```\n\n---\n\n## 3. CORE PAYMENT FLOW (CRITICAL)\n\n### 3.1 Payment Lifecycle\n\n```\nOrder Created → Payments Created → Payment Attempt Created → Provider API Call → Webhook/Status Update\n```\n\n**Key Steps:**\n\n1. **Order Creation** - Client creates an order with amount, currency, metadata\n2. **Bulk Payment Creation** - Multiple payment records created for the order\n   - File: `v2/workflow/create/payments/bulk/BulkPaymentCreateWorkflow.java`\n3. **Payment Attempt Creation** - Actual payment attempt with provider routing\n   - File: `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java`\n4. **Provider Processing** - Provider adapter calls external payment gateway\n5. **State Machine Updates** - Events trigger state transitions\n\n### 3.2 Workflow Execution Pipeline\n\n```java\n// Base workflow pattern (Workflow.java)\n1. validateAndEnrichContext()  // Validate inputs, enrich data\n2. persistIntent()             // Save entities to MySQL\n3. persistNonRelationalIntent() // Save to DynamoDB\n4. process()                   // Call provider API\n5. postProcess()               // Transform results\n6. publishEntityChangeEvents() // Trigger state machines\n7. throwErrorIfRequired()      // Handle errors\n```\n\n### 3.3 Payment Attempt Data Enrichment\n\n1. **Instrument Validation** - `InstrumentTypeProcessorManager`\n2. **Provider Routing** - `ProviderDeciderRouter` → Decision Tree\n3. **Auth Type Decision** - `AuthTypeDeciderFactory` (3DS, OTP, None)\n4. **Settlement Validation** - `SettlementRouteValidator`\n\n---\n\n## 4. STATE MACHINES\n\n### 4.1 Payment State Machine\n**File:** `statemachine/payment/PaymentStateMachine.java`\n\n```\nCREATED → PROCESSING → AUTHORIZED → COMPLETED\n                   ↘ FAILED\n                   ↘ BLOCKED\n```\n\n**Terminal States:** COMPLETED, FAILED, FORCE_FAILED, DISCARDED\n\n### 4.2 Order State Machine\n**File:** `statemachine/order/OrderStateMachine.java`\n\n- Reacts to payment events\n- Updates order status based on payment outcomes\n\n### 4.3 Events (EventBus - Guava)\n- `PaymentAttemptCreatedEvent`\n- `PaymentAttemptCompletedEvent`\n- `PaymentAttemptFailedEvent`\n- `PaymentAttemptProcessingEvent`\n- `PaymentAttemptAuthorizedEvent`\n\n---\n\n## 5. PROVIDER INTEGRATIONS (24+ Providers)\n\n**Location:** `v2/workflow/create/providers/`\n\n| Provider | Adapter File | Payment Types |\n|----------|-------------|---------------|\n| Cybersource | `CybersourceProviderAdapter.java` | Cards, 3DS, E-Mandates |\n| Cashfree | `CashfreeProviderAdapter.java` + variants | Cards, UPI, NetBanking |\n| PayU | `PayuProviderAdapter.java` + variants | Cards, NetBanking |\n| Pine Labs | `PineLabsEdgeProviderAdapter.java` | Multiple modes |\n| Razorpay | Via webhooks | All payment types |\n| Juspay | Via webhooks | Orchestration |\n| ICICI UPI | `icici-upi-client` | UPI |\n| Axis UPI | `axis-upi-client` | UPI |\n| YBL UPI | `ybl-upi-client` | UPI |\n| RBL UPI | `rbl-upi-client` | UPI |\n| Digio | `DigioMandateRegisterProviderAdapter.java` | E-Mandates |\n| Cred Points | `CredPointsProviderAdapter.java` | Reward redemption |\n\n### Provider Selection Flow\n\n```\nRequest → ProviderDeciderRouter → LCM (if enabled) → Decision Tree → Provider Adapter\n```\n\n**Decision Tree:** JSON-based rules cached in `DecisionTreeObjectCache`\n\n---\n\n## 6. KEY ENTITIES (V2 Schema)\n\n### Core Entities\n| Entity | File | Purpose |\n|--------|------|---------|\n| OrderEntity | `entity/OrderEntity.java` | Order records |\n| PaymentV2Entity | `entity/v2/PaymentV2Entity.java` | Payment records |\n| PaymentAttemptV2Entity | `entity/v2/PaymentAttemptV2Entity.java` | Payment attempts |\n| RefundEntity | `entity/v2/RefundEntity.java` | Refunds |\n| FeeEntity | `entity/v2/FeeEntity.java` | Fee tracking |\n\n### Configuration Entities\n| Entity | Purpose |\n|--------|---------|\n| ClientEntity | Application clients |\n| ProviderAccountEntity | Provider accounts |\n| PaymentProviderEntity | Provider configs |\n| MasterConfigurationEntity | System configs |\n\n---\n\n## 7. DATABASE ARCHITECTURE\n\n### Master-Replica Pattern\n\n**Master:** Write operations\n**Replica:** Read operations (via `@ReplicaRepository`)\n\n**Configuration Files:**\n- `configuration/database/MasterDataSourceConfiguration.java`\n- `configuration/database/ReplicaDataSourceConfiguration.java`\n\n**Database:** `payments_multi_tenancy`\n**Connection Pool:** HikariCP\n**ORM:** JPA + Hibernate\n\n---\n\n## 8. CACHING LAYER\n\n### Caffeine (In-Memory)\n| Cache | Purpose |\n|-------|---------|\n| `ClientConfigurationCache` | Client settings |\n| `PaymentProviderCache` | Provider configs |\n| `ProviderAccountCache` | Provider accounts |\n| `DecisionTreeObjectCache` | Routing rules |\n| `CardBinCache` | Card BIN data |\n| `MerchantCache` | Merchant data |\n| `FeeCache` | Fee calculations |\n\n### Redis (Distributed)\n- **Client:** Redisson with Kryo5Codec\n- **Use:** Distributed locks, rate limiting, shared state\n\n---\n\n## 9. ASYNC PROCESSING\n\n### Kafka Topics\n- `payment-attempt-platform-metrics-pinot-out-new-1` (Analytics)\n- Events: `PaymentAttemptAnalyticsEvent`, `CardPaymentAttemptAnalyticsEvent`, etc.\n\n### SQS Queues\n| Queue | Purpose |\n|-------|---------|\n| `FORCE_PAYMENT_FAILURE_QUEUE` | Manual failure forcing |\n| `MANDATE_EXPIRY_CRON_QUEUE` | Mandate expiry |\n| `REFUND_RESCHEDULE_QUEUE` | Refund scheduling |\n| `ORDER_EXPIRY_QUEUE` | Order expiration |\n| `PENDENCY_AUTOMATION_QUEUE` | Pending transactions |\n\n### Eventi (Internal Events)\n- Internal event framework for system events\n- Async worker threads (4-16 configurable)\n\n---\n\n## 10. API ENDPOINTS\n\n### Primary Controllers (v2)\n| Endpoint | Controller | Purpose |\n|----------|------------|---------|\n| `/v2/orders/{orderId}/payments` | `PaymentV2Controller` | Bulk payment creation |\n| `/v2/payments/{paymentId}/attempts` | `PaymentAttemptV2Controller` | Payment attempts |\n| `/v1/webhooks` | `WebhookController` | Provider webhooks |\n\n### Webhook Controllers\n- `RazorpayWebhookController`\n- `JuspayWebhookController`\n- `ICICIWebhookController`\n- `YBLWebhookController`\n- `RBLUpiWebhookController`\n- `DigioWebhookController`\n\n---\n\n## 11. AUTHENTICATION & SECURITY\n\n### Request Filters (Order of Execution)\n1. `ApplicationContextBuilderFilter` - Build context from headers\n2. `PAMerchantAuthenticationFilter` - Partner merchant auth\n3. `PAPartnerAuthorizationFilter` - Partner authorization\n\n### Headers Required\n- Client ID (`${CLIENT_HEADER_KEY}`)\n- Merchant ID (`${MERCHANT_HEADER_KEY}`)\n- Device info (DEVICE_ID, OS, OS_VERSION, APP_VERSION)\n\n### Rate Limiting\n- Redisson-based distributed rate limiting\n- Config in `ClientRateLimiter.java`\n\n---\n\n## 12. KEY FILES TO STUDY\n\n### Must-Read Files (Priority Order)\n\n1. **Entry Point:**\n   - `DarwinApplication.java`\n\n2. **Core Workflows:**\n   - `v2/workflow/create/Workflow.java` (base pattern)\n   - `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java`\n   - `v2/workflow/create/payments/bulk/BulkPaymentCreateWorkflow.java`\n\n3. **State Machines:**\n   - `statemachine/payment/PaymentStateMachine.java`\n   - `statemachine/order/OrderStateMachine.java`\n\n4. **Provider Routing:**\n   - `planner/ProviderDeciderRouter.java`\n   - `planner/decisiontree/DecisionTreeWorkflow.java`\n\n5. **Provider Adapters:**\n   - `v2/workflow/create/providers/` (pick any adapter)\n\n6. **Entities:**\n   - `entity/OrderEntity.java`\n   - `entity/v2/PaymentV2Entity.java`\n   - `entity/v2/PaymentAttemptV2Entity.java`\n\n7. **Configuration:**\n   - `application.properties` (1300+ lines - scan for context)\n\n8. **Webhooks:**\n   - `controller/WebhookController.java`\n\n---\n\n## 13. INTERNAL SERVICE DEPENDENCIES\n\n| Service | Client Library | Purpose |\n|---------|---------------|---------|\n| User Service | `user-service-client:4.0.1` | User data |\n| Merchant Service | `merchant-service-client:1.0.3` | Merchant info |\n| Mandate Service | `mandate-java-client:1.0.4` | Recurring payments |\n| Arsenal | - | Instrument vault |\n| Falcon | - | Offers/promotions |\n| Genie | `genie-java-client` | Configuration |\n| Syndicate | - | Authentication |\n| LCM | - | Terminal resolution |\n| Fee Service | `fees:0.18.0` | Fee calculation |\n\n---\n\n## 14. STUDY PATH RECOMMENDATION\n\n### Week 1: Foundation\n- [ ] Understand project structure\n- [ ] Read `DarwinApplication.java`\n- [ ] Study `application.properties` (key sections)\n- [ ] Understand entity relationships\n\n### Week 2: Core Flow\n- [ ] Master `PaymentAttemptCreateWorkflow.java`\n- [ ] Study state machines\n- [ ] Understand provider routing\n\n### Week 3: Integrations\n- [ ] Study 2-3 provider adapters\n- [ ] Understand webhook handling\n- [ ] Learn caching patterns\n\n### Week 4: Advanced\n- [ ] Decision tree engine\n- [ ] Async processing (Kafka, SQS)\n- [ ] Error handling patterns\n\n---\n\n## 15. KEY CONCEPTS\n\n1. **Multi-Provider Orchestration** - Route to optimal provider based on rules\n2. **Decision Trees** - JSON-based routing logic\n3. **State Machines** - Event-driven entity lifecycle\n4. **Master-Replica DB** - Read/write separation\n5. **Workflow Pattern** - 7-step execution pipeline\n6. **Event-Driven Architecture** - Guava EventBus + Kafka\n\n---\n\n# DATA LAYER DEEP-DIVE\n\n## 16. ENTITY HIERARCHY & INHERITANCE\n\n### Base Classes\n```\nBaseEntity (id, created_at, updated_at, created_by, updated_by)\n    └── BaseExternalEntity (+ external_id UUID, version for optimistic locking)\n            ├── OrderEntity\n            ├── PaymentV2Entity\n            ├── PaymentAttemptV2Entity\n            ├── RefundEntity\n            ├── ClientEntity\n            └── CustomerEntity\n```\n\n### Key Entity Files\n| Entity | File | Key Fields |\n|--------|------|------------|\n| OrderEntity | `entity/OrderEntity.java` | clientReferenceId, amount, status, metadata (JSON) |\n| PaymentV2Entity | `entity/v2/PaymentV2Entity.java` | orderId, amount, paymentMode, instrumentDetail (JSON) |\n| PaymentAttemptV2Entity | `entity/v2/PaymentAttemptV2Entity.java` | paymentId, providerReferenceId, gatewayReferenceId, status |\n| RefundEntity | `entity/v2/RefundEntity.java` | orderId, paymentAttemptId, refundType, refundStatus |\n| ClientEntity | `entity/ClientEntity.java` | name, merchantId, settings (OneToMany) |\n\n### Entity Relationships\n```\nClientEntity (1) ──> (M) OrderEntity\nOrderEntity (1) ──> (M) PaymentV2Entity\nPaymentV2Entity (1) ──> (M) PaymentAttemptV2Entity\nPaymentAttemptV2Entity ──> PaymentProviderEntity\nPaymentAttemptV2Entity ──> ProviderAccountEntity\nOrderEntity (1) ──> (M) RefundEntity\nRefundEntity (1) ──> (M) RefundAttemptEntity\n```\n\n---\n\n## 17. MASTER-REPLICA DATABASE ARCHITECTURE\n\n### How Routing Works\n\n**Master (Writes):** `MasterDataSourceConfiguration.java`\n- EntityManagerFactory: `MasterEntityManagerFactory`\n- TransactionManager: `MasterTransactionManager`\n- Excludes beans with `@ReplicaRepository`\n\n**Replica (Reads):** `ReplicaDataSourceConfiguration.java`\n- EntityManagerFactory: `ReplicaEntityManagerFactory`\n- TransactionManager: `ReplicaTransactionManager`\n- Includes ONLY beans with `@ReplicaRepository`\n- Connection pool set to `readOnly=true`\n\n### Usage Pattern\n```java\n// Write to master (default)\n@Repository\npublic interface PaymentRepository extends JpaRepository<...> {}\n\n// Read from replica\n@Repository\n@ReplicaRepository  // <-- Annotation routes to replica\npublic class RefundEntityReplicaDAOImpl extends AbstractReplicaDAOImpl<...> {}\n```\n\n### HikariCP Connection Pools\n| Pool | Config | Purpose |\n|------|--------|---------|\n| hikari_master | masterMinimumIdle, masterMaximumPoolSize | Write operations |\n| hikari_replica | replicaMinimumIdle, replicaMaximumPoolSize, readOnly=true | Read operations |\n\nBoth pools have:\n- idleTimeout, connectionTimeout, maxLifetime\n- leakDetectionThreshold for debugging\n- MaintenanceManager integration for graceful shutdown\n\n---\n\n## 18. REPOSITORY & DAO PATTERNS\n\n### JPA Repository Pattern\n```java\n@Repository\npublic interface OrderRepository extends JpaRepository<OrderEntity, Long> {\n    // FETCH JOIN to prevent N+1 queries\n    @Query(\"SELECT o FROM OrderEntity o \"\n            + \"JOIN FETCH o.customerEntity \"\n            + \"JOIN FETCH o.clientEntity \"\n            + \"WHERE o.externalId = :externalId\")\n    Optional<OrderEntity> findByExternalId(@Param(\"externalId\") String externalId);\n\n    // Property path navigation\n    Optional<OrderEntity> findByClientReferenceIdAndClientEntity_ExternalId(\n            String clientReferenceId, String externalId);\n}\n```\n\n### DAO Pattern (Custom EntityManager)\n```java\n@Repository\npublic class PaymentAttemptDAOV2Impl {\n    @PersistenceContext\n    private EntityManager entityManager;\n\n    public List<PaymentAttemptV2Entity> findByOrderId(Long orderId) {\n        // Complex JPQL with manual EntityManager\n    }\n}\n```\n\n### DynamoDB DAO Pattern\n```java\n@RequiredArgsConstructor\npublic abstract class AbstractDynamoDBDAO<T> {\n    private final DynamoDBMapper dynamoDBMapper;\n\n    public void save(T entity) { dynamoDBMapper.save(entity); }\n    public T findByHashKey(Object hashKey) { return dynamoDBMapper.load(tClass, hashKey); }\n}\n```\n\n---\n\n## 19. JSON COLUMNS & CONVERTERS\n\n**Flexible Attribute Storage:**\n| Column | Converter | Entity |\n|--------|-----------|--------|\n| metadata | ObjectMetadataMapConverter | OrderEntity |\n| instrument_detail | PaymentInstrumentConverter | PaymentV2Entity |\n| instrument_detail | EnrichedPaymentInstrumentConverter | PaymentAttemptV2Entity |\n| routes | RoutesBreakupConverter | PaymentAttemptV2Entity |\n| payment_specific_detail | PaymentSpecificDetailConverter | PaymentV2Entity |\n\n```java\n@Column(name = \"metadata\")\n@Convert(converter = ObjectMetadataMapConverter.class)\nprivate Map<String, String> metaData;\n```\n\n---\n\n## 20. CACHING ARCHITECTURE\n\n### Caffeine Caches (In-Memory)\n| Cache Class | What It Caches | TTL |\n|-------------|----------------|-----|\n| ClientConfigurationCache | Client settings by ID, by externalId, by merchantId | 10-20 min |\n| PaymentProviderCache | Provider configurations | 15-25 min |\n| ProviderAccountCache | Provider account entities | 15-25 min |\n| DecisionTreeObjectCache | Routing decision trees | 180-190 min |\n| FeeCache | Fee configurations | 1 day |\n| CardBinCache | Card BIN details | Configurable |\n| MasterConfigurationCache | Feature flags, system settings | 10-20 min |\n| PaymentErrorMessageMappingCache | Error code to message mappings | Long |\n\n### Cache Pattern\n```java\n@DPCache(cacheName = \"client_configuration_cache\")\nprivate LoadingCache<Long, Map<ClientSettingKey, String>> idCache;\n\n@Override\npublic void buildCache() {\n    idCache = DPCacheBuilder.getBuilder()\n        .refreshAfterWrite(10, MINUTES)  // Lazy refresh\n        .build(this::loadClientSettings);  // Loader function\n}\n```\n\n### Jittered TTLs (Prevent Thundering Herd)\n```java\n// Returns 15-25 instead of fixed 15\nprivate Long generateRandomCacheRefreshInterval(int base) {\n    return base + random.nextInt(10) + 1;\n}\n```\n\n---\n\n## 21. DYNAMODB USAGE\n\n### What Goes Where\n| MySQL | DynamoDB |\n|-------|----------|\n| Orders, Payments, Attempts | Workflow context (TTL-based) |\n| Refunds, Fees | Native OTP details |\n| Clients, Customers | Redirect tracking |\n| Provider configs | Metadata audit trails |\n\n### DynamoDB Entity Example\n```java\n@DynamoDBTable(tableName = \"darwin_payment_attempt_workflow_context\")\npublic class PaymentAttemptWorkflowContextEntity {\n    @DynamoDBHashKey(attributeName = \"payment_attempt_external_id\")\n    private String paymentAttemptExternalId;\n\n    @DynamoDBRangeKey\n    @DynamoDBAttribute(attributeName = \"workflow_step\")\n    private WorkflowStep workflowStep;\n\n    @Builder.Default\n    private long ttl = LocalDateTime.now().plusDays(1).toEpochSecond(ZoneOffset.UTC);\n}\n```\n\n### DynamoDB Tables\n| Table | Partition Key | Sort Key | Purpose |\n|-------|---------------|----------|---------|\n| darwin_payment_attempt_workflow_context | payment_attempt_external_id | workflow_step | Workflow state |\n| darwin_payment_attempt_native_otp_detail | payment_attempt_external_id | - | OTP auth details |\n| darwin_payment_attempt_redirection_detail | payment_attempt_external_id | - | 3DS redirects |\n| darwin_payment_attempt_metadata_audit | payment_attempt_external_id | - | Audit trail |\n\n---\n\n## 22. OPTIMISTIC LOCKING & AUDIT\n\n### @Version for Optimistic Locking\n```java\n@Version\n@Column(name = \"version\")\nprivate Integer version;  // Auto-incremented on each update\n```\n\nPrevents concurrent modification - throws `OptimisticLockException` on conflict.\n\n### Audit Columns (Auto-Managed)\n```java\n@CreationTimestamp\n@Column(name = \"created_at\")\nprivate LocalDateTime createAt;\n\n@UpdateTimestamp\n@Column(name = \"updated_at\")\nprivate LocalDateTime updatedAt;\n\n@PrePersist\npublic void onCreate() {\n    createdBy = ApplicationContext.getApplicationName();\n}\n\n@PreUpdate\npublic void onUpdate() {\n    updatedBy = ApplicationContext.getApplicationName();\n}\n```\n\n---\n\n## 23. DATA LAYER ARCHITECTURE DIAGRAM\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                    Service Layer                        │\n├─────────────────────────────────────────────────────────┤\n│ JPA Repositories      │ Custom DAOs      │ DynamoDB DAOs │\n├─────────────────────────────────────────────────────────┤\n│     Spring Data JPA + Hibernate ORM                     │\n├──────────────────────┬──────────────────────────────────┤\n│   Master DataSource  │      Replica DataSource          │\n│   (Writes)           │      (Reads - @ReplicaRepository)│\n├──────────────────────┼──────────────────────────────────┤\n│ HikariCP Master Pool │   HikariCP Replica Pool          │\n├──────────────────────┴──────────────────────────────────┤\n│         MySQL (payments_multi_tenancy)                  │\n└─────────────────────────────────────────────────────────┘\n         │                              │\n┌────────▼────────┐          ┌──────────▼─────────┐\n│    DynamoDB     │          │  Caffeine Caches   │\n│ (Workflow/Audit)│          │  (Client/Provider) │\n└─────────────────┘          └────────────────────┘\n```\n\n---\n\n## 24. KEY DATA LAYER FILES TO STUDY\n\n### Entity Classes (Priority)\n1. `entity/commons/BaseEntity.java` - Base class pattern\n2. `entity/provider/BaseExternalEntity.java` - External ID + versioning\n3. `entity/OrderEntity.java` - Main order entity\n4. `entity/v2/PaymentAttemptV2Entity.java` - Payment attempt (most complex)\n\n### Database Configuration\n1. `configuration/database/MasterDataSourceConfiguration.java`\n2. `configuration/database/ReplicaDataSourceConfiguration.java`\n3. `configuration/database/annotation/ReplicaRepository.java`\n\n### Repositories\n1. `repository/OrderRepository.java` - FETCH JOIN examples\n2. `repository/PaymentAttemptRepository.java` - Complex queries\n\n### Caches\n1. `cache/ClientConfigurationCache.java` - Cache pattern example\n2. `configuration/CacheConfig.java` - Cache configuration\n\n### DynamoDB\n1. `dynamo/dao/AbstractDynamoDBDAO.java` - Base DAO pattern\n2. `dynamo/domain/PaymentAttemptWorkflowContextEntity.java` - DynamoDB entity\n","structuredPatch":[{"oldStart":663,"oldLines":3,"newStart":663,"newLines":405,"lines":[" ### DynamoDB"," 1. `dynamo/dao/AbstractDynamoDBDAO.java` - Base DAO pattern"," 2. `dynamo/domain/PaymentAttemptWorkflowContextEntity.java` - DynamoDB entity","+","+---","+","+# PROVIDER INTEGRATION DEEP-DIVE","+","+## 25. PROVIDER ADAPTER ARCHITECTURE","+","+### Base Adapter Pattern","+**File:** `v2/workflow/create/providers/IPaymentProviderAdapter.java`","+","+```java","+public abstract class IPaymentProviderAdapter<T, R> implements SelfReferencingBean {","+    protected final PaymentProviderKey paymentProviderKey;  // e.g., CASHFREE, CYBERSOURCE","+    private final InstrumentType instrumentType;            // e.g., CARD, UPI_APPS","+    private final OrderType orderType;                      // e.g., PAY, REFUND","+","+    // Core lifecycle methods","+    public abstract ProviderPaymentResponse createPaymentAttempt(context, customerEntity);","+    protected abstract Object syncPaymentAttemptWithProviderId(paymentAttemptEntity);","+    protected abstract ProviderRefundCreateResponse createRefund(refundAttemptEntity, context);","+    protected abstract R getAuthConfig(providerAccountEntity);","+}","+```","+","+### Factory Pattern for Adapter Selection","+**File:** `v2/workflow/create/providers/PaymentProviderFactory.java`","+","+```java","+@Component","+public class PaymentProviderFactory {","+    // Multi-dimensional lookup: OrderType + ProviderKey + InstrumentType → Adapter","+    private Map<PaymentWorkflowKey, IPaymentProviderAdapter<?, ?>> paymentProviderMap;","+","+    // Secondary lookup: OrderType + ProviderKey → First adapter","+    private Table<OrderType, PaymentProviderKey, IPaymentProviderAdapter<?, ?>> paymentProviderByKey;","+","+    // 3DS variant support","+    private ThreeDSType threeDSType;  // 3DS1 vs 3DS2","+}","+```","+","+### Provider Response Structure","+```java","+@Data @Builder","+public class ProviderPaymentResponse {","+    private Object providerResponseObject;     // Raw provider response","+    private String providerReferenceId;        // Provider's transaction ID","+    private String gatewayReferenceId;         // Gateway ID","+    private String providerStatus;             // Raw status (\"SUCCESS\")","+    private PaymentAttemptStatus status;       // Mapped internal status","+    private ProviderRequestStatus providerRequestStatus;  // REQUEST_SUCCESS, RETRY_ABLE_FAILURE","+    private ProviderError providerError;       // Error details if failed","+}","+```","+","+---","+","+## 26. DECISION TREE ROUTING","+","+### Router Strategy Pattern","+**File:** `planner/providerdecider/ProviderDeciderRouter.java`","+","+```java","+@Service","+public class ProviderDeciderRouter {","+    public ProviderRoutingDecisionResult resolve(PaymentAttemptCreateContext context) {","+        // Priority 1: LCM routing (if instrument supported)","+        if (isInstrumentTypeSupportedInLCM(clientId, instrumentType)) {","+            return providerDeciderViaLCM.decideProvider(context);","+        }","+","+        // Priority 2: Decision Tree routing","+        if (isDecisionTreeEnabled) {","+            return providerDeciderV2.decideProvider(context);","+        }","+    }","+}","+```","+","+### Decision Tree Workflow","+**File:** `planner/providerdecider/ProviderDeciderV2.java`","+","+```","+Request → Fetch Cached Decision Tree → Create DT Context → Execute Tree → Apply Dynamic Routing → Return Provider","+```","+","+**Decision Tree Factors:**","+- Client configuration","+- Instrument type (Card, UPI, NetBanking)","+- Card brand/BIN","+- Customer attributes","+- Order amount","+- Provider availability/downtime","+","+### Decision Tree Caching","+**File:** `cache/DecisionTreeObjectCache.java`","+","+| Cache | TTL | Content |","+|-------|-----|---------|","+| decision_tree_object_cache | 180-190 min | Parsed decision tree JSON + workflow |","+","+---","+","+## 27. PROVIDER ADAPTERS (24+ Implementations)","+","+### Adapter Directory Structure","+```","+v2/workflow/create/providers/","+├── IPaymentProviderAdapter.java          # Base abstract class","+├── PaymentProviderFactory.java           # Factory for adapter selection","+├── CashfreeProviderAdapter.java          # Cashfree base","+├── CashfreeCardProviderAdapter.java      # Cashfree cards","+├── CashfreeNetBankingProviderAdapter.java","+├── CashfreeUPIProviderAdapter.java","+├── CashfreeUPIAppsProviderAdapter.java","+├── cybersource/","+│   ├── CybersourceProviderAdapter.java   # Cybersource base (3DS)","+│   ├── CybersourceRequestBuilder.java    # Request construction","+│   └── CybersourceAuthorizeRequestBuilder.java","+├── PayuProviderAdapter.java","+├── PayuCardProviderAdapter.java","+├── PineLabsEdgeProviderAdapter.java","+├── CredPointsProviderAdapter.java","+├── RewardPointsProviderAdapter.java","+└── AuthTokenNativeProviderAdapter.java","+```","+","+### Cashfree Adapter Example","+**File:** `v2/workflow/create/providers/CashfreeProviderAdapter.java`","+","+```java","+@Component","+public abstract class CashfreeProviderAdapter","+        extends IPaymentProviderAdapter<String, CashfreeAuthConfig> {","+","+    // Two-phase payment creation:","+    // 1. Create order at Cashfree","+    // 2. Create payment for that order","+","+    @Override","+    public ProviderPaymentResponse createPaymentAttempt(context, customer) {","+        // Phase 1: Create CF Order","+        Pair<BaseResponse<CreateOrderResponse>, ProviderError> orderResponse =","+            createCFOrder(context, authConfig);","+","+        // Phase 2: Create CF Payment","+        Pair<BaseResponse<CreatePaymentResponse>, ProviderError> paymentResponse =","+            createCFPayment(context, orderResponse.getLeft().getResponse(), authConfig);","+","+        return mapToProviderPaymentResponse(paymentResponse);","+    }","+}","+```","+","+### Cybersource Adapter (3DS Support)","+**File:** `v2/workflow/create/providers/cybersource/CybersourceProviderAdapter.java`","+","+```java","+@Component","+public abstract class CybersourceProviderAdapter","+        extends I3DSPaymentProviderAdapter<String, AuthConfig> {","+","+    // Status code mappings","+    private static final List<String> FAILED_STATUSES = Arrays.asList(","+        \"101\", \"102\", \"104\", \"150\", \"200\", \"201\", ...  // 43 codes","+    );","+    private static final List<String> PROCESSING_STATUSES = Arrays.asList(","+        \"110\", \"475\", \"480\"","+    );","+","+    // 3DS2 redirection flow","+    protected void createRedirectionHtml(response, paymentAttemptEntity) {","+        if (authInfo.getSpecificationVersion().startsWith(\"2\")) {","+            // 3DS2 flow with step-up URL","+            html = authenticationService.createAuthenticationPageFor3ds2(","+                authInfo.getStepUpUrl(),","+                authInfo.getAccessToken(),","+                paymentAttemptEntity.getExternalId());","+        }","+    }","+}","+```","+","+---","+","+## 28. WEBHOOK HANDLING","+","+### Webhook Architecture","+```","+Provider → /webhooks/v2/{provider} → Provider-Specific Controller → WebhookService → State Machine Update","+```","+","+### Provider Webhook Controllers","+| Endpoint | Controller | Provider |","+|----------|------------|----------|","+| `/webhooks/v2/cashfree` | CashfreeWebhookController | Cashfree |","+| `/webhooks/v2/razorpay` | RazorpayWebhookController | Razorpay |","+| `/webhooks/v2/payu` | PayuWebhookController | PayU |","+| `/webhooks/v2/cybersource` | CybersourceWebhookController | Cybersource |","+| `/webhooks/v2/juspay` | JuspayWebhookController | Juspay |","+| `/webhooks/v2/ybl` | YBLWebhookController | Yes Bank UPI |","+| `/webhooks/v2/icici` | ICICIWebhookController | ICICI UPI |","+| `/webhooks/v2/rbl-upi` | RBLUpiWebhookController | RBL UPI |","+| `/webhooks/v2/digio` | DigioWebhookController | Digio (eMandate) |","+","+### Webhook Processing Flow","+**File:** `controller/v2/CashfreeWebhookController.java`","+","+```java","+@PostMapping","+public void onWebhookReceive(@RequestBody CashfreeWebhook webhookRequest) {","+    switch (webhookRequest.getType()) {","+        case PAYMENT_SUCCESS_WEBHOOK:","+        case PAYMENT_FAILED_WEBHOOK:","+            // 1. Extract provider reference ID","+            String providerRefId = paymentWebhook.getData().getCfPaymentId();","+","+            // 2. Fetch payment attempt","+            PaymentAttempt attempt = paymentAttemptFetchWorkflow","+                .fetchByProviderReferenceId(providerRefId);","+","+            // 3. Audit webhook data","+            auditService.auditProviderData(webhookRequest, attempt.getId(), ...);","+","+            // 4. Sync status (triggers state machine)","+            break;","+","+        case REFUND_STATUS_WEBHOOK:","+            processRefundAttempt(webhookRequest);","+            break;","+    }","+}","+```","+","+### Idempotency Handling","+```java","+// In base adapter - only update if status actually changed","+public void syncPaymentAttemptWithProvider(PaymentAttemptV2Entity entity) {","+    String currentStatus = entity.getProviderStatus();","+","+    Object providerResponse = syncPaymentAttemptWithProviderId(entity);","+","+    // Only audit and process if status changed","+    if (!Objects.equals(currentStatus, entity.getProviderStatus())) {","+        auditService.auditProviderData(...);","+    }","+}","+```","+","+---","+","+## 29. PROVIDER CONFIGURATION","+","+### Configuration Entities","+**File:** `entity/ProviderAccountEntity.java`","+","+```java","+@Entity @Table(name = \"provider_accounts\")","+public class ProviderAccountEntity extends BaseEntity {","+    @ManyToOne","+    private PaymentProviderEntity paymentProvider;","+","+    private String providerAccountId;     // e.g., \"ACC_123456\"","+","+    @Lob","+    private byte[] accessToken;           // Encrypted credentials","+","+    private String endpoint;              // Provider API endpoint","+    private Boolean isProd;               // Production vs Sandbox","+    private Boolean active;","+    private String additionalConfig;      // JSON configuration","+    private String providerMid;           // Merchant ID at provider","+    private String settlementCategory;    // Settlement routing","+}","+```","+","+### Provider-Specific Configurations","+```java","+// Cashfree","+@Data","+public class CashfreeProviderAccountConfiguration {","+    private String apiClientId;","+    private String apiVersion;","+    private ShortCircuitConfiguration shortCircuitConfiguration;","+}","+","+// Cybersource","+@Data","+public class CybersourceProviderAccountConfiguration {","+    private String apiKey;","+    private String merchantId;","+    private Boolean enableRetries = false;","+    private Boolean enableCaptureWithAuth = true;","+    private Boolean enable3DS2 = true;","+    private Boolean enableRedirectionFlow = false;","+}","+```","+","+### Client-Provider Mapping","+**File:** `entity/ClientPaymentProviderConfigEntity.java`","+","+```java","+@Entity @Table(name = \"client_payment_provider_config\")","+public class ClientPaymentProviderConfigEntity extends BaseEntity {","+    @ManyToOne private ClientEntity client;","+    @ManyToOne private PaymentProviderEntity paymentProvider;","+    private String providerConfig;  // JSON configuration per client","+}","+```","+","+---","+","+## 30. ERROR HANDLING & RETRY LOGIC","+","+### Error Classification","+```java","+public enum ProviderRequestStatus {","+    REQUEST_SUCCESS,          // Payment processed","+    RETRY_ABLE_FAILURE,       // Timeout, rate limit - can retry","+    NON_RETRY_ABLE_FAILURE    // Invalid request - cannot retry","+}","+```","+","+### Provider Error Structure","+```java","+@Data @Builder","+public class ProviderError {","+    private String message;           // User-friendly message","+    private String code;              // Provider error code","+    private Object providerResponse;  // Raw error response","+    private Boolean retryable;        // Retry classification","+}","+```","+","+### Error Code Mapping (Cybersource Example)","+```java","+// Failure codes (43 codes)","+\"101\", \"102\", \"104\", \"150\", \"200\", \"201\", \"202\", \"203\", ...","+","+// Processing/Pending codes","+\"110\" (Pending), \"475\" (Timeout), \"480\" (Processing)","+```","+","+### Retry Pattern","+```java","+public ProviderPaymentResponse executePaymentAttempt(...) {","+    try {","+        return pilotMethod.apply(context, providerCustomer);","+    } catch (RateLimitException rle) {","+        return ProviderPaymentResponse.builder()","+            .providerRequestStatus(ProviderRequestStatus.RETRY_ABLE_FAILURE)","+            .providerError(ProviderError.builder()","+                .retryable(true).build())","+            .build();","+    } catch (AppException ae) {","+        return ProviderPaymentResponse.builder()","+            .providerRequestStatus(ProviderRequestStatus.NON_RETRY_ABLE_FAILURE)","+            .build();","+    }","+}","+```","+","+---","+","+## 31. ARCHITECTURAL PATTERNS SUMMARY","+","+| Pattern | Usage | File |","+|---------|-------|------|","+| **Factory** | Adapter selection by (OrderType, Provider, Instrument) | PaymentProviderFactory.java |","+| **Strategy** | LCM vs Decision Tree routing | ProviderDeciderRouter.java |","+| **Template Method** | Base adapter lifecycle | IPaymentProviderAdapter.java |","+| **Builder** | Complex request construction | CybersourceRequestBuilder.java |","+| **Decorator** | Provider-specific configuration | *ConfigValueDecoratorImpl.java |","+","+---","+","+## 32. KEY PROVIDER INTEGRATION FILES","+","+### Core Architecture","+1. `v2/workflow/create/providers/IPaymentProviderAdapter.java` - Base adapter","+2. `v2/workflow/create/providers/PaymentProviderFactory.java` - Factory","+3. `planner/providerdecider/ProviderDeciderRouter.java` - Routing strategy","+","+### Decision Tree","+1. `planner/providerdecider/ProviderDeciderV2.java` - DT workflow","+2. `planner/providerdecider/ProviderDeciderViaLCM.java` - LCM routing","+3. `cache/DecisionTreeObjectCache.java` - DT caching","+","+### Webhooks","+1. `controller/WebhookController.java` - Generic webhook endpoint","+2. `controller/v2/CashfreeWebhookController.java` - Cashfree webhooks","+3. `service/WebhookService.java` - Webhook processing","+","+### Provider Implementations","+1. `v2/workflow/create/providers/CashfreeProviderAdapter.java`","+2. `v2/workflow/create/providers/cybersource/CybersourceProviderAdapter.java`","+3. `v2/workflow/create/providers/PayuProviderAdapter.java`","+","+### Configuration","+1. `entity/ProviderAccountEntity.java` - Provider credentials","+2. `entity/PaymentProviderEntity.java` - Provider definition","+3. `entity/ClientPaymentProviderConfigEntity.java` - Client-provider mapping"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"6b40b5ca-190e-4487-b7b6-f83953a79fa3","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01FKLbTP29svUKa9imRYEXxm","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"I've added the comprehensive Provider Integration deep-dive to the study guide. The guide now has 32 sections covering:\n\n1. Overview & Tech Stack (Section 1)\n2. Project Structure (Section 2)\n3. Core Payment Flow (Section 3)\n4. State Machines (Section 4)\n5. Provider Integrations overview (Section 5)\n6. Key Entities (Section 6)\n7. Database Architecture (Section 7)\n8. Caching Layer (Section 8)\n9. Async Processing (Section 9)\n10. API Endpoints (Section 10)\n11. Authentication & Security (Section 11)\n12. Key Files to Study (Section 12)\n13. Internal Service Dependencies (Section 13)\n14. Study Path Recommendation (Section 14)\n15. Key Concepts (Section 15)\n\nDATA LAYER DEEP-DIVE:\n16. Entity Hierarchy & Inheritance (Section 16)\n17. Master-Replica Database Architecture (Section 17)\n18. Repository & DAO Patterns (Section 18)\n19. JSON Columns & Converters (Section 19)\n20. Caching Architecture (Section 20)\n21. DynamoDB Usage (Section 21)\n22. Optimistic Locking & Audit (Section 22)\n23. Data Layer Architecture Diagram (Section 23)\n24. Key Data Layer Files to Study (Section 24)\n\nPROVIDER INTEGRATION DEEP-DIVE:\n25. Provider Adapter Architecture (Section 25)\n26. Decision Tree Routing (Section 26)\n27. Provider Adapters (24+ implementations) (Section 27)\n28. Webhook Handling (Section 28)\n29. Provider Configuration (Section 29)\n30. Error Handling & Retry Logic (Section 30)\n31. Architectural Patterns Summary (Section 31)\n32. Key Provider Integration Files (Section 32)\n\nThis is now a comprehensive expert-level study guide. Let me ask the user if they want to continue with the Payment Flow deep-dive or if this is sufficient.","signature":"EvkNCkgICxABGAIqQKgThpQqynZW7M4DGRbvYwl470gNvcWYdaDZMluVHt4Fu4Z6DIjuUyxyzbZ5DSr3bhRMGmCFI2LiQhtfqayVavQSDMxnO/4AAXDDzH4eOhoMRDW+w6kAUegh4ORwIjCQ4GP8ikRnH8digUjtCVp1G7/9/HqvaBkHVCSlSnQu7c1HCDUeBf8x0G2Py1Vu6PIq3gzm4ZFrbXzsD+8bOAMnGgmJJuf7FTbx0VRMcK+u2NAmLj25KXDaP73TTWJo0OThQ5tmdv2UIrjPwffQMPBcfhWIMNIhGN2HMkTfk4/KUKDMB8rZ4fDGQ5E0PeUG6ine2n+U9O5QbtBDK775WuSm3XCuIFK+aw9VrJXcOvjRM5L8mtGQ+vh/nbTS8LQQDd7bykuagDo9TxS/cHZmMZuThKFYHpgxsH5QekD2kITchJq3z9A1R+fWmAn2A9K5RIuCdK+V+at3qKI0S2ClcCpLnEi3P/+J2+jsm+6iI/3kKSwP1BKeWP+r1bOcnsNV0s011/IL/Tpbhg4AGWSj38qu8klP5xGmTp78mCScsYNnOH1VVORIDyM6eNpF72+HK9dnJ+hlHzIqIHOIkJ5eCdjXgcelrmY9yEL+lFcCAValSLqdGpL0wgKXxYNAkLnJgJgWbj4xvABCJTdXNjxy+ufBj/PXChz/iyXDHqHCjweSpFw1gg+abeOveqOdtbN3djDXsJqRemvMIBQ8qcrSqwnDvXIbJDnF9cEdX8Aig+Q9isqfgJ+irQ+Gw8LtEyIaFcIjFHoTxZMB/Yz14gAYVIIC6tDFZcJog4JfloygRfYjOOIuafGIetABJDrtCeMQTz+ZNS0FzvUkiAw4PYlI9tlVdr97Wwg4ZUXYtOKBrOww6g/Y8j6JBAJrBKczyW7NpdVZZbypdi+w78Yuw3/FLpg33KvXqyeVJW9O8Dj3i6O/+dIUSd37zPQiXTDhbtgb2UpKCuxKBhpNfv8kyCXAxwut0CLt+nR+44i4m6yu2xPp8FZCv4z7f1fHso1sJHVtrthLkL5AZGmpC/2660pTQKvQ/nxg+vQlT4JdE7cD7ypazwUPL6j9CwTu37kDgiVLWtkhuwEzheuLMjwtMwdF3nhvW1XQONgAFFTr3zuNuywIurpm5sC81VuXVb4D1PcFjEMwOVsXECxdJc5r2ykJ3+Il8+9EnYXAD91UluuMghnIE6QKc3PtI4s8g36RkKEIk7qqQizQOvIxkPmZnfafcn8+hDsozJvPEJqosmgDlJvS0vsRj99dLvi1R4Nc4yZwyESZCIwyZ445cAqEXC+7De581eIuDfA1jcMS2jNP+YI+yYoOOiziCASn4/8RiuI0Hh2eeA+Q5pjojcvKcO3Jeg8Y8sTKm6VkOLFO8PppeQGG+4/2TDKzNqQSuKgCs5h7KP5pxoJ7io86KVoi3LS0U6Iz9wEYy3A030c1AjlrWekHD23LIV9xS4TXYOgVasMfAfDbj0kOoBeb2G012NBsvQEs9JqS8hu8FeN3v+zNWORJ+uQtsPu8JkyIMf0SKw33GBdTCrPiqXpKi8IoDNNyjK0gpGIGO9iz4C7cKhMJEg/eON3KI9C4pI4k0huKAbTmu/NHsLt3ex3DFwVZFhqe+Q62qfXDCd3LisWZy+IywRqWsytJAn6eB8qmXDhY/pHKvXjNkI5P7+tpa2FpThdQfx+Ygl46pzxnXVlu7ZVJxWLCqiDGopnSeNTNivUPNQwN5CwUeKQ8IKob7kAHCo78JAltTReFzJWr7rWbh0GfogIK9/nehPNBnzb054Dx5aMHsTLrRG7M0dZZ2VLr1FF4hUMkr/Dgvsjk9CSgIzXKFXn22I5ECFbm9dY/gMEUDLis/vqUp1Ppw7888a6kjmD7Zc3Eruv6kk4P+yhetqzkL6zUjkFVUDD/HxPD/a0/zxiI4y5+k0A49dDZwl+vfO/CPZixb2B3TAVZehuQQzq6BsQsc7VcOvqNcGqyAYMJILfplR1FSujZYjF5Hf7iPbVK4/Jg/o47qAZhxG9bcGLHPjGmummpWUvyralnYzSXLT4VfzkBpm+pi016fkYIQuq9k7uSUWkZ1YzNfSrvvUZBtpz+uExAs6VWBqolZUANd/71KOxd4S5tbjb6Q3+op7ggC1Qd/imSCzyZyTRG/II8VPpN9GGUU6g46eJlfgcYpHqSbNQ425mFfo4GqpsdSI8ZPnbX94hSRdnJR+b6r0xyKi2mALXO6aceIkqLs6JwxO9krLsdExMHK1/NGduBidb14+YlpxqbFDnO4h0DjYuHjuZQZJRUb9N/b7MrYjOy6BzmesyNIsRtN51oeCeFC2zUmDJRETkqNuH0u5Y77ZznIWy4fDI24vzyvn7vOvlqiWleNtRJGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":24383,"cache_read_input_tokens":67637,"cache_creation":{"ephemeral_5m_input_tokens":24383,"ephemeral_1h_input_tokens":0},"output_tokens":1}},"type":"assistant","uuid":"e230d59a-f2c0-43a4-bd7c-8c357cdc050c","timestamp":"2025-12-31T09:49:20.389Z"}
{"parentUuid":"e230d59a-f2c0-43a4-bd7c-8c357cdc050c","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01FKLbTP29svUKa9imRYEXxm","type":"message","role":"assistant","content":[{"type":"text","text":"I've added a comprehensive Provider Integration deep-dive to your study guide. Here's a summary of what's now covered:\n\n## Provider Integration Deep-Dive Summary\n\n### Key Components\n\n| Component | Purpose | Key File |\n|-----------|---------|----------|\n| **IPaymentProviderAdapter** | Base abstract class for all 24+ providers | `v2/workflow/create/providers/IPaymentProviderAdapter.java` |\n| **PaymentProviderFactory** | Multi-dimensional lookup for adapter selection | `PaymentProviderFactory.java` |\n| **ProviderDeciderRouter** | Strategy pattern: LCM vs Decision Tree routing | `planner/providerdecider/ProviderDeciderRouter.java` |\n| **Webhook Controllers** | 9+ provider-specific webhook handlers | `controller/v2/*WebhookController.java` |\n\n### Provider Routing Flow\n```\nRequest → ProviderDeciderRouter → [LCM or Decision Tree] → Provider Adapter → External API\n```\n\n### Error Handling\n- `REQUEST_SUCCESS` - Payment processed\n- `RETRY_ABLE_FAILURE` - Timeout/rate limit (can retry)\n- `NON_RETRY_ABLE_FAILURE` - Invalid request (cannot retry)\n\nYour study guide now has **32 comprehensive sections** covering:\n- Overview & Architecture (Sections 1-15)\n- Data Layer Deep-Dive (Sections 16-24)\n- Provider Integration Deep-Dive (Sections 25-32)"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":24383,"cache_read_input_tokens":67637,"cache_creation":{"ephemeral_5m_input_tokens":24383,"ephemeral_1h_input_tokens":0},"output_tokens":1}},"type":"assistant","uuid":"23843c34-a59b-4c63-b236-637589fb6190","timestamp":"2025-12-31T09:49:29.022Z"}
{"parentUuid":"23843c34-a59b-4c63-b236-637589fb6190","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01FKLbTP29svUKa9imRYEXxm","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_bdrk_01Rg3ztGgr9sQcXUxz6MbvX2","name":"AskUserQuestion","input":{"questions":[{"question":"Would you like to add a Payment Flow deep-dive (workflows, state machines, end-to-end processing) or is this study guide complete?","header":"Final Check","options":[{"label":"Add Payment Flow","description":"Deep-dive into PaymentAttemptCreateWorkflow, 7-step pipeline, state transitions, and complete end-to-end flow"},{"label":"Guide Complete","description":"The 32-section study guide is comprehensive - I'll start studying and ask questions as I go"}],"multiSelect":false}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":24383,"cache_read_input_tokens":67637,"cache_creation":{"ephemeral_5m_input_tokens":24383,"ephemeral_1h_input_tokens":0},"output_tokens":1021}},"type":"assistant","uuid":"48f829f9-c5a9-402a-a63e-7b0921201f59","timestamp":"2025-12-31T09:49:29.265Z"}
{"parentUuid":"48f829f9-c5a9-402a-a63e-7b0921201f59","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"User has answered your questions: \"Would you like to add a Payment Flow deep-dive (workflows, state machines, end-to-end processing) or is this study guide complete?\"=\"Add Payment Flow\". You can now continue with the user's answers in mind.","tool_use_id":"toolu_bdrk_01Rg3ztGgr9sQcXUxz6MbvX2"}]},"uuid":"4e99cc4a-1450-402a-a69b-4855d2b7a7a0","timestamp":"2025-12-31T09:49:35.596Z","toolUseResult":{"questions":[{"question":"Would you like to add a Payment Flow deep-dive (workflows, state machines, end-to-end processing) or is this study guide complete?","header":"Final Check","options":[{"label":"Add Payment Flow","description":"Deep-dive into PaymentAttemptCreateWorkflow, 7-step pipeline, state transitions, and complete end-to-end flow"},{"label":"Guide Complete","description":"The 32-section study guide is comprehensive - I'll start studying and ask questions as I go"}],"multiSelect":false}],"answers":{"Would you like to add a Payment Flow deep-dive (workflows, state machines, end-to-end processing) or is this study guide complete?":"Add Payment Flow"}}}
{"parentUuid":"4e99cc4a-1450-402a-a69b-4855d2b7a7a0","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01HnYtsUsaNiV2npHE4asz9K","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user wants to add a Payment Flow deep-dive. Let me launch an exploration agent to provide comprehensive analysis of the payment workflows, state machines, and end-to-end processing.","signature":"EuQCCkgICxABGAIqQLqOS9wHb0POjukOnUZS1nvwOA/c3ELIPr51LaJBFe4IjIJqCha+UVipuO9dzXZ9iw+CfvsXWKzbARY1SMUD6CASDGmO0ZBp0fXQbpuYPhoMJFvMA7Hrwtcy4cVMIjBUZAJNTS2iyTuxCcSYuKfDvpg6nxZ1vR59q6ojjcedrluQcRoRvPpmr5C+LSNOyWkqyQERuZxdJr5thGbSQIon0N8Roz6FCWhoVX/TDZcF40NXNCKNZujfuokfeis9Qqr6lyJyVWpqUwldEWafehj5u7AKl3LbQQ8iOafxW5CpqJ6u8oMoY97UYC5v1LlPlNi2OHmblwBE1t2dYKT5/mDaflYKvcd4N/tJWTwMnq732/ruTKbxK5GUHyMkcLG7Mbo/2Qyxi7cYaEZZMnhN1EGHly2KPdimHWpRp0NMUIOUwPZ1VSbBuySmNeOB85ykMk5qC5ILkjDXGnyFVo8YAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":1189,"cache_read_input_tokens":92020,"cache_creation":{"ephemeral_5m_input_tokens":1189,"ephemeral_1h_input_tokens":0},"output_tokens":1}},"type":"assistant","uuid":"e03a700a-245e-4bf3-85b8-8d027fddd1f1","timestamp":"2025-12-31T09:49:43.746Z"}
{"parentUuid":"e03a700a-245e-4bf3-85b8-8d027fddd1f1","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01HnYtsUsaNiV2npHE4asz9K","type":"message","role":"assistant","content":[{"type":"text","text":"Let me add the final deep-dive on Payment Flow - workflows, state machines, and end-to-end processing."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":1189,"cache_read_input_tokens":92020,"cache_creation":{"ephemeral_5m_input_tokens":1189,"ephemeral_1h_input_tokens":0},"output_tokens":1}},"type":"assistant","uuid":"df6cd656-6677-40c5-93d1-32d55c5ba749","timestamp":"2025-12-31T09:49:44.752Z"}
{"parentUuid":"df6cd656-6677-40c5-93d1-32d55c5ba749","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01HnYtsUsaNiV2npHE4asz9K","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_bdrk_01QcRqkgCLs1VyzHn8yLdqU5","name":"Task","input":{"description":"Deep-dive payment flow workflows","prompt":"Provide an extremely detailed analysis of the payment-service Payment Flow architecture for expert study. Cover:\n\n1. **PaymentAttemptCreateWorkflow Deep-Dive:**\n   - Complete 7-step workflow pipeline in detail\n   - Each step's purpose and implementation\n   - Context object and how data flows through steps\n   - How validation, enrichment, persistence work\n\n2. **Workflow Pattern Architecture:**\n   - Base Workflow class and template method pattern\n   - How workflows extend the base class\n   - Context builders and data enrichment\n   - Error collection and handling in workflows\n\n3. **State Machine Implementation:**\n   - PaymentStateMachine detailed implementation\n   - OrderStateMachine detailed implementation\n   - RefundStateMachine if exists\n   - Event types and how they're published (EventBus)\n   - State transitions and terminal states\n\n4. **Complete End-to-End Payment Flow:**\n   - From API request to response\n   - Order creation → Payment creation → Payment attempt → Provider call\n   - How webhooks update state\n   - How sync operations work\n   - Complete trace through the code\n\n5. **3DS/Authentication Flows:**\n   - How 3DS authentication is handled\n   - Native OTP flow\n   - Redirect flows and callbacks\n   - Authentication state management\n\n6. **Instrument Processing:**\n   - InstrumentTypeProcessorManager\n   - How different payment instruments are validated and enriched\n   - Card, UPI, NetBanking specific processing\n\nProvide specific file paths, method names, and code flow traces. This is for expert-level understanding.","subagent_type":"Explore"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":1189,"cache_read_input_tokens":92020,"cache_creation":{"ephemeral_5m_input_tokens":1189,"ephemeral_1h_input_tokens":0},"output_tokens":519}},"type":"assistant","uuid":"aa6a59d0-dfde-4ca4-8d2e-00f1ab704019","timestamp":"2025-12-31T09:49:53.554Z"}
{"parentUuid":"aa6a59d0-dfde-4ca4-8d2e-00f1ab704019","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01QcRqkgCLs1VyzHn8yLdqU5","type":"tool_result","content":[{"type":"text","text":"Perfect! I now have enough information to provide a comprehensive analysis. Let me compile the detailed document:\n\n---\n\n# EXPERT-LEVEL PAYMENT FLOW ARCHITECTURE ANALYSIS\n## Payment-Service Complete Deep Dive Study\n\n---\n\n## 1. PAYMENTATTEMPTCREATEWORKFLOW - COMPLETE 7-STEP PIPELINE\n\n### **File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java`\n\nThe PaymentAttemptCreateWorkflow extends `CreateWorkflowFromParent<CreatePaymentAttemptRequest, PaymentAttemptCreateContext, PaymentAttemptResponse, PaymentCreateContext>` and executes the 7-step payment attempt creation pipeline:\n\n### **7-Step Pipeline Execution:**\n\n**STEP 1: Validation & Enrichment (`validateAndEnrichContext`)**\n- **Method:** Lines 183-296\n- **Purpose:** Input validation, data enrichment, and context preparation\n- **Key Operations:**\n  - Validates compatible instrument type with payment mode (Line 223)\n  - **Data Enricher 1:** Calls `InstrumentTypeProcessorManager.validatePaymentInstrumentAndEnrich()` (Line 226-227)\n    - Enriches payment instrument details\n    - Returns `InstrumentTypeProcessorResult<?, ?>` containing:\n      - `paymentMethod` (PaymentInstrumentGroup)\n      - `paymentSubMethodDetail` (enriched details)\n      - `enrichedPaymentInstrument` (final instrument)\n  - Fetches customer entity (Line 229-231)\n  - **Data Enricher 2:** Provider routing decision via `providerDeciderRouter.resolve(context)` (Line 249-252)\n    - Routes to appropriate payment provider\n    - Returns `ProviderRoutingDecisionResult` with provider account\n  - Validates flow type compatibility (Line 257-268)\n  - **Data Enricher 3:** Auth type decision via `authTypeDeciderFactory.validateAndDecideAuthType()` (Line 278-282)\n    - Determines authentication type (NATIVE_OTP, REDIRECT, etc.)\n  - Decides native provider account (Line 284)\n  - **Data Enricher 4:** Enriches settlement route information (Line 289)\n  - **Context Object Structure:**\n    ```java\n    PaymentAttemptCreateContext {\n        CreatePaymentAttemptRequest request\n        PaymentAttemptResponse response\n        PaymentAttemptV2Entity paymentAttemptEntity (created)\n        PaymentV2Entity paymentEntity\n        OrderEntity orderEntity\n        CustomerEntity customerEntity\n        ClientEntity clientEntity\n        InstrumentTypeProcessorResult<?, ?> instrumentProcessorResult\n        ProviderAccountEntity providerAccountEntity\n        ProviderAccountEntity nativeProviderAccountEntity\n        ProviderRoutingDecisionResult routingDecisionResult\n        AuthType authType\n        Boolean isPlatformNativeOtpSupported\n        PaymentAttemptNativeOTPDetailEntity nativeOTPDetailEntity\n        RoutesBreakup routesBreakup\n        List<FeeCreateContext> feeCreateContexts\n        ProviderPaymentResponse createResponse\n        UserError userError\n        String mandateId\n        Mandate mandate\n        String threeDsVersion\n    }\n    ```\n\n**STEP 2: Persist Intent (`persistIntent`)**\n- **Method:** Lines 352-408 (Transactional boundary)\n- **Purpose:** Save payment attempt entity and fees to relational database\n- **Database Operations:**\n  - Creates `PaymentAttemptV2Entity` with:\n    - External ID (UUID via `PaymentAttemptUUIdGenerator.generate()`) - Line 379\n    - Status: `CREATED` - Line 371\n    - Provider account and payment provider - Lines 368-370\n    - Payment method and sub-method - Lines 363-366\n    - Instrument details - Line 376\n    - Routes breakup - Line 377\n  - Saves to `PaymentAttemptRepository` - Line 381\n  - Saves fee entities via `feeCreateWorkflow.persistIntent()` - Line 383\n  - Enriches attributes for DT/CM results - Lines 390-398\n  - Saves return URL if provided - Lines 401-407\n\n**STEP 3: Publish Pre-Persist Events (`publishEntityPrePersistEvents`)**\n- Base implementation (optional hook)\n- Placeholder for events before non-relational persistence\n\n**STEP 4: Persist Non-Relational Data (`persistNonRelationalIntent`)**\n- **Method:** Lines 440-450\n- **Purpose:** Save non-relational data (DynamoDB)\n- **Operations:**\n  - Initiates native OTP flow if applicable (Line 447)\n  - Saves `PaymentAttemptNativeOTPDetailEntity` to DynamoDB\n  - Audits provider metadata (Line 449)\n\n**STEP 5: Process (`process`)**\n- **Method:** Lines 453-481 (Provider interaction)\n- **Purpose:** Call payment provider API for payment attempt creation\n- **Key Logic:**\n  - Finds appropriate provider adapter via `paymentProviderFactory.findPaymentProviderAdapter()` (Lines 462-467)\n  - Determines 3DS type via `providerAccountManager.getThreeDSType()`\n  - Executes provider call:\n    ```java\n    paymentProviderAdapter.executePaymentAttempt(\n        context,\n        paymentProviderAdapter::createPaymentAttempt,\n        FlowType.CREATE\n    )\n    ```\n  - Checks platform OTP capability (Line 468)\n  - Returns `ProviderPaymentResponse` containing:\n    - Provider status\n    - Provider reference ID\n    - Transaction response (authentication details)\n    - Provider error (if any)\n    - Request status (SUCCESS, TIMED_OUT, etc.)\n  - Exception handling: Updates status to FAILED and collects errors (Lines 474-479)\n\n**STEP 6: Post-Process (`postProcess`)**\n- **Method:** Lines 485-550 (Transactional)\n- **Purpose:** Update payment attempt entity with provider response\n- **Post-Processing Logic:**\n  - Sets provider status and reference IDs (Lines 495-497)\n  - Adds browser and end URL details (Line 498)\n  - Enriches SDK parameters via `sdkTypeDeciderFactory` (Lines 500-505)\n  - Adds UPI intent URL if required (Lines 509-514)\n  - Sets error code/message if provider error (Lines 516-521)\n  - Updates status based on provider request status:\n    - If `REQUEST_SUCCESS`: Set to provider status (Line 524)\n    - If non-success on eligible payment modes: Set to PROCESSING or FAILED (Lines 526-536)\n    - If timeout: Set error code to `TIMED_OUT` (Lines 537-539)\n  - Adds mandate ID to attributes if applicable (Lines 542-545)\n  - Saves updated entity (Line 548)\n  - **Returns:** `PaymentAttemptResponse` via mapper (Line 549)\n\n**STEP 7: Post-Persist Non-Relational & Event Publishing**\n- **`postPersistNonRelationalDataStore`** (Line 553-557):\n  - Updates native OTP details after provider processing\n  - Persists OTP challenge ID and other SDK params\n  \n- **`publishEntityChangeEvents`** (Lines 560-585):\n  - Posts event to sync/async event buses:\n    ```java\n    asyncBus.post(PaymentAttemptEventFactory.findEvent(paymentAttemptEntity))\n    syncBus.post(PaymentAttemptEventFactory.findEvent(paymentAttemptEntity))\n    ```\n  - Publishes to multi-tenant event system (`eventiService`)\n  - Updates mandate token reference ID if mandate flow\n  - Adds entity for sync (Line 575)\n\n---\n\n## 2. WORKFLOW PATTERN ARCHITECTURE\n\n### **Base Workflow Class (Template Method Pattern)**\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/Workflow.java`\n\n```java\npublic abstract class Workflow<Request, Context extends WorkflowContext<Request, Response>, Response> {\n    \n    public Response execute(Request request) {\n        // STEP 1: Initialize and validate\n        Context context = selfProxy.validateAndEnrichContext(request);\n        \n        // STEP 2: Persist to database (transactional)\n        selfProxy.persistIntent(context);\n        \n        // STEP 3: Pre-persist events\n        selfProxy.publishEntityPrePersistEvents(context);\n        \n        // STEP 4: Persist to non-relational DB\n        selfProxy.persistNonRelationalIntent(context);\n        \n        // STEP 5: Process (external calls)\n        selfProxy.process(context);\n        \n        // STEP 6: Post-process and save results (transactional)\n        Response response = selfProxy.postProcess(context);\n        \n        // STEP 7: Post-persist non-relational updates\n        postPersistNonRelationalDataStore(context);\n        \n        // STEP 8: Publish events\n        selfProxy.publishEntityChangeEvents(context);\n        \n        // STEP 9: Throw error if required\n        throwErrorIfRequired(context);\n        \n        return response;\n    }\n}\n```\n\n### **Extension Pattern: CreateWorkflowFromParent**\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/CreateWorkflowFromParent.java`\n\n```java\npublic abstract class CreateWorkflowFromParent<Request, Context, Response, ParentContext> \n        extends Workflow<Request, Context, Response> {\n    \n    // Supports enriching context from parent workflow's context\n    // Example: PaymentAttemptCreateWorkflow enriches from PaymentCreateContext\n    public abstract Context validateAndEnrichContextFromParentContext(\n            ParentContext parentContext, \n            Request request\n    );\n}\n```\n\n**Usage Pattern:**\n- `OrderCreateWorkflow` → `PaymentCreateWorkflow` → `PaymentAttemptCreateWorkflow`\n- Each level passes enriched context to next level\n- Enables hierarchical data enrichment\n\n### **Sequential Workflow with Distributed Locking**\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/SequentialWorkflow.java`\n\n```java\npublic abstract class SequentialWorkflow<Request, Context, Response> \n        extends Workflow<Request, Context, Response> {\n    \n    @Override\n    public Response execute(Request request) {\n        LockSetting lockSetting = fetchLockSetting();\n        String lockKeyValue = evaluateLockKey(request, lockSetting.getLockKey());\n        \n        // Uses Redis for distributed locking\n        Optional<RLock> lock = acquireLock(lockKeyValue, lockSetting.getFlowType());\n        \n        if (lock.isPresent() || !lockSetting.getIsLockMandatory()) {\n            try {\n                return super.execute(request);\n            } finally {\n                lock.ifPresent(redisLockUtil::releaseLock);\n            }\n        }\n        throw Error.unable_to_acquire_lock.getBuilder().build();\n    }\n}\n```\n\n### **WorkflowContext Data Container**\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/workflow/WorkflowContext.java`\n\n```java\n@Data\npublic class WorkflowContext<Request, Response> {\n    private final Request request;\n    private final Response response;\n    private final List<WorkflowInternalError> workflowInternalErrors = new ArrayList<>();\n}\n```\n\n### **Error Collection Pattern**\n\n- `workflowInternalErrors` list accumulates errors during workflow execution\n- Errors thrown only after all processing complete\n- Enables graceful degradation and detailed error reporting\n\n---\n\n## 3. STATE MACHINE IMPLEMENTATION\n\n### **PaymentStateMachine - Event-Driven State Management**\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/statemachine/payment/PaymentStateMachine.java`\n\n#### **Architecture:**\n- Component-based, Spring-managed singleton\n- Uses Guava EventBus for event subscription\n- Implements self-referencing proxy pattern for transactional boundaries\n- Concurrent event handling via `@AllowConcurrentEvents`\n\n#### **Key Event Types & Subscriptions:**\n\n```\nPaymentStateMachine Subscriptions:\n├── @Subscribe onPaymentAttemptCreated(PaymentAttemptCreatedEvent)\n│   └── Updates Payment status: FAILED → CREATED (if applicable)\n│   └── Validates no completed attempts exist\n│\n├── @Subscribe onPaymentAttemptFailed(PaymentAttemptFailedEvent)\n│   └── Checks if all attempts non-failed\n│   └── If all failed: Updates Payment → FAILED\n│\n├── @Subscribe onPaymentAttemptCompleted(PaymentAttemptCompletedEvent) [Retryable]\n│   └── Acquires optimistic lock with retry (2 attempts, 10ms backoff)\n│   └── Updates Payment → COMPLETED\n│   └── Publishes to Pinot (analytics)\n│\n├── @Subscribe onPaymentAttemptAuthorized(PaymentAttemptAuthorizedEvent) [Retryable]\n│   └── Updates Payment → AUTHORIZED\n│   └── Executes 3DS next step if applicable\n│\n├── @Subscribe onPaymentAttemptProcessingEvent(PaymentAttemptProcessingEvent)\n│   └── Updates Payment → PROCESSING (if no completed attempts)\n│\n├── @Subscribe onPaymentAttemptBlockedEvent(PaymentAttemptBlockedEvent)\n│   └── Updates Payment → BLOCKED\n│\n├── @Subscribe onPaymentAttemptReversedEvent(PaymentAttemptReversedEvent)\n│   └── Updates Payment → FAILED\n│\n├── @Subscribe onPaymentAttemptAuthenticationSuccessfulEvent\n│   └── Updates Payment → AUTHENTICATION_SUCCESSFUL\n│   └── Executes 3DS next step\n│\n└── @Subscribe onPaymentAttemptAuthenticationFailedEvent\n    └── Updates Payment → AUTHENTICATION_FAILED\n```\n\n#### **State Transitions & Terminal States:**\n\n**Terminal Payment Statuses:**\n```\n- COMPLETED\n- FAILED\n- FORCE_FAILED\n- DISCARDED\n```\n\n**Non-Terminal Payment Statuses:**\n```\n- CREATED\n- PROCESSING\n- AUTHORIZED\n- AUTHENTICATION_SUCCESSFUL\n- AUTHENTICATION_FAILED\n- BLOCKED\n- FAILED (non-terminal until completed)\n```\n\n#### **State Transition Logic:**\n\n```java\nprivate boolean shouldUpdatePaymentStatus(PaymentV2Entity paymentEntity) {\n    return !Arrays.asList(\n        PaymentStatus.COMPLETED,\n        PaymentStatus.FAILED,\n        PaymentStatus.FORCE_FAILED,\n        PaymentStatus.DISCARDED\n    ).contains(paymentEntity.getStatus());\n}\n```\n\n#### **Event Publishing:**\n\n```java\nprivate void updatePaymentStatus(PaymentV2Entity paymentEntity, PaymentStatus newStatus, \n                                 boolean isAuthenticationFlow) {\n    paymentEntity.setStatus(newStatus);\n    \n    if (!newStatus.equals(currentStatus)) {\n        // Update database\n        paymentEntity = selfProxy.updatePaymentState(paymentEntity);\n        \n        // Post event to sync bus (state machines)\n        eventBus.post(PaymentEventFactory.findEvent(paymentEntity, isAuthenticationFlow));\n        \n        // Publish to multi-tenant event system\n        eventiService.publishEvent(paymentEntity);\n        \n        // Async publish to Pinot (analytics)\n        CompletableFuture.supplyAsync(() -> eventiService.publishToPinot(entity));\n    }\n}\n```\n\n### **OrderStateMachine - Order Level State Management**\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/statemachine/order/OrderStateMachine.java`\n\n#### **Event Subscriptions:**\n\n```\nOrderStateMachine Subscriptions:\n├── @Subscribe onPaymentCreated(PaymentCreatedEvent)\n│   └── Calculates total payment amount across all payments\n│   └── Determines OrderStatus based on:\n│       ├── All payments are non-auth & non-independent → AUTHLESS_READY_TO_PROCESS\n│       └── Otherwise → CREATED\n│\n├── @Subscribe onPaymentFailed(PaymentFailedEvent)\n│   └── Updates Order → FAILED (if not already terminal)\n│\n├── @Subscribe onPaymentAuthorized(PaymentAuthorizedEvent) [Retryable]\n│   └── Updates Order → AUTHORIZED (if not terminal)\n│\n├── @Subscribe onPaymentBlockedEvent(PaymentBlockedEvent)\n│   └── Checks for auth/authless payment presence\n│   └── Updates to PROCESSING or AUTHLESS_READY_TO_PROCESS\n│\n├── @Subscribe onPaymentCompleted(PaymentCompletedEvent) [Retryable]\n│   └── Complex logic:\n│       ├── All payments COMPLETED → COMPLETED\n│       ├── All auth payments COMPLETED + no failed payments → AUTHLESS_READY_TO_PROCESS\n│       └── Other conditions → PROCESSING\n│\n├── @Subscribe onPaymentProcessingEvent(PaymentProcessingEvent)\n│   └── Updates Order → PROCESSING (if not already COMPLETED)\n│\n├── @Subscribe onPaymentAuthenticationSuccessfulEvent\n│   └── Auth flow: Order → COMPLETED\n│   └── Non-auth flow: Order → PROCESSING\n│\n└── @Subscribe onPaymentAuthenticationFailedEvent\n    └── Updates Order → FAILED\n```\n\n#### **Terminal Order Statuses:**\n\n```\n- COMPLETED\n- FAILED\n- AUTHLESS_READY_TO_PROCESS (semi-terminal)\n```\n\n#### **Order Status Update Flow:**\n\n```java\nprivate void performOrderStatusActions(OrderEntity orderEntity, OrderStatus newStatus) {\n    // Guard: Prevent updates to already-terminal orders\n    if (OrderUtil.isTerminalOrder(orderEntity)) {\n        return;\n    }\n    \n    // Determine new external status\n    String newExternalStatus = orderEntity.determineOrderExternalStatus(newStatus).name();\n    \n    // Guard: Skip if no status change\n    if (newStatus.equals(currentStatus) && newExternalStatus.equals(orderExternalStatus)) {\n        return;\n    }\n    \n    // Update with retry logic\n    orderEntity = selfProxy.updateOrderEntity(orderEntity, newStatus, newExternalStatus);\n    \n    // Post event to async bus\n    selfProxy.asyncPost(OrderEventFactory.findEvent(orderEntity));\n    \n    // Publish to event system if external status changed\n    if (!orderEntity.getExternalStatus().equals(orderExternalStatus)) {\n        eventiService.publishEvent(orderEntity);\n    }\n}\n```\n\n### **RefundStateMachine - Refund Lifecycle Management**\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/statemachine/RefundStateMachine.java`\n\n#### **Event Subscriptions:**\n\n```\nRefundStateMachine Subscriptions:\n├── @Subscribe onRefundAttemptCreated(RefundAttemptCreatedEvent)\n│   └── Validates no completed refunds exist\n│   └── Updates Refund → PROCESSING\n│   └── Posts RefundEventFactory event\n│\n├── @Subscribe onRefundAttemptProcessing(RefundAttemptProcessingEvent)\n│   └── Updates Refund → PROCESSING (if not terminal and not completed)\n│\n├── @Subscribe onRefundAttemptManualReview(RefundAttemptManualReviewEvent)\n│   └── Updates Refund → PROCESSING (if not terminal or already processing)\n│\n├── @Subscribe onRefundAttemptCompleted(RefundAttemptCompletedEvent)\n│   └── Updates Refund → COMPLETED\n│   └── Double refund detection (logs error)\n│\n└── @Subscribe onRefundAttemptFailed(RefundAttemptFailedEvent)\n    └── Checks if other attempts are non-terminal\n    └── If all terminal: Updates Refund → FAILED\n```\n\n#### **Terminal Refund Statuses:**\n\n```\n- COMPLETED\n- FAILED\n- PROCESSING (semi-terminal)\n```\n\n---\n\n## 4. COMPLETE END-TO-END PAYMENT FLOW\n\n### **Request Entry Point**\n\n**API Call Flow:**\n```\nClient Request\n    ↓\nPaymentAttemptV2Controller (or OrderController)\n    ↓\nOrderCreateWorkflow.execute(CreateOrderRequest)\n```\n\n### **Phase 1: Order Creation**\n\n**Flow:**\n```\nOrderCreateWorkflow.validateAndEnrichContext()\n├── Validates request fields\n├── Fetches/creates customer entity\n├── Creates OrderEntity with CREATED status\n├── Posts PaymentCreatedEvent per payment\n└── Returns OrderCreateContext\n\n    ↓\n\nOrderCreateWorkflow.persistIntent()\n├── Saves OrderEntity to database\n└── Posts pre-persist events\n\n    ↓\n\nOrderCreateWorkflow.process()\n├── No-op for order creation\n\n    ↓\n\nOrderCreateWorkflow.postProcess()\n├── Returns Order DTO\n└── Posts PaymentEventFactory events\n\n    ↓\n\nOrderStateMachine receives PaymentCreatedEvent\n├── Calculates total payment amount\n├── Updates Order status (CREATED / AUTHLESS_READY_TO_PROCESS)\n└── Posts OrderEventFactory event\n```\n\n### **Phase 2: Payment Creation**\n\n**Flow:**\n```\nPaymentCreateWorkflow.validateAndEnrichContext()\n├── Validates payment fields\n├── Creates PaymentV2Entity (status: CREATED)\n├── Enrich with customer/client context\n└── Delegates to PaymentAttemptCreateWorkflow\n    \n    ↓\n\nPaymentCreateWorkflow.persistIntent()\n├── Saves PaymentV2Entity\n└── Delegates to PaymentAttemptCreateWorkflow\n\n    ↓\n\nPaymentCreateWorkflow.postProcess()\n├── Calls PaymentAttemptCreateWorkflow.execute()\n└── Returns Payment DTO\n\n    ↓\n\nPaymentStateMachine receives PaymentAttemptCreatedEvent\n└── Updates Payment: FAILED → CREATED (if needed)\n```\n\n### **Phase 3: Payment Attempt Creation (Core Flow)**\n\n**Detailed Trace:**\n\n```\nPaymentAttemptCreateWorkflow.validateAndEnrichContext()\n\nStep 1.1: Instrument Processing\n├── InstrumentTypeProcessorManager.validatePaymentInstrumentAndEnrich()\n│   └── Routes to CardInstrumentTypeProcessor, UPIPayInstrumentTypeProcessor, etc.\n│   └── Returns InstrumentTypeProcessorResult with:\n│       ├── PaymentMethod (CARD, UPI_PAY, NET_BANKING, etc.)\n│       ├── PaymentSubMethodDetail (enriched details)\n│       └── EnrichedPaymentInstrument (card type, issuer, etc.)\n└── Customer entity fetched from database\n\nStep 1.2: Provider Routing Decision\n├── ProviderDeciderRouter.resolve(context)\n│   └── Executes decision tree engine\n│   └── Considers:\n│       ├── Payment mode\n│       ├── Instrument type\n│       ├── Merchant configuration\n│       ├── Customer metadata\n│       └── Risk scoring\n│   └── Returns ProviderRoutingDecisionResult with:\n│       ├── ProviderAccountEntity (selected provider)\n│       ├── DecisionTreeId (for audit)\n│       ├── IsPlatformOtpEnabled (feature flag)\n│       ├── CmResolveTerminalResult (credit manager response)\n│       └── Browser type\n└── Stores decision in context.routingDecisionResult\n\nStep 1.3: Flow Type Validation\n├── Retrieves supported flow types for provider\n├── Validates request flow type compatibility\n└── Throws error if unsupported\n\nStep 1.4: SDK Type Decision\n├── SdkTypeDeciderFactory.getSdkTypeDeciderByInstrumentType()\n│   └── Routes to CardSdkTypeDecider, UpiSdkTypeDecider, etc.\n│   └── Performs instrument-specific validation\n└── Enriches SDK parameters\n\nStep 1.5: Authentication Type Decision\n├── AuthTypeDeciderFactory.validateAndDecideAuthType()\n│   └── Considers:\n│       ├── Instrument type\n│       ├── Provider capabilities\n│       ├── Amount thresholds\n│       ├── Customer metadata\n│       └── 3DS version support\n│   └── Returns AuthType:\n│       ├── NATIVE_OTP (3DS authentication on device)\n│       ├── REDIRECT (3DS redirect flow)\n│       ├── NO_AUTHENTICATION (for certain instruments)\n│       └── CLIENT_INITIATED_AUTHENTICATION\n└── Sets context.authType\n\nStep 1.6: Native Provider Decision\n├── NativeProviderDecider.decideNativeProviderAccountEntity()\n│   └── Selects provider for native OTP if applicable\n└── Sets context.nativeProviderAccountEntity\n\nStep 1.7: Settlement Route Enrichment\n├── SettlementRouteValidator.validateRoutesAndGetRouteInformation()\n│   └── Validates merchant settlement routes\n│   └── Enriches route breakup information\n└── Sets context.routesBreakup\n\nStep 1.8: Mandate Processing (if EMANDATE order)\n├── MandateServiceDataManager.registerMandateIntent()\n│   └── Creates mandate registration with provider\n│   └── Returns Mandate object with provider reference\n└── Sets context.mandateId and context.mandate\n\nStep 1.9: Additional Details Enrichment\n├── InstrumentTypeProcessorManager.enrichAdditionalDetailsFromPaymentAttemptContext()\n│   └── Calls CardInstrumentTypeProcessor.enrichAdditionalDetailsFromPaymentAttemptContext()\n│   └── Performs instrument-specific enrichment\n└── Common validations:\n    └── validatePaymentNotInTerminalStatus()\n        ├── Checks for existing COMPLETED attempts\n        └── Throws error if found (prevents double charging)\n\nContext Created: PaymentAttemptCreateContext\n\n\nPaymentAttemptCreateWorkflow.persistIntent()\n├── Creates PaymentAttemptV2Entity\n│   ├── ExternalId = PaymentAttemptUUIdGenerator.generate()\n│   │   └── Deterministic UUID from provider account + payment ID\n│   ├── Status = CREATED\n│   ├── Stores instrument details (enriched)\n│   ├── Stores payment method/sub-method\n│   └── Stores provider account references\n├── Saves PaymentAttemptV2Entity\n├── Saves FeeEntities if applicable\n├── Enriches attributes:\n│   ├── IS_DARWIN_REDIRECTION_FLOW (if redirect flow)\n│   ├── DT_ID (decision tree ID)\n│   ├── DT_RESULT (serialized decision tree result)\n│   └── CM_RESULT (credit manager result)\n└── Saves return URL if provided (in OrderAttributes)\n\n\nPaymentAttemptCreateWorkflow.publishEntityPrePersistEvents()\n├── Hook for custom implementations\n\n\nPaymentAttemptCreateWorkflow.persistNonRelationalIntent()\n├── Checks if native OTP flow:\n│   └── AuthType == NATIVE_OTP OR IsPlatformNativeOtpSupported\n├── If applicable:\n│   ├── NativeOTPDetailDataManager.actionOnStartAuthentication()\n│   │   └── Creates PaymentAttemptNativeOTPDetailEntity\n│   │       ├── Stores provider account ID\n│   │       ├── Stores auth type\n│   │       └── Persists to DynamoDB\n│   └── Sets context.nativeOTPDetailEntity\n└── Audits provider metadata\n\n\nPaymentAttemptCreateWorkflow.process()\n\nStep 5.1: Provider Adapter Selection\n├── PaymentProviderFactory.findPaymentProviderAdapter()\n│   ├── Routes on:\n│   │   ├── OrderType (PAY, AUTHORIZE, etc.)\n│   │   ├── PaymentProvider.Key (JUSPAY, RAZORPAY, etc.)\n│   │   ├── InstrumentType (CARD, UPI_PAY, etc.)\n│   │   └── ThreeDSType (from ProviderAccountManager)\n│   └── Returns IPaymentProviderAdapter subclass\n│       └── e.g., JuspayCardPaymentProviderAdapter\n└── Adapter handles provider-specific logic\n\nStep 5.2: Provider API Call\n├── adapter.executePaymentAttempt()\n│   ├── Gets provider customer (creates if needed)\n│   │   └── ProviderCustomerEntity stored in database\n│   ├── Updates provider-specific data\n│   │   └── For NetBanking: Maps issuer code\n│   ├── Calls adapter.createPaymentAttempt(context, providerCustomer)\n│   │   └── Provider-specific implementation:\n│   │       ├── Juspay: Calls Juspay create order API\n│   │       ├── Razorpay: Calls Razorpay create payment API\n│   │       └── Others: Provider-specific implementation\n│   ├── Returns ProviderPaymentResponse:\n│   │   ├── ProviderStatus (provider's internal status)\n│   │   ├── ProviderReferenceId (provider's order/payment ID)\n│   │   ├── GatewayReferenceId (gateway's reference)\n│   │   ├── Status (mapped to PaymentAttemptStatus)\n│   │   ├── TransactionResponse (authentication details)\n│   │   │   ├── Authentication (redirect URL, method, etc.)\n│   │   │   └── SdkParams (3DS parameters, OTP details)\n│   │   ├── ProviderError (error code, message, response)\n│   │   ├── ProviderRequestStatus (SUCCESS, TIMED_OUT, RETRY_ABLE, etc.)\n│   │   └── AuthTokenDetails (for instrument tokenization)\n│   └── Audits provider response\n└── Error Handling:\n    ├── RateLimitException → Non-retry failure\n    ├── AppException → Non-retry failure\n    └── Other Exception → Re-throw\n\nStep 5.3: Platform OTP Enhancement\n├── Checks if platform native OTP enabled\n├── If CARD payment AND native OTP capable:\n│   ├── CardNativeOTPSDKParamDetail created\n│   │   ├── AuthType = NATIVE_OTP\n│   │   ├── ChallengeId = UUID\n│   │   ├── FallbackUrl = provider auth URL\n│   │   └── ResendOTPAllowed/SubmitOTPAllowed flags\n│   └── Replaces authentication with SDK params\n\n\nPaymentAttemptCreateWorkflow.postProcess()\n\nStep 6.1: Update Entity from Provider Response\n├── Sets providerStatus (Line 495)\n├── Sets providerReferenceId (Line 496)\n├── Sets gatewayReferenceId (Line 497)\n├── Adds browser and end URLs (Line 498)\n├── Enriches SDK parameters (Lines 500-505)\n├── Adds UPI intent URL (Lines 509-514)\n├── Sets error code/message (Lines 516-521)\n\nStep 6.2: Status Determination\n├── If REQUEST_SUCCESS:\n│   └── Use provider status (Line 524)\n├── If request failed AND eligible payment mode:\n│   ├── If status is FAILED → FAILED (Line 530)\n│   └── Otherwise → PROCESSING (Line 532)\n├── If not eligible payment mode:\n│   └── FAILED (Line 535)\n└── If TIMED_OUT → Set error code (Line 538)\n\nStep 6.3: Additional Updates\n├── Adds mandate ID if applicable (Lines 542-545)\n├── Saves updated entity (Line 548)\n└── Maps to PaymentAttemptResponse (Line 549)\n\n\nPaymentAttemptCreateWorkflow.postPersistNonRelationalDataStore()\n├── NativeOTPDetailDataManager.actionOnOTPSent()\n│   ├── Updates PaymentAttemptNativeOTPDetailEntity\n│   ├── Stores provider challenge ID\n│   ├── Stores OTP sent details\n│   │   ├── Serial number\n│   │   ├── SubmitOTPAllowed flag\n│   │   └── ResendOTPAllowed flag\n│   └── Persists to DynamoDB\n\n\nPaymentAttemptCreateWorkflow.publishEntityChangeEvents()\n\nStep 7.1: Event Bus Publishing\n├── Posts to syncBus (sync internal EventBus):\n│   └── PaymentAttemptEventFactory.findEvent()\n│   └── Event routed to PaymentStateMachine\n└── Posts to asyncBus (async internal EventBus):\n    └── Event for async handlers\n\nStep 7.2: Multi-Tenant Event Publishing\n├── EventiService.publishEvent(paymentAttemptEntity)\n│   └── Publishes to multi-tenant event system\n│   └── Triggers webhooks, notifications, etc.\n\nStep 7.3: Mandate Processing\n├── If mandate created:\n│   └── MandateServiceDataManager.updateTokenReferenceId()\n│       ├── Updates mandate with provider reference\n│       └── Syncs with Arsenal (tokenization service)\n\nStep 7.4: Sync Manager\n├── SyncManager.addEntityForSync()\n│   ├── Adds payment attempt for async sync\n│   └── Enables webhook-based status updates\n└── Exception handled gracefully (Line 577-583)\n\n\nPaymentStateMachine receives PaymentAttemptCreatedEvent (or other status event)\n\nStep 7.5: State Machine Processing\n├── @Subscribe onPaymentAttemptCreated(event)\n│   ├── Gets PaymentEntity from attempt\n│   ├── Fetches all payment attempts for payment\n│   ├── Validates no completed attempts exist\n│   └── If payment status == FAILED:\n│       └── Updates to CREATED\n│       └── Posts PaymentEventFactory event\n│       └── Publishes to EventiService\n│\n└── Similar flow for:\n    ├── onPaymentAttemptFailed\n    ├── onPaymentAttemptCompleted\n    ├── onPaymentAttemptAuthorized\n    └── onPaymentAttemptAuthenticationSuccessful\n\n\nResult\n├── PaymentAttemptResponse returned to client\n└── Contains:\n    ├── Payment attempt ID\n    ├── Status\n    ├── Authentication details (if needed)\n    ├── SDK parameters (3DS/OTP details)\n    └── Error information (if any)\n```\n\n### **Phase 4: Webhook Update Flow**\n\n**Webhook Sync Mechanism:**\n\n```\nWebhook Received from Provider\n    ↓\nWebhookController.handlePaymentAttemptWebhook()\n    ↓\nWebhookSyncWorkflow.execute(WebhookRequest)\n    ├── Fetches PaymentAttemptV2Entity\n    ├── Calls adapter.syncPaymentAttemptWithWebhook()\n    │   └── Provider-specific webhook handling\n    │   └── Updates payment attempt entity:\n    │       ├── Sets provider status\n    │       ├── Sets status (based on webhook response)\n    │       ├── Extracts reference IDs\n    │       └── Updates instrument details if tokenized\n    ├── Saves updated entity\n    └── Posts event to state machines\n\n    ↓\n\nPaymentStateMachine receives event\n    └── Updates Payment entity status (cascades from attempt)\n    \n    ↓\n\nOrderStateMachine receives event\n    └── Updates Order entity status (cascades from payment)\n```\n\n### **Phase 5: Sync Operations (Cron/Manual)**\n\n**Sync Flow:**\n\n```\nPaymentAttemptSyncCron (scheduled or manual trigger)\n    ↓\nFilters payment attempts needing sync:\n├── Status in (CREATED, PROCESSING, AUTHORIZED, AUTHENTICATION_SUCCESSFUL)\n├── Created > X minutes ago\n├── Not in non-syncable status\n└── Payment not in terminal status\n\n    ↓\nFor each syncable attempt:\n├── Calls adapter.syncPaymentAttemptWithProvider()\n│   ├── If provider reference ID exists:\n│   │   └── Calls syncPaymentAttemptWithProviderId()\n│   │       └── Provider-specific status fetch\n│   └── Else:\n│       └── Tries to fetch reference ID from external system\n│           └── Calls fetchProviderIdByExternalId()\n│\n├── Gets current provider status\n├── If status changed:\n│   └── Audits provider response\n└── Saves updated entity\n\n    ↓\nPosts event if status changed\n    └── Triggers state machine updates\n    └── Updates Payment and Order entities\n```\n\n---\n\n## 5. 3DS/AUTHENTICATION FLOWS\n\n### **Native OTP Flow (Card Payments)**\n\n**File Path References:**\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/authenticate/`\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/service/NativeOTPDetailDataManager.java`\n\n#### **Detailed Flow:**\n\n**Step 1: OTP Capability Determination**\n\n```java\n// In PaymentAttemptCreateWorkflow.validateAndEnrichContext()\n\nboolean isPlatformNativeOtpEnabled(PaymentAttemptCreateContext context) {\n    if (!CARD.equals(context.getInstrumentProcessorResult().getPaymentMethod())) {\n        return false;  // Only for card payments\n    }\n    \n    String binHash = CardUtils.getBinHashForCard(\n        (CardPaymentInstrument) context.getRequest().getPaymentInstrument()\n    );\n    \n    return context.getRoutingDecisionResult().getIsPlatformOtpEnabled()\n           && wspService.isPlatformNativeOtpEnabled(clientId, binHash);\n}\n\ncontext.setIsPlatformNativeOtpSupported(isPlatformNativeOtpEnabled(context));\n```\n\n**Key Determination Factors:**\n- BIN (Bank Identification Number) hash\n- Merchant platform OTP enablement flag\n- WSP (Wallet Service Provider) whitespace service capability\n\n**Step 2: Provider OTP Request**\n\n```java\n// In PaymentAttemptCreateWorkflow.process()\n\nProviderPaymentResponse response = adapter.createPaymentAttempt(context, customerEntity);\n\n// If response contains:\n// - TransactionResponse.Authentication.Url → redirect 3DS\n// - TransactionResponse.SdkParams → Native OTP candidate\n```\n\n**Step 3: Platform OTP Override**\n\n```java\n// In PaymentAttemptCreateWorkflow.process()\n\nProviderPaymentResponse checkIfPlatformOtpEnabled(\n    PaymentAttemptCreateContext context, \n    ProviderPaymentResponse providerResponse) {\n    \n    if (!CARD.equals(context.getPaymentAttemptEntity().getPaymentMethod())) {\n        return providerResponse;  // Not applicable\n    }\n    \n    if (context.getRoutingDecisionResult().getIsPlatformOtpEnabled()\n        && wspService.isPlatformNativeOtpSupported(\n            clientId,\n            binHash,\n            providerResponse.getTransactionResponse().getAuthentication().getUrl(),\n            paymentAttemptId)) {\n        \n        // Create Native OTP SDK params\n        CardNativeOTPSDKParamDetail nativeOTPParams = CardNativeOTPSDKParamDetail.builder()\n            .authType(AuthType.NATIVE_OTP)\n            .fallbackUrl(providerResponse.getTransactionResponse()\n                .getAuthentication().getUrl())\n            .resendOTPAllowed(false)\n            .submitOTPAllowed(true)\n            .challengeId(UUID.randomUUID().toString())\n            .build();\n        \n        nativeOTPParams.setObjectType(ObjectType.CARD_NATIVE_OTP);\n        providerResponse.getTransactionResponse().setSdkParams(nativeOTPParams);\n        \n        // Replace authentication with SDK params\n        providerResponse.getTransactionResponse().setAuthentication(null);\n    }\n    \n    return providerResponse;\n}\n```\n\n**Step 4: OTP Storage (DynamoDB)**\n\n```java\n// In NativeOTPDetailDataManager.actionOnStartAuthentication()\n\nPaymentAttemptNativeOTPDetailEntity nativeOTPDetailEntity = \n    PaymentAttemptNativeOTPDetailEntity.builder()\n        .paymentAttemptId(paymentAttemptId)\n        .providerAccountId(nativeProviderAccountId)\n        .authType(AuthType.NATIVE_OTP)\n        .build();\n\n// Persisted to DynamoDB with:\n// - PaymentAttemptId (hash key)\n// - ProviderAccountId\n// - AuthType\n// - List of SentOTPDetails (empty initially)\n// - List of SentOTPDetail.AuthenticateOTPDetails (empty initially)\n\nnativeOTPDetailEntityDAO.save(nativeOTPDetailEntity);\n```\n\n### **OTP Authentication Request Flow**\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/authenticate/PaymentAttemptAuthenticateWorkflow.java`\n\n#### **Step 1: Validate & Enrich Context**\n\n```java\npublic PaymentAttemptAuthenticateContext validateAndEnrichContext(AuthenticateOTPRequest request) {\n    // Fetch payment attempt\n    PaymentAttemptV2Entity attemptEntity = paymentAttemptFetchWorkflow.fetchEntityById(\n        request.getPaymentAttemptId(), \n        FetchType.INTERNAL_SYNC, \n        false\n    );\n    \n    // Validate payment attempt status (must be CREATED/PROCESSING)\n    if (!POSSIBLE_STATUS_LIST.contains(attemptEntity.getStatus())) {\n        throw Error.invalid_state_transition.getBuilder().build();\n    }\n    \n    // Fetch OTP details from DynamoDB\n    PaymentAttemptNativeOTPDetailEntity otpDetailEntity = \n        nativeOTPDetailEntityDAO.findByHashKey(paymentAttemptId);\n    \n    // Validate it's native OTP flow\n    if (!NativeOtpUtil.isNativeOtpFlow(otpDetailEntity)) {\n        throw Error.invalid_payment_attempt_id.getBuilder().build();\n    }\n    \n    // Check for idempotency key (allows retry of same OTP submission)\n    AuthenticateOTPDetail latestOTPAuthenticateOTP = \n        findMatchingAuthenticateOTPByIdempotencyKey(otpDetailEntity, idempotencyKey);\n    \n    // Only check max attempts if new attempt\n    if (Objects.isNull(latestOTPAuthenticateOTP)) {\n        validateMaxAttempt(otpDetailEntity);  // Throws if max exceeded\n    }\n    \n    // Build context\n    PaymentAttemptAuthenticateContext context = new PaymentAttemptAuthenticateContext(request);\n    context.setPaymentAttemptEntity(attemptEntity);\n    context.setNativeOTPDetailEntity(otpDetailEntity);\n    context.setCurrentStatus(attemptEntity.getStatus());\n    context.setLatestAuthenticateOTP(latestOTPAuthenticateOTP);\n    context.setNativeProviderAccountEntity(\n        providerAccountService.getByProviderAccountReferenceId(\n            otpDetailEntity.getProviderAccountId()\n        ).orElseThrow(...)\n    );\n    \n    return context;\n}\n\n// Max attempt validation:\nprivate void validateMaxAttempt(PaymentAttemptNativeOTPDetailEntity otpDetailEntity) {\n    if (CollectionUtils.isNotEmpty(otpDetailEntity.getSentOTPDetails())\n        && !otpDetailEntity.getSentOTPDetails().get(0).isSubmitOTPAllowed()) {\n        throw Error.max_attempt_authentication_breached.getBuilder().build();\n    }\n}\n```\n\n#### **Step 2: Persist Intent (Non-Relational)**\n\n```java\npublic void persistNonRelationalIntent(PaymentAttemptAuthenticateContext context) {\n    if (!context.isExistingAuthenticationRequest()) {\n        // New OTP authentication attempt\n        NativeOTPDetailDataManager.actionOnAuthenticateStart(\n            nativeOTPDetailEntity, \n            request\n        );\n        // Adds new AuthenticateOTPDetail to SentOTPDetail[0].authenticateOTPDetails\n        // Sets status: INITIATED\n    } else if (INITIATED.equals(\n        context.getLatestAuthenticateOTP().getAuthenticationStatus())) {\n        \n        // Repair existing transaction (idempotent retry)\n        NativeOTPDetailDataManager.repairAuthenticationTransaction(\n            paymentAttemptEntity, \n            nativeOTPDetailEntity\n        );\n    }\n}\n```\n\n#### **Step 3: Process (Provider Call)**\n\n```java\npublic void process(PaymentAttemptAuthenticateContext context) {\n    PaymentAttemptV2Entity attemptEntity = context.getPaymentAttemptEntity();\n    \n    if (!context.isExistingAuthenticationRequest()) {\n        // Call provider to validate OTP\n        INativeProviderAdapter providerAdapter = \n            paymentProviderFactory.findPaymentProviderAdapter(\n                OrderType.PAY,\n                nativeProviderAccountEntity.getPaymentProvider().getKey(),\n                attemptEntity.getPaymentSubMethod().getType()\n            );\n        \n        ProviderPaymentResponse providerResponse = \n            providerAdapter.authenticateAttempt(context);\n            // Provider validates OTP and returns:\n            // - Status (AUTHENTICATION_SUCCESSFUL, AUTHENTICATION_FAILED)\n            // - Error information if failed\n        \n        context.setProviderPaymentResponse(providerResponse);\n        \n        // Create auth token for instrument tokenization (if applicable)\n        createAuthToken(context);\n    }\n}\n\nprivate void createAuthToken(PaymentAttemptAuthenticateContext context) {\n    if (Objects.nonNull(\n        context.getProviderPaymentResponse().getAuthTokenDetails())) {\n        \n        context.setCustomerAuthTokenEntity(\n            authTokenService.createAuthToken(\n                customerEntity.getClientReferenceId(),\n                authTokenDetails\n            )\n        );\n        // Stores token in Arsenal (instrument vault)\n    }\n}\n```\n\n#### **Step 4: Post-Process & Event Publishing**\n\n```java\npublic PaymentAttemptResponse postProcess(PaymentAttemptAuthenticateContext context) {\n    if (!context.isExistingAuthenticationRequest()) {\n        return postProcessForNewAuthenticationRequest(context);\n    } else {\n        return postProcessForExistingAuthenticationRequest(context);\n    }\n}\n\nprivate PaymentAttemptResponse postProcessForNewAuthenticationRequest(\n    PaymentAttemptAuthenticateContext context) {\n    \n    PaymentAttemptV2Entity attemptEntity = context.getPaymentAttemptEntity();\n    ProviderPaymentResponse providerResponse = context.getProviderPaymentResponse();\n    \n    // Update payment attempt entity\n    attemptEntity.setProviderStatus(providerResponse.getProviderStatus());\n    attemptEntity.setStatus(providerResponse.getStatus());  // SUCCESS/FAILED\n    \n    if (Objects.nonNull(providerResponse.getProviderError())) {\n        attemptEntity.setErrorCode(providerResponse.getProviderError().getCode());\n        attemptEntity.setErrorMessage(providerResponse.getProviderError().getMessage());\n    }\n    \n    paymentAttemptRepository.save(attemptEntity);\n    \n    return PaymentAttemptEntityMapperV2.convertToPaymentAttemptResponse(\n        attemptEntity, \n        providerResponse\n    );\n}\n\npublic void publishEntityChangeEvents(PaymentAttemptAuthenticateContext context) {\n    if (statusChanged) {\n        // Post to state machines\n        syncBus.post(PaymentAttemptEventFactory.findEvent(\n            paymentAttemptEntity, \n            true  // isAuthenticationFlow = true\n        ));\n        \n        eventiService.publishEvent(paymentAttemptEntity);\n    }\n    \n    if (tokenCreated) {\n        // Publish instrument addition event\n        eventiService.publishInstrumentAdditionEvent(\n            ArsenalInstrumentAdditionEvent.builder()\n                .userPaymentInstrument(\n                    ArsenalInstrumentMapper.mapToArsenalInstrument(context)\n                )\n                .paymentAttemptV2Entity(paymentAttemptEntity)\n                .build()\n        );\n    }\n}\n```\n\n### **Redirect/3DS Flow**\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/authenticate/PaymentAttemptInitiateAuthenticationWorkflow.java`\n\n#### **Flow:**\n\n```\nClient Request: InitiateAuthenticationRequest\n    ↓\nPaymentAttemptInitiateAuthenticationWorkflow.execute()\n\nStep 1: Validate Context\n├── Fetch payment attempt (must be CREATED/PROCESSING)\n├── Verify 3DS capable\n└── Store workflow context in DynamoDB\n\nStep 2: Call Provider 3DS Initiation\n├── Get 3DS adapter (I3DSPaymentProviderAdapter)\n├── Call adapter.initiateAuthenticationForAttempt()\n│   └── Provider 3DS API call\n│   └── Returns authentication URL + ACS form\n├── Update payment attempt:\n│   ├── providerStatus\n│   ├── providerReferenceId\n│   ├── status (if applicable)\n│   └── error information\n\nStep 3: Return 3DS URL to Client\n└── PaymentAttemptResponse with:\n    ├── TransactionResponse.Authentication.Url\n    ├── Browser type\n    └── End URLs for callback\n```\n\n**After Customer Redirected Back:**\n\n```\nCustomer completes 3DS authentication at issuer\n    ↓\nReturns to return_url (callback URL)\n    ↓\nValidateAuthenticationWorkflow.execute(CallbackRequest)\n    ├── Sync with provider for 3DS result\n    ├── Update payment attempt status\n    └── Publish events to state machines\n```\n\n---\n\n## 6. INSTRUMENT PROCESSING\n\n### **InstrumentTypeProcessorManager**\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/processors/instrumenttype/InstrumentTypeProcessorManager.java`\n\n```java\n@Component\npublic class InstrumentTypeProcessorManager {\n    private final List<IInstrumentTypeProcessor> processors;\n    private Map<InstrumentType, IInstrumentTypeProcessor> processorByType;\n    \n    @PostConstruct\n    private void init() {\n        // Maps each InstrumentType to its processor at startup\n        processorByType = processors.stream()\n            .collect(Collectors.toMap(\n                IInstrumentTypeProcessor::getInstrumentType, \n                Function.identity()\n            ));\n    }\n    \n    public InstrumentTypeProcessorResult validatePaymentInstrumentAndEnrich(\n        PaymentInstrument paymentInstrument) {\n        \n        // Route to appropriate processor\n        IInstrumentTypeProcessor processor = processorByType.get(\n            paymentInstrument.getType()\n        );\n        \n        if (processor == null) {\n            throw Error.internal_server_error\n                .getBuilder()\n                .message(\"Processor not present for instrument type\")\n                .build();\n        }\n        \n        return processor.validatePaymentInstrumentAndEnrich(paymentInstrument);\n    }\n}\n```\n\n### **IInstrumentTypeProcessor Interface**\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/processors/instrumenttype/IInstrumentTypeProcessor.java`\n\n```java\npublic interface IInstrumentTypeProcessor<T extends PaymentInstrument, \n                                         R extends PaymentSubMethodDetail, \n                                         S extends EnrichedPaymentInstrument> {\n    \n    InstrumentType getInstrumentType();\n    \n    /**\n     * Validates instrument and enriches with detailed information\n     * Returns processor result containing:\n     * - PaymentMethod (CARD, UPI_PAY, NET_BANKING, etc.)\n     * - PaymentSubMethodDetail (enriched details specific to instrument)\n     * - EnrichedPaymentInstrument (final enriched instrument object)\n     */\n    InstrumentTypeProcessorResult<R, S> validatePaymentInstrumentAndEnrich(\n        @NonNull T paymentInstrument\n    );\n    \n    /**\n     * Optional: Enrich additional details from payment attempt context\n     */\n    default void enrichAdditionalDetailsFromPaymentAttemptContext(\n        @NonNull PaymentAttemptCreateContext context) {}\n    \n    /**\n     * Optional: Get fee instrument for this payment type\n     */\n    default Instrument getFeeInstrument(\n        @NonNull InstrumentTypeProcessorResult instrumentTypeProcessorResult) {\n        return null;\n    }\n}\n```\n\n### **CardInstrumentTypeProcessor - Card Payment Processing**\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/processors/instrumenttype/CardInstrumentTypeProcessor.java`\n\n#### **Validation & Enrichment Flow:**\n\n```java\npublic InstrumentTypeProcessorResult<CardPaymentSubMethodDetail, CardEnrichedPaymentInstrument> \n    validatePaymentInstrumentAndEnrich(@NonNull CardPaymentInstrument paymentInstrument) {\n    \n    // Step 1: Handle tokenized card (vault reference)\n    if (StringUtils.isNotEmpty(paymentInstrument.getVaultReferenceId())\n        && StringUtils.isEmpty(paymentInstrument.getCardNumber())) {\n        enrichInstrumentDetailsFromVault(paymentInstrument);\n        // Fetches card details from Arsenal vault\n    }\n    \n    // Step 2: Determine card brand\n    String brand = Objects.nonNull(paymentInstrument.getPaymentSubMethod())\n        ? paymentInstrument.getPaymentSubMethod().name()\n        : paymentInstrument.getBrand();\n    \n    // Step 3: Extract & hash BIN\n    String binHash = null;\n    if (StringUtils.isNotEmpty(paymentInstrument.getCardNumber())) {\n        binHash = DarwinUtils.parseBin(paymentInstrument.getCardNumber())\n            .map(HashUtils::generateHash)\n            .orElse(null);\n        \n        // Step 4: BIN enrichment (from cache)\n        Optional<CardBinDetail> cardBinDetail = cardBinCache.getByHashBin(binHash);\n        cardBinDetail.ifPresent(binDetail -> {\n            // Enrich with:\n            // - Card type (CREDIT, DEBIT, etc.)\n            // - Issuer information\n            // - Network (VISA, MASTERCARD, etc.)\n            // - Regulatory information\n        });\n    }\n    \n    // Step 5: Issuer enrichment\n    Optional<Issuer> issuer = issuerCache.getIssuerByCode(\n        extractIssuerCode(paymentInstrument)\n    );\n    \n    // Step 6: Build card sub-method detail\n    CardPaymentSubMethodDetail cardSubMethodDetail = CardPaymentSubMethodDetail.builder()\n        .brand(brand)\n        .cardType(CardType.CREDIT)  // from BIN cache\n        .issuer(issuer.orElse(null))\n        .binHash(binHash)\n        .build();\n    \n    // Step 7: Build enriched instrument\n    CardEnrichedPaymentInstrument enrichedCard = CardEnrichedPaymentInstrument.builder()\n        .token(createTokenIfApplicable(paymentInstrument))\n        .maskedCardNumber(maskCardNumber(paymentInstrument.getCardNumber()))\n        .brand(brand)\n        .cardType(CardType.CREDIT)\n        .issuer(issuer.orElse(null))\n        .binHash(binHash)\n        .expiryDate(paymentInstrument.getExpiryDate())\n        .nameOnCard(paymentInstrument.getNameOnCard())\n        .build();\n    \n    // Step 8: Return processor result\n    return new InstrumentTypeProcessorResult<>(\n        PaymentInstrumentGroup.CARD,\n        cardSubMethodDetail,\n        enrichedCard\n    );\n}\n\n// Additional enrichment from context\npublic void enrichAdditionalDetailsFromPaymentAttemptContext(\n    PaymentAttemptCreateContext context) {\n    \n    CardPaymentInstrument cardInstrument = \n        (CardPaymentInstrument) context.getRequest().getPaymentInstrument();\n    \n    // Instrument-specific enrichment\n    if (shouldTokenizeCard(cardInstrument)) {\n        // Prepare for tokenization after successful payment\n        context.setTokenizationRequired(true);\n    }\n}\n```\n\n### **UPI Payment Processing**\n\n**Supported UPI Variants:**\n- `UPIPayInstrumentTypeProcessor` - UPI Push\n- `UPICollectInstrumentTypeProcessor` - UPI Collect (QR)\n- `UPICREDInstrumentTypeProcessor` - UPI CRED integration\n\n#### **Flow (UPIPayInstrumentTypeProcessor):**\n\n```java\npublic InstrumentTypeProcessorResult<UpiPaymentSubMethodDetail, UpiEnrichedPaymentInstrument> \n    validatePaymentInstrumentAndEnrich(@NonNull UpiPaymentInstrument paymentInstrument) {\n    \n    // Validations\n    validateUpiVpa(paymentInstrument.getVpa());\n    validateUpiTimeout(paymentInstrument.getTimeout());\n    \n    // Enrich UPI sub-method detail\n    UpiPaymentSubMethodDetail subMethodDetail = UpiPaymentSubMethodDetail.builder()\n        .vpa(paymentInstrument.getVpa())\n        .provider(paymentInstrument.getProvider())  // Google Pay, Phonepe, etc.\n        .build();\n    \n    // Enrich UPI instrument\n    UpiEnrichedPaymentInstrument enrichedUpi = UpiEnrichedPaymentInstrument.builder()\n        .vpa(paymentInstrument.getVpa())\n        .provider(paymentInstrument.getProvider())\n        .timeout(paymentInstrument.getTimeout())\n        .notificationUrl(paymentInstrument.getNotificationUrl())\n        .build();\n    \n    return new InstrumentTypeProcessorResult<>(\n        PaymentInstrumentGroup.UPI_PAY,\n        subMethodDetail,\n        enrichedUpi\n    );\n}\n```\n\n### **NetBanking Instrument Processing**\n\n**File:** References in `NetBankingInstrumentTypeProcessor.java`\n\n```java\npublic InstrumentTypeProcessorResult<NetBankingPaymentSubMethodDetail, \n                                     NetBankingEnrichedPaymentInstrument> \n    validatePaymentInstrumentAndEnrich(\n        @NonNull NetBankingPaymentInstrument paymentInstrument) {\n    \n    // Step 1: Validate bank code\n    validateBankCode(paymentInstrument.getBankCode());\n    \n    // Step 2: Fetch issuer details\n    Optional<Issuer> issuer = issuerCache.getIssuerByCode(\n        paymentInstrument.getBankCode()\n    );\n    \n    // Step 3: Build enriched details\n    NetBankingPaymentSubMethodDetail subMethodDetail = \n        NetBankingPaymentSubMethodDetail.builder()\n            .bankCode(paymentInstrument.getBankCode())\n            .bankName(issuer.map(Issuer::getName).orElse(null))\n            .bankLogo(issuer.map(Issuer::getLogoUrl).orElse(null))\n            .build();\n    \n    // Step 4: Enrich instrument\n    NetBankingEnrichedPaymentInstrument enrichedNetBanking = \n        NetBankingEnrichedPaymentInstrument.builder()\n            .bankCode(paymentInstrument.getBankCode())\n            .bankName(issuer.map(Issuer::getName).orElse(null))\n            .build();\n    \n    return new InstrumentTypeProcessorResult<>(\n        PaymentInstrumentGroup.NET_BANKING,\n        subMethodDetail,\n        enrichedNetBanking\n    );\n}\n```\n\n### **InstrumentTypeProcessorResult Data Structure**\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/processors/instrumenttype/InstrumentTypeProcessorResult.java`\n\n```java\n@Getter\n@RequiredArgsConstructor\npublic class InstrumentTypeProcessorResult<R extends PaymentSubMethodDetail, \n                                          S extends EnrichedPaymentInstrument> {\n    \n    // Payment method group (CARD, UPI_PAY, NET_BANKING, etc.)\n    private final PaymentInstrumentGroup paymentMethod;\n    \n    // Instrument-specific sub-method details\n    // Examples:\n    // - CardPaymentSubMethodDetail (for cards)\n    // - UpiPaymentSubMethodDetail (for UPI)\n    // - NetBankingPaymentSubMethodDetail (for banks)\n    private final R paymentSubMethodDetail;\n    \n    // Final enriched payment instrument with all details\n    // Used throughout the payment flow\n    private final S enrichedPaymentInstrument;\n}\n```\n\n### **Instrument Tokenization Integration**\n\n**Arsenal Integration (Instrument Vault):**\n\n```java\n// After successful authentication, tokens are created\n\npublic void publishEntityChangeEvents(PaymentAttemptAuthenticateContext context) {\n    if (isTokenCreated(context)) {\n        // Publish instrument addition event to Arsenal\n        eventiService.publishInstrumentAdditionEvent(\n            ArsenalInstrumentAdditionEvent.builder()\n                .userPaymentInstrument(\n                    ArsenalInstrumentMapper.mapToArsenalInstrument(context)\n                )\n                .paymentAttemptV2Entity(paymentAttemptEntity)\n                .build()\n        );\n        \n        // Arsenal service:\n        // 1. Receives instrument addition event\n        // 2. Creates unique vault reference ID\n        // 3. Stores masked instrument details\n        // 4. Returns reference for future use\n        // 5. Publishes instrument creation confirmation event\n    }\n}\n```\n\n---\n\n## SUMMARY - KEY ARCHITECTURAL PATTERNS\n\n### **1. Template Method Pattern (Workflow Execution)**\n- Base `Workflow` class defines 9-step execution pipeline\n- Each step is a hook for implementations to override\n- Transactional boundaries explicitly marked\n- Self-proxy pattern enables method-level transactions\n\n### **2. Event-Driven State Management**\n- EventBus (Guava) for decoupled state transitions\n- Multiple state machines react to events asynchronously\n- Cascading state updates: PaymentAttempt → Payment → Order\n- Terminal state guards prevent invalid transitions\n\n### **3. Context Object Pattern**\n- `PaymentAttemptCreateContext` accumulates data through execution\n- Each step enriches context with new information\n- Enables loose coupling between workflow steps\n- Easy to add new enrichment steps\n\n### **4. Factory & Strategy Pattern**\n- `InstrumentTypeProcessorManager` routes to specific processors\n- `PaymentProviderFactory` selects provider adapter\n- `AuthTypeDeciderFactory` determines authentication strategy\n- `SdkTypeDeciderFactory` selects SDK type handler\n\n### **5. Data Enrichment Pipeline**\n- Step 1: Instrument enrichment (BIN, issuer data)\n- Step 2: Provider routing (decision tree)\n- Step 3: Auth type decision\n- Step 4: Settlement routes\n- Step 5: Mandate processing (if applicable)\n\n### **6. Transaction Boundary Management**\n- Validation outside transaction (external calls risky)\n- Persist intent in transaction (atomic save)\n- Process outside transaction (provider calls)\n- Post-process in transaction (save results)\n- Events published outside transaction (async)\n\n### **7. Distributed Locking**\n- `SequentialWorkflow` uses Redis locks\n- Prevents concurrent execution of same order/payment\n- SPEL expression evaluation for lock key\n- Lock mandatory or optional based on config\n\n### **8. Non-Relational Data Persistence**\n- DynamoDB for OTP details, workflow context, redirection URLs\n- Separate from transactional relational data\n- Enables quick retrieval without DB joins\n- Scales independently\n\n### **9. Multi-Bus Event Publishing**\n- Sync bus: For immediate state machines (PaymentStateMachine)\n- Async bus: For deferred handlers\n- EventiService: For multi-tenant events (webhooks, notifications)\n- Pinot: For analytics and dashboards (async)\n\n### **10. Error Handling & Collection**\n- Errors accumulated in context during processing\n- Final error check before returning response\n- Graceful degradation possible\n- Detailed error information returned to client\n\nThis architecture enables:\n- **Scalability**: Distributed locking, async event processing\n- **Reliability**: Transaction boundaries, event sourcing\n- **Maintainability**: Clear separation of concerns, extensible patterns\n- **Testability**: Mockable components, context-based testing\n- **Observability**: Event trail, audit logging, provider audits\n\n---\n\nThis completes the expert-level deep dive into the Payment Flow Architecture of the payment-service codebase!"},{"type":"text","text":"agentId: a4bf161 (for resuming to continue this agent's work if needed)"}]}]},"uuid":"3e0f70fb-4437-4faf-99cb-0119b07f1f42","timestamp":"2025-12-31T09:52:54.049Z","toolUseResult":{"status":"completed","prompt":"Provide an extremely detailed analysis of the payment-service Payment Flow architecture for expert study. Cover:\n\n1. **PaymentAttemptCreateWorkflow Deep-Dive:**\n   - Complete 7-step workflow pipeline in detail\n   - Each step's purpose and implementation\n   - Context object and how data flows through steps\n   - How validation, enrichment, persistence work\n\n2. **Workflow Pattern Architecture:**\n   - Base Workflow class and template method pattern\n   - How workflows extend the base class\n   - Context builders and data enrichment\n   - Error collection and handling in workflows\n\n3. **State Machine Implementation:**\n   - PaymentStateMachine detailed implementation\n   - OrderStateMachine detailed implementation\n   - RefundStateMachine if exists\n   - Event types and how they're published (EventBus)\n   - State transitions and terminal states\n\n4. **Complete End-to-End Payment Flow:**\n   - From API request to response\n   - Order creation → Payment creation → Payment attempt → Provider call\n   - How webhooks update state\n   - How sync operations work\n   - Complete trace through the code\n\n5. **3DS/Authentication Flows:**\n   - How 3DS authentication is handled\n   - Native OTP flow\n   - Redirect flows and callbacks\n   - Authentication state management\n\n6. **Instrument Processing:**\n   - InstrumentTypeProcessorManager\n   - How different payment instruments are validated and enriched\n   - Card, UPI, NetBanking specific processing\n\nProvide specific file paths, method names, and code flow traces. This is for expert-level understanding.","agentId":"a4bf161","content":[{"type":"text","text":"Perfect! I now have enough information to provide a comprehensive analysis. Let me compile the detailed document:\n\n---\n\n# EXPERT-LEVEL PAYMENT FLOW ARCHITECTURE ANALYSIS\n## Payment-Service Complete Deep Dive Study\n\n---\n\n## 1. PAYMENTATTEMPTCREATEWORKFLOW - COMPLETE 7-STEP PIPELINE\n\n### **File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java`\n\nThe PaymentAttemptCreateWorkflow extends `CreateWorkflowFromParent<CreatePaymentAttemptRequest, PaymentAttemptCreateContext, PaymentAttemptResponse, PaymentCreateContext>` and executes the 7-step payment attempt creation pipeline:\n\n### **7-Step Pipeline Execution:**\n\n**STEP 1: Validation & Enrichment (`validateAndEnrichContext`)**\n- **Method:** Lines 183-296\n- **Purpose:** Input validation, data enrichment, and context preparation\n- **Key Operations:**\n  - Validates compatible instrument type with payment mode (Line 223)\n  - **Data Enricher 1:** Calls `InstrumentTypeProcessorManager.validatePaymentInstrumentAndEnrich()` (Line 226-227)\n    - Enriches payment instrument details\n    - Returns `InstrumentTypeProcessorResult<?, ?>` containing:\n      - `paymentMethod` (PaymentInstrumentGroup)\n      - `paymentSubMethodDetail` (enriched details)\n      - `enrichedPaymentInstrument` (final instrument)\n  - Fetches customer entity (Line 229-231)\n  - **Data Enricher 2:** Provider routing decision via `providerDeciderRouter.resolve(context)` (Line 249-252)\n    - Routes to appropriate payment provider\n    - Returns `ProviderRoutingDecisionResult` with provider account\n  - Validates flow type compatibility (Line 257-268)\n  - **Data Enricher 3:** Auth type decision via `authTypeDeciderFactory.validateAndDecideAuthType()` (Line 278-282)\n    - Determines authentication type (NATIVE_OTP, REDIRECT, etc.)\n  - Decides native provider account (Line 284)\n  - **Data Enricher 4:** Enriches settlement route information (Line 289)\n  - **Context Object Structure:**\n    ```java\n    PaymentAttemptCreateContext {\n        CreatePaymentAttemptRequest request\n        PaymentAttemptResponse response\n        PaymentAttemptV2Entity paymentAttemptEntity (created)\n        PaymentV2Entity paymentEntity\n        OrderEntity orderEntity\n        CustomerEntity customerEntity\n        ClientEntity clientEntity\n        InstrumentTypeProcessorResult<?, ?> instrumentProcessorResult\n        ProviderAccountEntity providerAccountEntity\n        ProviderAccountEntity nativeProviderAccountEntity\n        ProviderRoutingDecisionResult routingDecisionResult\n        AuthType authType\n        Boolean isPlatformNativeOtpSupported\n        PaymentAttemptNativeOTPDetailEntity nativeOTPDetailEntity\n        RoutesBreakup routesBreakup\n        List<FeeCreateContext> feeCreateContexts\n        ProviderPaymentResponse createResponse\n        UserError userError\n        String mandateId\n        Mandate mandate\n        String threeDsVersion\n    }\n    ```\n\n**STEP 2: Persist Intent (`persistIntent`)**\n- **Method:** Lines 352-408 (Transactional boundary)\n- **Purpose:** Save payment attempt entity and fees to relational database\n- **Database Operations:**\n  - Creates `PaymentAttemptV2Entity` with:\n    - External ID (UUID via `PaymentAttemptUUIdGenerator.generate()`) - Line 379\n    - Status: `CREATED` - Line 371\n    - Provider account and payment provider - Lines 368-370\n    - Payment method and sub-method - Lines 363-366\n    - Instrument details - Line 376\n    - Routes breakup - Line 377\n  - Saves to `PaymentAttemptRepository` - Line 381\n  - Saves fee entities via `feeCreateWorkflow.persistIntent()` - Line 383\n  - Enriches attributes for DT/CM results - Lines 390-398\n  - Saves return URL if provided - Lines 401-407\n\n**STEP 3: Publish Pre-Persist Events (`publishEntityPrePersistEvents`)**\n- Base implementation (optional hook)\n- Placeholder for events before non-relational persistence\n\n**STEP 4: Persist Non-Relational Data (`persistNonRelationalIntent`)**\n- **Method:** Lines 440-450\n- **Purpose:** Save non-relational data (DynamoDB)\n- **Operations:**\n  - Initiates native OTP flow if applicable (Line 447)\n  - Saves `PaymentAttemptNativeOTPDetailEntity` to DynamoDB\n  - Audits provider metadata (Line 449)\n\n**STEP 5: Process (`process`)**\n- **Method:** Lines 453-481 (Provider interaction)\n- **Purpose:** Call payment provider API for payment attempt creation\n- **Key Logic:**\n  - Finds appropriate provider adapter via `paymentProviderFactory.findPaymentProviderAdapter()` (Lines 462-467)\n  - Determines 3DS type via `providerAccountManager.getThreeDSType()`\n  - Executes provider call:\n    ```java\n    paymentProviderAdapter.executePaymentAttempt(\n        context,\n        paymentProviderAdapter::createPaymentAttempt,\n        FlowType.CREATE\n    )\n    ```\n  - Checks platform OTP capability (Line 468)\n  - Returns `ProviderPaymentResponse` containing:\n    - Provider status\n    - Provider reference ID\n    - Transaction response (authentication details)\n    - Provider error (if any)\n    - Request status (SUCCESS, TIMED_OUT, etc.)\n  - Exception handling: Updates status to FAILED and collects errors (Lines 474-479)\n\n**STEP 6: Post-Process (`postProcess`)**\n- **Method:** Lines 485-550 (Transactional)\n- **Purpose:** Update payment attempt entity with provider response\n- **Post-Processing Logic:**\n  - Sets provider status and reference IDs (Lines 495-497)\n  - Adds browser and end URL details (Line 498)\n  - Enriches SDK parameters via `sdkTypeDeciderFactory` (Lines 500-505)\n  - Adds UPI intent URL if required (Lines 509-514)\n  - Sets error code/message if provider error (Lines 516-521)\n  - Updates status based on provider request status:\n    - If `REQUEST_SUCCESS`: Set to provider status (Line 524)\n    - If non-success on eligible payment modes: Set to PROCESSING or FAILED (Lines 526-536)\n    - If timeout: Set error code to `TIMED_OUT` (Lines 537-539)\n  - Adds mandate ID to attributes if applicable (Lines 542-545)\n  - Saves updated entity (Line 548)\n  - **Returns:** `PaymentAttemptResponse` via mapper (Line 549)\n\n**STEP 7: Post-Persist Non-Relational & Event Publishing**\n- **`postPersistNonRelationalDataStore`** (Line 553-557):\n  - Updates native OTP details after provider processing\n  - Persists OTP challenge ID and other SDK params\n  \n- **`publishEntityChangeEvents`** (Lines 560-585):\n  - Posts event to sync/async event buses:\n    ```java\n    asyncBus.post(PaymentAttemptEventFactory.findEvent(paymentAttemptEntity))\n    syncBus.post(PaymentAttemptEventFactory.findEvent(paymentAttemptEntity))\n    ```\n  - Publishes to multi-tenant event system (`eventiService`)\n  - Updates mandate token reference ID if mandate flow\n  - Adds entity for sync (Line 575)\n\n---\n\n## 2. WORKFLOW PATTERN ARCHITECTURE\n\n### **Base Workflow Class (Template Method Pattern)**\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/Workflow.java`\n\n```java\npublic abstract class Workflow<Request, Context extends WorkflowContext<Request, Response>, Response> {\n    \n    public Response execute(Request request) {\n        // STEP 1: Initialize and validate\n        Context context = selfProxy.validateAndEnrichContext(request);\n        \n        // STEP 2: Persist to database (transactional)\n        selfProxy.persistIntent(context);\n        \n        // STEP 3: Pre-persist events\n        selfProxy.publishEntityPrePersistEvents(context);\n        \n        // STEP 4: Persist to non-relational DB\n        selfProxy.persistNonRelationalIntent(context);\n        \n        // STEP 5: Process (external calls)\n        selfProxy.process(context);\n        \n        // STEP 6: Post-process and save results (transactional)\n        Response response = selfProxy.postProcess(context);\n        \n        // STEP 7: Post-persist non-relational updates\n        postPersistNonRelationalDataStore(context);\n        \n        // STEP 8: Publish events\n        selfProxy.publishEntityChangeEvents(context);\n        \n        // STEP 9: Throw error if required\n        throwErrorIfRequired(context);\n        \n        return response;\n    }\n}\n```\n\n### **Extension Pattern: CreateWorkflowFromParent**\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/CreateWorkflowFromParent.java`\n\n```java\npublic abstract class CreateWorkflowFromParent<Request, Context, Response, ParentContext> \n        extends Workflow<Request, Context, Response> {\n    \n    // Supports enriching context from parent workflow's context\n    // Example: PaymentAttemptCreateWorkflow enriches from PaymentCreateContext\n    public abstract Context validateAndEnrichContextFromParentContext(\n            ParentContext parentContext, \n            Request request\n    );\n}\n```\n\n**Usage Pattern:**\n- `OrderCreateWorkflow` → `PaymentCreateWorkflow` → `PaymentAttemptCreateWorkflow`\n- Each level passes enriched context to next level\n- Enables hierarchical data enrichment\n\n### **Sequential Workflow with Distributed Locking**\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/create/SequentialWorkflow.java`\n\n```java\npublic abstract class SequentialWorkflow<Request, Context, Response> \n        extends Workflow<Request, Context, Response> {\n    \n    @Override\n    public Response execute(Request request) {\n        LockSetting lockSetting = fetchLockSetting();\n        String lockKeyValue = evaluateLockKey(request, lockSetting.getLockKey());\n        \n        // Uses Redis for distributed locking\n        Optional<RLock> lock = acquireLock(lockKeyValue, lockSetting.getFlowType());\n        \n        if (lock.isPresent() || !lockSetting.getIsLockMandatory()) {\n            try {\n                return super.execute(request);\n            } finally {\n                lock.ifPresent(redisLockUtil::releaseLock);\n            }\n        }\n        throw Error.unable_to_acquire_lock.getBuilder().build();\n    }\n}\n```\n\n### **WorkflowContext Data Container**\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/workflow/WorkflowContext.java`\n\n```java\n@Data\npublic class WorkflowContext<Request, Response> {\n    private final Request request;\n    private final Response response;\n    private final List<WorkflowInternalError> workflowInternalErrors = new ArrayList<>();\n}\n```\n\n### **Error Collection Pattern**\n\n- `workflowInternalErrors` list accumulates errors during workflow execution\n- Errors thrown only after all processing complete\n- Enables graceful degradation and detailed error reporting\n\n---\n\n## 3. STATE MACHINE IMPLEMENTATION\n\n### **PaymentStateMachine - Event-Driven State Management**\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/statemachine/payment/PaymentStateMachine.java`\n\n#### **Architecture:**\n- Component-based, Spring-managed singleton\n- Uses Guava EventBus for event subscription\n- Implements self-referencing proxy pattern for transactional boundaries\n- Concurrent event handling via `@AllowConcurrentEvents`\n\n#### **Key Event Types & Subscriptions:**\n\n```\nPaymentStateMachine Subscriptions:\n├── @Subscribe onPaymentAttemptCreated(PaymentAttemptCreatedEvent)\n│   └── Updates Payment status: FAILED → CREATED (if applicable)\n│   └── Validates no completed attempts exist\n│\n├── @Subscribe onPaymentAttemptFailed(PaymentAttemptFailedEvent)\n│   └── Checks if all attempts non-failed\n│   └── If all failed: Updates Payment → FAILED\n│\n├── @Subscribe onPaymentAttemptCompleted(PaymentAttemptCompletedEvent) [Retryable]\n│   └── Acquires optimistic lock with retry (2 attempts, 10ms backoff)\n│   └── Updates Payment → COMPLETED\n│   └── Publishes to Pinot (analytics)\n│\n├── @Subscribe onPaymentAttemptAuthorized(PaymentAttemptAuthorizedEvent) [Retryable]\n│   └── Updates Payment → AUTHORIZED\n│   └── Executes 3DS next step if applicable\n│\n├── @Subscribe onPaymentAttemptProcessingEvent(PaymentAttemptProcessingEvent)\n│   └── Updates Payment → PROCESSING (if no completed attempts)\n│\n├── @Subscribe onPaymentAttemptBlockedEvent(PaymentAttemptBlockedEvent)\n│   └── Updates Payment → BLOCKED\n│\n├── @Subscribe onPaymentAttemptReversedEvent(PaymentAttemptReversedEvent)\n│   └── Updates Payment → FAILED\n│\n├── @Subscribe onPaymentAttemptAuthenticationSuccessfulEvent\n│   └── Updates Payment → AUTHENTICATION_SUCCESSFUL\n│   └── Executes 3DS next step\n│\n└── @Subscribe onPaymentAttemptAuthenticationFailedEvent\n    └── Updates Payment → AUTHENTICATION_FAILED\n```\n\n#### **State Transitions & Terminal States:**\n\n**Terminal Payment Statuses:**\n```\n- COMPLETED\n- FAILED\n- FORCE_FAILED\n- DISCARDED\n```\n\n**Non-Terminal Payment Statuses:**\n```\n- CREATED\n- PROCESSING\n- AUTHORIZED\n- AUTHENTICATION_SUCCESSFUL\n- AUTHENTICATION_FAILED\n- BLOCKED\n- FAILED (non-terminal until completed)\n```\n\n#### **State Transition Logic:**\n\n```java\nprivate boolean shouldUpdatePaymentStatus(PaymentV2Entity paymentEntity) {\n    return !Arrays.asList(\n        PaymentStatus.COMPLETED,\n        PaymentStatus.FAILED,\n        PaymentStatus.FORCE_FAILED,\n        PaymentStatus.DISCARDED\n    ).contains(paymentEntity.getStatus());\n}\n```\n\n#### **Event Publishing:**\n\n```java\nprivate void updatePaymentStatus(PaymentV2Entity paymentEntity, PaymentStatus newStatus, \n                                 boolean isAuthenticationFlow) {\n    paymentEntity.setStatus(newStatus);\n    \n    if (!newStatus.equals(currentStatus)) {\n        // Update database\n        paymentEntity = selfProxy.updatePaymentState(paymentEntity);\n        \n        // Post event to sync bus (state machines)\n        eventBus.post(PaymentEventFactory.findEvent(paymentEntity, isAuthenticationFlow));\n        \n        // Publish to multi-tenant event system\n        eventiService.publishEvent(paymentEntity);\n        \n        // Async publish to Pinot (analytics)\n        CompletableFuture.supplyAsync(() -> eventiService.publishToPinot(entity));\n    }\n}\n```\n\n### **OrderStateMachine - Order Level State Management**\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/statemachine/order/OrderStateMachine.java`\n\n#### **Event Subscriptions:**\n\n```\nOrderStateMachine Subscriptions:\n├── @Subscribe onPaymentCreated(PaymentCreatedEvent)\n│   └── Calculates total payment amount across all payments\n│   └── Determines OrderStatus based on:\n│       ├── All payments are non-auth & non-independent → AUTHLESS_READY_TO_PROCESS\n│       └── Otherwise → CREATED\n│\n├── @Subscribe onPaymentFailed(PaymentFailedEvent)\n│   └── Updates Order → FAILED (if not already terminal)\n│\n├── @Subscribe onPaymentAuthorized(PaymentAuthorizedEvent) [Retryable]\n│   └── Updates Order → AUTHORIZED (if not terminal)\n│\n├── @Subscribe onPaymentBlockedEvent(PaymentBlockedEvent)\n│   └── Checks for auth/authless payment presence\n│   └── Updates to PROCESSING or AUTHLESS_READY_TO_PROCESS\n│\n├── @Subscribe onPaymentCompleted(PaymentCompletedEvent) [Retryable]\n│   └── Complex logic:\n│       ├── All payments COMPLETED → COMPLETED\n│       ├── All auth payments COMPLETED + no failed payments → AUTHLESS_READY_TO_PROCESS\n│       └── Other conditions → PROCESSING\n│\n├── @Subscribe onPaymentProcessingEvent(PaymentProcessingEvent)\n│   └── Updates Order → PROCESSING (if not already COMPLETED)\n│\n├── @Subscribe onPaymentAuthenticationSuccessfulEvent\n│   └── Auth flow: Order → COMPLETED\n│   └── Non-auth flow: Order → PROCESSING\n│\n└── @Subscribe onPaymentAuthenticationFailedEvent\n    └── Updates Order → FAILED\n```\n\n#### **Terminal Order Statuses:**\n\n```\n- COMPLETED\n- FAILED\n- AUTHLESS_READY_TO_PROCESS (semi-terminal)\n```\n\n#### **Order Status Update Flow:**\n\n```java\nprivate void performOrderStatusActions(OrderEntity orderEntity, OrderStatus newStatus) {\n    // Guard: Prevent updates to already-terminal orders\n    if (OrderUtil.isTerminalOrder(orderEntity)) {\n        return;\n    }\n    \n    // Determine new external status\n    String newExternalStatus = orderEntity.determineOrderExternalStatus(newStatus).name();\n    \n    // Guard: Skip if no status change\n    if (newStatus.equals(currentStatus) && newExternalStatus.equals(orderExternalStatus)) {\n        return;\n    }\n    \n    // Update with retry logic\n    orderEntity = selfProxy.updateOrderEntity(orderEntity, newStatus, newExternalStatus);\n    \n    // Post event to async bus\n    selfProxy.asyncPost(OrderEventFactory.findEvent(orderEntity));\n    \n    // Publish to event system if external status changed\n    if (!orderEntity.getExternalStatus().equals(orderExternalStatus)) {\n        eventiService.publishEvent(orderEntity);\n    }\n}\n```\n\n### **RefundStateMachine - Refund Lifecycle Management**\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/statemachine/RefundStateMachine.java`\n\n#### **Event Subscriptions:**\n\n```\nRefundStateMachine Subscriptions:\n├── @Subscribe onRefundAttemptCreated(RefundAttemptCreatedEvent)\n│   └── Validates no completed refunds exist\n│   └── Updates Refund → PROCESSING\n│   └── Posts RefundEventFactory event\n│\n├── @Subscribe onRefundAttemptProcessing(RefundAttemptProcessingEvent)\n│   └── Updates Refund → PROCESSING (if not terminal and not completed)\n│\n├── @Subscribe onRefundAttemptManualReview(RefundAttemptManualReviewEvent)\n│   └── Updates Refund → PROCESSING (if not terminal or already processing)\n│\n├── @Subscribe onRefundAttemptCompleted(RefundAttemptCompletedEvent)\n│   └── Updates Refund → COMPLETED\n│   └── Double refund detection (logs error)\n│\n└── @Subscribe onRefundAttemptFailed(RefundAttemptFailedEvent)\n    └── Checks if other attempts are non-terminal\n    └── If all terminal: Updates Refund → FAILED\n```\n\n#### **Terminal Refund Statuses:**\n\n```\n- COMPLETED\n- FAILED\n- PROCESSING (semi-terminal)\n```\n\n---\n\n## 4. COMPLETE END-TO-END PAYMENT FLOW\n\n### **Request Entry Point**\n\n**API Call Flow:**\n```\nClient Request\n    ↓\nPaymentAttemptV2Controller (or OrderController)\n    ↓\nOrderCreateWorkflow.execute(CreateOrderRequest)\n```\n\n### **Phase 1: Order Creation**\n\n**Flow:**\n```\nOrderCreateWorkflow.validateAndEnrichContext()\n├── Validates request fields\n├── Fetches/creates customer entity\n├── Creates OrderEntity with CREATED status\n├── Posts PaymentCreatedEvent per payment\n└── Returns OrderCreateContext\n\n    ↓\n\nOrderCreateWorkflow.persistIntent()\n├── Saves OrderEntity to database\n└── Posts pre-persist events\n\n    ↓\n\nOrderCreateWorkflow.process()\n├── No-op for order creation\n\n    ↓\n\nOrderCreateWorkflow.postProcess()\n├── Returns Order DTO\n└── Posts PaymentEventFactory events\n\n    ↓\n\nOrderStateMachine receives PaymentCreatedEvent\n├── Calculates total payment amount\n├── Updates Order status (CREATED / AUTHLESS_READY_TO_PROCESS)\n└── Posts OrderEventFactory event\n```\n\n### **Phase 2: Payment Creation**\n\n**Flow:**\n```\nPaymentCreateWorkflow.validateAndEnrichContext()\n├── Validates payment fields\n├── Creates PaymentV2Entity (status: CREATED)\n├── Enrich with customer/client context\n└── Delegates to PaymentAttemptCreateWorkflow\n    \n    ↓\n\nPaymentCreateWorkflow.persistIntent()\n├── Saves PaymentV2Entity\n└── Delegates to PaymentAttemptCreateWorkflow\n\n    ↓\n\nPaymentCreateWorkflow.postProcess()\n├── Calls PaymentAttemptCreateWorkflow.execute()\n└── Returns Payment DTO\n\n    ↓\n\nPaymentStateMachine receives PaymentAttemptCreatedEvent\n└── Updates Payment: FAILED → CREATED (if needed)\n```\n\n### **Phase 3: Payment Attempt Creation (Core Flow)**\n\n**Detailed Trace:**\n\n```\nPaymentAttemptCreateWorkflow.validateAndEnrichContext()\n\nStep 1.1: Instrument Processing\n├── InstrumentTypeProcessorManager.validatePaymentInstrumentAndEnrich()\n│   └── Routes to CardInstrumentTypeProcessor, UPIPayInstrumentTypeProcessor, etc.\n│   └── Returns InstrumentTypeProcessorResult with:\n│       ├── PaymentMethod (CARD, UPI_PAY, NET_BANKING, etc.)\n│       ├── PaymentSubMethodDetail (enriched details)\n│       └── EnrichedPaymentInstrument (card type, issuer, etc.)\n└── Customer entity fetched from database\n\nStep 1.2: Provider Routing Decision\n├── ProviderDeciderRouter.resolve(context)\n│   └── Executes decision tree engine\n│   └── Considers:\n│       ├── Payment mode\n│       ├── Instrument type\n│       ├── Merchant configuration\n│       ├── Customer metadata\n│       └── Risk scoring\n│   └── Returns ProviderRoutingDecisionResult with:\n│       ├── ProviderAccountEntity (selected provider)\n│       ├── DecisionTreeId (for audit)\n│       ├── IsPlatformOtpEnabled (feature flag)\n│       ├── CmResolveTerminalResult (credit manager response)\n│       └── Browser type\n└── Stores decision in context.routingDecisionResult\n\nStep 1.3: Flow Type Validation\n├── Retrieves supported flow types for provider\n├── Validates request flow type compatibility\n└── Throws error if unsupported\n\nStep 1.4: SDK Type Decision\n├── SdkTypeDeciderFactory.getSdkTypeDeciderByInstrumentType()\n│   └── Routes to CardSdkTypeDecider, UpiSdkTypeDecider, etc.\n│   └── Performs instrument-specific validation\n└── Enriches SDK parameters\n\nStep 1.5: Authentication Type Decision\n├── AuthTypeDeciderFactory.validateAndDecideAuthType()\n│   └── Considers:\n│       ├── Instrument type\n│       ├── Provider capabilities\n│       ├── Amount thresholds\n│       ├── Customer metadata\n│       └── 3DS version support\n│   └── Returns AuthType:\n│       ├── NATIVE_OTP (3DS authentication on device)\n│       ├── REDIRECT (3DS redirect flow)\n│       ├── NO_AUTHENTICATION (for certain instruments)\n│       └── CLIENT_INITIATED_AUTHENTICATION\n└── Sets context.authType\n\nStep 1.6: Native Provider Decision\n├── NativeProviderDecider.decideNativeProviderAccountEntity()\n│   └── Selects provider for native OTP if applicable\n└── Sets context.nativeProviderAccountEntity\n\nStep 1.7: Settlement Route Enrichment\n├── SettlementRouteValidator.validateRoutesAndGetRouteInformation()\n│   └── Validates merchant settlement routes\n│   └── Enriches route breakup information\n└── Sets context.routesBreakup\n\nStep 1.8: Mandate Processing (if EMANDATE order)\n├── MandateServiceDataManager.registerMandateIntent()\n│   └── Creates mandate registration with provider\n│   └── Returns Mandate object with provider reference\n└── Sets context.mandateId and context.mandate\n\nStep 1.9: Additional Details Enrichment\n├── InstrumentTypeProcessorManager.enrichAdditionalDetailsFromPaymentAttemptContext()\n│   └── Calls CardInstrumentTypeProcessor.enrichAdditionalDetailsFromPaymentAttemptContext()\n│   └── Performs instrument-specific enrichment\n└── Common validations:\n    └── validatePaymentNotInTerminalStatus()\n        ├── Checks for existing COMPLETED attempts\n        └── Throws error if found (prevents double charging)\n\nContext Created: PaymentAttemptCreateContext\n\n\nPaymentAttemptCreateWorkflow.persistIntent()\n├── Creates PaymentAttemptV2Entity\n│   ├── ExternalId = PaymentAttemptUUIdGenerator.generate()\n│   │   └── Deterministic UUID from provider account + payment ID\n│   ├── Status = CREATED\n│   ├── Stores instrument details (enriched)\n│   ├── Stores payment method/sub-method\n│   └── Stores provider account references\n├── Saves PaymentAttemptV2Entity\n├── Saves FeeEntities if applicable\n├── Enriches attributes:\n│   ├── IS_DARWIN_REDIRECTION_FLOW (if redirect flow)\n│   ├── DT_ID (decision tree ID)\n│   ├── DT_RESULT (serialized decision tree result)\n│   └── CM_RESULT (credit manager result)\n└── Saves return URL if provided (in OrderAttributes)\n\n\nPaymentAttemptCreateWorkflow.publishEntityPrePersistEvents()\n├── Hook for custom implementations\n\n\nPaymentAttemptCreateWorkflow.persistNonRelationalIntent()\n├── Checks if native OTP flow:\n│   └── AuthType == NATIVE_OTP OR IsPlatformNativeOtpSupported\n├── If applicable:\n│   ├── NativeOTPDetailDataManager.actionOnStartAuthentication()\n│   │   └── Creates PaymentAttemptNativeOTPDetailEntity\n│   │       ├── Stores provider account ID\n│   │       ├── Stores auth type\n│   │       └── Persists to DynamoDB\n│   └── Sets context.nativeOTPDetailEntity\n└── Audits provider metadata\n\n\nPaymentAttemptCreateWorkflow.process()\n\nStep 5.1: Provider Adapter Selection\n├── PaymentProviderFactory.findPaymentProviderAdapter()\n│   ├── Routes on:\n│   │   ├── OrderType (PAY, AUTHORIZE, etc.)\n│   │   ├── PaymentProvider.Key (JUSPAY, RAZORPAY, etc.)\n│   │   ├── InstrumentType (CARD, UPI_PAY, etc.)\n│   │   └── ThreeDSType (from ProviderAccountManager)\n│   └── Returns IPaymentProviderAdapter subclass\n│       └── e.g., JuspayCardPaymentProviderAdapter\n└── Adapter handles provider-specific logic\n\nStep 5.2: Provider API Call\n├── adapter.executePaymentAttempt()\n│   ├── Gets provider customer (creates if needed)\n│   │   └── ProviderCustomerEntity stored in database\n│   ├── Updates provider-specific data\n│   │   └── For NetBanking: Maps issuer code\n│   ├── Calls adapter.createPaymentAttempt(context, providerCustomer)\n│   │   └── Provider-specific implementation:\n│   │       ├── Juspay: Calls Juspay create order API\n│   │       ├── Razorpay: Calls Razorpay create payment API\n│   │       └── Others: Provider-specific implementation\n│   ├── Returns ProviderPaymentResponse:\n│   │   ├── ProviderStatus (provider's internal status)\n│   │   ├── ProviderReferenceId (provider's order/payment ID)\n│   │   ├── GatewayReferenceId (gateway's reference)\n│   │   ├── Status (mapped to PaymentAttemptStatus)\n│   │   ├── TransactionResponse (authentication details)\n│   │   │   ├── Authentication (redirect URL, method, etc.)\n│   │   │   └── SdkParams (3DS parameters, OTP details)\n│   │   ├── ProviderError (error code, message, response)\n│   │   ├── ProviderRequestStatus (SUCCESS, TIMED_OUT, RETRY_ABLE, etc.)\n│   │   └── AuthTokenDetails (for instrument tokenization)\n│   └── Audits provider response\n└── Error Handling:\n    ├── RateLimitException → Non-retry failure\n    ├── AppException → Non-retry failure\n    └── Other Exception → Re-throw\n\nStep 5.3: Platform OTP Enhancement\n├── Checks if platform native OTP enabled\n├── If CARD payment AND native OTP capable:\n│   ├── CardNativeOTPSDKParamDetail created\n│   │   ├── AuthType = NATIVE_OTP\n│   │   ├── ChallengeId = UUID\n│   │   ├── FallbackUrl = provider auth URL\n│   │   └── ResendOTPAllowed/SubmitOTPAllowed flags\n│   └── Replaces authentication with SDK params\n\n\nPaymentAttemptCreateWorkflow.postProcess()\n\nStep 6.1: Update Entity from Provider Response\n├── Sets providerStatus (Line 495)\n├── Sets providerReferenceId (Line 496)\n├── Sets gatewayReferenceId (Line 497)\n├── Adds browser and end URLs (Line 498)\n├── Enriches SDK parameters (Lines 500-505)\n├── Adds UPI intent URL (Lines 509-514)\n├── Sets error code/message (Lines 516-521)\n\nStep 6.2: Status Determination\n├── If REQUEST_SUCCESS:\n│   └── Use provider status (Line 524)\n├── If request failed AND eligible payment mode:\n│   ├── If status is FAILED → FAILED (Line 530)\n│   └── Otherwise → PROCESSING (Line 532)\n├── If not eligible payment mode:\n│   └── FAILED (Line 535)\n└── If TIMED_OUT → Set error code (Line 538)\n\nStep 6.3: Additional Updates\n├── Adds mandate ID if applicable (Lines 542-545)\n├── Saves updated entity (Line 548)\n└── Maps to PaymentAttemptResponse (Line 549)\n\n\nPaymentAttemptCreateWorkflow.postPersistNonRelationalDataStore()\n├── NativeOTPDetailDataManager.actionOnOTPSent()\n│   ├── Updates PaymentAttemptNativeOTPDetailEntity\n│   ├── Stores provider challenge ID\n│   ├── Stores OTP sent details\n│   │   ├── Serial number\n│   │   ├── SubmitOTPAllowed flag\n│   │   └── ResendOTPAllowed flag\n│   └── Persists to DynamoDB\n\n\nPaymentAttemptCreateWorkflow.publishEntityChangeEvents()\n\nStep 7.1: Event Bus Publishing\n├── Posts to syncBus (sync internal EventBus):\n│   └── PaymentAttemptEventFactory.findEvent()\n│   └── Event routed to PaymentStateMachine\n└── Posts to asyncBus (async internal EventBus):\n    └── Event for async handlers\n\nStep 7.2: Multi-Tenant Event Publishing\n├── EventiService.publishEvent(paymentAttemptEntity)\n│   └── Publishes to multi-tenant event system\n│   └── Triggers webhooks, notifications, etc.\n\nStep 7.3: Mandate Processing\n├── If mandate created:\n│   └── MandateServiceDataManager.updateTokenReferenceId()\n│       ├── Updates mandate with provider reference\n│       └── Syncs with Arsenal (tokenization service)\n\nStep 7.4: Sync Manager\n├── SyncManager.addEntityForSync()\n│   ├── Adds payment attempt for async sync\n│   └── Enables webhook-based status updates\n└── Exception handled gracefully (Line 577-583)\n\n\nPaymentStateMachine receives PaymentAttemptCreatedEvent (or other status event)\n\nStep 7.5: State Machine Processing\n├── @Subscribe onPaymentAttemptCreated(event)\n│   ├── Gets PaymentEntity from attempt\n│   ├── Fetches all payment attempts for payment\n│   ├── Validates no completed attempts exist\n│   └── If payment status == FAILED:\n│       └── Updates to CREATED\n│       └── Posts PaymentEventFactory event\n│       └── Publishes to EventiService\n│\n└── Similar flow for:\n    ├── onPaymentAttemptFailed\n    ├── onPaymentAttemptCompleted\n    ├── onPaymentAttemptAuthorized\n    └── onPaymentAttemptAuthenticationSuccessful\n\n\nResult\n├── PaymentAttemptResponse returned to client\n└── Contains:\n    ├── Payment attempt ID\n    ├── Status\n    ├── Authentication details (if needed)\n    ├── SDK parameters (3DS/OTP details)\n    └── Error information (if any)\n```\n\n### **Phase 4: Webhook Update Flow**\n\n**Webhook Sync Mechanism:**\n\n```\nWebhook Received from Provider\n    ↓\nWebhookController.handlePaymentAttemptWebhook()\n    ↓\nWebhookSyncWorkflow.execute(WebhookRequest)\n    ├── Fetches PaymentAttemptV2Entity\n    ├── Calls adapter.syncPaymentAttemptWithWebhook()\n    │   └── Provider-specific webhook handling\n    │   └── Updates payment attempt entity:\n    │       ├── Sets provider status\n    │       ├── Sets status (based on webhook response)\n    │       ├── Extracts reference IDs\n    │       └── Updates instrument details if tokenized\n    ├── Saves updated entity\n    └── Posts event to state machines\n\n    ↓\n\nPaymentStateMachine receives event\n    └── Updates Payment entity status (cascades from attempt)\n    \n    ↓\n\nOrderStateMachine receives event\n    └── Updates Order entity status (cascades from payment)\n```\n\n### **Phase 5: Sync Operations (Cron/Manual)**\n\n**Sync Flow:**\n\n```\nPaymentAttemptSyncCron (scheduled or manual trigger)\n    ↓\nFilters payment attempts needing sync:\n├── Status in (CREATED, PROCESSING, AUTHORIZED, AUTHENTICATION_SUCCESSFUL)\n├── Created > X minutes ago\n├── Not in non-syncable status\n└── Payment not in terminal status\n\n    ↓\nFor each syncable attempt:\n├── Calls adapter.syncPaymentAttemptWithProvider()\n│   ├── If provider reference ID exists:\n│   │   └── Calls syncPaymentAttemptWithProviderId()\n│   │       └── Provider-specific status fetch\n│   └── Else:\n│       └── Tries to fetch reference ID from external system\n│           └── Calls fetchProviderIdByExternalId()\n│\n├── Gets current provider status\n├── If status changed:\n│   └── Audits provider response\n└── Saves updated entity\n\n    ↓\nPosts event if status changed\n    └── Triggers state machine updates\n    └── Updates Payment and Order entities\n```\n\n---\n\n## 5. 3DS/AUTHENTICATION FLOWS\n\n### **Native OTP Flow (Card Payments)**\n\n**File Path References:**\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/authenticate/`\n- `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/service/NativeOTPDetailDataManager.java`\n\n#### **Detailed Flow:**\n\n**Step 1: OTP Capability Determination**\n\n```java\n// In PaymentAttemptCreateWorkflow.validateAndEnrichContext()\n\nboolean isPlatformNativeOtpEnabled(PaymentAttemptCreateContext context) {\n    if (!CARD.equals(context.getInstrumentProcessorResult().getPaymentMethod())) {\n        return false;  // Only for card payments\n    }\n    \n    String binHash = CardUtils.getBinHashForCard(\n        (CardPaymentInstrument) context.getRequest().getPaymentInstrument()\n    );\n    \n    return context.getRoutingDecisionResult().getIsPlatformOtpEnabled()\n           && wspService.isPlatformNativeOtpEnabled(clientId, binHash);\n}\n\ncontext.setIsPlatformNativeOtpSupported(isPlatformNativeOtpEnabled(context));\n```\n\n**Key Determination Factors:**\n- BIN (Bank Identification Number) hash\n- Merchant platform OTP enablement flag\n- WSP (Wallet Service Provider) whitespace service capability\n\n**Step 2: Provider OTP Request**\n\n```java\n// In PaymentAttemptCreateWorkflow.process()\n\nProviderPaymentResponse response = adapter.createPaymentAttempt(context, customerEntity);\n\n// If response contains:\n// - TransactionResponse.Authentication.Url → redirect 3DS\n// - TransactionResponse.SdkParams → Native OTP candidate\n```\n\n**Step 3: Platform OTP Override**\n\n```java\n// In PaymentAttemptCreateWorkflow.process()\n\nProviderPaymentResponse checkIfPlatformOtpEnabled(\n    PaymentAttemptCreateContext context, \n    ProviderPaymentResponse providerResponse) {\n    \n    if (!CARD.equals(context.getPaymentAttemptEntity().getPaymentMethod())) {\n        return providerResponse;  // Not applicable\n    }\n    \n    if (context.getRoutingDecisionResult().getIsPlatformOtpEnabled()\n        && wspService.isPlatformNativeOtpSupported(\n            clientId,\n            binHash,\n            providerResponse.getTransactionResponse().getAuthentication().getUrl(),\n            paymentAttemptId)) {\n        \n        // Create Native OTP SDK params\n        CardNativeOTPSDKParamDetail nativeOTPParams = CardNativeOTPSDKParamDetail.builder()\n            .authType(AuthType.NATIVE_OTP)\n            .fallbackUrl(providerResponse.getTransactionResponse()\n                .getAuthentication().getUrl())\n            .resendOTPAllowed(false)\n            .submitOTPAllowed(true)\n            .challengeId(UUID.randomUUID().toString())\n            .build();\n        \n        nativeOTPParams.setObjectType(ObjectType.CARD_NATIVE_OTP);\n        providerResponse.getTransactionResponse().setSdkParams(nativeOTPParams);\n        \n        // Replace authentication with SDK params\n        providerResponse.getTransactionResponse().setAuthentication(null);\n    }\n    \n    return providerResponse;\n}\n```\n\n**Step 4: OTP Storage (DynamoDB)**\n\n```java\n// In NativeOTPDetailDataManager.actionOnStartAuthentication()\n\nPaymentAttemptNativeOTPDetailEntity nativeOTPDetailEntity = \n    PaymentAttemptNativeOTPDetailEntity.builder()\n        .paymentAttemptId(paymentAttemptId)\n        .providerAccountId(nativeProviderAccountId)\n        .authType(AuthType.NATIVE_OTP)\n        .build();\n\n// Persisted to DynamoDB with:\n// - PaymentAttemptId (hash key)\n// - ProviderAccountId\n// - AuthType\n// - List of SentOTPDetails (empty initially)\n// - List of SentOTPDetail.AuthenticateOTPDetails (empty initially)\n\nnativeOTPDetailEntityDAO.save(nativeOTPDetailEntity);\n```\n\n### **OTP Authentication Request Flow**\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/authenticate/PaymentAttemptAuthenticateWorkflow.java`\n\n#### **Step 1: Validate & Enrich Context**\n\n```java\npublic PaymentAttemptAuthenticateContext validateAndEnrichContext(AuthenticateOTPRequest request) {\n    // Fetch payment attempt\n    PaymentAttemptV2Entity attemptEntity = paymentAttemptFetchWorkflow.fetchEntityById(\n        request.getPaymentAttemptId(), \n        FetchType.INTERNAL_SYNC, \n        false\n    );\n    \n    // Validate payment attempt status (must be CREATED/PROCESSING)\n    if (!POSSIBLE_STATUS_LIST.contains(attemptEntity.getStatus())) {\n        throw Error.invalid_state_transition.getBuilder().build();\n    }\n    \n    // Fetch OTP details from DynamoDB\n    PaymentAttemptNativeOTPDetailEntity otpDetailEntity = \n        nativeOTPDetailEntityDAO.findByHashKey(paymentAttemptId);\n    \n    // Validate it's native OTP flow\n    if (!NativeOtpUtil.isNativeOtpFlow(otpDetailEntity)) {\n        throw Error.invalid_payment_attempt_id.getBuilder().build();\n    }\n    \n    // Check for idempotency key (allows retry of same OTP submission)\n    AuthenticateOTPDetail latestOTPAuthenticateOTP = \n        findMatchingAuthenticateOTPByIdempotencyKey(otpDetailEntity, idempotencyKey);\n    \n    // Only check max attempts if new attempt\n    if (Objects.isNull(latestOTPAuthenticateOTP)) {\n        validateMaxAttempt(otpDetailEntity);  // Throws if max exceeded\n    }\n    \n    // Build context\n    PaymentAttemptAuthenticateContext context = new PaymentAttemptAuthenticateContext(request);\n    context.setPaymentAttemptEntity(attemptEntity);\n    context.setNativeOTPDetailEntity(otpDetailEntity);\n    context.setCurrentStatus(attemptEntity.getStatus());\n    context.setLatestAuthenticateOTP(latestOTPAuthenticateOTP);\n    context.setNativeProviderAccountEntity(\n        providerAccountService.getByProviderAccountReferenceId(\n            otpDetailEntity.getProviderAccountId()\n        ).orElseThrow(...)\n    );\n    \n    return context;\n}\n\n// Max attempt validation:\nprivate void validateMaxAttempt(PaymentAttemptNativeOTPDetailEntity otpDetailEntity) {\n    if (CollectionUtils.isNotEmpty(otpDetailEntity.getSentOTPDetails())\n        && !otpDetailEntity.getSentOTPDetails().get(0).isSubmitOTPAllowed()) {\n        throw Error.max_attempt_authentication_breached.getBuilder().build();\n    }\n}\n```\n\n#### **Step 2: Persist Intent (Non-Relational)**\n\n```java\npublic void persistNonRelationalIntent(PaymentAttemptAuthenticateContext context) {\n    if (!context.isExistingAuthenticationRequest()) {\n        // New OTP authentication attempt\n        NativeOTPDetailDataManager.actionOnAuthenticateStart(\n            nativeOTPDetailEntity, \n            request\n        );\n        // Adds new AuthenticateOTPDetail to SentOTPDetail[0].authenticateOTPDetails\n        // Sets status: INITIATED\n    } else if (INITIATED.equals(\n        context.getLatestAuthenticateOTP().getAuthenticationStatus())) {\n        \n        // Repair existing transaction (idempotent retry)\n        NativeOTPDetailDataManager.repairAuthenticationTransaction(\n            paymentAttemptEntity, \n            nativeOTPDetailEntity\n        );\n    }\n}\n```\n\n#### **Step 3: Process (Provider Call)**\n\n```java\npublic void process(PaymentAttemptAuthenticateContext context) {\n    PaymentAttemptV2Entity attemptEntity = context.getPaymentAttemptEntity();\n    \n    if (!context.isExistingAuthenticationRequest()) {\n        // Call provider to validate OTP\n        INativeProviderAdapter providerAdapter = \n            paymentProviderFactory.findPaymentProviderAdapter(\n                OrderType.PAY,\n                nativeProviderAccountEntity.getPaymentProvider().getKey(),\n                attemptEntity.getPaymentSubMethod().getType()\n            );\n        \n        ProviderPaymentResponse providerResponse = \n            providerAdapter.authenticateAttempt(context);\n            // Provider validates OTP and returns:\n            // - Status (AUTHENTICATION_SUCCESSFUL, AUTHENTICATION_FAILED)\n            // - Error information if failed\n        \n        context.setProviderPaymentResponse(providerResponse);\n        \n        // Create auth token for instrument tokenization (if applicable)\n        createAuthToken(context);\n    }\n}\n\nprivate void createAuthToken(PaymentAttemptAuthenticateContext context) {\n    if (Objects.nonNull(\n        context.getProviderPaymentResponse().getAuthTokenDetails())) {\n        \n        context.setCustomerAuthTokenEntity(\n            authTokenService.createAuthToken(\n                customerEntity.getClientReferenceId(),\n                authTokenDetails\n            )\n        );\n        // Stores token in Arsenal (instrument vault)\n    }\n}\n```\n\n#### **Step 4: Post-Process & Event Publishing**\n\n```java\npublic PaymentAttemptResponse postProcess(PaymentAttemptAuthenticateContext context) {\n    if (!context.isExistingAuthenticationRequest()) {\n        return postProcessForNewAuthenticationRequest(context);\n    } else {\n        return postProcessForExistingAuthenticationRequest(context);\n    }\n}\n\nprivate PaymentAttemptResponse postProcessForNewAuthenticationRequest(\n    PaymentAttemptAuthenticateContext context) {\n    \n    PaymentAttemptV2Entity attemptEntity = context.getPaymentAttemptEntity();\n    ProviderPaymentResponse providerResponse = context.getProviderPaymentResponse();\n    \n    // Update payment attempt entity\n    attemptEntity.setProviderStatus(providerResponse.getProviderStatus());\n    attemptEntity.setStatus(providerResponse.getStatus());  // SUCCESS/FAILED\n    \n    if (Objects.nonNull(providerResponse.getProviderError())) {\n        attemptEntity.setErrorCode(providerResponse.getProviderError().getCode());\n        attemptEntity.setErrorMessage(providerResponse.getProviderError().getMessage());\n    }\n    \n    paymentAttemptRepository.save(attemptEntity);\n    \n    return PaymentAttemptEntityMapperV2.convertToPaymentAttemptResponse(\n        attemptEntity, \n        providerResponse\n    );\n}\n\npublic void publishEntityChangeEvents(PaymentAttemptAuthenticateContext context) {\n    if (statusChanged) {\n        // Post to state machines\n        syncBus.post(PaymentAttemptEventFactory.findEvent(\n            paymentAttemptEntity, \n            true  // isAuthenticationFlow = true\n        ));\n        \n        eventiService.publishEvent(paymentAttemptEntity);\n    }\n    \n    if (tokenCreated) {\n        // Publish instrument addition event\n        eventiService.publishInstrumentAdditionEvent(\n            ArsenalInstrumentAdditionEvent.builder()\n                .userPaymentInstrument(\n                    ArsenalInstrumentMapper.mapToArsenalInstrument(context)\n                )\n                .paymentAttemptV2Entity(paymentAttemptEntity)\n                .build()\n        );\n    }\n}\n```\n\n### **Redirect/3DS Flow**\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/v2/workflow/authenticate/PaymentAttemptInitiateAuthenticationWorkflow.java`\n\n#### **Flow:**\n\n```\nClient Request: InitiateAuthenticationRequest\n    ↓\nPaymentAttemptInitiateAuthenticationWorkflow.execute()\n\nStep 1: Validate Context\n├── Fetch payment attempt (must be CREATED/PROCESSING)\n├── Verify 3DS capable\n└── Store workflow context in DynamoDB\n\nStep 2: Call Provider 3DS Initiation\n├── Get 3DS adapter (I3DSPaymentProviderAdapter)\n├── Call adapter.initiateAuthenticationForAttempt()\n│   └── Provider 3DS API call\n│   └── Returns authentication URL + ACS form\n├── Update payment attempt:\n│   ├── providerStatus\n│   ├── providerReferenceId\n│   ├── status (if applicable)\n│   └── error information\n\nStep 3: Return 3DS URL to Client\n└── PaymentAttemptResponse with:\n    ├── TransactionResponse.Authentication.Url\n    ├── Browser type\n    └── End URLs for callback\n```\n\n**After Customer Redirected Back:**\n\n```\nCustomer completes 3DS authentication at issuer\n    ↓\nReturns to return_url (callback URL)\n    ↓\nValidateAuthenticationWorkflow.execute(CallbackRequest)\n    ├── Sync with provider for 3DS result\n    ├── Update payment attempt status\n    └── Publish events to state machines\n```\n\n---\n\n## 6. INSTRUMENT PROCESSING\n\n### **InstrumentTypeProcessorManager**\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/processors/instrumenttype/InstrumentTypeProcessorManager.java`\n\n```java\n@Component\npublic class InstrumentTypeProcessorManager {\n    private final List<IInstrumentTypeProcessor> processors;\n    private Map<InstrumentType, IInstrumentTypeProcessor> processorByType;\n    \n    @PostConstruct\n    private void init() {\n        // Maps each InstrumentType to its processor at startup\n        processorByType = processors.stream()\n            .collect(Collectors.toMap(\n                IInstrumentTypeProcessor::getInstrumentType, \n                Function.identity()\n            ));\n    }\n    \n    public InstrumentTypeProcessorResult validatePaymentInstrumentAndEnrich(\n        PaymentInstrument paymentInstrument) {\n        \n        // Route to appropriate processor\n        IInstrumentTypeProcessor processor = processorByType.get(\n            paymentInstrument.getType()\n        );\n        \n        if (processor == null) {\n            throw Error.internal_server_error\n                .getBuilder()\n                .message(\"Processor not present for instrument type\")\n                .build();\n        }\n        \n        return processor.validatePaymentInstrumentAndEnrich(paymentInstrument);\n    }\n}\n```\n\n### **IInstrumentTypeProcessor Interface**\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/processors/instrumenttype/IInstrumentTypeProcessor.java`\n\n```java\npublic interface IInstrumentTypeProcessor<T extends PaymentInstrument, \n                                         R extends PaymentSubMethodDetail, \n                                         S extends EnrichedPaymentInstrument> {\n    \n    InstrumentType getInstrumentType();\n    \n    /**\n     * Validates instrument and enriches with detailed information\n     * Returns processor result containing:\n     * - PaymentMethod (CARD, UPI_PAY, NET_BANKING, etc.)\n     * - PaymentSubMethodDetail (enriched details specific to instrument)\n     * - EnrichedPaymentInstrument (final enriched instrument object)\n     */\n    InstrumentTypeProcessorResult<R, S> validatePaymentInstrumentAndEnrich(\n        @NonNull T paymentInstrument\n    );\n    \n    /**\n     * Optional: Enrich additional details from payment attempt context\n     */\n    default void enrichAdditionalDetailsFromPaymentAttemptContext(\n        @NonNull PaymentAttemptCreateContext context) {}\n    \n    /**\n     * Optional: Get fee instrument for this payment type\n     */\n    default Instrument getFeeInstrument(\n        @NonNull InstrumentTypeProcessorResult instrumentTypeProcessorResult) {\n        return null;\n    }\n}\n```\n\n### **CardInstrumentTypeProcessor - Card Payment Processing**\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/processors/instrumenttype/CardInstrumentTypeProcessor.java`\n\n#### **Validation & Enrichment Flow:**\n\n```java\npublic InstrumentTypeProcessorResult<CardPaymentSubMethodDetail, CardEnrichedPaymentInstrument> \n    validatePaymentInstrumentAndEnrich(@NonNull CardPaymentInstrument paymentInstrument) {\n    \n    // Step 1: Handle tokenized card (vault reference)\n    if (StringUtils.isNotEmpty(paymentInstrument.getVaultReferenceId())\n        && StringUtils.isEmpty(paymentInstrument.getCardNumber())) {\n        enrichInstrumentDetailsFromVault(paymentInstrument);\n        // Fetches card details from Arsenal vault\n    }\n    \n    // Step 2: Determine card brand\n    String brand = Objects.nonNull(paymentInstrument.getPaymentSubMethod())\n        ? paymentInstrument.getPaymentSubMethod().name()\n        : paymentInstrument.getBrand();\n    \n    // Step 3: Extract & hash BIN\n    String binHash = null;\n    if (StringUtils.isNotEmpty(paymentInstrument.getCardNumber())) {\n        binHash = DarwinUtils.parseBin(paymentInstrument.getCardNumber())\n            .map(HashUtils::generateHash)\n            .orElse(null);\n        \n        // Step 4: BIN enrichment (from cache)\n        Optional<CardBinDetail> cardBinDetail = cardBinCache.getByHashBin(binHash);\n        cardBinDetail.ifPresent(binDetail -> {\n            // Enrich with:\n            // - Card type (CREDIT, DEBIT, etc.)\n            // - Issuer information\n            // - Network (VISA, MASTERCARD, etc.)\n            // - Regulatory information\n        });\n    }\n    \n    // Step 5: Issuer enrichment\n    Optional<Issuer> issuer = issuerCache.getIssuerByCode(\n        extractIssuerCode(paymentInstrument)\n    );\n    \n    // Step 6: Build card sub-method detail\n    CardPaymentSubMethodDetail cardSubMethodDetail = CardPaymentSubMethodDetail.builder()\n        .brand(brand)\n        .cardType(CardType.CREDIT)  // from BIN cache\n        .issuer(issuer.orElse(null))\n        .binHash(binHash)\n        .build();\n    \n    // Step 7: Build enriched instrument\n    CardEnrichedPaymentInstrument enrichedCard = CardEnrichedPaymentInstrument.builder()\n        .token(createTokenIfApplicable(paymentInstrument))\n        .maskedCardNumber(maskCardNumber(paymentInstrument.getCardNumber()))\n        .brand(brand)\n        .cardType(CardType.CREDIT)\n        .issuer(issuer.orElse(null))\n        .binHash(binHash)\n        .expiryDate(paymentInstrument.getExpiryDate())\n        .nameOnCard(paymentInstrument.getNameOnCard())\n        .build();\n    \n    // Step 8: Return processor result\n    return new InstrumentTypeProcessorResult<>(\n        PaymentInstrumentGroup.CARD,\n        cardSubMethodDetail,\n        enrichedCard\n    );\n}\n\n// Additional enrichment from context\npublic void enrichAdditionalDetailsFromPaymentAttemptContext(\n    PaymentAttemptCreateContext context) {\n    \n    CardPaymentInstrument cardInstrument = \n        (CardPaymentInstrument) context.getRequest().getPaymentInstrument();\n    \n    // Instrument-specific enrichment\n    if (shouldTokenizeCard(cardInstrument)) {\n        // Prepare for tokenization after successful payment\n        context.setTokenizationRequired(true);\n    }\n}\n```\n\n### **UPI Payment Processing**\n\n**Supported UPI Variants:**\n- `UPIPayInstrumentTypeProcessor` - UPI Push\n- `UPICollectInstrumentTypeProcessor` - UPI Collect (QR)\n- `UPICREDInstrumentTypeProcessor` - UPI CRED integration\n\n#### **Flow (UPIPayInstrumentTypeProcessor):**\n\n```java\npublic InstrumentTypeProcessorResult<UpiPaymentSubMethodDetail, UpiEnrichedPaymentInstrument> \n    validatePaymentInstrumentAndEnrich(@NonNull UpiPaymentInstrument paymentInstrument) {\n    \n    // Validations\n    validateUpiVpa(paymentInstrument.getVpa());\n    validateUpiTimeout(paymentInstrument.getTimeout());\n    \n    // Enrich UPI sub-method detail\n    UpiPaymentSubMethodDetail subMethodDetail = UpiPaymentSubMethodDetail.builder()\n        .vpa(paymentInstrument.getVpa())\n        .provider(paymentInstrument.getProvider())  // Google Pay, Phonepe, etc.\n        .build();\n    \n    // Enrich UPI instrument\n    UpiEnrichedPaymentInstrument enrichedUpi = UpiEnrichedPaymentInstrument.builder()\n        .vpa(paymentInstrument.getVpa())\n        .provider(paymentInstrument.getProvider())\n        .timeout(paymentInstrument.getTimeout())\n        .notificationUrl(paymentInstrument.getNotificationUrl())\n        .build();\n    \n    return new InstrumentTypeProcessorResult<>(\n        PaymentInstrumentGroup.UPI_PAY,\n        subMethodDetail,\n        enrichedUpi\n    );\n}\n```\n\n### **NetBanking Instrument Processing**\n\n**File:** References in `NetBankingInstrumentTypeProcessor.java`\n\n```java\npublic InstrumentTypeProcessorResult<NetBankingPaymentSubMethodDetail, \n                                     NetBankingEnrichedPaymentInstrument> \n    validatePaymentInstrumentAndEnrich(\n        @NonNull NetBankingPaymentInstrument paymentInstrument) {\n    \n    // Step 1: Validate bank code\n    validateBankCode(paymentInstrument.getBankCode());\n    \n    // Step 2: Fetch issuer details\n    Optional<Issuer> issuer = issuerCache.getIssuerByCode(\n        paymentInstrument.getBankCode()\n    );\n    \n    // Step 3: Build enriched details\n    NetBankingPaymentSubMethodDetail subMethodDetail = \n        NetBankingPaymentSubMethodDetail.builder()\n            .bankCode(paymentInstrument.getBankCode())\n            .bankName(issuer.map(Issuer::getName).orElse(null))\n            .bankLogo(issuer.map(Issuer::getLogoUrl).orElse(null))\n            .build();\n    \n    // Step 4: Enrich instrument\n    NetBankingEnrichedPaymentInstrument enrichedNetBanking = \n        NetBankingEnrichedPaymentInstrument.builder()\n            .bankCode(paymentInstrument.getBankCode())\n            .bankName(issuer.map(Issuer::getName).orElse(null))\n            .build();\n    \n    return new InstrumentTypeProcessorResult<>(\n        PaymentInstrumentGroup.NET_BANKING,\n        subMethodDetail,\n        enrichedNetBanking\n    );\n}\n```\n\n### **InstrumentTypeProcessorResult Data Structure**\n\n**File:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/src/main/java/in/dreamplug/darwin/processors/instrumenttype/InstrumentTypeProcessorResult.java`\n\n```java\n@Getter\n@RequiredArgsConstructor\npublic class InstrumentTypeProcessorResult<R extends PaymentSubMethodDetail, \n                                          S extends EnrichedPaymentInstrument> {\n    \n    // Payment method group (CARD, UPI_PAY, NET_BANKING, etc.)\n    private final PaymentInstrumentGroup paymentMethod;\n    \n    // Instrument-specific sub-method details\n    // Examples:\n    // - CardPaymentSubMethodDetail (for cards)\n    // - UpiPaymentSubMethodDetail (for UPI)\n    // - NetBankingPaymentSubMethodDetail (for banks)\n    private final R paymentSubMethodDetail;\n    \n    // Final enriched payment instrument with all details\n    // Used throughout the payment flow\n    private final S enrichedPaymentInstrument;\n}\n```\n\n### **Instrument Tokenization Integration**\n\n**Arsenal Integration (Instrument Vault):**\n\n```java\n// After successful authentication, tokens are created\n\npublic void publishEntityChangeEvents(PaymentAttemptAuthenticateContext context) {\n    if (isTokenCreated(context)) {\n        // Publish instrument addition event to Arsenal\n        eventiService.publishInstrumentAdditionEvent(\n            ArsenalInstrumentAdditionEvent.builder()\n                .userPaymentInstrument(\n                    ArsenalInstrumentMapper.mapToArsenalInstrument(context)\n                )\n                .paymentAttemptV2Entity(paymentAttemptEntity)\n                .build()\n        );\n        \n        // Arsenal service:\n        // 1. Receives instrument addition event\n        // 2. Creates unique vault reference ID\n        // 3. Stores masked instrument details\n        // 4. Returns reference for future use\n        // 5. Publishes instrument creation confirmation event\n    }\n}\n```\n\n---\n\n## SUMMARY - KEY ARCHITECTURAL PATTERNS\n\n### **1. Template Method Pattern (Workflow Execution)**\n- Base `Workflow` class defines 9-step execution pipeline\n- Each step is a hook for implementations to override\n- Transactional boundaries explicitly marked\n- Self-proxy pattern enables method-level transactions\n\n### **2. Event-Driven State Management**\n- EventBus (Guava) for decoupled state transitions\n- Multiple state machines react to events asynchronously\n- Cascading state updates: PaymentAttempt → Payment → Order\n- Terminal state guards prevent invalid transitions\n\n### **3. Context Object Pattern**\n- `PaymentAttemptCreateContext` accumulates data through execution\n- Each step enriches context with new information\n- Enables loose coupling between workflow steps\n- Easy to add new enrichment steps\n\n### **4. Factory & Strategy Pattern**\n- `InstrumentTypeProcessorManager` routes to specific processors\n- `PaymentProviderFactory` selects provider adapter\n- `AuthTypeDeciderFactory` determines authentication strategy\n- `SdkTypeDeciderFactory` selects SDK type handler\n\n### **5. Data Enrichment Pipeline**\n- Step 1: Instrument enrichment (BIN, issuer data)\n- Step 2: Provider routing (decision tree)\n- Step 3: Auth type decision\n- Step 4: Settlement routes\n- Step 5: Mandate processing (if applicable)\n\n### **6. Transaction Boundary Management**\n- Validation outside transaction (external calls risky)\n- Persist intent in transaction (atomic save)\n- Process outside transaction (provider calls)\n- Post-process in transaction (save results)\n- Events published outside transaction (async)\n\n### **7. Distributed Locking**\n- `SequentialWorkflow` uses Redis locks\n- Prevents concurrent execution of same order/payment\n- SPEL expression evaluation for lock key\n- Lock mandatory or optional based on config\n\n### **8. Non-Relational Data Persistence**\n- DynamoDB for OTP details, workflow context, redirection URLs\n- Separate from transactional relational data\n- Enables quick retrieval without DB joins\n- Scales independently\n\n### **9. Multi-Bus Event Publishing**\n- Sync bus: For immediate state machines (PaymentStateMachine)\n- Async bus: For deferred handlers\n- EventiService: For multi-tenant events (webhooks, notifications)\n- Pinot: For analytics and dashboards (async)\n\n### **10. Error Handling & Collection**\n- Errors accumulated in context during processing\n- Final error check before returning response\n- Graceful degradation possible\n- Detailed error information returned to client\n\nThis architecture enables:\n- **Scalability**: Distributed locking, async event processing\n- **Reliability**: Transaction boundaries, event sourcing\n- **Maintainability**: Clear separation of concerns, extensible patterns\n- **Testability**: Mockable components, context-based testing\n- **Observability**: Event trail, audit logging, provider audits\n\n---\n\nThis completes the expert-level deep dive into the Payment Flow Architecture of the payment-service codebase!"}],"totalDurationMs":180361,"totalTokens":109968,"totalToolUseCount":40,"usage":{"input_tokens":187,"cache_creation_input_tokens":2927,"cache_read_input_tokens":90310,"cache_creation":{"ephemeral_5m_input_tokens":2927,"ephemeral_1h_input_tokens":0},"output_tokens":16544}}}
{"parentUuid":"3e0f70fb-4437-4faf-99cb-0119b07f1f42","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01Pz9KroQwYBg3izBn2JqkAf","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Excellent! The exploration agent returned an extremely comprehensive deep-dive into the Payment Flow architecture. Let me add this to the plan file to complete the expert study guide.","signature":"EuICCkgICxABGAIqQI8kf9cXD2rA1mdOzU4BbLvU9RC+iceOWtf25w7nmpgsAyCZi3H64M5/jhK9sXY80M/VY8T1y792l9JpQM/T4ZwSDECHmxcq5Qc5PwZ0YxoML2XAcI8cIBoSxLEbIjBNYwMTSGzNZ04WNSVO6mZ8yE/HU4rd9iJg1ZmqgshuX6AcH6VKa2SPYhOvf0Nf6WoqxwHaGZmsThAS8ZATNZCAYSokmvmBwslfuIiuT0yx7m4DZNXx/ps7Z4yy0MoLSogKvZfXANyFsTLEoTacFt7K7GLruOjOEXhzFIo0g9NGhI+fScvK342+ncoXhJa0o3gdQ/NKPM1kmCzjRp40UdIZfBp1/F/57l09Ik5hHC/xvaEQoqWXkz0LGAT6YmomMfVImAf6VKeAzCvsyTrHtmq/kUNTXkFzunzawqNpWyeQyvdcktovJl3oedfTlEx1GckQwVOTlHkoXxlxGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":17100,"cache_read_input_tokens":93209,"cache_creation":{"ephemeral_5m_input_tokens":17100,"ephemeral_1h_input_tokens":0},"output_tokens":4}},"type":"assistant","uuid":"912f6052-747e-4094-a87d-1f0d5f061e71","timestamp":"2025-12-31T09:53:01.076Z"}
{"parentUuid":"912f6052-747e-4094-a87d-1f0d5f061e71","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01Pz9KroQwYBg3izBn2JqkAf","type":"message","role":"assistant","content":[{"type":"text","text":"Let me add this comprehensive Payment Flow deep-dive to complete your expert study guide."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":17100,"cache_read_input_tokens":93209,"cache_creation":{"ephemeral_5m_input_tokens":17100,"ephemeral_1h_input_tokens":0},"output_tokens":4}},"type":"assistant","uuid":"119ccf53-42af-45b3-ae6f-cae4a496284b","timestamp":"2025-12-31T09:53:01.570Z"}
{"parentUuid":"119ccf53-42af-45b3-ae6f-cae4a496284b","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01Pz9KroQwYBg3izBn2JqkAf","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_bdrk_01T4nrCQ2BWa27ss8KWABvSf","name":"Edit","input":{"file_path":"/Users/kiranbiliyawala/.claude/plans/distributed-marinating-mango.md","old_string":"### Configuration\n1. `entity/ProviderAccountEntity.java` - Provider credentials\n2. `entity/PaymentProviderEntity.java` - Provider definition\n3. `entity/ClientPaymentProviderConfigEntity.java` - Client-provider mapping","new_string":"### Configuration\n1. `entity/ProviderAccountEntity.java` - Provider credentials\n2. `entity/PaymentProviderEntity.java` - Provider definition\n3. `entity/ClientPaymentProviderConfigEntity.java` - Client-provider mapping\n\n---\n\n# PAYMENT FLOW DEEP-DIVE\n\n## 33. THE 7-STEP WORKFLOW PIPELINE\n\n### Base Workflow Pattern (Template Method)\n**File:** `v2/workflow/create/Workflow.java`\n\n```java\npublic Response execute(Request request) {\n    // STEP 1: Validate inputs and enrich context\n    Context context = validateAndEnrichContext(request);\n\n    // STEP 2: Persist to relational DB (transactional)\n    persistIntent(context);\n\n    // STEP 3: Pre-persist event hooks\n    publishEntityPrePersistEvents(context);\n\n    // STEP 4: Persist to non-relational DB (DynamoDB)\n    persistNonRelationalIntent(context);\n\n    // STEP 5: Process (external provider calls)\n    process(context);\n\n    // STEP 6: Post-process and save results (transactional)\n    Response response = postProcess(context);\n\n    // STEP 7: Post-persist & publish events\n    postPersistNonRelationalDataStore(context);\n    publishEntityChangeEvents(context);\n\n    throwErrorIfRequired(context);\n    return response;\n}\n```\n\n---\n\n## 34. PAYMENTATTEMPTCREATEWORKFLOW DETAILED\n\n**File:** `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java`\n\n### Step 1: Validate & Enrich Context\n\n| Enricher | Purpose | Output |\n|----------|---------|--------|\n| `InstrumentTypeProcessorManager` | Validate & enrich payment instrument | `InstrumentTypeProcessorResult` |\n| `ProviderDeciderRouter.resolve()` | Route to provider via Decision Tree | `ProviderRoutingDecisionResult` |\n| `AuthTypeDeciderFactory` | Determine auth type (3DS, OTP, None) | `AuthType` |\n| `NativeProviderDecider` | Select native OTP provider | `ProviderAccountEntity` |\n| `SettlementRouteValidator` | Validate & enrich settlement routes | `RoutesBreakup` |\n| `MandateServiceDataManager` | Register mandate (if eMandate) | `Mandate` |\n\n### Context Object Structure\n```java\nPaymentAttemptCreateContext {\n    // Request/Response\n    CreatePaymentAttemptRequest request\n    PaymentAttemptResponse response\n\n    // Entities\n    PaymentAttemptV2Entity paymentAttemptEntity\n    PaymentV2Entity paymentEntity\n    OrderEntity orderEntity\n    CustomerEntity customerEntity\n    ClientEntity clientEntity\n\n    // Enriched Data\n    InstrumentTypeProcessorResult instrumentProcessorResult\n    ProviderAccountEntity providerAccountEntity\n    ProviderRoutingDecisionResult routingDecisionResult\n    AuthType authType\n    RoutesBreakup routesBreakup\n    ProviderPaymentResponse createResponse\n\n    // OTP/Auth Flow\n    Boolean isPlatformNativeOtpSupported\n    PaymentAttemptNativeOTPDetailEntity nativeOTPDetailEntity\n\n    // Error Collection\n    List<WorkflowInternalError> errors\n}\n```\n\n### Step 2: Persist Intent\n```java\n@Transactional(transactionManager = \"MasterTransactionManager\")\npublic void persistIntent(PaymentAttemptCreateContext context) {\n    // Create PaymentAttemptV2Entity\n    PaymentAttemptV2Entity entity = PaymentAttemptV2Entity.builder()\n        .externalId(PaymentAttemptUUIdGenerator.generate())\n        .status(PaymentAttemptStatus.CREATED)\n        .paymentEntity(paymentEntity)\n        .providerAccountEntity(providerAccountEntity)\n        .paymentMethod(instrumentResult.getPaymentMethod())\n        .instrumentDetail(instrumentResult.getEnrichedInstrument())\n        .routesBreakup(routesBreakup)\n        .build();\n\n    // Save to repository\n    paymentAttemptRepository.save(entity);\n\n    // Save fees\n    feeCreateWorkflow.persistIntent(feeContexts);\n\n    // Add attributes (DT_ID, DT_RESULT, etc.)\n    enrichAttributes(entity);\n}\n```\n\n### Step 5: Process (Provider Call)\n```java\npublic void process(PaymentAttemptCreateContext context) {\n    // Find adapter\n    IPaymentProviderAdapter adapter = paymentProviderFactory\n        .findPaymentProviderAdapter(orderType, providerKey, instrumentType, threeDSType);\n\n    // Execute provider call\n    ProviderPaymentResponse response = adapter.executePaymentAttempt(\n        context,\n        adapter::createPaymentAttempt,\n        FlowType.CREATE\n    );\n\n    // Check platform OTP capability\n    response = checkIfPlatformOtpEnabled(context, response);\n\n    context.setCreateResponse(response);\n}\n```\n\n### Step 6: Post-Process\n```java\n@Transactional\npublic PaymentAttemptResponse postProcess(PaymentAttemptCreateContext context) {\n    PaymentAttemptV2Entity entity = context.getPaymentAttemptEntity();\n    ProviderPaymentResponse response = context.getCreateResponse();\n\n    // Update from provider response\n    entity.setProviderStatus(response.getProviderStatus());\n    entity.setProviderReferenceId(response.getProviderReferenceId());\n    entity.setGatewayReferenceId(response.getGatewayReferenceId());\n\n    // Determine final status\n    if (response.getProviderRequestStatus() == REQUEST_SUCCESS) {\n        entity.setStatus(response.getStatus());\n    } else if (isEligiblePaymentMode) {\n        entity.setStatus(response.getStatus() == FAILED ? FAILED : PROCESSING);\n    }\n\n    paymentAttemptRepository.save(entity);\n    return mapper.toResponse(entity, response);\n}\n```\n\n### Step 7: Publish Events\n```java\npublic void publishEntityChangeEvents(PaymentAttemptCreateContext context) {\n    // Post to sync EventBus (triggers PaymentStateMachine)\n    syncBus.post(PaymentAttemptEventFactory.findEvent(paymentAttemptEntity));\n\n    // Post to async EventBus\n    asyncBus.post(PaymentAttemptEventFactory.findEvent(paymentAttemptEntity));\n\n    // Publish to multi-tenant event system\n    eventiService.publishEvent(paymentAttemptEntity);\n\n    // Add to sync manager for webhook updates\n    syncManager.addEntityForSync(paymentAttemptEntity);\n}\n```\n\n---\n\n## 35. STATE MACHINE IMPLEMENTATION\n\n### PaymentStateMachine\n**File:** `statemachine/payment/PaymentStateMachine.java`\n\n```\nEvent Subscriptions:\n├── @Subscribe onPaymentAttemptCreated\n│   └── Payment: FAILED → CREATED\n├── @Subscribe onPaymentAttemptFailed\n│   └── If all attempts failed: Payment → FAILED\n├── @Subscribe onPaymentAttemptCompleted\n│   └── Payment → COMPLETED (with optimistic lock retry)\n├── @Subscribe onPaymentAttemptAuthorized\n│   └── Payment → AUTHORIZED\n├── @Subscribe onPaymentAttemptProcessing\n│   └── Payment → PROCESSING\n├── @Subscribe onPaymentAttemptBlocked\n│   └── Payment → BLOCKED\n└── @Subscribe onAuthenticationSuccessful/Failed\n    └── Payment → AUTHENTICATION_SUCCESSFUL/FAILED\n```\n\n### OrderStateMachine\n**File:** `statemachine/order/OrderStateMachine.java`\n\n```\nEvent Subscriptions:\n├── @Subscribe onPaymentCreated\n│   └── Order → CREATED or AUTHLESS_READY_TO_PROCESS\n├── @Subscribe onPaymentFailed\n│   └── Order → FAILED\n├── @Subscribe onPaymentCompleted\n│   └── Order → COMPLETED (if all payments done)\n├── @Subscribe onPaymentAuthorized\n│   └── Order → AUTHORIZED\n└── @Subscribe onPaymentProcessing\n    └── Order → PROCESSING\n```\n\n### Terminal States\n| Entity | Terminal States |\n|--------|-----------------|\n| PaymentAttempt | COMPLETED, FAILED, FORCE_FAILED |\n| Payment | COMPLETED, FAILED, FORCE_FAILED, DISCARDED |\n| Order | COMPLETED, FAILED |\n\n### State Transition Guard\n```java\nprivate boolean shouldUpdatePaymentStatus(PaymentV2Entity entity) {\n    return !Arrays.asList(COMPLETED, FAILED, FORCE_FAILED, DISCARDED)\n        .contains(entity.getStatus());\n}\n```\n\n---\n\n## 36. END-TO-END PAYMENT FLOW\n\n```\n┌─────────────────────────────────────────────────────────────────────────┐\n│                         CLIENT REQUEST                                   │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  1. ORDER CREATION                                                       │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ OrderCreateWorkflow.execute()                                       │ │\n│  │ ├── validateAndEnrichContext() - Customer lookup, order validation │ │\n│  │ ├── persistIntent() - Save OrderEntity (status: CREATED)           │ │\n│  │ └── publishEvents() → OrderStateMachine                            │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  2. PAYMENT CREATION                                                     │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ BulkPaymentCreateWorkflow.execute()                                 │ │\n│  │ ├── validateAndEnrichContext() - Payment mode validation           │ │\n│  │ ├── persistIntent() - Save PaymentV2Entity (status: CREATED)       │ │\n│  │ └── publishEvents() → PaymentStateMachine                          │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  3. PAYMENT ATTEMPT CREATION (Core Flow)                                 │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ PaymentAttemptCreateWorkflow.execute()                              │ │\n│  │ ├── validateAndEnrichContext()                                     │ │\n│  │ │   ├── InstrumentTypeProcessorManager (Card/UPI/NetBanking)       │ │\n│  │ │   ├── ProviderDeciderRouter (Decision Tree routing)              │ │\n│  │ │   ├── AuthTypeDeciderFactory (3DS/OTP/None)                      │ │\n│  │ │   └── SettlementRouteValidator                                   │ │\n│  │ ├── persistIntent() - Save PaymentAttemptV2Entity                  │ │\n│  │ ├── persistNonRelationalIntent() - DynamoDB (OTP details)          │ │\n│  │ ├── process() - Provider API call via Adapter                      │ │\n│  │ ├── postProcess() - Update entity with provider response           │ │\n│  │ └── publishEvents() → PaymentStateMachine → OrderStateMachine      │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  4. PROVIDER API RESPONSE                                                │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ ProviderPaymentResponse contains:                                   │ │\n│  │ ├── providerStatus: \"SUCCESS\" / \"PENDING\" / \"FAILED\"               │ │\n│  │ ├── providerReferenceId: Provider's transaction ID                 │ │\n│  │ ├── status: PaymentAttemptStatus (mapped)                          │ │\n│  │ ├── transactionResponse:                                           │ │\n│  │ │   ├── authentication: { url, method } (for 3DS redirect)         │ │\n│  │ │   └── sdkParams: Native OTP/SDK details                          │ │\n│  │ └── providerError: Error details if failed                         │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n         ┌──────────────────────────┴──────────────────────────┐\n         ▼                                                      ▼\n┌─────────────────────────┐                    ┌─────────────────────────┐\n│  5A. 3DS/OTP FLOW       │                    │  5B. DIRECT SUCCESS     │\n│  ┌───────────────────┐  │                    │  ┌───────────────────┐  │\n│  │ Client performs   │  │                    │  │ Status: COMPLETED │  │\n│  │ authentication    │  │                    │  │ Payment done!     │  │\n│  │ (redirect/native) │  │                    │  └───────────────────┘  │\n│  └───────────────────┘  │                    └─────────────────────────┘\n│           │             │\n│           ▼             │\n│  ┌───────────────────┐  │\n│  │ Authenticate      │  │\n│  │ Workflow called   │  │\n│  │ with OTP/callback │  │\n│  └───────────────────┘  │\n└─────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  6. WEBHOOK / SYNC UPDATE                                                │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ Provider sends webhook OR SyncManager polls status                  │ │\n│  │ ├── WebhookController receives update                              │ │\n│  │ ├── adapter.syncPaymentAttemptWithWebhook()                        │ │\n│  │ ├── Update PaymentAttemptV2Entity status                           │ │\n│  │ └── publishEvents() → State machines cascade updates               │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  7. FINAL STATE                                                          │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ PaymentAttempt: COMPLETED ──► Payment: COMPLETED ──► Order: COMPLETED│\n│  │                                                                     │ │\n│  │ eventiService.publishEvent() → Client webhook notification          │ │\n│  │ eventiService.publishToPinot() → Analytics dashboard               │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## 37. 3DS / NATIVE OTP AUTHENTICATION\n\n### Native OTP Flow (Card Payments)\n```\n1. PaymentAttemptCreateWorkflow detects CARD + OTP-capable BIN\n2. wspService.isPlatformNativeOtpEnabled() returns true\n3. Provider returns redirect URL, but we override with SDK params\n4. CardNativeOTPSDKParamDetail created:\n   ├── authType: NATIVE_OTP\n   ├── challengeId: UUID\n   ├── fallbackUrl: Provider's original auth URL\n   └── submitOTPAllowed: true\n\n5. PaymentAttemptNativeOTPDetailEntity saved to DynamoDB\n6. Client submits OTP via PaymentAttemptAuthenticateWorkflow\n7. Provider validates OTP, returns success/failure\n8. State machines update payment/order status\n```\n\n### 3DS Redirect Flow\n```\n1. Provider returns authentication URL\n2. Client redirects to issuer's 3DS page\n3. User completes authentication\n4. Callback to return_url\n5. ValidateAuthenticationWorkflow processes callback\n6. Provider confirms authentication status\n7. State machines update accordingly\n```\n\n---\n\n## 38. INSTRUMENT PROCESSING\n\n### InstrumentTypeProcessorManager\n**File:** `processors/instrumenttype/InstrumentTypeProcessorManager.java`\n\n```java\n// Routes to specific processor based on instrument type\nIInstrumentTypeProcessor processor = processorByType.get(instrument.getType());\nreturn processor.validatePaymentInstrumentAndEnrich(instrument);\n```\n\n### Processor Implementations\n| Processor | InstrumentType | Enrichment |\n|-----------|----------------|------------|\n| `CardInstrumentTypeProcessor` | CARD | BIN lookup, issuer, card type |\n| `UPIPayInstrumentTypeProcessor` | UPI_APPS | VPA validation, provider |\n| `UPICollectInstrumentTypeProcessor` | UPI_COLLECT | QR code, timeout |\n| `NetBankingInstrumentTypeProcessor` | NET_BANKING | Bank code, issuer |\n| `EMandateInstrumentTypeProcessor` | NET_BANKING_WITH_PI | Mandate details |\n\n### InstrumentTypeProcessorResult\n```java\nInstrumentTypeProcessorResult<R, S> {\n    PaymentInstrumentGroup paymentMethod;  // CARD, UPI_PAY, etc.\n    R paymentSubMethodDetail;              // CardPaymentSubMethodDetail\n    S enrichedPaymentInstrument;           // CardEnrichedPaymentInstrument\n}\n```\n\n---\n\n## 39. DISTRIBUTED LOCKING\n\n### SequentialWorkflow Pattern\n**File:** `v2/workflow/create/SequentialWorkflow.java`\n\n```java\npublic Response execute(Request request) {\n    LockSetting lockSetting = fetchLockSetting();\n    String lockKey = evaluateLockKey(request, lockSetting.getLockKey());\n\n    // Acquire Redis distributed lock\n    Optional<RLock> lock = redisLockUtil.acquireLock(lockKey, flowType);\n\n    if (lock.isPresent() || !lockSetting.getIsLockMandatory()) {\n        try {\n            return super.execute(request);  // Run workflow\n        } finally {\n            lock.ifPresent(redisLockUtil::releaseLock);\n        }\n    }\n    throw Error.unable_to_acquire_lock.getBuilder().build();\n}\n```\n\n**Use Cases:**\n- Prevents concurrent payment attempts on same order\n- Ensures single webhook processing per transaction\n- Avoids race conditions in status updates\n\n---\n\n## 40. KEY PAYMENT FLOW FILES\n\n### Core Workflows\n1. `v2/workflow/create/Workflow.java` - Base template\n2. `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java` - Main flow\n3. `v2/workflow/create/payments/bulk/BulkPaymentCreateWorkflow.java` - Payment creation\n4. `v2/workflow/authenticate/PaymentAttemptAuthenticateWorkflow.java` - OTP auth\n\n### State Machines\n1. `statemachine/payment/PaymentStateMachine.java`\n2. `statemachine/order/OrderStateMachine.java`\n3. `statemachine/RefundStateMachine.java`\n\n### Instrument Processing\n1. `processors/instrumenttype/InstrumentTypeProcessorManager.java`\n2. `processors/instrumenttype/CardInstrumentTypeProcessor.java`\n3. `processors/instrumenttype/UPIPayInstrumentTypeProcessor.java`\n\n### Context & Events\n1. `v2/workflow/create/paymentattempts/PaymentAttemptCreateContext.java`\n2. `statemachine/payment/events/PaymentAttemptEventFactory.java`\n3. `statemachine/order/events/OrderEventFactory.java`\n\n---\n\n## 41. ARCHITECTURAL PATTERNS SUMMARY\n\n| Pattern | Implementation | Purpose |\n|---------|----------------|---------|\n| **Template Method** | `Workflow.execute()` 7-step pipeline | Consistent execution flow |\n| **Factory** | `PaymentProviderFactory`, `InstrumentTypeProcessorManager` | Dynamic component selection |\n| **Strategy** | `AuthTypeDeciderFactory`, `SdkTypeDeciderFactory` | Pluggable algorithms |\n| **Observer** | Guava EventBus, State Machines | Decoupled state transitions |\n| **Context Object** | `PaymentAttemptCreateContext` | Data flow through pipeline |\n| **Distributed Lock** | `SequentialWorkflow` + Redis | Concurrency control |\n| **Event Sourcing** | DynamoDB workflow context | Audit trail |\n\n---\n\n## 42. COMPLETE STUDY GUIDE SUMMARY\n\nYou now have a **42-section expert study guide** covering:\n\n### Foundation (Sections 1-15)\n- Tech stack, project structure, core concepts\n- API endpoints, authentication, dependencies\n\n### Data Layer Deep-Dive (Sections 16-24)\n- Entity hierarchy, Master-Replica DB\n- Repository patterns, caching, DynamoDB\n\n### Provider Integration Deep-Dive (Sections 25-32)\n- Adapter architecture, Decision Tree routing\n- Webhook handling, provider configuration\n- Error handling and retry logic\n\n### Payment Flow Deep-Dive (Sections 33-41)\n- 7-step workflow pipeline\n- State machine implementation\n- End-to-end payment flow\n- 3DS/OTP authentication\n- Instrument processing\n- Distributed locking"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":17100,"cache_read_input_tokens":93209,"cache_creation":{"ephemeral_5m_input_tokens":17100,"ephemeral_1h_input_tokens":0},"output_tokens":5945}},"type":"assistant","uuid":"7e9d5ccb-d609-4513-9292-71b4bac863ad","timestamp":"2025-12-31T09:54:29.362Z"}
{"parentUuid":"7e9d5ccb-d609-4513-9292-71b4bac863ad","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01T4nrCQ2BWa27ss8KWABvSf","type":"tool_result","content":"The file /Users/kiranbiliyawala/.claude/plans/distributed-marinating-mango.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  1060→1. `v2/workflow/create/providers/CashfreeProviderAdapter.java`\n  1061→2. `v2/workflow/create/providers/cybersource/CybersourceProviderAdapter.java`\n  1062→3. `v2/workflow/create/providers/PayuProviderAdapter.java`\n  1063→\n  1064→### Configuration\n  1065→1. `entity/ProviderAccountEntity.java` - Provider credentials\n  1066→2. `entity/PaymentProviderEntity.java` - Provider definition\n  1067→3. `entity/ClientPaymentProviderConfigEntity.java` - Client-provider mapping\n  1068→\n  1069→---\n  1070→\n  1071→# PAYMENT FLOW DEEP-DIVE\n  1072→\n  1073→## 33. THE 7-STEP WORKFLOW PIPELINE\n  1074→\n  1075→### Base Workflow Pattern (Template Method)\n  1076→**File:** `v2/workflow/create/Workflow.java`\n  1077→\n  1078→```java\n  1079→public Response execute(Request request) {\n  1080→    // STEP 1: Validate inputs and enrich context\n  1081→    Context context = validateAndEnrichContext(request);\n  1082→\n  1083→    // STEP 2: Persist to relational DB (transactional)\n  1084→    persistIntent(context);\n  1085→\n  1086→    // STEP 3: Pre-persist event hooks\n  1087→    publishEntityPrePersistEvents(context);\n  1088→\n  1089→    // STEP 4: Persist to non-relational DB (DynamoDB)\n  1090→    persistNonRelationalIntent(context);\n  1091→\n  1092→    // STEP 5: Process (external provider calls)\n  1093→    process(context);\n  1094→\n  1095→    // STEP 6: Post-process and save results (transactional)\n  1096→    Response response = postProcess(context);\n  1097→\n  1098→    // STEP 7: Post-persist & publish events\n  1099→    postPersistNonRelationalDataStore(context);\n  1100→    publishEntityChangeEvents(context);\n  1101→\n  1102→    throwErrorIfRequired(context);\n  1103→    return response;\n  1104→}\n  1105→```\n  1106→\n  1107→---\n  1108→\n  1109→## 34. PAYMENTATTEMPTCREATEWORKFLOW DETAILED\n  1110→\n  1111→**File:** `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java`\n  1112→\n  1113→### Step 1: Validate & Enrich Context\n  1114→\n  1115→| Enricher | Purpose | Output |\n  1116→|----------|---------|--------|\n  1117→| `InstrumentTypeProcessorManager` | Validate & enrich payment instrument | `InstrumentTypeProcessorResult` |\n  1118→| `ProviderDeciderRouter.resolve()` | Route to provider via Decision Tree | `ProviderRoutingDecisionResult` |\n  1119→| `AuthTypeDeciderFactory` | Determine auth type (3DS, OTP, None) | `AuthType` |\n  1120→| `NativeProviderDecider` | Select native OTP provider | `ProviderAccountEntity` |\n  1121→| `SettlementRouteValidator` | Validate & enrich settlement routes | `RoutesBreakup` |\n  1122→| `MandateServiceDataManager` | Register mandate (if eMandate) | `Mandate` |\n  1123→\n  1124→### Context Object Structure\n  1125→```java\n  1126→PaymentAttemptCreateContext {\n  1127→    // Request/Response\n  1128→    CreatePaymentAttemptRequest request\n  1129→    PaymentAttemptResponse response\n  1130→\n  1131→    // Entities\n  1132→    PaymentAttemptV2Entity paymentAttemptEntity\n  1133→    PaymentV2Entity paymentEntity\n  1134→    OrderEntity orderEntity\n  1135→    CustomerEntity customerEntity\n  1136→    ClientEntity clientEntity\n  1137→\n  1138→    // Enriched Data\n  1139→    InstrumentTypeProcessorResult instrumentProcessorResult\n  1140→    ProviderAccountEntity providerAccountEntity\n  1141→    ProviderRoutingDecisionResult routingDecisionResult\n  1142→    AuthType authType\n  1143→    RoutesBreakup routesBreakup\n  1144→    ProviderPaymentResponse createResponse\n  1145→\n  1146→    // OTP/Auth Flow\n  1147→    Boolean isPlatformNativeOtpSupported\n  1148→    PaymentAttemptNativeOTPDetailEntity nativeOTPDetailEntity\n  1149→\n  1150→    // Error Collection\n  1151→    List<WorkflowInternalError> errors\n  1152→}\n  1153→```\n  1154→\n  1155→### Step 2: Persist Intent\n  1156→```java\n  1157→@Transactional(transactionManager = \"MasterTransactionManager\")\n  1158→public void persistIntent(PaymentAttemptCreateContext context) {\n  1159→    // Create PaymentAttemptV2Entity\n  1160→    PaymentAttemptV2Entity entity = PaymentAttemptV2Entity.builder()\n  1161→        .externalId(PaymentAttemptUUIdGenerator.generate())\n  1162→        .status(PaymentAttemptStatus.CREATED)\n  1163→        .paymentEntity(paymentEntity)\n  1164→        .providerAccountEntity(providerAccountEntity)\n  1165→        .paymentMethod(instrumentResult.getPaymentMethod())\n  1166→        .instrumentDetail(instrumentResult.getEnrichedInstrument())\n  1167→        .routesBreakup(routesBreakup)\n  1168→        .build();\n  1169→\n  1170→    // Save to repository\n  1171→    paymentAttemptRepository.save(entity);\n  1172→\n  1173→    // Save fees\n  1174→    feeCreateWorkflow.persistIntent(feeContexts);\n  1175→\n  1176→    // Add attributes (DT_ID, DT_RESULT, etc.)\n  1177→    enrichAttributes(entity);\n  1178→}\n  1179→```\n  1180→\n  1181→### Step 5: Process (Provider Call)\n  1182→```java\n  1183→public void process(PaymentAttemptCreateContext context) {\n  1184→    // Find adapter\n  1185→    IPaymentProviderAdapter adapter = paymentProviderFactory\n  1186→        .findPaymentProviderAdapter(orderType, providerKey, instrumentType, threeDSType);\n  1187→\n  1188→    // Execute provider call\n  1189→    ProviderPaymentResponse response = adapter.executePaymentAttempt(\n  1190→        context,\n  1191→        adapter::createPaymentAttempt,\n  1192→        FlowType.CREATE\n  1193→    );\n  1194→\n  1195→    // Check platform OTP capability\n  1196→    response = checkIfPlatformOtpEnabled(context, response);\n  1197→\n  1198→    context.setCreateResponse(response);\n  1199→}\n  1200→```\n  1201→\n  1202→### Step 6: Post-Process\n  1203→```java\n  1204→@Transactional\n  1205→public PaymentAttemptResponse postProcess(PaymentAttemptCreateContext context) {\n  1206→    PaymentAttemptV2Entity entity = context.getPaymentAttemptEntity();\n  1207→    ProviderPaymentResponse response = context.getCreateResponse();\n  1208→\n  1209→    // Update from provider response\n  1210→    entity.setProviderStatus(response.getProviderStatus());\n  1211→    entity.setProviderReferenceId(response.getProviderReferenceId());\n  1212→    entity.setGatewayReferenceId(response.getGatewayReferenceId());\n  1213→\n  1214→    // Determine final status\n  1215→    if (response.getProviderRequestStatus() == REQUEST_SUCCESS) {\n  1216→        entity.setStatus(response.getStatus());\n  1217→    } else if (isEligiblePaymentMode) {\n  1218→        entity.setStatus(response.getStatus() == FAILED ? FAILED : PROCESSING);\n  1219→    }\n  1220→\n  1221→    paymentAttemptRepository.save(entity);\n  1222→    return mapper.toResponse(entity, response);\n  1223→}\n  1224→```\n  1225→\n  1226→### Step 7: Publish Events\n  1227→```java\n  1228→public void publishEntityChangeEvents(PaymentAttemptCreateContext context) {\n  1229→    // Post to sync EventBus (triggers PaymentStateMachine)\n  1230→    syncBus.post(PaymentAttemptEventFactory.findEvent(paymentAttemptEntity));\n  1231→\n  1232→    // Post to async EventBus\n  1233→    asyncBus.post(PaymentAttemptEventFactory.findEvent(paymentAttemptEntity));\n  1234→\n  1235→    // Publish to multi-tenant event system\n  1236→    eventiService.publishEvent(paymentAttemptEntity);\n  1237→\n  1238→    // Add to sync manager for webhook updates\n  1239→    syncManager.addEntityForSync(paymentAttemptEntity);\n  1240→}\n  1241→```\n  1242→\n  1243→---\n  1244→\n  1245→## 35. STATE MACHINE IMPLEMENTATION\n  1246→\n  1247→### PaymentStateMachine\n  1248→**File:** `statemachine/payment/PaymentStateMachine.java`\n  1249→\n  1250→```\n  1251→Event Subscriptions:\n  1252→├── @Subscribe onPaymentAttemptCreated\n  1253→│   └── Payment: FAILED → CREATED\n  1254→├── @Subscribe onPaymentAttemptFailed\n  1255→│   └── If all attempts failed: Payment → FAILED\n  1256→├── @Subscribe onPaymentAttemptCompleted\n  1257→│   └── Payment → COMPLETED (with optimistic lock retry)\n  1258→├── @Subscribe onPaymentAttemptAuthorized\n  1259→│   └── Payment → AUTHORIZED\n  1260→├── @Subscribe onPaymentAttemptProcessing\n  1261→│   └── Payment → PROCESSING\n  1262→├── @Subscribe onPaymentAttemptBlocked\n  1263→│   └── Payment → BLOCKED\n  1264→└── @Subscribe onAuthenticationSuccessful/Failed\n  1265→    └── Payment → AUTHENTICATION_SUCCESSFUL/FAILED\n  1266→```\n  1267→\n  1268→### OrderStateMachine\n  1269→**File:** `statemachine/order/OrderStateMachine.java`\n  1270→\n  1271→```\n  1272→Event Subscriptions:\n  1273→├── @Subscribe onPaymentCreated\n  1274→│   └── Order → CREATED or AUTHLESS_READY_TO_PROCESS\n  1275→├── @Subscribe onPaymentFailed\n  1276→│   └── Order → FAILED\n  1277→├── @Subscribe onPaymentCompleted\n  1278→│   └── Order → COMPLETED (if all payments done)\n  1279→├── @Subscribe onPaymentAuthorized\n  1280→│   └── Order → AUTHORIZED\n  1281→└── @Subscribe onPaymentProcessing\n  1282→    └── Order → PROCESSING\n  1283→```\n  1284→\n  1285→### Terminal States\n  1286→| Entity | Terminal States |\n  1287→|--------|-----------------|\n  1288→| PaymentAttempt | COMPLETED, FAILED, FORCE_FAILED |\n  1289→| Payment | COMPLETED, FAILED, FORCE_FAILED, DISCARDED |\n  1290→| Order | COMPLETED, FAILED |\n  1291→\n  1292→### State Transition Guard\n  1293→```java\n  1294→private boolean shouldUpdatePaymentStatus(PaymentV2Entity entity) {\n  1295→    return !Arrays.asList(COMPLETED, FAILED, FORCE_FAILED, DISCARDED)\n  1296→        .contains(entity.getStatus());\n  1297→}\n  1298→```\n  1299→\n  1300→---\n  1301→\n  1302→## 36. END-TO-END PAYMENT FLOW\n  1303→\n  1304→```\n  1305→┌─────────────────────────────────────────────────────────────────────────┐\n  1306→│                         CLIENT REQUEST                                   │\n  1307→└─────────────────────────────────────────────────────────────────────────┘\n  1308→                                    │\n  1309→                                    ▼\n  1310→┌─────────────────────────────────────────────────────────────────────────┐\n  1311→│  1. ORDER CREATION                                                       │\n  1312→│  ┌────────────────────────────────────────────────────────────────────┐ │\n  1313→│  │ OrderCreateWorkflow.execute()                                       │ │\n  1314→│  │ ├── validateAndEnrichContext() - Customer lookup, order validation │ │\n  1315→│  │ ├── persistIntent() - Save OrderEntity (status: CREATED)           │ │\n  1316→│  │ └── publishEvents() → OrderStateMachine                            │ │\n  1317→│  └────────────────────────────────────────────────────────────────────┘ │\n  1318→└─────────────────────────────────────────────────────────────────────────┘\n  1319→                                    │\n  1320→                                    ▼\n  1321→┌─────────────────────────────────────────────────────────────────────────┐\n  1322→│  2. PAYMENT CREATION                                                     │\n  1323→│  ┌────────────────────────────────────────────────────────────────────┐ │\n  1324→│  │ BulkPaymentCreateWorkflow.execute()                                 │ │\n  1325→│  │ ├── validateAndEnrichContext() - Payment mode validation           │ │\n  1326→│  │ ├── persistIntent() - Save PaymentV2Entity (status: CREATED)       │ │\n  1327→│  │ └── publishEvents() → PaymentStateMachine                          │ │\n  1328→│  └────────────────────────────────────────────────────────────────────┘ │\n  1329→└─────────────────────────────────────────────────────────────────────────┘\n  1330→                                    │\n  1331→                                    ▼\n  1332→┌─────────────────────────────────────────────────────────────────────────┐\n  1333→│  3. PAYMENT ATTEMPT CREATION (Core Flow)                                 │\n  1334→│  ┌────────────────────────────────────────────────────────────────────┐ │\n  1335→│  │ PaymentAttemptCreateWorkflow.execute()                              │ │\n  1336→│  │ ├── validateAndEnrichContext()                                     │ │\n  1337→│  │ │   ├── InstrumentTypeProcessorManager (Card/UPI/NetBanking)       │ │\n  1338→│  │ │   ├── ProviderDeciderRouter (Decision Tree routing)              │ │\n  1339→│  │ │   ├── AuthTypeDeciderFactory (3DS/OTP/None)                      │ │\n  1340→│  │ │   └── SettlementRouteValidator                                   │ │\n  1341→│  │ ├── persistIntent() - Save PaymentAttemptV2Entity                  │ │\n  1342→│  │ ├── persistNonRelationalIntent() - DynamoDB (OTP details)          │ │\n  1343→│  │ ├── process() - Provider API call via Adapter                      │ │\n  1344→│  │ ├── postProcess() - Update entity with provider response           │ │\n  1345→│  │ └── publishEvents() → PaymentStateMachine → OrderStateMachine      │ │\n  1346→│  └────────────────────────────────────────────────────────────────────┘ │\n  1347→└─────────────────────────────────────────────────────────────────────────┘\n  1348→                                    │\n  1349→                                    ▼\n  1350→┌─────────────────────────────────────────────────────────────────────────┐\n  1351→│  4. PROVIDER API RESPONSE                                                │\n  1352→│  ┌────────────────────────────────────────────────────────────────────┐ │\n  1353→│  │ ProviderPaymentResponse contains:                                   │ │\n  1354→│  │ ├── providerStatus: \"SUCCESS\" / \"PENDING\" / \"FAILED\"               │ │\n  1355→│  │ ├── providerReferenceId: Provider's transaction ID                 │ │\n  1356→│  │ ├── status: PaymentAttemptStatus (mapped)                          │ │\n  1357→│  │ ├── transactionResponse:                                           │ │\n  1358→│  │ │   ├── authentication: { url, method } (for 3DS redirect)         │ │\n  1359→│  │ │   └── sdkParams: Native OTP/SDK details                          │ │\n  1360→│  │ └── providerError: Error details if failed                         │ │\n  1361→│  └────────────────────────────────────────────────────────────────────┘ │\n  1362→└─────────────────────────────────────────────────────────────────────────┘\n  1363→                                    │\n  1364→         ┌──────────────────────────┴──────────────────────────┐\n  1365→         ▼                                                      ▼\n  1366→┌─────────────────────────┐                    ┌─────────────────────────┐\n  1367→│  5A. 3DS/OTP FLOW       │                    │  5B. DIRECT SUCCESS     │\n  1368→│  ┌───────────────────┐  │                    │  ┌───────────────────┐  │\n  1369→│  │ Client performs   │  │                    │  │ Status: COMPLETED │  │\n  1370→│  │ authentication    │  │                    │  │ Payment done!     │  │\n  1371→│  │ (redirect/native) │  │                    │  └───────────────────┘  │\n  1372→│  └───────────────────┘  │                    └─────────────────────────┘\n  1373→│           │             │\n  1374→│           ▼             │\n  1375→│  ┌───────────────────┐  │\n  1376→│  │ Authenticate      │  │\n  1377→│  │ Workflow called   │  │\n  1378→│  │ with OTP/callback │  │\n  1379→│  └───────────────────┘  │\n  1380→└─────────────────────────┘\n  1381→                                    │\n  1382→                                    ▼\n  1383→┌─────────────────────────────────────────────────────────────────────────┐\n  1384→│  6. WEBHOOK / SYNC UPDATE                                                │\n  1385→│  ┌────────────────────────────────────────────────────────────────────┐ │\n  1386→│  │ Provider sends webhook OR SyncManager polls status                  │ │\n  1387→│  │ ├── WebhookController receives update                              │ │\n  1388→│  │ ├── adapter.syncPaymentAttemptWithWebhook()                        │ │\n  1389→│  │ ├── Update PaymentAttemptV2Entity status                           │ │\n  1390→│  │ └── publishEvents() → State machines cascade updates               │ │\n  1391→│  └────────────────────────────────────────────────────────────────────┘ │\n  1392→└─────────────────────────────────────────────────────────────────────────┘\n  1393→                                    │\n  1394→                                    ▼\n  1395→┌─────────────────────────────────────────────────────────────────────────┐\n  1396→│  7. FINAL STATE                                                          │\n  1397→│  ┌────────────────────────────────────────────────────────────────────┐ │\n  1398→│  │ PaymentAttempt: COMPLETED ──► Payment: COMPLETED ──► Order: COMPLETED│\n  1399→│  │                                                                     │ │\n  1400→│  │ eventiService.publishEvent() → Client webhook notification          │ │\n  1401→│  │ eventiService.publishToPinot() → Analytics dashboard               │ │\n  1402→│  └────────────────────────────────────────────────────────────────────┘ │\n  1403→└─────────────────────────────────────────────────────────────────────────┘\n  1404→```\n  1405→\n  1406→---\n  1407→\n  1408→## 37. 3DS / NATIVE OTP AUTHENTICATION\n  1409→\n  1410→### Native OTP Flow (Card Payments)\n  1411→```\n  1412→1. PaymentAttemptCreateWorkflow detects CARD + OTP-capable BIN\n  1413→2. wspService.isPlatformNativeOtpEnabled() returns true\n  1414→3. Provider returns redirect URL, but we override with SDK params\n  1415→4. CardNativeOTPSDKParamDetail created:\n  1416→   ├── authType: NATIVE_OTP\n  1417→   ├── challengeId: UUID\n  1418→   ├── fallbackUrl: Provider's original auth URL\n  1419→   └── submitOTPAllowed: true\n  1420→\n  1421→5. PaymentAttemptNativeOTPDetailEntity saved to DynamoDB\n  1422→6. Client submits OTP via PaymentAttemptAuthenticateWorkflow\n  1423→7. Provider validates OTP, returns success/failure\n  1424→8. State machines update payment/order status\n  1425→```\n  1426→\n  1427→### 3DS Redirect Flow\n  1428→```\n  1429→1. Provider returns authentication URL\n  1430→2. Client redirects to issuer's 3DS page\n  1431→3. User completes authentication\n  1432→4. Callback to return_url\n  1433→5. ValidateAuthenticationWorkflow processes callback\n  1434→6. Provider confirms authentication status\n  1435→7. State machines update accordingly\n  1436→```\n  1437→\n  1438→---\n  1439→\n  1440→## 38. INSTRUMENT PROCESSING\n  1441→\n  1442→### InstrumentTypeProcessorManager\n  1443→**File:** `processors/instrumenttype/InstrumentTypeProcessorManager.java`\n  1444→\n  1445→```java\n  1446→// Routes to specific processor based on instrument type\n  1447→IInstrumentTypeProcessor processor = processorByType.get(instrument.getType());\n  1448→return processor.validatePaymentInstrumentAndEnrich(instrument);\n  1449→```\n  1450→\n  1451→### Processor Implementations\n  1452→| Processor | InstrumentType | Enrichment |\n  1453→|-----------|----------------|------------|\n  1454→| `CardInstrumentTypeProcessor` | CARD | BIN lookup, issuer, card type |\n  1455→| `UPIPayInstrumentTypeProcessor` | UPI_APPS | VPA validation, provider |\n  1456→| `UPICollectInstrumentTypeProcessor` | UPI_COLLECT | QR code, timeout |\n  1457→| `NetBankingInstrumentTypeProcessor` | NET_BANKING | Bank code, issuer |\n  1458→| `EMandateInstrumentTypeProcessor` | NET_BANKING_WITH_PI | Mandate details |\n  1459→\n  1460→### InstrumentTypeProcessorResult\n  1461→```java\n  1462→InstrumentTypeProcessorResult<R, S> {\n  1463→    PaymentInstrumentGroup paymentMethod;  // CARD, UPI_PAY, etc.\n  1464→    R paymentSubMethodDetail;              // CardPaymentSubMethodDetail\n  1465→    S enrichedPaymentInstrument;           // CardEnrichedPaymentInstrument\n  1466→}\n  1467→```\n  1468→\n  1469→---\n  1470→\n  1471→## 39. DISTRIBUTED LOCKING\n  1472→\n  1473→### SequentialWorkflow Pattern\n  1474→**File:** `v2/workflow/create/SequentialWorkflow.java`\n  1475→\n  1476→```java\n  1477→public Response execute(Request request) {\n  1478→    LockSetting lockSetting = fetchLockSetting();\n  1479→    String lockKey = evaluateLockKey(request, lockSetting.getLockKey());\n  1480→\n  1481→    // Acquire Redis distributed lock\n  1482→    Optional<RLock> lock = redisLockUtil.acquireLock(lockKey, flowType);\n  1483→\n  1484→    if (lock.isPresent() || !lockSetting.getIsLockMandatory()) {\n  1485→        try {\n  1486→            return super.execute(request);  // Run workflow\n  1487→        } finally {\n  1488→            lock.ifPresent(redisLockUtil::releaseLock);\n  1489→        }\n  1490→    }\n  1491→    throw Error.unable_to_acquire_lock.getBuilder().build();\n  1492→}\n  1493→```\n  1494→\n  1495→**Use Cases:**\n  1496→- Prevents concurrent payment attempts on same order\n  1497→- Ensures single webhook processing per transaction\n  1498→- Avoids race conditions in status updates\n  1499→\n  1500→---\n  1501→\n  1502→## 40. KEY PAYMENT FLOW FILES\n  1503→\n  1504→### Core Workflows\n  1505→1. `v2/workflow/create/Workflow.java` - Base template\n  1506→2. `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java` - Main flow\n  1507→3. `v2/workflow/create/payments/bulk/BulkPaymentCreateWorkflow.java` - Payment creation\n  1508→4. `v2/workflow/authenticate/PaymentAttemptAuthenticateWorkflow.java` - OTP auth\n  1509→\n  1510→### State Machines\n  1511→1. `statemachine/payment/PaymentStateMachine.java`\n  1512→2. `statemachine/order/OrderStateMachine.java`\n  1513→3. `statemachine/RefundStateMachine.java`\n  1514→\n  1515→### Instrument Processing\n  1516→1. `processors/instrumenttype/InstrumentTypeProcessorManager.java`\n  1517→2. `processors/instrumenttype/CardInstrumentTypeProcessor.java`\n  1518→3. `processors/instrumenttype/UPIPayInstrumentTypeProcessor.java`\n  1519→\n  1520→### Context & Events\n  1521→1. `v2/workflow/create/paymentattempts/PaymentAttemptCreateContext.java`\n  1522→2. `statemachine/payment/events/PaymentAttemptEventFactory.java`\n  1523→3. `statemachine/order/events/OrderEventFactory.java`\n  1524→\n  1525→---\n  1526→\n  1527→## 41. ARCHITECTURAL PATTERNS SUMMARY\n  1528→\n  1529→| Pattern | Implementation | Purpose |\n  1530→|---------|----------------|---------|\n  1531→| **Template Method** | `Workflow.execute()` 7-step pipeline | Consistent execution flow |\n  1532→| **Factory** | `PaymentProviderFactory`, `InstrumentTypeProcessorManager` | Dynamic component selection |\n  1533→| **Strategy** | `AuthTypeDeciderFactory`, `SdkTypeDeciderFactory` | Pluggable algorithms |\n  1534→| **Observer** | Guava EventBus, State Machines | Decoupled state transitions |\n  1535→| **Context Object** | `PaymentAttemptCreateContext` | Data flow through pipeline |\n  1536→| **Distributed Lock** | `SequentialWorkflow` + Redis | Concurrency control |\n  1537→| **Event Sourcing** | DynamoDB workflow context | Audit trail |\n  1538→\n  1539→---\n  1540→\n  1541→## 42. COMPLETE STUDY GUIDE SUMMARY\n  1542→\n  1543→You now have a **42-section expert study guide** covering:\n  1544→\n  1545→### Foundation (Sections 1-15)\n  1546→- Tech stack, project structure, core concepts\n  1547→- API endpoints, authentication, dependencies\n  1548→\n  1549→### Data Layer Deep-Dive (Sections 16-24)\n  1550→- Entity hierarchy, Master-Replica DB\n  1551→- Repository patterns, caching, DynamoDB\n  1552→\n  1553→### Provider Integration Deep-Dive (Sections 25-32)\n  1554→- Adapter architecture, Decision Tree routing\n  1555→- Webhook handling, provider configuration\n  1556→- Error handling and retry logic\n  1557→\n  1558→### Payment Flow Deep-Dive (Sections 33-41)\n  1559→- 7-step workflow pipeline\n  1560→- State machine implementation\n  1561→- End-to-end payment flow\n  1562→- 3DS/OTP authentication\n  1563→- Instrument processing\n  1564→- Distributed locking\n  1565→"}]},"uuid":"32a78b51-020d-4e4d-87a4-32ba681923d7","timestamp":"2025-12-31T09:54:30.376Z","toolUseResult":{"filePath":"/Users/kiranbiliyawala/.claude/plans/distributed-marinating-mango.md","oldString":"### Configuration\n1. `entity/ProviderAccountEntity.java` - Provider credentials\n2. `entity/PaymentProviderEntity.java` - Provider definition\n3. `entity/ClientPaymentProviderConfigEntity.java` - Client-provider mapping","newString":"### Configuration\n1. `entity/ProviderAccountEntity.java` - Provider credentials\n2. `entity/PaymentProviderEntity.java` - Provider definition\n3. `entity/ClientPaymentProviderConfigEntity.java` - Client-provider mapping\n\n---\n\n# PAYMENT FLOW DEEP-DIVE\n\n## 33. THE 7-STEP WORKFLOW PIPELINE\n\n### Base Workflow Pattern (Template Method)\n**File:** `v2/workflow/create/Workflow.java`\n\n```java\npublic Response execute(Request request) {\n    // STEP 1: Validate inputs and enrich context\n    Context context = validateAndEnrichContext(request);\n\n    // STEP 2: Persist to relational DB (transactional)\n    persistIntent(context);\n\n    // STEP 3: Pre-persist event hooks\n    publishEntityPrePersistEvents(context);\n\n    // STEP 4: Persist to non-relational DB (DynamoDB)\n    persistNonRelationalIntent(context);\n\n    // STEP 5: Process (external provider calls)\n    process(context);\n\n    // STEP 6: Post-process and save results (transactional)\n    Response response = postProcess(context);\n\n    // STEP 7: Post-persist & publish events\n    postPersistNonRelationalDataStore(context);\n    publishEntityChangeEvents(context);\n\n    throwErrorIfRequired(context);\n    return response;\n}\n```\n\n---\n\n## 34. PAYMENTATTEMPTCREATEWORKFLOW DETAILED\n\n**File:** `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java`\n\n### Step 1: Validate & Enrich Context\n\n| Enricher | Purpose | Output |\n|----------|---------|--------|\n| `InstrumentTypeProcessorManager` | Validate & enrich payment instrument | `InstrumentTypeProcessorResult` |\n| `ProviderDeciderRouter.resolve()` | Route to provider via Decision Tree | `ProviderRoutingDecisionResult` |\n| `AuthTypeDeciderFactory` | Determine auth type (3DS, OTP, None) | `AuthType` |\n| `NativeProviderDecider` | Select native OTP provider | `ProviderAccountEntity` |\n| `SettlementRouteValidator` | Validate & enrich settlement routes | `RoutesBreakup` |\n| `MandateServiceDataManager` | Register mandate (if eMandate) | `Mandate` |\n\n### Context Object Structure\n```java\nPaymentAttemptCreateContext {\n    // Request/Response\n    CreatePaymentAttemptRequest request\n    PaymentAttemptResponse response\n\n    // Entities\n    PaymentAttemptV2Entity paymentAttemptEntity\n    PaymentV2Entity paymentEntity\n    OrderEntity orderEntity\n    CustomerEntity customerEntity\n    ClientEntity clientEntity\n\n    // Enriched Data\n    InstrumentTypeProcessorResult instrumentProcessorResult\n    ProviderAccountEntity providerAccountEntity\n    ProviderRoutingDecisionResult routingDecisionResult\n    AuthType authType\n    RoutesBreakup routesBreakup\n    ProviderPaymentResponse createResponse\n\n    // OTP/Auth Flow\n    Boolean isPlatformNativeOtpSupported\n    PaymentAttemptNativeOTPDetailEntity nativeOTPDetailEntity\n\n    // Error Collection\n    List<WorkflowInternalError> errors\n}\n```\n\n### Step 2: Persist Intent\n```java\n@Transactional(transactionManager = \"MasterTransactionManager\")\npublic void persistIntent(PaymentAttemptCreateContext context) {\n    // Create PaymentAttemptV2Entity\n    PaymentAttemptV2Entity entity = PaymentAttemptV2Entity.builder()\n        .externalId(PaymentAttemptUUIdGenerator.generate())\n        .status(PaymentAttemptStatus.CREATED)\n        .paymentEntity(paymentEntity)\n        .providerAccountEntity(providerAccountEntity)\n        .paymentMethod(instrumentResult.getPaymentMethod())\n        .instrumentDetail(instrumentResult.getEnrichedInstrument())\n        .routesBreakup(routesBreakup)\n        .build();\n\n    // Save to repository\n    paymentAttemptRepository.save(entity);\n\n    // Save fees\n    feeCreateWorkflow.persistIntent(feeContexts);\n\n    // Add attributes (DT_ID, DT_RESULT, etc.)\n    enrichAttributes(entity);\n}\n```\n\n### Step 5: Process (Provider Call)\n```java\npublic void process(PaymentAttemptCreateContext context) {\n    // Find adapter\n    IPaymentProviderAdapter adapter = paymentProviderFactory\n        .findPaymentProviderAdapter(orderType, providerKey, instrumentType, threeDSType);\n\n    // Execute provider call\n    ProviderPaymentResponse response = adapter.executePaymentAttempt(\n        context,\n        adapter::createPaymentAttempt,\n        FlowType.CREATE\n    );\n\n    // Check platform OTP capability\n    response = checkIfPlatformOtpEnabled(context, response);\n\n    context.setCreateResponse(response);\n}\n```\n\n### Step 6: Post-Process\n```java\n@Transactional\npublic PaymentAttemptResponse postProcess(PaymentAttemptCreateContext context) {\n    PaymentAttemptV2Entity entity = context.getPaymentAttemptEntity();\n    ProviderPaymentResponse response = context.getCreateResponse();\n\n    // Update from provider response\n    entity.setProviderStatus(response.getProviderStatus());\n    entity.setProviderReferenceId(response.getProviderReferenceId());\n    entity.setGatewayReferenceId(response.getGatewayReferenceId());\n\n    // Determine final status\n    if (response.getProviderRequestStatus() == REQUEST_SUCCESS) {\n        entity.setStatus(response.getStatus());\n    } else if (isEligiblePaymentMode) {\n        entity.setStatus(response.getStatus() == FAILED ? FAILED : PROCESSING);\n    }\n\n    paymentAttemptRepository.save(entity);\n    return mapper.toResponse(entity, response);\n}\n```\n\n### Step 7: Publish Events\n```java\npublic void publishEntityChangeEvents(PaymentAttemptCreateContext context) {\n    // Post to sync EventBus (triggers PaymentStateMachine)\n    syncBus.post(PaymentAttemptEventFactory.findEvent(paymentAttemptEntity));\n\n    // Post to async EventBus\n    asyncBus.post(PaymentAttemptEventFactory.findEvent(paymentAttemptEntity));\n\n    // Publish to multi-tenant event system\n    eventiService.publishEvent(paymentAttemptEntity);\n\n    // Add to sync manager for webhook updates\n    syncManager.addEntityForSync(paymentAttemptEntity);\n}\n```\n\n---\n\n## 35. STATE MACHINE IMPLEMENTATION\n\n### PaymentStateMachine\n**File:** `statemachine/payment/PaymentStateMachine.java`\n\n```\nEvent Subscriptions:\n├── @Subscribe onPaymentAttemptCreated\n│   └── Payment: FAILED → CREATED\n├── @Subscribe onPaymentAttemptFailed\n│   └── If all attempts failed: Payment → FAILED\n├── @Subscribe onPaymentAttemptCompleted\n│   └── Payment → COMPLETED (with optimistic lock retry)\n├── @Subscribe onPaymentAttemptAuthorized\n│   └── Payment → AUTHORIZED\n├── @Subscribe onPaymentAttemptProcessing\n│   └── Payment → PROCESSING\n├── @Subscribe onPaymentAttemptBlocked\n│   └── Payment → BLOCKED\n└── @Subscribe onAuthenticationSuccessful/Failed\n    └── Payment → AUTHENTICATION_SUCCESSFUL/FAILED\n```\n\n### OrderStateMachine\n**File:** `statemachine/order/OrderStateMachine.java`\n\n```\nEvent Subscriptions:\n├── @Subscribe onPaymentCreated\n│   └── Order → CREATED or AUTHLESS_READY_TO_PROCESS\n├── @Subscribe onPaymentFailed\n│   └── Order → FAILED\n├── @Subscribe onPaymentCompleted\n│   └── Order → COMPLETED (if all payments done)\n├── @Subscribe onPaymentAuthorized\n│   └── Order → AUTHORIZED\n└── @Subscribe onPaymentProcessing\n    └── Order → PROCESSING\n```\n\n### Terminal States\n| Entity | Terminal States |\n|--------|-----------------|\n| PaymentAttempt | COMPLETED, FAILED, FORCE_FAILED |\n| Payment | COMPLETED, FAILED, FORCE_FAILED, DISCARDED |\n| Order | COMPLETED, FAILED |\n\n### State Transition Guard\n```java\nprivate boolean shouldUpdatePaymentStatus(PaymentV2Entity entity) {\n    return !Arrays.asList(COMPLETED, FAILED, FORCE_FAILED, DISCARDED)\n        .contains(entity.getStatus());\n}\n```\n\n---\n\n## 36. END-TO-END PAYMENT FLOW\n\n```\n┌─────────────────────────────────────────────────────────────────────────┐\n│                         CLIENT REQUEST                                   │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  1. ORDER CREATION                                                       │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ OrderCreateWorkflow.execute()                                       │ │\n│  │ ├── validateAndEnrichContext() - Customer lookup, order validation │ │\n│  │ ├── persistIntent() - Save OrderEntity (status: CREATED)           │ │\n│  │ └── publishEvents() → OrderStateMachine                            │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  2. PAYMENT CREATION                                                     │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ BulkPaymentCreateWorkflow.execute()                                 │ │\n│  │ ├── validateAndEnrichContext() - Payment mode validation           │ │\n│  │ ├── persistIntent() - Save PaymentV2Entity (status: CREATED)       │ │\n│  │ └── publishEvents() → PaymentStateMachine                          │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  3. PAYMENT ATTEMPT CREATION (Core Flow)                                 │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ PaymentAttemptCreateWorkflow.execute()                              │ │\n│  │ ├── validateAndEnrichContext()                                     │ │\n│  │ │   ├── InstrumentTypeProcessorManager (Card/UPI/NetBanking)       │ │\n│  │ │   ├── ProviderDeciderRouter (Decision Tree routing)              │ │\n│  │ │   ├── AuthTypeDeciderFactory (3DS/OTP/None)                      │ │\n│  │ │   └── SettlementRouteValidator                                   │ │\n│  │ ├── persistIntent() - Save PaymentAttemptV2Entity                  │ │\n│  │ ├── persistNonRelationalIntent() - DynamoDB (OTP details)          │ │\n│  │ ├── process() - Provider API call via Adapter                      │ │\n│  │ ├── postProcess() - Update entity with provider response           │ │\n│  │ └── publishEvents() → PaymentStateMachine → OrderStateMachine      │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  4. PROVIDER API RESPONSE                                                │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ ProviderPaymentResponse contains:                                   │ │\n│  │ ├── providerStatus: \"SUCCESS\" / \"PENDING\" / \"FAILED\"               │ │\n│  │ ├── providerReferenceId: Provider's transaction ID                 │ │\n│  │ ├── status: PaymentAttemptStatus (mapped)                          │ │\n│  │ ├── transactionResponse:                                           │ │\n│  │ │   ├── authentication: { url, method } (for 3DS redirect)         │ │\n│  │ │   └── sdkParams: Native OTP/SDK details                          │ │\n│  │ └── providerError: Error details if failed                         │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n         ┌──────────────────────────┴──────────────────────────┐\n         ▼                                                      ▼\n┌─────────────────────────┐                    ┌─────────────────────────┐\n│  5A. 3DS/OTP FLOW       │                    │  5B. DIRECT SUCCESS     │\n│  ┌───────────────────┐  │                    │  ┌───────────────────┐  │\n│  │ Client performs   │  │                    │  │ Status: COMPLETED │  │\n│  │ authentication    │  │                    │  │ Payment done!     │  │\n│  │ (redirect/native) │  │                    │  └───────────────────┘  │\n│  └───────────────────┘  │                    └─────────────────────────┘\n│           │             │\n│           ▼             │\n│  ┌───────────────────┐  │\n│  │ Authenticate      │  │\n│  │ Workflow called   │  │\n│  │ with OTP/callback │  │\n│  └───────────────────┘  │\n└─────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  6. WEBHOOK / SYNC UPDATE                                                │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ Provider sends webhook OR SyncManager polls status                  │ │\n│  │ ├── WebhookController receives update                              │ │\n│  │ ├── adapter.syncPaymentAttemptWithWebhook()                        │ │\n│  │ ├── Update PaymentAttemptV2Entity status                           │ │\n│  │ └── publishEvents() → State machines cascade updates               │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  7. FINAL STATE                                                          │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ PaymentAttempt: COMPLETED ──► Payment: COMPLETED ──► Order: COMPLETED│\n│  │                                                                     │ │\n│  │ eventiService.publishEvent() → Client webhook notification          │ │\n│  │ eventiService.publishToPinot() → Analytics dashboard               │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## 37. 3DS / NATIVE OTP AUTHENTICATION\n\n### Native OTP Flow (Card Payments)\n```\n1. PaymentAttemptCreateWorkflow detects CARD + OTP-capable BIN\n2. wspService.isPlatformNativeOtpEnabled() returns true\n3. Provider returns redirect URL, but we override with SDK params\n4. CardNativeOTPSDKParamDetail created:\n   ├── authType: NATIVE_OTP\n   ├── challengeId: UUID\n   ├── fallbackUrl: Provider's original auth URL\n   └── submitOTPAllowed: true\n\n5. PaymentAttemptNativeOTPDetailEntity saved to DynamoDB\n6. Client submits OTP via PaymentAttemptAuthenticateWorkflow\n7. Provider validates OTP, returns success/failure\n8. State machines update payment/order status\n```\n\n### 3DS Redirect Flow\n```\n1. Provider returns authentication URL\n2. Client redirects to issuer's 3DS page\n3. User completes authentication\n4. Callback to return_url\n5. ValidateAuthenticationWorkflow processes callback\n6. Provider confirms authentication status\n7. State machines update accordingly\n```\n\n---\n\n## 38. INSTRUMENT PROCESSING\n\n### InstrumentTypeProcessorManager\n**File:** `processors/instrumenttype/InstrumentTypeProcessorManager.java`\n\n```java\n// Routes to specific processor based on instrument type\nIInstrumentTypeProcessor processor = processorByType.get(instrument.getType());\nreturn processor.validatePaymentInstrumentAndEnrich(instrument);\n```\n\n### Processor Implementations\n| Processor | InstrumentType | Enrichment |\n|-----------|----------------|------------|\n| `CardInstrumentTypeProcessor` | CARD | BIN lookup, issuer, card type |\n| `UPIPayInstrumentTypeProcessor` | UPI_APPS | VPA validation, provider |\n| `UPICollectInstrumentTypeProcessor` | UPI_COLLECT | QR code, timeout |\n| `NetBankingInstrumentTypeProcessor` | NET_BANKING | Bank code, issuer |\n| `EMandateInstrumentTypeProcessor` | NET_BANKING_WITH_PI | Mandate details |\n\n### InstrumentTypeProcessorResult\n```java\nInstrumentTypeProcessorResult<R, S> {\n    PaymentInstrumentGroup paymentMethod;  // CARD, UPI_PAY, etc.\n    R paymentSubMethodDetail;              // CardPaymentSubMethodDetail\n    S enrichedPaymentInstrument;           // CardEnrichedPaymentInstrument\n}\n```\n\n---\n\n## 39. DISTRIBUTED LOCKING\n\n### SequentialWorkflow Pattern\n**File:** `v2/workflow/create/SequentialWorkflow.java`\n\n```java\npublic Response execute(Request request) {\n    LockSetting lockSetting = fetchLockSetting();\n    String lockKey = evaluateLockKey(request, lockSetting.getLockKey());\n\n    // Acquire Redis distributed lock\n    Optional<RLock> lock = redisLockUtil.acquireLock(lockKey, flowType);\n\n    if (lock.isPresent() || !lockSetting.getIsLockMandatory()) {\n        try {\n            return super.execute(request);  // Run workflow\n        } finally {\n            lock.ifPresent(redisLockUtil::releaseLock);\n        }\n    }\n    throw Error.unable_to_acquire_lock.getBuilder().build();\n}\n```\n\n**Use Cases:**\n- Prevents concurrent payment attempts on same order\n- Ensures single webhook processing per transaction\n- Avoids race conditions in status updates\n\n---\n\n## 40. KEY PAYMENT FLOW FILES\n\n### Core Workflows\n1. `v2/workflow/create/Workflow.java` - Base template\n2. `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java` - Main flow\n3. `v2/workflow/create/payments/bulk/BulkPaymentCreateWorkflow.java` - Payment creation\n4. `v2/workflow/authenticate/PaymentAttemptAuthenticateWorkflow.java` - OTP auth\n\n### State Machines\n1. `statemachine/payment/PaymentStateMachine.java`\n2. `statemachine/order/OrderStateMachine.java`\n3. `statemachine/RefundStateMachine.java`\n\n### Instrument Processing\n1. `processors/instrumenttype/InstrumentTypeProcessorManager.java`\n2. `processors/instrumenttype/CardInstrumentTypeProcessor.java`\n3. `processors/instrumenttype/UPIPayInstrumentTypeProcessor.java`\n\n### Context & Events\n1. `v2/workflow/create/paymentattempts/PaymentAttemptCreateContext.java`\n2. `statemachine/payment/events/PaymentAttemptEventFactory.java`\n3. `statemachine/order/events/OrderEventFactory.java`\n\n---\n\n## 41. ARCHITECTURAL PATTERNS SUMMARY\n\n| Pattern | Implementation | Purpose |\n|---------|----------------|---------|\n| **Template Method** | `Workflow.execute()` 7-step pipeline | Consistent execution flow |\n| **Factory** | `PaymentProviderFactory`, `InstrumentTypeProcessorManager` | Dynamic component selection |\n| **Strategy** | `AuthTypeDeciderFactory`, `SdkTypeDeciderFactory` | Pluggable algorithms |\n| **Observer** | Guava EventBus, State Machines | Decoupled state transitions |\n| **Context Object** | `PaymentAttemptCreateContext` | Data flow through pipeline |\n| **Distributed Lock** | `SequentialWorkflow` + Redis | Concurrency control |\n| **Event Sourcing** | DynamoDB workflow context | Audit trail |\n\n---\n\n## 42. COMPLETE STUDY GUIDE SUMMARY\n\nYou now have a **42-section expert study guide** covering:\n\n### Foundation (Sections 1-15)\n- Tech stack, project structure, core concepts\n- API endpoints, authentication, dependencies\n\n### Data Layer Deep-Dive (Sections 16-24)\n- Entity hierarchy, Master-Replica DB\n- Repository patterns, caching, DynamoDB\n\n### Provider Integration Deep-Dive (Sections 25-32)\n- Adapter architecture, Decision Tree routing\n- Webhook handling, provider configuration\n- Error handling and retry logic\n\n### Payment Flow Deep-Dive (Sections 33-41)\n- 7-step workflow pipeline\n- State machine implementation\n- End-to-end payment flow\n- 3DS/OTP authentication\n- Instrument processing\n- Distributed locking","originalFile":"# Payment Service (Darwin) - Expert Study Guide\n\nA comprehensive guide to understanding the payment-service repository.\n\n---\n\n## 1. OVERVIEW & TECH STACK\n\n**Project Name:** Darwin (internal name for payment-service)\n**Purpose:** Enterprise-grade payment processing microservice handling multi-provider payment orchestration\n\n| Technology | Version | Purpose |\n|------------|---------|---------|\n| Java | 17 | Runtime |\n| Spring Boot | 2.7.14 | Framework |\n| Gradle | 7.6 | Build |\n| MySQL | - | Primary Database (Master-Replica) |\n| DynamoDB | - | Audit/State Storage |\n| Redis (Redisson) | 3.19.1 | Distributed Cache |\n| Kafka | - | Event Streaming |\n| AWS SQS | - | Task Processing |\n\n**Server:** Port 9010, Context Path: `/payments`\n\n---\n\n## 2. PROJECT STRUCTURE\n\n```\npayment-service/\n├── src/main/java/in/dreamplug/darwin/\n│   ├── controller/         # REST API endpoints\n│   │   └── v2/             # V2 API controllers (primary)\n│   ├── service/            # Business logic services\n│   ├── v2/\n│   │   ├── service/        # V2 services\n│   │   └── workflow/       # Payment workflows (CRITICAL)\n│   │       └── create/\n│   │           ├── payments/       # Payment creation\n│   │           ├── paymentattempts/ # Payment attempt creation\n│   │           └── providers/      # Provider adapters (24+)\n│   ├── entity/             # JPA entities\n│   │   └── v2/             # V2 entities (primary)\n│   ├── repository/         # Data access layer\n│   ├── statemachine/       # Payment/Order state machines\n│   ├── planner/            # Decision tree routing\n│   ├── cache/              # Caching layer (Caffeine)\n│   ├── client/             # External service clients\n│   ├── provider/           # Legacy provider implementations\n│   ├── configuration/      # Spring configs\n│   │   └── database/       # DB configs (Master/Replica)\n│   ├── kafka/              # Kafka producers/consumers\n│   ├── sqs/                # SQS message processors\n│   ├── dynamo/             # DynamoDB DAOs\n│   ├── error/              # Error handling\n│   ├── dto/                # Data transfer objects\n│   └── commons/spring/filters/  # Auth/Context filters\n├── src/main/resources/\n│   └── application.properties  # Main config (1300+ lines)\n├── codepipeline/           # CI/CD configurations\n├── build.gradle            # Dependencies\n└── Dockerfile              # Container setup\n```\n\n---\n\n## 3. CORE PAYMENT FLOW (CRITICAL)\n\n### 3.1 Payment Lifecycle\n\n```\nOrder Created → Payments Created → Payment Attempt Created → Provider API Call → Webhook/Status Update\n```\n\n**Key Steps:**\n\n1. **Order Creation** - Client creates an order with amount, currency, metadata\n2. **Bulk Payment Creation** - Multiple payment records created for the order\n   - File: `v2/workflow/create/payments/bulk/BulkPaymentCreateWorkflow.java`\n3. **Payment Attempt Creation** - Actual payment attempt with provider routing\n   - File: `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java`\n4. **Provider Processing** - Provider adapter calls external payment gateway\n5. **State Machine Updates** - Events trigger state transitions\n\n### 3.2 Workflow Execution Pipeline\n\n```java\n// Base workflow pattern (Workflow.java)\n1. validateAndEnrichContext()  // Validate inputs, enrich data\n2. persistIntent()             // Save entities to MySQL\n3. persistNonRelationalIntent() // Save to DynamoDB\n4. process()                   // Call provider API\n5. postProcess()               // Transform results\n6. publishEntityChangeEvents() // Trigger state machines\n7. throwErrorIfRequired()      // Handle errors\n```\n\n### 3.3 Payment Attempt Data Enrichment\n\n1. **Instrument Validation** - `InstrumentTypeProcessorManager`\n2. **Provider Routing** - `ProviderDeciderRouter` → Decision Tree\n3. **Auth Type Decision** - `AuthTypeDeciderFactory` (3DS, OTP, None)\n4. **Settlement Validation** - `SettlementRouteValidator`\n\n---\n\n## 4. STATE MACHINES\n\n### 4.1 Payment State Machine\n**File:** `statemachine/payment/PaymentStateMachine.java`\n\n```\nCREATED → PROCESSING → AUTHORIZED → COMPLETED\n                   ↘ FAILED\n                   ↘ BLOCKED\n```\n\n**Terminal States:** COMPLETED, FAILED, FORCE_FAILED, DISCARDED\n\n### 4.2 Order State Machine\n**File:** `statemachine/order/OrderStateMachine.java`\n\n- Reacts to payment events\n- Updates order status based on payment outcomes\n\n### 4.3 Events (EventBus - Guava)\n- `PaymentAttemptCreatedEvent`\n- `PaymentAttemptCompletedEvent`\n- `PaymentAttemptFailedEvent`\n- `PaymentAttemptProcessingEvent`\n- `PaymentAttemptAuthorizedEvent`\n\n---\n\n## 5. PROVIDER INTEGRATIONS (24+ Providers)\n\n**Location:** `v2/workflow/create/providers/`\n\n| Provider | Adapter File | Payment Types |\n|----------|-------------|---------------|\n| Cybersource | `CybersourceProviderAdapter.java` | Cards, 3DS, E-Mandates |\n| Cashfree | `CashfreeProviderAdapter.java` + variants | Cards, UPI, NetBanking |\n| PayU | `PayuProviderAdapter.java` + variants | Cards, NetBanking |\n| Pine Labs | `PineLabsEdgeProviderAdapter.java` | Multiple modes |\n| Razorpay | Via webhooks | All payment types |\n| Juspay | Via webhooks | Orchestration |\n| ICICI UPI | `icici-upi-client` | UPI |\n| Axis UPI | `axis-upi-client` | UPI |\n| YBL UPI | `ybl-upi-client` | UPI |\n| RBL UPI | `rbl-upi-client` | UPI |\n| Digio | `DigioMandateRegisterProviderAdapter.java` | E-Mandates |\n| Cred Points | `CredPointsProviderAdapter.java` | Reward redemption |\n\n### Provider Selection Flow\n\n```\nRequest → ProviderDeciderRouter → LCM (if enabled) → Decision Tree → Provider Adapter\n```\n\n**Decision Tree:** JSON-based rules cached in `DecisionTreeObjectCache`\n\n---\n\n## 6. KEY ENTITIES (V2 Schema)\n\n### Core Entities\n| Entity | File | Purpose |\n|--------|------|---------|\n| OrderEntity | `entity/OrderEntity.java` | Order records |\n| PaymentV2Entity | `entity/v2/PaymentV2Entity.java` | Payment records |\n| PaymentAttemptV2Entity | `entity/v2/PaymentAttemptV2Entity.java` | Payment attempts |\n| RefundEntity | `entity/v2/RefundEntity.java` | Refunds |\n| FeeEntity | `entity/v2/FeeEntity.java` | Fee tracking |\n\n### Configuration Entities\n| Entity | Purpose |\n|--------|---------|\n| ClientEntity | Application clients |\n| ProviderAccountEntity | Provider accounts |\n| PaymentProviderEntity | Provider configs |\n| MasterConfigurationEntity | System configs |\n\n---\n\n## 7. DATABASE ARCHITECTURE\n\n### Master-Replica Pattern\n\n**Master:** Write operations\n**Replica:** Read operations (via `@ReplicaRepository`)\n\n**Configuration Files:**\n- `configuration/database/MasterDataSourceConfiguration.java`\n- `configuration/database/ReplicaDataSourceConfiguration.java`\n\n**Database:** `payments_multi_tenancy`\n**Connection Pool:** HikariCP\n**ORM:** JPA + Hibernate\n\n---\n\n## 8. CACHING LAYER\n\n### Caffeine (In-Memory)\n| Cache | Purpose |\n|-------|---------|\n| `ClientConfigurationCache` | Client settings |\n| `PaymentProviderCache` | Provider configs |\n| `ProviderAccountCache` | Provider accounts |\n| `DecisionTreeObjectCache` | Routing rules |\n| `CardBinCache` | Card BIN data |\n| `MerchantCache` | Merchant data |\n| `FeeCache` | Fee calculations |\n\n### Redis (Distributed)\n- **Client:** Redisson with Kryo5Codec\n- **Use:** Distributed locks, rate limiting, shared state\n\n---\n\n## 9. ASYNC PROCESSING\n\n### Kafka Topics\n- `payment-attempt-platform-metrics-pinot-out-new-1` (Analytics)\n- Events: `PaymentAttemptAnalyticsEvent`, `CardPaymentAttemptAnalyticsEvent`, etc.\n\n### SQS Queues\n| Queue | Purpose |\n|-------|---------|\n| `FORCE_PAYMENT_FAILURE_QUEUE` | Manual failure forcing |\n| `MANDATE_EXPIRY_CRON_QUEUE` | Mandate expiry |\n| `REFUND_RESCHEDULE_QUEUE` | Refund scheduling |\n| `ORDER_EXPIRY_QUEUE` | Order expiration |\n| `PENDENCY_AUTOMATION_QUEUE` | Pending transactions |\n\n### Eventi (Internal Events)\n- Internal event framework for system events\n- Async worker threads (4-16 configurable)\n\n---\n\n## 10. API ENDPOINTS\n\n### Primary Controllers (v2)\n| Endpoint | Controller | Purpose |\n|----------|------------|---------|\n| `/v2/orders/{orderId}/payments` | `PaymentV2Controller` | Bulk payment creation |\n| `/v2/payments/{paymentId}/attempts` | `PaymentAttemptV2Controller` | Payment attempts |\n| `/v1/webhooks` | `WebhookController` | Provider webhooks |\n\n### Webhook Controllers\n- `RazorpayWebhookController`\n- `JuspayWebhookController`\n- `ICICIWebhookController`\n- `YBLWebhookController`\n- `RBLUpiWebhookController`\n- `DigioWebhookController`\n\n---\n\n## 11. AUTHENTICATION & SECURITY\n\n### Request Filters (Order of Execution)\n1. `ApplicationContextBuilderFilter` - Build context from headers\n2. `PAMerchantAuthenticationFilter` - Partner merchant auth\n3. `PAPartnerAuthorizationFilter` - Partner authorization\n\n### Headers Required\n- Client ID (`${CLIENT_HEADER_KEY}`)\n- Merchant ID (`${MERCHANT_HEADER_KEY}`)\n- Device info (DEVICE_ID, OS, OS_VERSION, APP_VERSION)\n\n### Rate Limiting\n- Redisson-based distributed rate limiting\n- Config in `ClientRateLimiter.java`\n\n---\n\n## 12. KEY FILES TO STUDY\n\n### Must-Read Files (Priority Order)\n\n1. **Entry Point:**\n   - `DarwinApplication.java`\n\n2. **Core Workflows:**\n   - `v2/workflow/create/Workflow.java` (base pattern)\n   - `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java`\n   - `v2/workflow/create/payments/bulk/BulkPaymentCreateWorkflow.java`\n\n3. **State Machines:**\n   - `statemachine/payment/PaymentStateMachine.java`\n   - `statemachine/order/OrderStateMachine.java`\n\n4. **Provider Routing:**\n   - `planner/ProviderDeciderRouter.java`\n   - `planner/decisiontree/DecisionTreeWorkflow.java`\n\n5. **Provider Adapters:**\n   - `v2/workflow/create/providers/` (pick any adapter)\n\n6. **Entities:**\n   - `entity/OrderEntity.java`\n   - `entity/v2/PaymentV2Entity.java`\n   - `entity/v2/PaymentAttemptV2Entity.java`\n\n7. **Configuration:**\n   - `application.properties` (1300+ lines - scan for context)\n\n8. **Webhooks:**\n   - `controller/WebhookController.java`\n\n---\n\n## 13. INTERNAL SERVICE DEPENDENCIES\n\n| Service | Client Library | Purpose |\n|---------|---------------|---------|\n| User Service | `user-service-client:4.0.1` | User data |\n| Merchant Service | `merchant-service-client:1.0.3` | Merchant info |\n| Mandate Service | `mandate-java-client:1.0.4` | Recurring payments |\n| Arsenal | - | Instrument vault |\n| Falcon | - | Offers/promotions |\n| Genie | `genie-java-client` | Configuration |\n| Syndicate | - | Authentication |\n| LCM | - | Terminal resolution |\n| Fee Service | `fees:0.18.0` | Fee calculation |\n\n---\n\n## 14. STUDY PATH RECOMMENDATION\n\n### Week 1: Foundation\n- [ ] Understand project structure\n- [ ] Read `DarwinApplication.java`\n- [ ] Study `application.properties` (key sections)\n- [ ] Understand entity relationships\n\n### Week 2: Core Flow\n- [ ] Master `PaymentAttemptCreateWorkflow.java`\n- [ ] Study state machines\n- [ ] Understand provider routing\n\n### Week 3: Integrations\n- [ ] Study 2-3 provider adapters\n- [ ] Understand webhook handling\n- [ ] Learn caching patterns\n\n### Week 4: Advanced\n- [ ] Decision tree engine\n- [ ] Async processing (Kafka, SQS)\n- [ ] Error handling patterns\n\n---\n\n## 15. KEY CONCEPTS\n\n1. **Multi-Provider Orchestration** - Route to optimal provider based on rules\n2. **Decision Trees** - JSON-based routing logic\n3. **State Machines** - Event-driven entity lifecycle\n4. **Master-Replica DB** - Read/write separation\n5. **Workflow Pattern** - 7-step execution pipeline\n6. **Event-Driven Architecture** - Guava EventBus + Kafka\n\n---\n\n# DATA LAYER DEEP-DIVE\n\n## 16. ENTITY HIERARCHY & INHERITANCE\n\n### Base Classes\n```\nBaseEntity (id, created_at, updated_at, created_by, updated_by)\n    └── BaseExternalEntity (+ external_id UUID, version for optimistic locking)\n            ├── OrderEntity\n            ├── PaymentV2Entity\n            ├── PaymentAttemptV2Entity\n            ├── RefundEntity\n            ├── ClientEntity\n            └── CustomerEntity\n```\n\n### Key Entity Files\n| Entity | File | Key Fields |\n|--------|------|------------|\n| OrderEntity | `entity/OrderEntity.java` | clientReferenceId, amount, status, metadata (JSON) |\n| PaymentV2Entity | `entity/v2/PaymentV2Entity.java` | orderId, amount, paymentMode, instrumentDetail (JSON) |\n| PaymentAttemptV2Entity | `entity/v2/PaymentAttemptV2Entity.java` | paymentId, providerReferenceId, gatewayReferenceId, status |\n| RefundEntity | `entity/v2/RefundEntity.java` | orderId, paymentAttemptId, refundType, refundStatus |\n| ClientEntity | `entity/ClientEntity.java` | name, merchantId, settings (OneToMany) |\n\n### Entity Relationships\n```\nClientEntity (1) ──> (M) OrderEntity\nOrderEntity (1) ──> (M) PaymentV2Entity\nPaymentV2Entity (1) ──> (M) PaymentAttemptV2Entity\nPaymentAttemptV2Entity ──> PaymentProviderEntity\nPaymentAttemptV2Entity ──> ProviderAccountEntity\nOrderEntity (1) ──> (M) RefundEntity\nRefundEntity (1) ──> (M) RefundAttemptEntity\n```\n\n---\n\n## 17. MASTER-REPLICA DATABASE ARCHITECTURE\n\n### How Routing Works\n\n**Master (Writes):** `MasterDataSourceConfiguration.java`\n- EntityManagerFactory: `MasterEntityManagerFactory`\n- TransactionManager: `MasterTransactionManager`\n- Excludes beans with `@ReplicaRepository`\n\n**Replica (Reads):** `ReplicaDataSourceConfiguration.java`\n- EntityManagerFactory: `ReplicaEntityManagerFactory`\n- TransactionManager: `ReplicaTransactionManager`\n- Includes ONLY beans with `@ReplicaRepository`\n- Connection pool set to `readOnly=true`\n\n### Usage Pattern\n```java\n// Write to master (default)\n@Repository\npublic interface PaymentRepository extends JpaRepository<...> {}\n\n// Read from replica\n@Repository\n@ReplicaRepository  // <-- Annotation routes to replica\npublic class RefundEntityReplicaDAOImpl extends AbstractReplicaDAOImpl<...> {}\n```\n\n### HikariCP Connection Pools\n| Pool | Config | Purpose |\n|------|--------|---------|\n| hikari_master | masterMinimumIdle, masterMaximumPoolSize | Write operations |\n| hikari_replica | replicaMinimumIdle, replicaMaximumPoolSize, readOnly=true | Read operations |\n\nBoth pools have:\n- idleTimeout, connectionTimeout, maxLifetime\n- leakDetectionThreshold for debugging\n- MaintenanceManager integration for graceful shutdown\n\n---\n\n## 18. REPOSITORY & DAO PATTERNS\n\n### JPA Repository Pattern\n```java\n@Repository\npublic interface OrderRepository extends JpaRepository<OrderEntity, Long> {\n    // FETCH JOIN to prevent N+1 queries\n    @Query(\"SELECT o FROM OrderEntity o \"\n            + \"JOIN FETCH o.customerEntity \"\n            + \"JOIN FETCH o.clientEntity \"\n            + \"WHERE o.externalId = :externalId\")\n    Optional<OrderEntity> findByExternalId(@Param(\"externalId\") String externalId);\n\n    // Property path navigation\n    Optional<OrderEntity> findByClientReferenceIdAndClientEntity_ExternalId(\n            String clientReferenceId, String externalId);\n}\n```\n\n### DAO Pattern (Custom EntityManager)\n```java\n@Repository\npublic class PaymentAttemptDAOV2Impl {\n    @PersistenceContext\n    private EntityManager entityManager;\n\n    public List<PaymentAttemptV2Entity> findByOrderId(Long orderId) {\n        // Complex JPQL with manual EntityManager\n    }\n}\n```\n\n### DynamoDB DAO Pattern\n```java\n@RequiredArgsConstructor\npublic abstract class AbstractDynamoDBDAO<T> {\n    private final DynamoDBMapper dynamoDBMapper;\n\n    public void save(T entity) { dynamoDBMapper.save(entity); }\n    public T findByHashKey(Object hashKey) { return dynamoDBMapper.load(tClass, hashKey); }\n}\n```\n\n---\n\n## 19. JSON COLUMNS & CONVERTERS\n\n**Flexible Attribute Storage:**\n| Column | Converter | Entity |\n|--------|-----------|--------|\n| metadata | ObjectMetadataMapConverter | OrderEntity |\n| instrument_detail | PaymentInstrumentConverter | PaymentV2Entity |\n| instrument_detail | EnrichedPaymentInstrumentConverter | PaymentAttemptV2Entity |\n| routes | RoutesBreakupConverter | PaymentAttemptV2Entity |\n| payment_specific_detail | PaymentSpecificDetailConverter | PaymentV2Entity |\n\n```java\n@Column(name = \"metadata\")\n@Convert(converter = ObjectMetadataMapConverter.class)\nprivate Map<String, String> metaData;\n```\n\n---\n\n## 20. CACHING ARCHITECTURE\n\n### Caffeine Caches (In-Memory)\n| Cache Class | What It Caches | TTL |\n|-------------|----------------|-----|\n| ClientConfigurationCache | Client settings by ID, by externalId, by merchantId | 10-20 min |\n| PaymentProviderCache | Provider configurations | 15-25 min |\n| ProviderAccountCache | Provider account entities | 15-25 min |\n| DecisionTreeObjectCache | Routing decision trees | 180-190 min |\n| FeeCache | Fee configurations | 1 day |\n| CardBinCache | Card BIN details | Configurable |\n| MasterConfigurationCache | Feature flags, system settings | 10-20 min |\n| PaymentErrorMessageMappingCache | Error code to message mappings | Long |\n\n### Cache Pattern\n```java\n@DPCache(cacheName = \"client_configuration_cache\")\nprivate LoadingCache<Long, Map<ClientSettingKey, String>> idCache;\n\n@Override\npublic void buildCache() {\n    idCache = DPCacheBuilder.getBuilder()\n        .refreshAfterWrite(10, MINUTES)  // Lazy refresh\n        .build(this::loadClientSettings);  // Loader function\n}\n```\n\n### Jittered TTLs (Prevent Thundering Herd)\n```java\n// Returns 15-25 instead of fixed 15\nprivate Long generateRandomCacheRefreshInterval(int base) {\n    return base + random.nextInt(10) + 1;\n}\n```\n\n---\n\n## 21. DYNAMODB USAGE\n\n### What Goes Where\n| MySQL | DynamoDB |\n|-------|----------|\n| Orders, Payments, Attempts | Workflow context (TTL-based) |\n| Refunds, Fees | Native OTP details |\n| Clients, Customers | Redirect tracking |\n| Provider configs | Metadata audit trails |\n\n### DynamoDB Entity Example\n```java\n@DynamoDBTable(tableName = \"darwin_payment_attempt_workflow_context\")\npublic class PaymentAttemptWorkflowContextEntity {\n    @DynamoDBHashKey(attributeName = \"payment_attempt_external_id\")\n    private String paymentAttemptExternalId;\n\n    @DynamoDBRangeKey\n    @DynamoDBAttribute(attributeName = \"workflow_step\")\n    private WorkflowStep workflowStep;\n\n    @Builder.Default\n    private long ttl = LocalDateTime.now().plusDays(1).toEpochSecond(ZoneOffset.UTC);\n}\n```\n\n### DynamoDB Tables\n| Table | Partition Key | Sort Key | Purpose |\n|-------|---------------|----------|---------|\n| darwin_payment_attempt_workflow_context | payment_attempt_external_id | workflow_step | Workflow state |\n| darwin_payment_attempt_native_otp_detail | payment_attempt_external_id | - | OTP auth details |\n| darwin_payment_attempt_redirection_detail | payment_attempt_external_id | - | 3DS redirects |\n| darwin_payment_attempt_metadata_audit | payment_attempt_external_id | - | Audit trail |\n\n---\n\n## 22. OPTIMISTIC LOCKING & AUDIT\n\n### @Version for Optimistic Locking\n```java\n@Version\n@Column(name = \"version\")\nprivate Integer version;  // Auto-incremented on each update\n```\n\nPrevents concurrent modification - throws `OptimisticLockException` on conflict.\n\n### Audit Columns (Auto-Managed)\n```java\n@CreationTimestamp\n@Column(name = \"created_at\")\nprivate LocalDateTime createAt;\n\n@UpdateTimestamp\n@Column(name = \"updated_at\")\nprivate LocalDateTime updatedAt;\n\n@PrePersist\npublic void onCreate() {\n    createdBy = ApplicationContext.getApplicationName();\n}\n\n@PreUpdate\npublic void onUpdate() {\n    updatedBy = ApplicationContext.getApplicationName();\n}\n```\n\n---\n\n## 23. DATA LAYER ARCHITECTURE DIAGRAM\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                    Service Layer                        │\n├─────────────────────────────────────────────────────────┤\n│ JPA Repositories      │ Custom DAOs      │ DynamoDB DAOs │\n├─────────────────────────────────────────────────────────┤\n│     Spring Data JPA + Hibernate ORM                     │\n├──────────────────────┬──────────────────────────────────┤\n│   Master DataSource  │      Replica DataSource          │\n│   (Writes)           │      (Reads - @ReplicaRepository)│\n├──────────────────────┼──────────────────────────────────┤\n│ HikariCP Master Pool │   HikariCP Replica Pool          │\n├──────────────────────┴──────────────────────────────────┤\n│         MySQL (payments_multi_tenancy)                  │\n└─────────────────────────────────────────────────────────┘\n         │                              │\n┌────────▼────────┐          ┌──────────▼─────────┐\n│    DynamoDB     │          │  Caffeine Caches   │\n│ (Workflow/Audit)│          │  (Client/Provider) │\n└─────────────────┘          └────────────────────┘\n```\n\n---\n\n## 24. KEY DATA LAYER FILES TO STUDY\n\n### Entity Classes (Priority)\n1. `entity/commons/BaseEntity.java` - Base class pattern\n2. `entity/provider/BaseExternalEntity.java` - External ID + versioning\n3. `entity/OrderEntity.java` - Main order entity\n4. `entity/v2/PaymentAttemptV2Entity.java` - Payment attempt (most complex)\n\n### Database Configuration\n1. `configuration/database/MasterDataSourceConfiguration.java`\n2. `configuration/database/ReplicaDataSourceConfiguration.java`\n3. `configuration/database/annotation/ReplicaRepository.java`\n\n### Repositories\n1. `repository/OrderRepository.java` - FETCH JOIN examples\n2. `repository/PaymentAttemptRepository.java` - Complex queries\n\n### Caches\n1. `cache/ClientConfigurationCache.java` - Cache pattern example\n2. `configuration/CacheConfig.java` - Cache configuration\n\n### DynamoDB\n1. `dynamo/dao/AbstractDynamoDBDAO.java` - Base DAO pattern\n2. `dynamo/domain/PaymentAttemptWorkflowContextEntity.java` - DynamoDB entity\n\n---\n\n# PROVIDER INTEGRATION DEEP-DIVE\n\n## 25. PROVIDER ADAPTER ARCHITECTURE\n\n### Base Adapter Pattern\n**File:** `v2/workflow/create/providers/IPaymentProviderAdapter.java`\n\n```java\npublic abstract class IPaymentProviderAdapter<T, R> implements SelfReferencingBean {\n    protected final PaymentProviderKey paymentProviderKey;  // e.g., CASHFREE, CYBERSOURCE\n    private final InstrumentType instrumentType;            // e.g., CARD, UPI_APPS\n    private final OrderType orderType;                      // e.g., PAY, REFUND\n\n    // Core lifecycle methods\n    public abstract ProviderPaymentResponse createPaymentAttempt(context, customerEntity);\n    protected abstract Object syncPaymentAttemptWithProviderId(paymentAttemptEntity);\n    protected abstract ProviderRefundCreateResponse createRefund(refundAttemptEntity, context);\n    protected abstract R getAuthConfig(providerAccountEntity);\n}\n```\n\n### Factory Pattern for Adapter Selection\n**File:** `v2/workflow/create/providers/PaymentProviderFactory.java`\n\n```java\n@Component\npublic class PaymentProviderFactory {\n    // Multi-dimensional lookup: OrderType + ProviderKey + InstrumentType → Adapter\n    private Map<PaymentWorkflowKey, IPaymentProviderAdapter<?, ?>> paymentProviderMap;\n\n    // Secondary lookup: OrderType + ProviderKey → First adapter\n    private Table<OrderType, PaymentProviderKey, IPaymentProviderAdapter<?, ?>> paymentProviderByKey;\n\n    // 3DS variant support\n    private ThreeDSType threeDSType;  // 3DS1 vs 3DS2\n}\n```\n\n### Provider Response Structure\n```java\n@Data @Builder\npublic class ProviderPaymentResponse {\n    private Object providerResponseObject;     // Raw provider response\n    private String providerReferenceId;        // Provider's transaction ID\n    private String gatewayReferenceId;         // Gateway ID\n    private String providerStatus;             // Raw status (\"SUCCESS\")\n    private PaymentAttemptStatus status;       // Mapped internal status\n    private ProviderRequestStatus providerRequestStatus;  // REQUEST_SUCCESS, RETRY_ABLE_FAILURE\n    private ProviderError providerError;       // Error details if failed\n}\n```\n\n---\n\n## 26. DECISION TREE ROUTING\n\n### Router Strategy Pattern\n**File:** `planner/providerdecider/ProviderDeciderRouter.java`\n\n```java\n@Service\npublic class ProviderDeciderRouter {\n    public ProviderRoutingDecisionResult resolve(PaymentAttemptCreateContext context) {\n        // Priority 1: LCM routing (if instrument supported)\n        if (isInstrumentTypeSupportedInLCM(clientId, instrumentType)) {\n            return providerDeciderViaLCM.decideProvider(context);\n        }\n\n        // Priority 2: Decision Tree routing\n        if (isDecisionTreeEnabled) {\n            return providerDeciderV2.decideProvider(context);\n        }\n    }\n}\n```\n\n### Decision Tree Workflow\n**File:** `planner/providerdecider/ProviderDeciderV2.java`\n\n```\nRequest → Fetch Cached Decision Tree → Create DT Context → Execute Tree → Apply Dynamic Routing → Return Provider\n```\n\n**Decision Tree Factors:**\n- Client configuration\n- Instrument type (Card, UPI, NetBanking)\n- Card brand/BIN\n- Customer attributes\n- Order amount\n- Provider availability/downtime\n\n### Decision Tree Caching\n**File:** `cache/DecisionTreeObjectCache.java`\n\n| Cache | TTL | Content |\n|-------|-----|---------|\n| decision_tree_object_cache | 180-190 min | Parsed decision tree JSON + workflow |\n\n---\n\n## 27. PROVIDER ADAPTERS (24+ Implementations)\n\n### Adapter Directory Structure\n```\nv2/workflow/create/providers/\n├── IPaymentProviderAdapter.java          # Base abstract class\n├── PaymentProviderFactory.java           # Factory for adapter selection\n├── CashfreeProviderAdapter.java          # Cashfree base\n├── CashfreeCardProviderAdapter.java      # Cashfree cards\n├── CashfreeNetBankingProviderAdapter.java\n├── CashfreeUPIProviderAdapter.java\n├── CashfreeUPIAppsProviderAdapter.java\n├── cybersource/\n│   ├── CybersourceProviderAdapter.java   # Cybersource base (3DS)\n│   ├── CybersourceRequestBuilder.java    # Request construction\n│   └── CybersourceAuthorizeRequestBuilder.java\n├── PayuProviderAdapter.java\n├── PayuCardProviderAdapter.java\n├── PineLabsEdgeProviderAdapter.java\n├── CredPointsProviderAdapter.java\n├── RewardPointsProviderAdapter.java\n└── AuthTokenNativeProviderAdapter.java\n```\n\n### Cashfree Adapter Example\n**File:** `v2/workflow/create/providers/CashfreeProviderAdapter.java`\n\n```java\n@Component\npublic abstract class CashfreeProviderAdapter\n        extends IPaymentProviderAdapter<String, CashfreeAuthConfig> {\n\n    // Two-phase payment creation:\n    // 1. Create order at Cashfree\n    // 2. Create payment for that order\n\n    @Override\n    public ProviderPaymentResponse createPaymentAttempt(context, customer) {\n        // Phase 1: Create CF Order\n        Pair<BaseResponse<CreateOrderResponse>, ProviderError> orderResponse =\n            createCFOrder(context, authConfig);\n\n        // Phase 2: Create CF Payment\n        Pair<BaseResponse<CreatePaymentResponse>, ProviderError> paymentResponse =\n            createCFPayment(context, orderResponse.getLeft().getResponse(), authConfig);\n\n        return mapToProviderPaymentResponse(paymentResponse);\n    }\n}\n```\n\n### Cybersource Adapter (3DS Support)\n**File:** `v2/workflow/create/providers/cybersource/CybersourceProviderAdapter.java`\n\n```java\n@Component\npublic abstract class CybersourceProviderAdapter\n        extends I3DSPaymentProviderAdapter<String, AuthConfig> {\n\n    // Status code mappings\n    private static final List<String> FAILED_STATUSES = Arrays.asList(\n        \"101\", \"102\", \"104\", \"150\", \"200\", \"201\", ...  // 43 codes\n    );\n    private static final List<String> PROCESSING_STATUSES = Arrays.asList(\n        \"110\", \"475\", \"480\"\n    );\n\n    // 3DS2 redirection flow\n    protected void createRedirectionHtml(response, paymentAttemptEntity) {\n        if (authInfo.getSpecificationVersion().startsWith(\"2\")) {\n            // 3DS2 flow with step-up URL\n            html = authenticationService.createAuthenticationPageFor3ds2(\n                authInfo.getStepUpUrl(),\n                authInfo.getAccessToken(),\n                paymentAttemptEntity.getExternalId());\n        }\n    }\n}\n```\n\n---\n\n## 28. WEBHOOK HANDLING\n\n### Webhook Architecture\n```\nProvider → /webhooks/v2/{provider} → Provider-Specific Controller → WebhookService → State Machine Update\n```\n\n### Provider Webhook Controllers\n| Endpoint | Controller | Provider |\n|----------|------------|----------|\n| `/webhooks/v2/cashfree` | CashfreeWebhookController | Cashfree |\n| `/webhooks/v2/razorpay` | RazorpayWebhookController | Razorpay |\n| `/webhooks/v2/payu` | PayuWebhookController | PayU |\n| `/webhooks/v2/cybersource` | CybersourceWebhookController | Cybersource |\n| `/webhooks/v2/juspay` | JuspayWebhookController | Juspay |\n| `/webhooks/v2/ybl` | YBLWebhookController | Yes Bank UPI |\n| `/webhooks/v2/icici` | ICICIWebhookController | ICICI UPI |\n| `/webhooks/v2/rbl-upi` | RBLUpiWebhookController | RBL UPI |\n| `/webhooks/v2/digio` | DigioWebhookController | Digio (eMandate) |\n\n### Webhook Processing Flow\n**File:** `controller/v2/CashfreeWebhookController.java`\n\n```java\n@PostMapping\npublic void onWebhookReceive(@RequestBody CashfreeWebhook webhookRequest) {\n    switch (webhookRequest.getType()) {\n        case PAYMENT_SUCCESS_WEBHOOK:\n        case PAYMENT_FAILED_WEBHOOK:\n            // 1. Extract provider reference ID\n            String providerRefId = paymentWebhook.getData().getCfPaymentId();\n\n            // 2. Fetch payment attempt\n            PaymentAttempt attempt = paymentAttemptFetchWorkflow\n                .fetchByProviderReferenceId(providerRefId);\n\n            // 3. Audit webhook data\n            auditService.auditProviderData(webhookRequest, attempt.getId(), ...);\n\n            // 4. Sync status (triggers state machine)\n            break;\n\n        case REFUND_STATUS_WEBHOOK:\n            processRefundAttempt(webhookRequest);\n            break;\n    }\n}\n```\n\n### Idempotency Handling\n```java\n// In base adapter - only update if status actually changed\npublic void syncPaymentAttemptWithProvider(PaymentAttemptV2Entity entity) {\n    String currentStatus = entity.getProviderStatus();\n\n    Object providerResponse = syncPaymentAttemptWithProviderId(entity);\n\n    // Only audit and process if status changed\n    if (!Objects.equals(currentStatus, entity.getProviderStatus())) {\n        auditService.auditProviderData(...);\n    }\n}\n```\n\n---\n\n## 29. PROVIDER CONFIGURATION\n\n### Configuration Entities\n**File:** `entity/ProviderAccountEntity.java`\n\n```java\n@Entity @Table(name = \"provider_accounts\")\npublic class ProviderAccountEntity extends BaseEntity {\n    @ManyToOne\n    private PaymentProviderEntity paymentProvider;\n\n    private String providerAccountId;     // e.g., \"ACC_123456\"\n\n    @Lob\n    private byte[] accessToken;           // Encrypted credentials\n\n    private String endpoint;              // Provider API endpoint\n    private Boolean isProd;               // Production vs Sandbox\n    private Boolean active;\n    private String additionalConfig;      // JSON configuration\n    private String providerMid;           // Merchant ID at provider\n    private String settlementCategory;    // Settlement routing\n}\n```\n\n### Provider-Specific Configurations\n```java\n// Cashfree\n@Data\npublic class CashfreeProviderAccountConfiguration {\n    private String apiClientId;\n    private String apiVersion;\n    private ShortCircuitConfiguration shortCircuitConfiguration;\n}\n\n// Cybersource\n@Data\npublic class CybersourceProviderAccountConfiguration {\n    private String apiKey;\n    private String merchantId;\n    private Boolean enableRetries = false;\n    private Boolean enableCaptureWithAuth = true;\n    private Boolean enable3DS2 = true;\n    private Boolean enableRedirectionFlow = false;\n}\n```\n\n### Client-Provider Mapping\n**File:** `entity/ClientPaymentProviderConfigEntity.java`\n\n```java\n@Entity @Table(name = \"client_payment_provider_config\")\npublic class ClientPaymentProviderConfigEntity extends BaseEntity {\n    @ManyToOne private ClientEntity client;\n    @ManyToOne private PaymentProviderEntity paymentProvider;\n    private String providerConfig;  // JSON configuration per client\n}\n```\n\n---\n\n## 30. ERROR HANDLING & RETRY LOGIC\n\n### Error Classification\n```java\npublic enum ProviderRequestStatus {\n    REQUEST_SUCCESS,          // Payment processed\n    RETRY_ABLE_FAILURE,       // Timeout, rate limit - can retry\n    NON_RETRY_ABLE_FAILURE    // Invalid request - cannot retry\n}\n```\n\n### Provider Error Structure\n```java\n@Data @Builder\npublic class ProviderError {\n    private String message;           // User-friendly message\n    private String code;              // Provider error code\n    private Object providerResponse;  // Raw error response\n    private Boolean retryable;        // Retry classification\n}\n```\n\n### Error Code Mapping (Cybersource Example)\n```java\n// Failure codes (43 codes)\n\"101\", \"102\", \"104\", \"150\", \"200\", \"201\", \"202\", \"203\", ...\n\n// Processing/Pending codes\n\"110\" (Pending), \"475\" (Timeout), \"480\" (Processing)\n```\n\n### Retry Pattern\n```java\npublic ProviderPaymentResponse executePaymentAttempt(...) {\n    try {\n        return pilotMethod.apply(context, providerCustomer);\n    } catch (RateLimitException rle) {\n        return ProviderPaymentResponse.builder()\n            .providerRequestStatus(ProviderRequestStatus.RETRY_ABLE_FAILURE)\n            .providerError(ProviderError.builder()\n                .retryable(true).build())\n            .build();\n    } catch (AppException ae) {\n        return ProviderPaymentResponse.builder()\n            .providerRequestStatus(ProviderRequestStatus.NON_RETRY_ABLE_FAILURE)\n            .build();\n    }\n}\n```\n\n---\n\n## 31. ARCHITECTURAL PATTERNS SUMMARY\n\n| Pattern | Usage | File |\n|---------|-------|------|\n| **Factory** | Adapter selection by (OrderType, Provider, Instrument) | PaymentProviderFactory.java |\n| **Strategy** | LCM vs Decision Tree routing | ProviderDeciderRouter.java |\n| **Template Method** | Base adapter lifecycle | IPaymentProviderAdapter.java |\n| **Builder** | Complex request construction | CybersourceRequestBuilder.java |\n| **Decorator** | Provider-specific configuration | *ConfigValueDecoratorImpl.java |\n\n---\n\n## 32. KEY PROVIDER INTEGRATION FILES\n\n### Core Architecture\n1. `v2/workflow/create/providers/IPaymentProviderAdapter.java` - Base adapter\n2. `v2/workflow/create/providers/PaymentProviderFactory.java` - Factory\n3. `planner/providerdecider/ProviderDeciderRouter.java` - Routing strategy\n\n### Decision Tree\n1. `planner/providerdecider/ProviderDeciderV2.java` - DT workflow\n2. `planner/providerdecider/ProviderDeciderViaLCM.java` - LCM routing\n3. `cache/DecisionTreeObjectCache.java` - DT caching\n\n### Webhooks\n1. `controller/WebhookController.java` - Generic webhook endpoint\n2. `controller/v2/CashfreeWebhookController.java` - Cashfree webhooks\n3. `service/WebhookService.java` - Webhook processing\n\n### Provider Implementations\n1. `v2/workflow/create/providers/CashfreeProviderAdapter.java`\n2. `v2/workflow/create/providers/cybersource/CybersourceProviderAdapter.java`\n3. `v2/workflow/create/providers/PayuProviderAdapter.java`\n\n### Configuration\n1. `entity/ProviderAccountEntity.java` - Provider credentials\n2. `entity/PaymentProviderEntity.java` - Provider definition\n3. `entity/ClientPaymentProviderConfigEntity.java` - Client-provider mapping\n","structuredPatch":[{"oldStart":1065,"oldLines":3,"newStart":1065,"newLines":500,"lines":[" 1. `entity/ProviderAccountEntity.java` - Provider credentials"," 2. `entity/PaymentProviderEntity.java` - Provider definition"," 3. `entity/ClientPaymentProviderConfigEntity.java` - Client-provider mapping","+","+---","+","+# PAYMENT FLOW DEEP-DIVE","+","+## 33. THE 7-STEP WORKFLOW PIPELINE","+","+### Base Workflow Pattern (Template Method)","+**File:** `v2/workflow/create/Workflow.java`","+","+```java","+public Response execute(Request request) {","+    // STEP 1: Validate inputs and enrich context","+    Context context = validateAndEnrichContext(request);","+","+    // STEP 2: Persist to relational DB (transactional)","+    persistIntent(context);","+","+    // STEP 3: Pre-persist event hooks","+    publishEntityPrePersistEvents(context);","+","+    // STEP 4: Persist to non-relational DB (DynamoDB)","+    persistNonRelationalIntent(context);","+","+    // STEP 5: Process (external provider calls)","+    process(context);","+","+    // STEP 6: Post-process and save results (transactional)","+    Response response = postProcess(context);","+","+    // STEP 7: Post-persist & publish events","+    postPersistNonRelationalDataStore(context);","+    publishEntityChangeEvents(context);","+","+    throwErrorIfRequired(context);","+    return response;","+}","+```","+","+---","+","+## 34. PAYMENTATTEMPTCREATEWORKFLOW DETAILED","+","+**File:** `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java`","+","+### Step 1: Validate & Enrich Context","+","+| Enricher | Purpose | Output |","+|----------|---------|--------|","+| `InstrumentTypeProcessorManager` | Validate & enrich payment instrument | `InstrumentTypeProcessorResult` |","+| `ProviderDeciderRouter.resolve()` | Route to provider via Decision Tree | `ProviderRoutingDecisionResult` |","+| `AuthTypeDeciderFactory` | Determine auth type (3DS, OTP, None) | `AuthType` |","+| `NativeProviderDecider` | Select native OTP provider | `ProviderAccountEntity` |","+| `SettlementRouteValidator` | Validate & enrich settlement routes | `RoutesBreakup` |","+| `MandateServiceDataManager` | Register mandate (if eMandate) | `Mandate` |","+","+### Context Object Structure","+```java","+PaymentAttemptCreateContext {","+    // Request/Response","+    CreatePaymentAttemptRequest request","+    PaymentAttemptResponse response","+","+    // Entities","+    PaymentAttemptV2Entity paymentAttemptEntity","+    PaymentV2Entity paymentEntity","+    OrderEntity orderEntity","+    CustomerEntity customerEntity","+    ClientEntity clientEntity","+","+    // Enriched Data","+    InstrumentTypeProcessorResult instrumentProcessorResult","+    ProviderAccountEntity providerAccountEntity","+    ProviderRoutingDecisionResult routingDecisionResult","+    AuthType authType","+    RoutesBreakup routesBreakup","+    ProviderPaymentResponse createResponse","+","+    // OTP/Auth Flow","+    Boolean isPlatformNativeOtpSupported","+    PaymentAttemptNativeOTPDetailEntity nativeOTPDetailEntity","+","+    // Error Collection","+    List<WorkflowInternalError> errors","+}","+```","+","+### Step 2: Persist Intent","+```java","+@Transactional(transactionManager = \"MasterTransactionManager\")","+public void persistIntent(PaymentAttemptCreateContext context) {","+    // Create PaymentAttemptV2Entity","+    PaymentAttemptV2Entity entity = PaymentAttemptV2Entity.builder()","+        .externalId(PaymentAttemptUUIdGenerator.generate())","+        .status(PaymentAttemptStatus.CREATED)","+        .paymentEntity(paymentEntity)","+        .providerAccountEntity(providerAccountEntity)","+        .paymentMethod(instrumentResult.getPaymentMethod())","+        .instrumentDetail(instrumentResult.getEnrichedInstrument())","+        .routesBreakup(routesBreakup)","+        .build();","+","+    // Save to repository","+    paymentAttemptRepository.save(entity);","+","+    // Save fees","+    feeCreateWorkflow.persistIntent(feeContexts);","+","+    // Add attributes (DT_ID, DT_RESULT, etc.)","+    enrichAttributes(entity);","+}","+```","+","+### Step 5: Process (Provider Call)","+```java","+public void process(PaymentAttemptCreateContext context) {","+    // Find adapter","+    IPaymentProviderAdapter adapter = paymentProviderFactory","+        .findPaymentProviderAdapter(orderType, providerKey, instrumentType, threeDSType);","+","+    // Execute provider call","+    ProviderPaymentResponse response = adapter.executePaymentAttempt(","+        context,","+        adapter::createPaymentAttempt,","+        FlowType.CREATE","+    );","+","+    // Check platform OTP capability","+    response = checkIfPlatformOtpEnabled(context, response);","+","+    context.setCreateResponse(response);","+}","+```","+","+### Step 6: Post-Process","+```java","+@Transactional","+public PaymentAttemptResponse postProcess(PaymentAttemptCreateContext context) {","+    PaymentAttemptV2Entity entity = context.getPaymentAttemptEntity();","+    ProviderPaymentResponse response = context.getCreateResponse();","+","+    // Update from provider response","+    entity.setProviderStatus(response.getProviderStatus());","+    entity.setProviderReferenceId(response.getProviderReferenceId());","+    entity.setGatewayReferenceId(response.getGatewayReferenceId());","+","+    // Determine final status","+    if (response.getProviderRequestStatus() == REQUEST_SUCCESS) {","+        entity.setStatus(response.getStatus());","+    } else if (isEligiblePaymentMode) {","+        entity.setStatus(response.getStatus() == FAILED ? FAILED : PROCESSING);","+    }","+","+    paymentAttemptRepository.save(entity);","+    return mapper.toResponse(entity, response);","+}","+```","+","+### Step 7: Publish Events","+```java","+public void publishEntityChangeEvents(PaymentAttemptCreateContext context) {","+    // Post to sync EventBus (triggers PaymentStateMachine)","+    syncBus.post(PaymentAttemptEventFactory.findEvent(paymentAttemptEntity));","+","+    // Post to async EventBus","+    asyncBus.post(PaymentAttemptEventFactory.findEvent(paymentAttemptEntity));","+","+    // Publish to multi-tenant event system","+    eventiService.publishEvent(paymentAttemptEntity);","+","+    // Add to sync manager for webhook updates","+    syncManager.addEntityForSync(paymentAttemptEntity);","+}","+```","+","+---","+","+## 35. STATE MACHINE IMPLEMENTATION","+","+### PaymentStateMachine","+**File:** `statemachine/payment/PaymentStateMachine.java`","+","+```","+Event Subscriptions:","+├── @Subscribe onPaymentAttemptCreated","+│   └── Payment: FAILED → CREATED","+├── @Subscribe onPaymentAttemptFailed","+│   └── If all attempts failed: Payment → FAILED","+├── @Subscribe onPaymentAttemptCompleted","+│   └── Payment → COMPLETED (with optimistic lock retry)","+├── @Subscribe onPaymentAttemptAuthorized","+│   └── Payment → AUTHORIZED","+├── @Subscribe onPaymentAttemptProcessing","+│   └── Payment → PROCESSING","+├── @Subscribe onPaymentAttemptBlocked","+│   └── Payment → BLOCKED","+└── @Subscribe onAuthenticationSuccessful/Failed","+    └── Payment → AUTHENTICATION_SUCCESSFUL/FAILED","+```","+","+### OrderStateMachine","+**File:** `statemachine/order/OrderStateMachine.java`","+","+```","+Event Subscriptions:","+├── @Subscribe onPaymentCreated","+│   └── Order → CREATED or AUTHLESS_READY_TO_PROCESS","+├── @Subscribe onPaymentFailed","+│   └── Order → FAILED","+├── @Subscribe onPaymentCompleted","+│   └── Order → COMPLETED (if all payments done)","+├── @Subscribe onPaymentAuthorized","+│   └── Order → AUTHORIZED","+└── @Subscribe onPaymentProcessing","+    └── Order → PROCESSING","+```","+","+### Terminal States","+| Entity | Terminal States |","+|--------|-----------------|","+| PaymentAttempt | COMPLETED, FAILED, FORCE_FAILED |","+| Payment | COMPLETED, FAILED, FORCE_FAILED, DISCARDED |","+| Order | COMPLETED, FAILED |","+","+### State Transition Guard","+```java","+private boolean shouldUpdatePaymentStatus(PaymentV2Entity entity) {","+    return !Arrays.asList(COMPLETED, FAILED, FORCE_FAILED, DISCARDED)","+        .contains(entity.getStatus());","+}","+```","+","+---","+","+## 36. END-TO-END PAYMENT FLOW","+","+```","+┌─────────────────────────────────────────────────────────────────────────┐","+│                         CLIENT REQUEST                                   │","+└─────────────────────────────────────────────────────────────────────────┘","+                                    │","+                                    ▼","+┌─────────────────────────────────────────────────────────────────────────┐","+│  1. ORDER CREATION                                                       │","+│  ┌────────────────────────────────────────────────────────────────────┐ │","+│  │ OrderCreateWorkflow.execute()                                       │ │","+│  │ ├── validateAndEnrichContext() - Customer lookup, order validation │ │","+│  │ ├── persistIntent() - Save OrderEntity (status: CREATED)           │ │","+│  │ └── publishEvents() → OrderStateMachine                            │ │","+│  └────────────────────────────────────────────────────────────────────┘ │","+└─────────────────────────────────────────────────────────────────────────┘","+                                    │","+                                    ▼","+┌─────────────────────────────────────────────────────────────────────────┐","+│  2. PAYMENT CREATION                                                     │","+│  ┌────────────────────────────────────────────────────────────────────┐ │","+│  │ BulkPaymentCreateWorkflow.execute()                                 │ │","+│  │ ├── validateAndEnrichContext() - Payment mode validation           │ │","+│  │ ├── persistIntent() - Save PaymentV2Entity (status: CREATED)       │ │","+│  │ └── publishEvents() → PaymentStateMachine                          │ │","+│  └────────────────────────────────────────────────────────────────────┘ │","+└─────────────────────────────────────────────────────────────────────────┘","+                                    │","+                                    ▼","+┌─────────────────────────────────────────────────────────────────────────┐","+│  3. PAYMENT ATTEMPT CREATION (Core Flow)                                 │","+│  ┌────────────────────────────────────────────────────────────────────┐ │","+│  │ PaymentAttemptCreateWorkflow.execute()                              │ │","+│  │ ├── validateAndEnrichContext()                                     │ │","+│  │ │   ├── InstrumentTypeProcessorManager (Card/UPI/NetBanking)       │ │","+│  │ │   ├── ProviderDeciderRouter (Decision Tree routing)              │ │","+│  │ │   ├── AuthTypeDeciderFactory (3DS/OTP/None)                      │ │","+│  │ │   └── SettlementRouteValidator                                   │ │","+│  │ ├── persistIntent() - Save PaymentAttemptV2Entity                  │ │","+│  │ ├── persistNonRelationalIntent() - DynamoDB (OTP details)          │ │","+│  │ ├── process() - Provider API call via Adapter                      │ │","+│  │ ├── postProcess() - Update entity with provider response           │ │","+│  │ └── publishEvents() → PaymentStateMachine → OrderStateMachine      │ │","+│  └────────────────────────────────────────────────────────────────────┘ │","+└─────────────────────────────────────────────────────────────────────────┘","+                                    │","+                                    ▼","+┌─────────────────────────────────────────────────────────────────────────┐","+│  4. PROVIDER API RESPONSE                                                │","+│  ┌────────────────────────────────────────────────────────────────────┐ │","+│  │ ProviderPaymentResponse contains:                                   │ │","+│  │ ├── providerStatus: \"SUCCESS\" / \"PENDING\" / \"FAILED\"               │ │","+│  │ ├── providerReferenceId: Provider's transaction ID                 │ │","+│  │ ├── status: PaymentAttemptStatus (mapped)                          │ │","+│  │ ├── transactionResponse:                                           │ │","+│  │ │   ├── authentication: { url, method } (for 3DS redirect)         │ │","+│  │ │   └── sdkParams: Native OTP/SDK details                          │ │","+│  │ └── providerError: Error details if failed                         │ │","+│  └────────────────────────────────────────────────────────────────────┘ │","+└─────────────────────────────────────────────────────────────────────────┘","+                                    │","+         ┌──────────────────────────┴──────────────────────────┐","+         ▼                                                      ▼","+┌─────────────────────────┐                    ┌─────────────────────────┐","+│  5A. 3DS/OTP FLOW       │                    │  5B. DIRECT SUCCESS     │","+│  ┌───────────────────┐  │                    │  ┌───────────────────┐  │","+│  │ Client performs   │  │                    │  │ Status: COMPLETED │  │","+│  │ authentication    │  │                    │  │ Payment done!     │  │","+│  │ (redirect/native) │  │                    │  └───────────────────┘  │","+│  └───────────────────┘  │                    └─────────────────────────┘","+│           │             │","+│           ▼             │","+│  ┌───────────────────┐  │","+│  │ Authenticate      │  │","+│  │ Workflow called   │  │","+│  │ with OTP/callback │  │","+│  └───────────────────┘  │","+└─────────────────────────┘","+                                    │","+                                    ▼","+┌─────────────────────────────────────────────────────────────────────────┐","+│  6. WEBHOOK / SYNC UPDATE                                                │","+│  ┌────────────────────────────────────────────────────────────────────┐ │","+│  │ Provider sends webhook OR SyncManager polls status                  │ │","+│  │ ├── WebhookController receives update                              │ │","+│  │ ├── adapter.syncPaymentAttemptWithWebhook()                        │ │","+│  │ ├── Update PaymentAttemptV2Entity status                           │ │","+│  │ └── publishEvents() → State machines cascade updates               │ │","+│  └────────────────────────────────────────────────────────────────────┘ │","+└─────────────────────────────────────────────────────────────────────────┘","+                                    │","+                                    ▼","+┌─────────────────────────────────────────────────────────────────────────┐","+│  7. FINAL STATE                                                          │","+│  ┌────────────────────────────────────────────────────────────────────┐ │","+│  │ PaymentAttempt: COMPLETED ──► Payment: COMPLETED ──► Order: COMPLETED│","+│  │                                                                     │ │","+│  │ eventiService.publishEvent() → Client webhook notification          │ │","+│  │ eventiService.publishToPinot() → Analytics dashboard               │ │","+│  └────────────────────────────────────────────────────────────────────┘ │","+└─────────────────────────────────────────────────────────────────────────┘","+```","+","+---","+","+## 37. 3DS / NATIVE OTP AUTHENTICATION","+","+### Native OTP Flow (Card Payments)","+```","+1. PaymentAttemptCreateWorkflow detects CARD + OTP-capable BIN","+2. wspService.isPlatformNativeOtpEnabled() returns true","+3. Provider returns redirect URL, but we override with SDK params","+4. CardNativeOTPSDKParamDetail created:","+   ├── authType: NATIVE_OTP","+   ├── challengeId: UUID","+   ├── fallbackUrl: Provider's original auth URL","+   └── submitOTPAllowed: true","+","+5. PaymentAttemptNativeOTPDetailEntity saved to DynamoDB","+6. Client submits OTP via PaymentAttemptAuthenticateWorkflow","+7. Provider validates OTP, returns success/failure","+8. State machines update payment/order status","+```","+","+### 3DS Redirect Flow","+```","+1. Provider returns authentication URL","+2. Client redirects to issuer's 3DS page","+3. User completes authentication","+4. Callback to return_url","+5. ValidateAuthenticationWorkflow processes callback","+6. Provider confirms authentication status","+7. State machines update accordingly","+```","+","+---","+","+## 38. INSTRUMENT PROCESSING","+","+### InstrumentTypeProcessorManager","+**File:** `processors/instrumenttype/InstrumentTypeProcessorManager.java`","+","+```java","+// Routes to specific processor based on instrument type","+IInstrumentTypeProcessor processor = processorByType.get(instrument.getType());","+return processor.validatePaymentInstrumentAndEnrich(instrument);","+```","+","+### Processor Implementations","+| Processor | InstrumentType | Enrichment |","+|-----------|----------------|------------|","+| `CardInstrumentTypeProcessor` | CARD | BIN lookup, issuer, card type |","+| `UPIPayInstrumentTypeProcessor` | UPI_APPS | VPA validation, provider |","+| `UPICollectInstrumentTypeProcessor` | UPI_COLLECT | QR code, timeout |","+| `NetBankingInstrumentTypeProcessor` | NET_BANKING | Bank code, issuer |","+| `EMandateInstrumentTypeProcessor` | NET_BANKING_WITH_PI | Mandate details |","+","+### InstrumentTypeProcessorResult","+```java","+InstrumentTypeProcessorResult<R, S> {","+    PaymentInstrumentGroup paymentMethod;  // CARD, UPI_PAY, etc.","+    R paymentSubMethodDetail;              // CardPaymentSubMethodDetail","+    S enrichedPaymentInstrument;           // CardEnrichedPaymentInstrument","+}","+```","+","+---","+","+## 39. DISTRIBUTED LOCKING","+","+### SequentialWorkflow Pattern","+**File:** `v2/workflow/create/SequentialWorkflow.java`","+","+```java","+public Response execute(Request request) {","+    LockSetting lockSetting = fetchLockSetting();","+    String lockKey = evaluateLockKey(request, lockSetting.getLockKey());","+","+    // Acquire Redis distributed lock","+    Optional<RLock> lock = redisLockUtil.acquireLock(lockKey, flowType);","+","+    if (lock.isPresent() || !lockSetting.getIsLockMandatory()) {","+        try {","+            return super.execute(request);  // Run workflow","+        } finally {","+            lock.ifPresent(redisLockUtil::releaseLock);","+        }","+    }","+    throw Error.unable_to_acquire_lock.getBuilder().build();","+}","+```","+","+**Use Cases:**","+- Prevents concurrent payment attempts on same order","+- Ensures single webhook processing per transaction","+- Avoids race conditions in status updates","+","+---","+","+## 40. KEY PAYMENT FLOW FILES","+","+### Core Workflows","+1. `v2/workflow/create/Workflow.java` - Base template","+2. `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java` - Main flow","+3. `v2/workflow/create/payments/bulk/BulkPaymentCreateWorkflow.java` - Payment creation","+4. `v2/workflow/authenticate/PaymentAttemptAuthenticateWorkflow.java` - OTP auth","+","+### State Machines","+1. `statemachine/payment/PaymentStateMachine.java`","+2. `statemachine/order/OrderStateMachine.java`","+3. `statemachine/RefundStateMachine.java`","+","+### Instrument Processing","+1. `processors/instrumenttype/InstrumentTypeProcessorManager.java`","+2. `processors/instrumenttype/CardInstrumentTypeProcessor.java`","+3. `processors/instrumenttype/UPIPayInstrumentTypeProcessor.java`","+","+### Context & Events","+1. `v2/workflow/create/paymentattempts/PaymentAttemptCreateContext.java`","+2. `statemachine/payment/events/PaymentAttemptEventFactory.java`","+3. `statemachine/order/events/OrderEventFactory.java`","+","+---","+","+## 41. ARCHITECTURAL PATTERNS SUMMARY","+","+| Pattern | Implementation | Purpose |","+|---------|----------------|---------|","+| **Template Method** | `Workflow.execute()` 7-step pipeline | Consistent execution flow |","+| **Factory** | `PaymentProviderFactory`, `InstrumentTypeProcessorManager` | Dynamic component selection |","+| **Strategy** | `AuthTypeDeciderFactory`, `SdkTypeDeciderFactory` | Pluggable algorithms |","+| **Observer** | Guava EventBus, State Machines | Decoupled state transitions |","+| **Context Object** | `PaymentAttemptCreateContext` | Data flow through pipeline |","+| **Distributed Lock** | `SequentialWorkflow` + Redis | Concurrency control |","+| **Event Sourcing** | DynamoDB workflow context | Audit trail |","+","+---","+","+## 42. COMPLETE STUDY GUIDE SUMMARY","+","+You now have a **42-section expert study guide** covering:","+","+### Foundation (Sections 1-15)","+- Tech stack, project structure, core concepts","+- API endpoints, authentication, dependencies","+","+### Data Layer Deep-Dive (Sections 16-24)","+- Entity hierarchy, Master-Replica DB","+- Repository patterns, caching, DynamoDB","+","+### Provider Integration Deep-Dive (Sections 25-32)","+- Adapter architecture, Decision Tree routing","+- Webhook handling, provider configuration","+- Error handling and retry logic","+","+### Payment Flow Deep-Dive (Sections 33-41)","+- 7-step workflow pipeline","+- State machine implementation","+- End-to-end payment flow","+- 3DS/OTP authentication","+- Instrument processing","+- Distributed locking"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"32a78b51-020d-4e4d-87a4-32ba681923d7","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_014yPJwcucEtkhc9rXDqy26A","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"I've successfully added the comprehensive Payment Flow deep-dive to the study guide. The guide is now complete with 42 sections covering all aspects of the payment-service codebase. Let me provide a final summary to the user and exit plan mode since this is a research/study task, not an implementation task.","signature":"Et8DCkgICxABGAIqQLLR4hNs6eN/it6hyvIsqj36ZS2duz8SY68lYenv73e9s2SUojTUzsp27l0BCKkVzrr/nRGkxRkE2URJlkAau0QSDHw7E8rmwgkfF66sHRoMUPWQmlX706B1WcmEIjBwAYgTt8IPYXEvqV8Efqhj5t5A5wTnJiFiH/7NA/rSh65KkK9qkKhprL+g6CRS97wqxAJSsl7xLUw15u61thUss9kFS2oMc1czN602hm8WenkY0bCdOYZxrLh3UthMLMFkcBmKfmLi6lpSIOtBVD/dR5ozPaFjtSYDWdHY7BEo+6A7mXe5BnViiHx04/mPGe9kel1Sf7tu1+YMW2S/AMRe7rJqotTpqQfi/nUn0TS2nAPgj3PofCkTtEzj8t2M06gAUHfd5oe9uPV480cb8S9UrmO+rno54azCOAWbPE+AO7AltUEB2xG54VGMRtB7plmipK2NWpKV1j9eDBMDUjXEqcpWkWNW/OrNlR6B3dJODP0aKOh+D3Ai2ttwcQncbXRDu5jVsLiAUsTVSbSsrc8ZHtGhEU7bsdUDcN+baYZHdrWbxzR5Lb8eo87IvvnelOlYqZp+pNQmkjpuzLqJbGf55kAFiiW47TCrwa5mFk4WN+IJ0lzuZ5IYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":14913,"cache_read_input_tokens":110309,"cache_creation":{"ephemeral_5m_input_tokens":14913,"ephemeral_1h_input_tokens":0},"output_tokens":1}},"type":"assistant","uuid":"7dfb8b94-e821-4961-8d30-9d734ec956aa","timestamp":"2025-12-31T09:54:42.955Z"}
{"parentUuid":"7dfb8b94-e821-4961-8d30-9d734ec956aa","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_014yPJwcucEtkhc9rXDqy26A","type":"message","role":"assistant","content":[{"type":"text","text":"Your **42-section expert study guide** is now complete! Here's what's covered:\n\n## Complete Study Guide Summary\n\n| Section Range | Topic | Key Content |\n|--------------|-------|-------------|\n| **1-15** | Foundation | Tech stack, project structure, API endpoints, auth, dependencies |\n| **16-24** | Data Layer | Entity hierarchy, Master-Replica DB, caching, DynamoDB |\n| **25-32** | Provider Integration | Adapter architecture, Decision Tree, webhooks, error handling |\n| **33-42** | Payment Flow | 7-step workflow, state machines, end-to-end flow, 3DS/OTP |\n\n## Key Architectural Patterns Covered\n\n| Pattern | Where Used |\n|---------|-----------|\n| **Template Method** | 7-step Workflow pipeline |\n| **Factory** | Provider adapter selection, Instrument processors |\n| **Strategy** | LCM vs Decision Tree routing, Auth type decisions |\n| **Observer** | Guava EventBus, State Machines |\n| **Context Object** | Data flow through workflow steps |\n| **Distributed Lock** | Redis-based concurrency control |\n\n## Recommended Study Path\n\n1. **Week 1:** Sections 1-15 (Foundation)\n2. **Week 2:** Sections 16-24 (Data Layer)\n3. **Week 3:** Sections 25-32 (Provider Integration)\n4. **Week 4:** Sections 33-42 (Payment Flow)\n\nYour study guide is saved at:\n`/Users/kiranbiliyawala/.claude/plans/distributed-marinating-mango.md`"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":14913,"cache_read_input_tokens":110309,"cache_creation":{"ephemeral_5m_input_tokens":14913,"ephemeral_1h_input_tokens":0},"output_tokens":1}},"type":"assistant","uuid":"8011720b-c11a-49a7-9b8c-a5f4f60f36b5","timestamp":"2025-12-31T09:54:48.215Z"}
{"parentUuid":"8011720b-c11a-49a7-9b8c-a5f4f60f36b5","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_014yPJwcucEtkhc9rXDqy26A","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_bdrk_013LawCuHHVJWp6JCM1VmnMh","name":"ExitPlanMode","input":{"plan":"# Payment Service (Darwin) - Expert Study Guide\n\nA comprehensive guide to understanding the payment-service repository.\n\n---\n\n## 1. OVERVIEW & TECH STACK\n\n**Project Name:** Darwin (internal name for payment-service)\n**Purpose:** Enterprise-grade payment processing microservice handling multi-provider payment orchestration\n\n| Technology | Version | Purpose |\n|------------|---------|---------|\n| Java | 17 | Runtime |\n| Spring Boot | 2.7.14 | Framework |\n| Gradle | 7.6 | Build |\n| MySQL | - | Primary Database (Master-Replica) |\n| DynamoDB | - | Audit/State Storage |\n| Redis (Redisson) | 3.19.1 | Distributed Cache |\n| Kafka | - | Event Streaming |\n| AWS SQS | - | Task Processing |\n\n**Server:** Port 9010, Context Path: `/payments`\n\n---\n\n## 2. PROJECT STRUCTURE\n\n```\npayment-service/\n├── src/main/java/in/dreamplug/darwin/\n│   ├── controller/         # REST API endpoints\n│   │   └── v2/             # V2 API controllers (primary)\n│   ├── service/            # Business logic services\n│   ├── v2/\n│   │   ├── service/        # V2 services\n│   │   └── workflow/       # Payment workflows (CRITICAL)\n│   │       └── create/\n│   │           ├── payments/       # Payment creation\n│   │           ├── paymentattempts/ # Payment attempt creation\n│   │           └── providers/      # Provider adapters (24+)\n│   ├── entity/             # JPA entities\n│   │   └── v2/             # V2 entities (primary)\n│   ├── repository/         # Data access layer\n│   ├── statemachine/       # Payment/Order state machines\n│   ├── planner/            # Decision tree routing\n│   ├── cache/              # Caching layer (Caffeine)\n│   ├── client/             # External service clients\n│   ├── provider/           # Legacy provider implementations\n│   ├── configuration/      # Spring configs\n│   │   └── database/       # DB configs (Master/Replica)\n│   ├── kafka/              # Kafka producers/consumers\n│   ├── sqs/                # SQS message processors\n│   ├── dynamo/             # DynamoDB DAOs\n│   ├── error/              # Error handling\n│   ├── dto/                # Data transfer objects\n│   └── commons/spring/filters/  # Auth/Context filters\n├── src/main/resources/\n│   └── application.properties  # Main config (1300+ lines)\n├── codepipeline/           # CI/CD configurations\n├── build.gradle            # Dependencies\n└── Dockerfile              # Container setup\n```\n\n---\n\n## 3. CORE PAYMENT FLOW (CRITICAL)\n\n### 3.1 Payment Lifecycle\n\n```\nOrder Created → Payments Created → Payment Attempt Created → Provider API Call → Webhook/Status Update\n```\n\n**Key Steps:**\n\n1. **Order Creation** - Client creates an order with amount, currency, metadata\n2. **Bulk Payment Creation** - Multiple payment records created for the order\n   - File: `v2/workflow/create/payments/bulk/BulkPaymentCreateWorkflow.java`\n3. **Payment Attempt Creation** - Actual payment attempt with provider routing\n   - File: `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java`\n4. **Provider Processing** - Provider adapter calls external payment gateway\n5. **State Machine Updates** - Events trigger state transitions\n\n### 3.2 Workflow Execution Pipeline\n\n```java\n// Base workflow pattern (Workflow.java)\n1. validateAndEnrichContext()  // Validate inputs, enrich data\n2. persistIntent()             // Save entities to MySQL\n3. persistNonRelationalIntent() // Save to DynamoDB\n4. process()                   // Call provider API\n5. postProcess()               // Transform results\n6. publishEntityChangeEvents() // Trigger state machines\n7. throwErrorIfRequired()      // Handle errors\n```\n\n### 3.3 Payment Attempt Data Enrichment\n\n1. **Instrument Validation** - `InstrumentTypeProcessorManager`\n2. **Provider Routing** - `ProviderDeciderRouter` → Decision Tree\n3. **Auth Type Decision** - `AuthTypeDeciderFactory` (3DS, OTP, None)\n4. **Settlement Validation** - `SettlementRouteValidator`\n\n---\n\n## 4. STATE MACHINES\n\n### 4.1 Payment State Machine\n**File:** `statemachine/payment/PaymentStateMachine.java`\n\n```\nCREATED → PROCESSING → AUTHORIZED → COMPLETED\n                   ↘ FAILED\n                   ↘ BLOCKED\n```\n\n**Terminal States:** COMPLETED, FAILED, FORCE_FAILED, DISCARDED\n\n### 4.2 Order State Machine\n**File:** `statemachine/order/OrderStateMachine.java`\n\n- Reacts to payment events\n- Updates order status based on payment outcomes\n\n### 4.3 Events (EventBus - Guava)\n- `PaymentAttemptCreatedEvent`\n- `PaymentAttemptCompletedEvent`\n- `PaymentAttemptFailedEvent`\n- `PaymentAttemptProcessingEvent`\n- `PaymentAttemptAuthorizedEvent`\n\n---\n\n## 5. PROVIDER INTEGRATIONS (24+ Providers)\n\n**Location:** `v2/workflow/create/providers/`\n\n| Provider | Adapter File | Payment Types |\n|----------|-------------|---------------|\n| Cybersource | `CybersourceProviderAdapter.java` | Cards, 3DS, E-Mandates |\n| Cashfree | `CashfreeProviderAdapter.java` + variants | Cards, UPI, NetBanking |\n| PayU | `PayuProviderAdapter.java` + variants | Cards, NetBanking |\n| Pine Labs | `PineLabsEdgeProviderAdapter.java` | Multiple modes |\n| Razorpay | Via webhooks | All payment types |\n| Juspay | Via webhooks | Orchestration |\n| ICICI UPI | `icici-upi-client` | UPI |\n| Axis UPI | `axis-upi-client` | UPI |\n| YBL UPI | `ybl-upi-client` | UPI |\n| RBL UPI | `rbl-upi-client` | UPI |\n| Digio | `DigioMandateRegisterProviderAdapter.java` | E-Mandates |\n| Cred Points | `CredPointsProviderAdapter.java` | Reward redemption |\n\n### Provider Selection Flow\n\n```\nRequest → ProviderDeciderRouter → LCM (if enabled) → Decision Tree → Provider Adapter\n```\n\n**Decision Tree:** JSON-based rules cached in `DecisionTreeObjectCache`\n\n---\n\n## 6. KEY ENTITIES (V2 Schema)\n\n### Core Entities\n| Entity | File | Purpose |\n|--------|------|---------|\n| OrderEntity | `entity/OrderEntity.java` | Order records |\n| PaymentV2Entity | `entity/v2/PaymentV2Entity.java` | Payment records |\n| PaymentAttemptV2Entity | `entity/v2/PaymentAttemptV2Entity.java` | Payment attempts |\n| RefundEntity | `entity/v2/RefundEntity.java` | Refunds |\n| FeeEntity | `entity/v2/FeeEntity.java` | Fee tracking |\n\n### Configuration Entities\n| Entity | Purpose |\n|--------|---------|\n| ClientEntity | Application clients |\n| ProviderAccountEntity | Provider accounts |\n| PaymentProviderEntity | Provider configs |\n| MasterConfigurationEntity | System configs |\n\n---\n\n## 7. DATABASE ARCHITECTURE\n\n### Master-Replica Pattern\n\n**Master:** Write operations\n**Replica:** Read operations (via `@ReplicaRepository`)\n\n**Configuration Files:**\n- `configuration/database/MasterDataSourceConfiguration.java`\n- `configuration/database/ReplicaDataSourceConfiguration.java`\n\n**Database:** `payments_multi_tenancy`\n**Connection Pool:** HikariCP\n**ORM:** JPA + Hibernate\n\n---\n\n## 8. CACHING LAYER\n\n### Caffeine (In-Memory)\n| Cache | Purpose |\n|-------|---------|\n| `ClientConfigurationCache` | Client settings |\n| `PaymentProviderCache` | Provider configs |\n| `ProviderAccountCache` | Provider accounts |\n| `DecisionTreeObjectCache` | Routing rules |\n| `CardBinCache` | Card BIN data |\n| `MerchantCache` | Merchant data |\n| `FeeCache` | Fee calculations |\n\n### Redis (Distributed)\n- **Client:** Redisson with Kryo5Codec\n- **Use:** Distributed locks, rate limiting, shared state\n\n---\n\n## 9. ASYNC PROCESSING\n\n### Kafka Topics\n- `payment-attempt-platform-metrics-pinot-out-new-1` (Analytics)\n- Events: `PaymentAttemptAnalyticsEvent`, `CardPaymentAttemptAnalyticsEvent`, etc.\n\n### SQS Queues\n| Queue | Purpose |\n|-------|---------|\n| `FORCE_PAYMENT_FAILURE_QUEUE` | Manual failure forcing |\n| `MANDATE_EXPIRY_CRON_QUEUE` | Mandate expiry |\n| `REFUND_RESCHEDULE_QUEUE` | Refund scheduling |\n| `ORDER_EXPIRY_QUEUE` | Order expiration |\n| `PENDENCY_AUTOMATION_QUEUE` | Pending transactions |\n\n### Eventi (Internal Events)\n- Internal event framework for system events\n- Async worker threads (4-16 configurable)\n\n---\n\n## 10. API ENDPOINTS\n\n### Primary Controllers (v2)\n| Endpoint | Controller | Purpose |\n|----------|------------|---------|\n| `/v2/orders/{orderId}/payments` | `PaymentV2Controller` | Bulk payment creation |\n| `/v2/payments/{paymentId}/attempts` | `PaymentAttemptV2Controller` | Payment attempts |\n| `/v1/webhooks` | `WebhookController` | Provider webhooks |\n\n### Webhook Controllers\n- `RazorpayWebhookController`\n- `JuspayWebhookController`\n- `ICICIWebhookController`\n- `YBLWebhookController`\n- `RBLUpiWebhookController`\n- `DigioWebhookController`\n\n---\n\n## 11. AUTHENTICATION & SECURITY\n\n### Request Filters (Order of Execution)\n1. `ApplicationContextBuilderFilter` - Build context from headers\n2. `PAMerchantAuthenticationFilter` - Partner merchant auth\n3. `PAPartnerAuthorizationFilter` - Partner authorization\n\n### Headers Required\n- Client ID (`${CLIENT_HEADER_KEY}`)\n- Merchant ID (`${MERCHANT_HEADER_KEY}`)\n- Device info (DEVICE_ID, OS, OS_VERSION, APP_VERSION)\n\n### Rate Limiting\n- Redisson-based distributed rate limiting\n- Config in `ClientRateLimiter.java`\n\n---\n\n## 12. KEY FILES TO STUDY\n\n### Must-Read Files (Priority Order)\n\n1. **Entry Point:**\n   - `DarwinApplication.java`\n\n2. **Core Workflows:**\n   - `v2/workflow/create/Workflow.java` (base pattern)\n   - `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java`\n   - `v2/workflow/create/payments/bulk/BulkPaymentCreateWorkflow.java`\n\n3. **State Machines:**\n   - `statemachine/payment/PaymentStateMachine.java`\n   - `statemachine/order/OrderStateMachine.java`\n\n4. **Provider Routing:**\n   - `planner/ProviderDeciderRouter.java`\n   - `planner/decisiontree/DecisionTreeWorkflow.java`\n\n5. **Provider Adapters:**\n   - `v2/workflow/create/providers/` (pick any adapter)\n\n6. **Entities:**\n   - `entity/OrderEntity.java`\n   - `entity/v2/PaymentV2Entity.java`\n   - `entity/v2/PaymentAttemptV2Entity.java`\n\n7. **Configuration:**\n   - `application.properties` (1300+ lines - scan for context)\n\n8. **Webhooks:**\n   - `controller/WebhookController.java`\n\n---\n\n## 13. INTERNAL SERVICE DEPENDENCIES\n\n| Service | Client Library | Purpose |\n|---------|---------------|---------|\n| User Service | `user-service-client:4.0.1` | User data |\n| Merchant Service | `merchant-service-client:1.0.3` | Merchant info |\n| Mandate Service | `mandate-java-client:1.0.4` | Recurring payments |\n| Arsenal | - | Instrument vault |\n| Falcon | - | Offers/promotions |\n| Genie | `genie-java-client` | Configuration |\n| Syndicate | - | Authentication |\n| LCM | - | Terminal resolution |\n| Fee Service | `fees:0.18.0` | Fee calculation |\n\n---\n\n## 14. STUDY PATH RECOMMENDATION\n\n### Week 1: Foundation\n- [ ] Understand project structure\n- [ ] Read `DarwinApplication.java`\n- [ ] Study `application.properties` (key sections)\n- [ ] Understand entity relationships\n\n### Week 2: Core Flow\n- [ ] Master `PaymentAttemptCreateWorkflow.java`\n- [ ] Study state machines\n- [ ] Understand provider routing\n\n### Week 3: Integrations\n- [ ] Study 2-3 provider adapters\n- [ ] Understand webhook handling\n- [ ] Learn caching patterns\n\n### Week 4: Advanced\n- [ ] Decision tree engine\n- [ ] Async processing (Kafka, SQS)\n- [ ] Error handling patterns\n\n---\n\n## 15. KEY CONCEPTS\n\n1. **Multi-Provider Orchestration** - Route to optimal provider based on rules\n2. **Decision Trees** - JSON-based routing logic\n3. **State Machines** - Event-driven entity lifecycle\n4. **Master-Replica DB** - Read/write separation\n5. **Workflow Pattern** - 7-step execution pipeline\n6. **Event-Driven Architecture** - Guava EventBus + Kafka\n\n---\n\n# DATA LAYER DEEP-DIVE\n\n## 16. ENTITY HIERARCHY & INHERITANCE\n\n### Base Classes\n```\nBaseEntity (id, created_at, updated_at, created_by, updated_by)\n    └── BaseExternalEntity (+ external_id UUID, version for optimistic locking)\n            ├── OrderEntity\n            ├── PaymentV2Entity\n            ├── PaymentAttemptV2Entity\n            ├── RefundEntity\n            ├── ClientEntity\n            └── CustomerEntity\n```\n\n### Key Entity Files\n| Entity | File | Key Fields |\n|--------|------|------------|\n| OrderEntity | `entity/OrderEntity.java` | clientReferenceId, amount, status, metadata (JSON) |\n| PaymentV2Entity | `entity/v2/PaymentV2Entity.java` | orderId, amount, paymentMode, instrumentDetail (JSON) |\n| PaymentAttemptV2Entity | `entity/v2/PaymentAttemptV2Entity.java` | paymentId, providerReferenceId, gatewayReferenceId, status |\n| RefundEntity | `entity/v2/RefundEntity.java` | orderId, paymentAttemptId, refundType, refundStatus |\n| ClientEntity | `entity/ClientEntity.java` | name, merchantId, settings (OneToMany) |\n\n### Entity Relationships\n```\nClientEntity (1) ──> (M) OrderEntity\nOrderEntity (1) ──> (M) PaymentV2Entity\nPaymentV2Entity (1) ──> (M) PaymentAttemptV2Entity\nPaymentAttemptV2Entity ──> PaymentProviderEntity\nPaymentAttemptV2Entity ──> ProviderAccountEntity\nOrderEntity (1) ──> (M) RefundEntity\nRefundEntity (1) ──> (M) RefundAttemptEntity\n```\n\n---\n\n## 17. MASTER-REPLICA DATABASE ARCHITECTURE\n\n### How Routing Works\n\n**Master (Writes):** `MasterDataSourceConfiguration.java`\n- EntityManagerFactory: `MasterEntityManagerFactory`\n- TransactionManager: `MasterTransactionManager`\n- Excludes beans with `@ReplicaRepository`\n\n**Replica (Reads):** `ReplicaDataSourceConfiguration.java`\n- EntityManagerFactory: `ReplicaEntityManagerFactory`\n- TransactionManager: `ReplicaTransactionManager`\n- Includes ONLY beans with `@ReplicaRepository`\n- Connection pool set to `readOnly=true`\n\n### Usage Pattern\n```java\n// Write to master (default)\n@Repository\npublic interface PaymentRepository extends JpaRepository<...> {}\n\n// Read from replica\n@Repository\n@ReplicaRepository  // <-- Annotation routes to replica\npublic class RefundEntityReplicaDAOImpl extends AbstractReplicaDAOImpl<...> {}\n```\n\n### HikariCP Connection Pools\n| Pool | Config | Purpose |\n|------|--------|---------|\n| hikari_master | masterMinimumIdle, masterMaximumPoolSize | Write operations |\n| hikari_replica | replicaMinimumIdle, replicaMaximumPoolSize, readOnly=true | Read operations |\n\nBoth pools have:\n- idleTimeout, connectionTimeout, maxLifetime\n- leakDetectionThreshold for debugging\n- MaintenanceManager integration for graceful shutdown\n\n---\n\n## 18. REPOSITORY & DAO PATTERNS\n\n### JPA Repository Pattern\n```java\n@Repository\npublic interface OrderRepository extends JpaRepository<OrderEntity, Long> {\n    // FETCH JOIN to prevent N+1 queries\n    @Query(\"SELECT o FROM OrderEntity o \"\n            + \"JOIN FETCH o.customerEntity \"\n            + \"JOIN FETCH o.clientEntity \"\n            + \"WHERE o.externalId = :externalId\")\n    Optional<OrderEntity> findByExternalId(@Param(\"externalId\") String externalId);\n\n    // Property path navigation\n    Optional<OrderEntity> findByClientReferenceIdAndClientEntity_ExternalId(\n            String clientReferenceId, String externalId);\n}\n```\n\n### DAO Pattern (Custom EntityManager)\n```java\n@Repository\npublic class PaymentAttemptDAOV2Impl {\n    @PersistenceContext\n    private EntityManager entityManager;\n\n    public List<PaymentAttemptV2Entity> findByOrderId(Long orderId) {\n        // Complex JPQL with manual EntityManager\n    }\n}\n```\n\n### DynamoDB DAO Pattern\n```java\n@RequiredArgsConstructor\npublic abstract class AbstractDynamoDBDAO<T> {\n    private final DynamoDBMapper dynamoDBMapper;\n\n    public void save(T entity) { dynamoDBMapper.save(entity); }\n    public T findByHashKey(Object hashKey) { return dynamoDBMapper.load(tClass, hashKey); }\n}\n```\n\n---\n\n## 19. JSON COLUMNS & CONVERTERS\n\n**Flexible Attribute Storage:**\n| Column | Converter | Entity |\n|--------|-----------|--------|\n| metadata | ObjectMetadataMapConverter | OrderEntity |\n| instrument_detail | PaymentInstrumentConverter | PaymentV2Entity |\n| instrument_detail | EnrichedPaymentInstrumentConverter | PaymentAttemptV2Entity |\n| routes | RoutesBreakupConverter | PaymentAttemptV2Entity |\n| payment_specific_detail | PaymentSpecificDetailConverter | PaymentV2Entity |\n\n```java\n@Column(name = \"metadata\")\n@Convert(converter = ObjectMetadataMapConverter.class)\nprivate Map<String, String> metaData;\n```\n\n---\n\n## 20. CACHING ARCHITECTURE\n\n### Caffeine Caches (In-Memory)\n| Cache Class | What It Caches | TTL |\n|-------------|----------------|-----|\n| ClientConfigurationCache | Client settings by ID, by externalId, by merchantId | 10-20 min |\n| PaymentProviderCache | Provider configurations | 15-25 min |\n| ProviderAccountCache | Provider account entities | 15-25 min |\n| DecisionTreeObjectCache | Routing decision trees | 180-190 min |\n| FeeCache | Fee configurations | 1 day |\n| CardBinCache | Card BIN details | Configurable |\n| MasterConfigurationCache | Feature flags, system settings | 10-20 min |\n| PaymentErrorMessageMappingCache | Error code to message mappings | Long |\n\n### Cache Pattern\n```java\n@DPCache(cacheName = \"client_configuration_cache\")\nprivate LoadingCache<Long, Map<ClientSettingKey, String>> idCache;\n\n@Override\npublic void buildCache() {\n    idCache = DPCacheBuilder.getBuilder()\n        .refreshAfterWrite(10, MINUTES)  // Lazy refresh\n        .build(this::loadClientSettings);  // Loader function\n}\n```\n\n### Jittered TTLs (Prevent Thundering Herd)\n```java\n// Returns 15-25 instead of fixed 15\nprivate Long generateRandomCacheRefreshInterval(int base) {\n    return base + random.nextInt(10) + 1;\n}\n```\n\n---\n\n## 21. DYNAMODB USAGE\n\n### What Goes Where\n| MySQL | DynamoDB |\n|-------|----------|\n| Orders, Payments, Attempts | Workflow context (TTL-based) |\n| Refunds, Fees | Native OTP details |\n| Clients, Customers | Redirect tracking |\n| Provider configs | Metadata audit trails |\n\n### DynamoDB Entity Example\n```java\n@DynamoDBTable(tableName = \"darwin_payment_attempt_workflow_context\")\npublic class PaymentAttemptWorkflowContextEntity {\n    @DynamoDBHashKey(attributeName = \"payment_attempt_external_id\")\n    private String paymentAttemptExternalId;\n\n    @DynamoDBRangeKey\n    @DynamoDBAttribute(attributeName = \"workflow_step\")\n    private WorkflowStep workflowStep;\n\n    @Builder.Default\n    private long ttl = LocalDateTime.now().plusDays(1).toEpochSecond(ZoneOffset.UTC);\n}\n```\n\n### DynamoDB Tables\n| Table | Partition Key | Sort Key | Purpose |\n|-------|---------------|----------|---------|\n| darwin_payment_attempt_workflow_context | payment_attempt_external_id | workflow_step | Workflow state |\n| darwin_payment_attempt_native_otp_detail | payment_attempt_external_id | - | OTP auth details |\n| darwin_payment_attempt_redirection_detail | payment_attempt_external_id | - | 3DS redirects |\n| darwin_payment_attempt_metadata_audit | payment_attempt_external_id | - | Audit trail |\n\n---\n\n## 22. OPTIMISTIC LOCKING & AUDIT\n\n### @Version for Optimistic Locking\n```java\n@Version\n@Column(name = \"version\")\nprivate Integer version;  // Auto-incremented on each update\n```\n\nPrevents concurrent modification - throws `OptimisticLockException` on conflict.\n\n### Audit Columns (Auto-Managed)\n```java\n@CreationTimestamp\n@Column(name = \"created_at\")\nprivate LocalDateTime createAt;\n\n@UpdateTimestamp\n@Column(name = \"updated_at\")\nprivate LocalDateTime updatedAt;\n\n@PrePersist\npublic void onCreate() {\n    createdBy = ApplicationContext.getApplicationName();\n}\n\n@PreUpdate\npublic void onUpdate() {\n    updatedBy = ApplicationContext.getApplicationName();\n}\n```\n\n---\n\n## 23. DATA LAYER ARCHITECTURE DIAGRAM\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                    Service Layer                        │\n├─────────────────────────────────────────────────────────┤\n│ JPA Repositories      │ Custom DAOs      │ DynamoDB DAOs │\n├─────────────────────────────────────────────────────────┤\n│     Spring Data JPA + Hibernate ORM                     │\n├──────────────────────┬──────────────────────────────────┤\n│   Master DataSource  │      Replica DataSource          │\n│   (Writes)           │      (Reads - @ReplicaRepository)│\n├──────────────────────┼──────────────────────────────────┤\n│ HikariCP Master Pool │   HikariCP Replica Pool          │\n├──────────────────────┴──────────────────────────────────┤\n│         MySQL (payments_multi_tenancy)                  │\n└─────────────────────────────────────────────────────────┘\n         │                              │\n┌────────▼────────┐          ┌──────────▼─────────┐\n│    DynamoDB     │          │  Caffeine Caches   │\n│ (Workflow/Audit)│          │  (Client/Provider) │\n└─────────────────┘          └────────────────────┘\n```\n\n---\n\n## 24. KEY DATA LAYER FILES TO STUDY\n\n### Entity Classes (Priority)\n1. `entity/commons/BaseEntity.java` - Base class pattern\n2. `entity/provider/BaseExternalEntity.java` - External ID + versioning\n3. `entity/OrderEntity.java` - Main order entity\n4. `entity/v2/PaymentAttemptV2Entity.java` - Payment attempt (most complex)\n\n### Database Configuration\n1. `configuration/database/MasterDataSourceConfiguration.java`\n2. `configuration/database/ReplicaDataSourceConfiguration.java`\n3. `configuration/database/annotation/ReplicaRepository.java`\n\n### Repositories\n1. `repository/OrderRepository.java` - FETCH JOIN examples\n2. `repository/PaymentAttemptRepository.java` - Complex queries\n\n### Caches\n1. `cache/ClientConfigurationCache.java` - Cache pattern example\n2. `configuration/CacheConfig.java` - Cache configuration\n\n### DynamoDB\n1. `dynamo/dao/AbstractDynamoDBDAO.java` - Base DAO pattern\n2. `dynamo/domain/PaymentAttemptWorkflowContextEntity.java` - DynamoDB entity\n\n---\n\n# PROVIDER INTEGRATION DEEP-DIVE\n\n## 25. PROVIDER ADAPTER ARCHITECTURE\n\n### Base Adapter Pattern\n**File:** `v2/workflow/create/providers/IPaymentProviderAdapter.java`\n\n```java\npublic abstract class IPaymentProviderAdapter<T, R> implements SelfReferencingBean {\n    protected final PaymentProviderKey paymentProviderKey;  // e.g., CASHFREE, CYBERSOURCE\n    private final InstrumentType instrumentType;            // e.g., CARD, UPI_APPS\n    private final OrderType orderType;                      // e.g., PAY, REFUND\n\n    // Core lifecycle methods\n    public abstract ProviderPaymentResponse createPaymentAttempt(context, customerEntity);\n    protected abstract Object syncPaymentAttemptWithProviderId(paymentAttemptEntity);\n    protected abstract ProviderRefundCreateResponse createRefund(refundAttemptEntity, context);\n    protected abstract R getAuthConfig(providerAccountEntity);\n}\n```\n\n### Factory Pattern for Adapter Selection\n**File:** `v2/workflow/create/providers/PaymentProviderFactory.java`\n\n```java\n@Component\npublic class PaymentProviderFactory {\n    // Multi-dimensional lookup: OrderType + ProviderKey + InstrumentType → Adapter\n    private Map<PaymentWorkflowKey, IPaymentProviderAdapter<?, ?>> paymentProviderMap;\n\n    // Secondary lookup: OrderType + ProviderKey → First adapter\n    private Table<OrderType, PaymentProviderKey, IPaymentProviderAdapter<?, ?>> paymentProviderByKey;\n\n    // 3DS variant support\n    private ThreeDSType threeDSType;  // 3DS1 vs 3DS2\n}\n```\n\n### Provider Response Structure\n```java\n@Data @Builder\npublic class ProviderPaymentResponse {\n    private Object providerResponseObject;     // Raw provider response\n    private String providerReferenceId;        // Provider's transaction ID\n    private String gatewayReferenceId;         // Gateway ID\n    private String providerStatus;             // Raw status (\"SUCCESS\")\n    private PaymentAttemptStatus status;       // Mapped internal status\n    private ProviderRequestStatus providerRequestStatus;  // REQUEST_SUCCESS, RETRY_ABLE_FAILURE\n    private ProviderError providerError;       // Error details if failed\n}\n```\n\n---\n\n## 26. DECISION TREE ROUTING\n\n### Router Strategy Pattern\n**File:** `planner/providerdecider/ProviderDeciderRouter.java`\n\n```java\n@Service\npublic class ProviderDeciderRouter {\n    public ProviderRoutingDecisionResult resolve(PaymentAttemptCreateContext context) {\n        // Priority 1: LCM routing (if instrument supported)\n        if (isInstrumentTypeSupportedInLCM(clientId, instrumentType)) {\n            return providerDeciderViaLCM.decideProvider(context);\n        }\n\n        // Priority 2: Decision Tree routing\n        if (isDecisionTreeEnabled) {\n            return providerDeciderV2.decideProvider(context);\n        }\n    }\n}\n```\n\n### Decision Tree Workflow\n**File:** `planner/providerdecider/ProviderDeciderV2.java`\n\n```\nRequest → Fetch Cached Decision Tree → Create DT Context → Execute Tree → Apply Dynamic Routing → Return Provider\n```\n\n**Decision Tree Factors:**\n- Client configuration\n- Instrument type (Card, UPI, NetBanking)\n- Card brand/BIN\n- Customer attributes\n- Order amount\n- Provider availability/downtime\n\n### Decision Tree Caching\n**File:** `cache/DecisionTreeObjectCache.java`\n\n| Cache | TTL | Content |\n|-------|-----|---------|\n| decision_tree_object_cache | 180-190 min | Parsed decision tree JSON + workflow |\n\n---\n\n## 27. PROVIDER ADAPTERS (24+ Implementations)\n\n### Adapter Directory Structure\n```\nv2/workflow/create/providers/\n├── IPaymentProviderAdapter.java          # Base abstract class\n├── PaymentProviderFactory.java           # Factory for adapter selection\n├── CashfreeProviderAdapter.java          # Cashfree base\n├── CashfreeCardProviderAdapter.java      # Cashfree cards\n├── CashfreeNetBankingProviderAdapter.java\n├── CashfreeUPIProviderAdapter.java\n├── CashfreeUPIAppsProviderAdapter.java\n├── cybersource/\n│   ├── CybersourceProviderAdapter.java   # Cybersource base (3DS)\n│   ├── CybersourceRequestBuilder.java    # Request construction\n│   └── CybersourceAuthorizeRequestBuilder.java\n├── PayuProviderAdapter.java\n├── PayuCardProviderAdapter.java\n├── PineLabsEdgeProviderAdapter.java\n├── CredPointsProviderAdapter.java\n├── RewardPointsProviderAdapter.java\n└── AuthTokenNativeProviderAdapter.java\n```\n\n### Cashfree Adapter Example\n**File:** `v2/workflow/create/providers/CashfreeProviderAdapter.java`\n\n```java\n@Component\npublic abstract class CashfreeProviderAdapter\n        extends IPaymentProviderAdapter<String, CashfreeAuthConfig> {\n\n    // Two-phase payment creation:\n    // 1. Create order at Cashfree\n    // 2. Create payment for that order\n\n    @Override\n    public ProviderPaymentResponse createPaymentAttempt(context, customer) {\n        // Phase 1: Create CF Order\n        Pair<BaseResponse<CreateOrderResponse>, ProviderError> orderResponse =\n            createCFOrder(context, authConfig);\n\n        // Phase 2: Create CF Payment\n        Pair<BaseResponse<CreatePaymentResponse>, ProviderError> paymentResponse =\n            createCFPayment(context, orderResponse.getLeft().getResponse(), authConfig);\n\n        return mapToProviderPaymentResponse(paymentResponse);\n    }\n}\n```\n\n### Cybersource Adapter (3DS Support)\n**File:** `v2/workflow/create/providers/cybersource/CybersourceProviderAdapter.java`\n\n```java\n@Component\npublic abstract class CybersourceProviderAdapter\n        extends I3DSPaymentProviderAdapter<String, AuthConfig> {\n\n    // Status code mappings\n    private static final List<String> FAILED_STATUSES = Arrays.asList(\n        \"101\", \"102\", \"104\", \"150\", \"200\", \"201\", ...  // 43 codes\n    );\n    private static final List<String> PROCESSING_STATUSES = Arrays.asList(\n        \"110\", \"475\", \"480\"\n    );\n\n    // 3DS2 redirection flow\n    protected void createRedirectionHtml(response, paymentAttemptEntity) {\n        if (authInfo.getSpecificationVersion().startsWith(\"2\")) {\n            // 3DS2 flow with step-up URL\n            html = authenticationService.createAuthenticationPageFor3ds2(\n                authInfo.getStepUpUrl(),\n                authInfo.getAccessToken(),\n                paymentAttemptEntity.getExternalId());\n        }\n    }\n}\n```\n\n---\n\n## 28. WEBHOOK HANDLING\n\n### Webhook Architecture\n```\nProvider → /webhooks/v2/{provider} → Provider-Specific Controller → WebhookService → State Machine Update\n```\n\n### Provider Webhook Controllers\n| Endpoint | Controller | Provider |\n|----------|------------|----------|\n| `/webhooks/v2/cashfree` | CashfreeWebhookController | Cashfree |\n| `/webhooks/v2/razorpay` | RazorpayWebhookController | Razorpay |\n| `/webhooks/v2/payu` | PayuWebhookController | PayU |\n| `/webhooks/v2/cybersource` | CybersourceWebhookController | Cybersource |\n| `/webhooks/v2/juspay` | JuspayWebhookController | Juspay |\n| `/webhooks/v2/ybl` | YBLWebhookController | Yes Bank UPI |\n| `/webhooks/v2/icici` | ICICIWebhookController | ICICI UPI |\n| `/webhooks/v2/rbl-upi` | RBLUpiWebhookController | RBL UPI |\n| `/webhooks/v2/digio` | DigioWebhookController | Digio (eMandate) |\n\n### Webhook Processing Flow\n**File:** `controller/v2/CashfreeWebhookController.java`\n\n```java\n@PostMapping\npublic void onWebhookReceive(@RequestBody CashfreeWebhook webhookRequest) {\n    switch (webhookRequest.getType()) {\n        case PAYMENT_SUCCESS_WEBHOOK:\n        case PAYMENT_FAILED_WEBHOOK:\n            // 1. Extract provider reference ID\n            String providerRefId = paymentWebhook.getData().getCfPaymentId();\n\n            // 2. Fetch payment attempt\n            PaymentAttempt attempt = paymentAttemptFetchWorkflow\n                .fetchByProviderReferenceId(providerRefId);\n\n            // 3. Audit webhook data\n            auditService.auditProviderData(webhookRequest, attempt.getId(), ...);\n\n            // 4. Sync status (triggers state machine)\n            break;\n\n        case REFUND_STATUS_WEBHOOK:\n            processRefundAttempt(webhookRequest);\n            break;\n    }\n}\n```\n\n### Idempotency Handling\n```java\n// In base adapter - only update if status actually changed\npublic void syncPaymentAttemptWithProvider(PaymentAttemptV2Entity entity) {\n    String currentStatus = entity.getProviderStatus();\n\n    Object providerResponse = syncPaymentAttemptWithProviderId(entity);\n\n    // Only audit and process if status changed\n    if (!Objects.equals(currentStatus, entity.getProviderStatus())) {\n        auditService.auditProviderData(...);\n    }\n}\n```\n\n---\n\n## 29. PROVIDER CONFIGURATION\n\n### Configuration Entities\n**File:** `entity/ProviderAccountEntity.java`\n\n```java\n@Entity @Table(name = \"provider_accounts\")\npublic class ProviderAccountEntity extends BaseEntity {\n    @ManyToOne\n    private PaymentProviderEntity paymentProvider;\n\n    private String providerAccountId;     // e.g., \"ACC_123456\"\n\n    @Lob\n    private byte[] accessToken;           // Encrypted credentials\n\n    private String endpoint;              // Provider API endpoint\n    private Boolean isProd;               // Production vs Sandbox\n    private Boolean active;\n    private String additionalConfig;      // JSON configuration\n    private String providerMid;           // Merchant ID at provider\n    private String settlementCategory;    // Settlement routing\n}\n```\n\n### Provider-Specific Configurations\n```java\n// Cashfree\n@Data\npublic class CashfreeProviderAccountConfiguration {\n    private String apiClientId;\n    private String apiVersion;\n    private ShortCircuitConfiguration shortCircuitConfiguration;\n}\n\n// Cybersource\n@Data\npublic class CybersourceProviderAccountConfiguration {\n    private String apiKey;\n    private String merchantId;\n    private Boolean enableRetries = false;\n    private Boolean enableCaptureWithAuth = true;\n    private Boolean enable3DS2 = true;\n    private Boolean enableRedirectionFlow = false;\n}\n```\n\n### Client-Provider Mapping\n**File:** `entity/ClientPaymentProviderConfigEntity.java`\n\n```java\n@Entity @Table(name = \"client_payment_provider_config\")\npublic class ClientPaymentProviderConfigEntity extends BaseEntity {\n    @ManyToOne private ClientEntity client;\n    @ManyToOne private PaymentProviderEntity paymentProvider;\n    private String providerConfig;  // JSON configuration per client\n}\n```\n\n---\n\n## 30. ERROR HANDLING & RETRY LOGIC\n\n### Error Classification\n```java\npublic enum ProviderRequestStatus {\n    REQUEST_SUCCESS,          // Payment processed\n    RETRY_ABLE_FAILURE,       // Timeout, rate limit - can retry\n    NON_RETRY_ABLE_FAILURE    // Invalid request - cannot retry\n}\n```\n\n### Provider Error Structure\n```java\n@Data @Builder\npublic class ProviderError {\n    private String message;           // User-friendly message\n    private String code;              // Provider error code\n    private Object providerResponse;  // Raw error response\n    private Boolean retryable;        // Retry classification\n}\n```\n\n### Error Code Mapping (Cybersource Example)\n```java\n// Failure codes (43 codes)\n\"101\", \"102\", \"104\", \"150\", \"200\", \"201\", \"202\", \"203\", ...\n\n// Processing/Pending codes\n\"110\" (Pending), \"475\" (Timeout), \"480\" (Processing)\n```\n\n### Retry Pattern\n```java\npublic ProviderPaymentResponse executePaymentAttempt(...) {\n    try {\n        return pilotMethod.apply(context, providerCustomer);\n    } catch (RateLimitException rle) {\n        return ProviderPaymentResponse.builder()\n            .providerRequestStatus(ProviderRequestStatus.RETRY_ABLE_FAILURE)\n            .providerError(ProviderError.builder()\n                .retryable(true).build())\n            .build();\n    } catch (AppException ae) {\n        return ProviderPaymentResponse.builder()\n            .providerRequestStatus(ProviderRequestStatus.NON_RETRY_ABLE_FAILURE)\n            .build();\n    }\n}\n```\n\n---\n\n## 31. ARCHITECTURAL PATTERNS SUMMARY\n\n| Pattern | Usage | File |\n|---------|-------|------|\n| **Factory** | Adapter selection by (OrderType, Provider, Instrument) | PaymentProviderFactory.java |\n| **Strategy** | LCM vs Decision Tree routing | ProviderDeciderRouter.java |\n| **Template Method** | Base adapter lifecycle | IPaymentProviderAdapter.java |\n| **Builder** | Complex request construction | CybersourceRequestBuilder.java |\n| **Decorator** | Provider-specific configuration | *ConfigValueDecoratorImpl.java |\n\n---\n\n## 32. KEY PROVIDER INTEGRATION FILES\n\n### Core Architecture\n1. `v2/workflow/create/providers/IPaymentProviderAdapter.java` - Base adapter\n2. `v2/workflow/create/providers/PaymentProviderFactory.java` - Factory\n3. `planner/providerdecider/ProviderDeciderRouter.java` - Routing strategy\n\n### Decision Tree\n1. `planner/providerdecider/ProviderDeciderV2.java` - DT workflow\n2. `planner/providerdecider/ProviderDeciderViaLCM.java` - LCM routing\n3. `cache/DecisionTreeObjectCache.java` - DT caching\n\n### Webhooks\n1. `controller/WebhookController.java` - Generic webhook endpoint\n2. `controller/v2/CashfreeWebhookController.java` - Cashfree webhooks\n3. `service/WebhookService.java` - Webhook processing\n\n### Provider Implementations\n1. `v2/workflow/create/providers/CashfreeProviderAdapter.java`\n2. `v2/workflow/create/providers/cybersource/CybersourceProviderAdapter.java`\n3. `v2/workflow/create/providers/PayuProviderAdapter.java`\n\n### Configuration\n1. `entity/ProviderAccountEntity.java` - Provider credentials\n2. `entity/PaymentProviderEntity.java` - Provider definition\n3. `entity/ClientPaymentProviderConfigEntity.java` - Client-provider mapping\n\n---\n\n# PAYMENT FLOW DEEP-DIVE\n\n## 33. THE 7-STEP WORKFLOW PIPELINE\n\n### Base Workflow Pattern (Template Method)\n**File:** `v2/workflow/create/Workflow.java`\n\n```java\npublic Response execute(Request request) {\n    // STEP 1: Validate inputs and enrich context\n    Context context = validateAndEnrichContext(request);\n\n    // STEP 2: Persist to relational DB (transactional)\n    persistIntent(context);\n\n    // STEP 3: Pre-persist event hooks\n    publishEntityPrePersistEvents(context);\n\n    // STEP 4: Persist to non-relational DB (DynamoDB)\n    persistNonRelationalIntent(context);\n\n    // STEP 5: Process (external provider calls)\n    process(context);\n\n    // STEP 6: Post-process and save results (transactional)\n    Response response = postProcess(context);\n\n    // STEP 7: Post-persist & publish events\n    postPersistNonRelationalDataStore(context);\n    publishEntityChangeEvents(context);\n\n    throwErrorIfRequired(context);\n    return response;\n}\n```\n\n---\n\n## 34. PAYMENTATTEMPTCREATEWORKFLOW DETAILED\n\n**File:** `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java`\n\n### Step 1: Validate & Enrich Context\n\n| Enricher | Purpose | Output |\n|----------|---------|--------|\n| `InstrumentTypeProcessorManager` | Validate & enrich payment instrument | `InstrumentTypeProcessorResult` |\n| `ProviderDeciderRouter.resolve()` | Route to provider via Decision Tree | `ProviderRoutingDecisionResult` |\n| `AuthTypeDeciderFactory` | Determine auth type (3DS, OTP, None) | `AuthType` |\n| `NativeProviderDecider` | Select native OTP provider | `ProviderAccountEntity` |\n| `SettlementRouteValidator` | Validate & enrich settlement routes | `RoutesBreakup` |\n| `MandateServiceDataManager` | Register mandate (if eMandate) | `Mandate` |\n\n### Context Object Structure\n```java\nPaymentAttemptCreateContext {\n    // Request/Response\n    CreatePaymentAttemptRequest request\n    PaymentAttemptResponse response\n\n    // Entities\n    PaymentAttemptV2Entity paymentAttemptEntity\n    PaymentV2Entity paymentEntity\n    OrderEntity orderEntity\n    CustomerEntity customerEntity\n    ClientEntity clientEntity\n\n    // Enriched Data\n    InstrumentTypeProcessorResult instrumentProcessorResult\n    ProviderAccountEntity providerAccountEntity\n    ProviderRoutingDecisionResult routingDecisionResult\n    AuthType authType\n    RoutesBreakup routesBreakup\n    ProviderPaymentResponse createResponse\n\n    // OTP/Auth Flow\n    Boolean isPlatformNativeOtpSupported\n    PaymentAttemptNativeOTPDetailEntity nativeOTPDetailEntity\n\n    // Error Collection\n    List<WorkflowInternalError> errors\n}\n```\n\n### Step 2: Persist Intent\n```java\n@Transactional(transactionManager = \"MasterTransactionManager\")\npublic void persistIntent(PaymentAttemptCreateContext context) {\n    // Create PaymentAttemptV2Entity\n    PaymentAttemptV2Entity entity = PaymentAttemptV2Entity.builder()\n        .externalId(PaymentAttemptUUIdGenerator.generate())\n        .status(PaymentAttemptStatus.CREATED)\n        .paymentEntity(paymentEntity)\n        .providerAccountEntity(providerAccountEntity)\n        .paymentMethod(instrumentResult.getPaymentMethod())\n        .instrumentDetail(instrumentResult.getEnrichedInstrument())\n        .routesBreakup(routesBreakup)\n        .build();\n\n    // Save to repository\n    paymentAttemptRepository.save(entity);\n\n    // Save fees\n    feeCreateWorkflow.persistIntent(feeContexts);\n\n    // Add attributes (DT_ID, DT_RESULT, etc.)\n    enrichAttributes(entity);\n}\n```\n\n### Step 5: Process (Provider Call)\n```java\npublic void process(PaymentAttemptCreateContext context) {\n    // Find adapter\n    IPaymentProviderAdapter adapter = paymentProviderFactory\n        .findPaymentProviderAdapter(orderType, providerKey, instrumentType, threeDSType);\n\n    // Execute provider call\n    ProviderPaymentResponse response = adapter.executePaymentAttempt(\n        context,\n        adapter::createPaymentAttempt,\n        FlowType.CREATE\n    );\n\n    // Check platform OTP capability\n    response = checkIfPlatformOtpEnabled(context, response);\n\n    context.setCreateResponse(response);\n}\n```\n\n### Step 6: Post-Process\n```java\n@Transactional\npublic PaymentAttemptResponse postProcess(PaymentAttemptCreateContext context) {\n    PaymentAttemptV2Entity entity = context.getPaymentAttemptEntity();\n    ProviderPaymentResponse response = context.getCreateResponse();\n\n    // Update from provider response\n    entity.setProviderStatus(response.getProviderStatus());\n    entity.setProviderReferenceId(response.getProviderReferenceId());\n    entity.setGatewayReferenceId(response.getGatewayReferenceId());\n\n    // Determine final status\n    if (response.getProviderRequestStatus() == REQUEST_SUCCESS) {\n        entity.setStatus(response.getStatus());\n    } else if (isEligiblePaymentMode) {\n        entity.setStatus(response.getStatus() == FAILED ? FAILED : PROCESSING);\n    }\n\n    paymentAttemptRepository.save(entity);\n    return mapper.toResponse(entity, response);\n}\n```\n\n### Step 7: Publish Events\n```java\npublic void publishEntityChangeEvents(PaymentAttemptCreateContext context) {\n    // Post to sync EventBus (triggers PaymentStateMachine)\n    syncBus.post(PaymentAttemptEventFactory.findEvent(paymentAttemptEntity));\n\n    // Post to async EventBus\n    asyncBus.post(PaymentAttemptEventFactory.findEvent(paymentAttemptEntity));\n\n    // Publish to multi-tenant event system\n    eventiService.publishEvent(paymentAttemptEntity);\n\n    // Add to sync manager for webhook updates\n    syncManager.addEntityForSync(paymentAttemptEntity);\n}\n```\n\n---\n\n## 35. STATE MACHINE IMPLEMENTATION\n\n### PaymentStateMachine\n**File:** `statemachine/payment/PaymentStateMachine.java`\n\n```\nEvent Subscriptions:\n├── @Subscribe onPaymentAttemptCreated\n│   └── Payment: FAILED → CREATED\n├── @Subscribe onPaymentAttemptFailed\n│   └── If all attempts failed: Payment → FAILED\n├── @Subscribe onPaymentAttemptCompleted\n│   └── Payment → COMPLETED (with optimistic lock retry)\n├── @Subscribe onPaymentAttemptAuthorized\n│   └── Payment → AUTHORIZED\n├── @Subscribe onPaymentAttemptProcessing\n│   └── Payment → PROCESSING\n├── @Subscribe onPaymentAttemptBlocked\n│   └── Payment → BLOCKED\n└── @Subscribe onAuthenticationSuccessful/Failed\n    └── Payment → AUTHENTICATION_SUCCESSFUL/FAILED\n```\n\n### OrderStateMachine\n**File:** `statemachine/order/OrderStateMachine.java`\n\n```\nEvent Subscriptions:\n├── @Subscribe onPaymentCreated\n│   └── Order → CREATED or AUTHLESS_READY_TO_PROCESS\n├── @Subscribe onPaymentFailed\n│   └── Order → FAILED\n├── @Subscribe onPaymentCompleted\n│   └── Order → COMPLETED (if all payments done)\n├── @Subscribe onPaymentAuthorized\n│   └── Order → AUTHORIZED\n└── @Subscribe onPaymentProcessing\n    └── Order → PROCESSING\n```\n\n### Terminal States\n| Entity | Terminal States |\n|--------|-----------------|\n| PaymentAttempt | COMPLETED, FAILED, FORCE_FAILED |\n| Payment | COMPLETED, FAILED, FORCE_FAILED, DISCARDED |\n| Order | COMPLETED, FAILED |\n\n### State Transition Guard\n```java\nprivate boolean shouldUpdatePaymentStatus(PaymentV2Entity entity) {\n    return !Arrays.asList(COMPLETED, FAILED, FORCE_FAILED, DISCARDED)\n        .contains(entity.getStatus());\n}\n```\n\n---\n\n## 36. END-TO-END PAYMENT FLOW\n\n```\n┌─────────────────────────────────────────────────────────────────────────┐\n│                         CLIENT REQUEST                                   │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  1. ORDER CREATION                                                       │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ OrderCreateWorkflow.execute()                                       │ │\n│  │ ├── validateAndEnrichContext() - Customer lookup, order validation │ │\n│  │ ├── persistIntent() - Save OrderEntity (status: CREATED)           │ │\n│  │ └── publishEvents() → OrderStateMachine                            │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  2. PAYMENT CREATION                                                     │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ BulkPaymentCreateWorkflow.execute()                                 │ │\n│  │ ├── validateAndEnrichContext() - Payment mode validation           │ │\n│  │ ├── persistIntent() - Save PaymentV2Entity (status: CREATED)       │ │\n│  │ └── publishEvents() → PaymentStateMachine                          │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  3. PAYMENT ATTEMPT CREATION (Core Flow)                                 │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ PaymentAttemptCreateWorkflow.execute()                              │ │\n│  │ ├── validateAndEnrichContext()                                     │ │\n│  │ │   ├── InstrumentTypeProcessorManager (Card/UPI/NetBanking)       │ │\n│  │ │   ├── ProviderDeciderRouter (Decision Tree routing)              │ │\n│  │ │   ├── AuthTypeDeciderFactory (3DS/OTP/None)                      │ │\n│  │ │   └── SettlementRouteValidator                                   │ │\n│  │ ├── persistIntent() - Save PaymentAttemptV2Entity                  │ │\n│  │ ├── persistNonRelationalIntent() - DynamoDB (OTP details)          │ │\n│  │ ├── process() - Provider API call via Adapter                      │ │\n│  │ ├── postProcess() - Update entity with provider response           │ │\n│  │ └── publishEvents() → PaymentStateMachine → OrderStateMachine      │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  4. PROVIDER API RESPONSE                                                │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ ProviderPaymentResponse contains:                                   │ │\n│  │ ├── providerStatus: \"SUCCESS\" / \"PENDING\" / \"FAILED\"               │ │\n│  │ ├── providerReferenceId: Provider's transaction ID                 │ │\n│  │ ├── status: PaymentAttemptStatus (mapped)                          │ │\n│  │ ├── transactionResponse:                                           │ │\n│  │ │   ├── authentication: { url, method } (for 3DS redirect)         │ │\n│  │ │   └── sdkParams: Native OTP/SDK details                          │ │\n│  │ └── providerError: Error details if failed                         │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n         ┌──────────────────────────┴──────────────────────────┐\n         ▼                                                      ▼\n┌─────────────────────────┐                    ┌─────────────────────────┐\n│  5A. 3DS/OTP FLOW       │                    │  5B. DIRECT SUCCESS     │\n│  ┌───────────────────┐  │                    │  ┌───────────────────┐  │\n│  │ Client performs   │  │                    │  │ Status: COMPLETED │  │\n│  │ authentication    │  │                    │  │ Payment done!     │  │\n│  │ (redirect/native) │  │                    │  └───────────────────┘  │\n│  └───────────────────┘  │                    └─────────────────────────┘\n│           │             │\n│           ▼             │\n│  ┌───────────────────┐  │\n│  │ Authenticate      │  │\n│  │ Workflow called   │  │\n│  │ with OTP/callback │  │\n│  └───────────────────┘  │\n└─────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  6. WEBHOOK / SYNC UPDATE                                                │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ Provider sends webhook OR SyncManager polls status                  │ │\n│  │ ├── WebhookController receives update                              │ │\n│  │ ├── adapter.syncPaymentAttemptWithWebhook()                        │ │\n│  │ ├── Update PaymentAttemptV2Entity status                           │ │\n│  │ └── publishEvents() → State machines cascade updates               │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  7. FINAL STATE                                                          │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ PaymentAttempt: COMPLETED ──► Payment: COMPLETED ──► Order: COMPLETED│\n│  │                                                                     │ │\n│  │ eventiService.publishEvent() → Client webhook notification          │ │\n│  │ eventiService.publishToPinot() → Analytics dashboard               │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## 37. 3DS / NATIVE OTP AUTHENTICATION\n\n### Native OTP Flow (Card Payments)\n```\n1. PaymentAttemptCreateWorkflow detects CARD + OTP-capable BIN\n2. wspService.isPlatformNativeOtpEnabled() returns true\n3. Provider returns redirect URL, but we override with SDK params\n4. CardNativeOTPSDKParamDetail created:\n   ├── authType: NATIVE_OTP\n   ├── challengeId: UUID\n   ├── fallbackUrl: Provider's original auth URL\n   └── submitOTPAllowed: true\n\n5. PaymentAttemptNativeOTPDetailEntity saved to DynamoDB\n6. Client submits OTP via PaymentAttemptAuthenticateWorkflow\n7. Provider validates OTP, returns success/failure\n8. State machines update payment/order status\n```\n\n### 3DS Redirect Flow\n```\n1. Provider returns authentication URL\n2. Client redirects to issuer's 3DS page\n3. User completes authentication\n4. Callback to return_url\n5. ValidateAuthenticationWorkflow processes callback\n6. Provider confirms authentication status\n7. State machines update accordingly\n```\n\n---\n\n## 38. INSTRUMENT PROCESSING\n\n### InstrumentTypeProcessorManager\n**File:** `processors/instrumenttype/InstrumentTypeProcessorManager.java`\n\n```java\n// Routes to specific processor based on instrument type\nIInstrumentTypeProcessor processor = processorByType.get(instrument.getType());\nreturn processor.validatePaymentInstrumentAndEnrich(instrument);\n```\n\n### Processor Implementations\n| Processor | InstrumentType | Enrichment |\n|-----------|----------------|------------|\n| `CardInstrumentTypeProcessor` | CARD | BIN lookup, issuer, card type |\n| `UPIPayInstrumentTypeProcessor` | UPI_APPS | VPA validation, provider |\n| `UPICollectInstrumentTypeProcessor` | UPI_COLLECT | QR code, timeout |\n| `NetBankingInstrumentTypeProcessor` | NET_BANKING | Bank code, issuer |\n| `EMandateInstrumentTypeProcessor` | NET_BANKING_WITH_PI | Mandate details |\n\n### InstrumentTypeProcessorResult\n```java\nInstrumentTypeProcessorResult<R, S> {\n    PaymentInstrumentGroup paymentMethod;  // CARD, UPI_PAY, etc.\n    R paymentSubMethodDetail;              // CardPaymentSubMethodDetail\n    S enrichedPaymentInstrument;           // CardEnrichedPaymentInstrument\n}\n```\n\n---\n\n## 39. DISTRIBUTED LOCKING\n\n### SequentialWorkflow Pattern\n**File:** `v2/workflow/create/SequentialWorkflow.java`\n\n```java\npublic Response execute(Request request) {\n    LockSetting lockSetting = fetchLockSetting();\n    String lockKey = evaluateLockKey(request, lockSetting.getLockKey());\n\n    // Acquire Redis distributed lock\n    Optional<RLock> lock = redisLockUtil.acquireLock(lockKey, flowType);\n\n    if (lock.isPresent() || !lockSetting.getIsLockMandatory()) {\n        try {\n            return super.execute(request);  // Run workflow\n        } finally {\n            lock.ifPresent(redisLockUtil::releaseLock);\n        }\n    }\n    throw Error.unable_to_acquire_lock.getBuilder().build();\n}\n```\n\n**Use Cases:**\n- Prevents concurrent payment attempts on same order\n- Ensures single webhook processing per transaction\n- Avoids race conditions in status updates\n\n---\n\n## 40. KEY PAYMENT FLOW FILES\n\n### Core Workflows\n1. `v2/workflow/create/Workflow.java` - Base template\n2. `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java` - Main flow\n3. `v2/workflow/create/payments/bulk/BulkPaymentCreateWorkflow.java` - Payment creation\n4. `v2/workflow/authenticate/PaymentAttemptAuthenticateWorkflow.java` - OTP auth\n\n### State Machines\n1. `statemachine/payment/PaymentStateMachine.java`\n2. `statemachine/order/OrderStateMachine.java`\n3. `statemachine/RefundStateMachine.java`\n\n### Instrument Processing\n1. `processors/instrumenttype/InstrumentTypeProcessorManager.java`\n2. `processors/instrumenttype/CardInstrumentTypeProcessor.java`\n3. `processors/instrumenttype/UPIPayInstrumentTypeProcessor.java`\n\n### Context & Events\n1. `v2/workflow/create/paymentattempts/PaymentAttemptCreateContext.java`\n2. `statemachine/payment/events/PaymentAttemptEventFactory.java`\n3. `statemachine/order/events/OrderEventFactory.java`\n\n---\n\n## 41. ARCHITECTURAL PATTERNS SUMMARY\n\n| Pattern | Implementation | Purpose |\n|---------|----------------|---------|\n| **Template Method** | `Workflow.execute()` 7-step pipeline | Consistent execution flow |\n| **Factory** | `PaymentProviderFactory`, `InstrumentTypeProcessorManager` | Dynamic component selection |\n| **Strategy** | `AuthTypeDeciderFactory`, `SdkTypeDeciderFactory` | Pluggable algorithms |\n| **Observer** | Guava EventBus, State Machines | Decoupled state transitions |\n| **Context Object** | `PaymentAttemptCreateContext` | Data flow through pipeline |\n| **Distributed Lock** | `SequentialWorkflow` + Redis | Concurrency control |\n| **Event Sourcing** | DynamoDB workflow context | Audit trail |\n\n---\n\n## 42. COMPLETE STUDY GUIDE SUMMARY\n\nYou now have a **42-section expert study guide** covering:\n\n### Foundation (Sections 1-15)\n- Tech stack, project structure, core concepts\n- API endpoints, authentication, dependencies\n\n### Data Layer Deep-Dive (Sections 16-24)\n- Entity hierarchy, Master-Replica DB\n- Repository patterns, caching, DynamoDB\n\n### Provider Integration Deep-Dive (Sections 25-32)\n- Adapter architecture, Decision Tree routing\n- Webhook handling, provider configuration\n- Error handling and retry logic\n\n### Payment Flow Deep-Dive (Sections 33-41)\n- 7-step workflow pipeline\n- State machine implementation\n- End-to-end payment flow\n- 3DS/OTP authentication\n- Instrument processing\n- Distributed locking\n"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":14913,"cache_read_input_tokens":110309,"cache_creation":{"ephemeral_5m_input_tokens":14913,"ephemeral_1h_input_tokens":0},"output_tokens":492}},"type":"assistant","uuid":"4ffc080e-674f-45ff-994b-932d85b05beb","timestamp":"2025-12-31T09:54:48.346Z"}
{"parentUuid":"4ffc080e-674f-45ff-994b-932d85b05beb","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"User has approved your plan. You can now start coding. Start with updating your todo list if applicable\n\nYour plan has been saved to: /Users/kiranbiliyawala/.claude/plans/distributed-marinating-mango.md\nYou can refer back to it if needed during implementation.\n\n## Approved Plan:\n# Payment Service (Darwin) - Expert Study Guide\n\nA comprehensive guide to understanding the payment-service repository.\n\n---\n\n## 1. OVERVIEW & TECH STACK\n\n**Project Name:** Darwin (internal name for payment-service)\n**Purpose:** Enterprise-grade payment processing microservice handling multi-provider payment orchestration\n\n| Technology | Version | Purpose |\n|------------|---------|---------|\n| Java | 17 | Runtime |\n| Spring Boot | 2.7.14 | Framework |\n| Gradle | 7.6 | Build |\n| MySQL | - | Primary Database (Master-Replica) |\n| DynamoDB | - | Audit/State Storage |\n| Redis (Redisson) | 3.19.1 | Distributed Cache |\n| Kafka | - | Event Streaming |\n| AWS SQS | - | Task Processing |\n\n**Server:** Port 9010, Context Path: `/payments`\n\n---\n\n## 2. PROJECT STRUCTURE\n\n```\npayment-service/\n├── src/main/java/in/dreamplug/darwin/\n│   ├── controller/         # REST API endpoints\n│   │   └── v2/             # V2 API controllers (primary)\n│   ├── service/            # Business logic services\n│   ├── v2/\n│   │   ├── service/        # V2 services\n│   │   └── workflow/       # Payment workflows (CRITICAL)\n│   │       └── create/\n│   │           ├── payments/       # Payment creation\n│   │           ├── paymentattempts/ # Payment attempt creation\n│   │           └── providers/      # Provider adapters (24+)\n│   ├── entity/             # JPA entities\n│   │   └── v2/             # V2 entities (primary)\n│   ├── repository/         # Data access layer\n│   ├── statemachine/       # Payment/Order state machines\n│   ├── planner/            # Decision tree routing\n│   ├── cache/              # Caching layer (Caffeine)\n│   ├── client/             # External service clients\n│   ├── provider/           # Legacy provider implementations\n│   ├── configuration/      # Spring configs\n│   │   └── database/       # DB configs (Master/Replica)\n│   ├── kafka/              # Kafka producers/consumers\n│   ├── sqs/                # SQS message processors\n│   ├── dynamo/             # DynamoDB DAOs\n│   ├── error/              # Error handling\n│   ├── dto/                # Data transfer objects\n│   └── commons/spring/filters/  # Auth/Context filters\n├── src/main/resources/\n│   └── application.properties  # Main config (1300+ lines)\n├── codepipeline/           # CI/CD configurations\n├── build.gradle            # Dependencies\n└── Dockerfile              # Container setup\n```\n\n---\n\n## 3. CORE PAYMENT FLOW (CRITICAL)\n\n### 3.1 Payment Lifecycle\n\n```\nOrder Created → Payments Created → Payment Attempt Created → Provider API Call → Webhook/Status Update\n```\n\n**Key Steps:**\n\n1. **Order Creation** - Client creates an order with amount, currency, metadata\n2. **Bulk Payment Creation** - Multiple payment records created for the order\n   - File: `v2/workflow/create/payments/bulk/BulkPaymentCreateWorkflow.java`\n3. **Payment Attempt Creation** - Actual payment attempt with provider routing\n   - File: `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java`\n4. **Provider Processing** - Provider adapter calls external payment gateway\n5. **State Machine Updates** - Events trigger state transitions\n\n### 3.2 Workflow Execution Pipeline\n\n```java\n// Base workflow pattern (Workflow.java)\n1. validateAndEnrichContext()  // Validate inputs, enrich data\n2. persistIntent()             // Save entities to MySQL\n3. persistNonRelationalIntent() // Save to DynamoDB\n4. process()                   // Call provider API\n5. postProcess()               // Transform results\n6. publishEntityChangeEvents() // Trigger state machines\n7. throwErrorIfRequired()      // Handle errors\n```\n\n### 3.3 Payment Attempt Data Enrichment\n\n1. **Instrument Validation** - `InstrumentTypeProcessorManager`\n2. **Provider Routing** - `ProviderDeciderRouter` → Decision Tree\n3. **Auth Type Decision** - `AuthTypeDeciderFactory` (3DS, OTP, None)\n4. **Settlement Validation** - `SettlementRouteValidator`\n\n---\n\n## 4. STATE MACHINES\n\n### 4.1 Payment State Machine\n**File:** `statemachine/payment/PaymentStateMachine.java`\n\n```\nCREATED → PROCESSING → AUTHORIZED → COMPLETED\n                   ↘ FAILED\n                   ↘ BLOCKED\n```\n\n**Terminal States:** COMPLETED, FAILED, FORCE_FAILED, DISCARDED\n\n### 4.2 Order State Machine\n**File:** `statemachine/order/OrderStateMachine.java`\n\n- Reacts to payment events\n- Updates order status based on payment outcomes\n\n### 4.3 Events (EventBus - Guava)\n- `PaymentAttemptCreatedEvent`\n- `PaymentAttemptCompletedEvent`\n- `PaymentAttemptFailedEvent`\n- `PaymentAttemptProcessingEvent`\n- `PaymentAttemptAuthorizedEvent`\n\n---\n\n## 5. PROVIDER INTEGRATIONS (24+ Providers)\n\n**Location:** `v2/workflow/create/providers/`\n\n| Provider | Adapter File | Payment Types |\n|----------|-------------|---------------|\n| Cybersource | `CybersourceProviderAdapter.java` | Cards, 3DS, E-Mandates |\n| Cashfree | `CashfreeProviderAdapter.java` + variants | Cards, UPI, NetBanking |\n| PayU | `PayuProviderAdapter.java` + variants | Cards, NetBanking |\n| Pine Labs | `PineLabsEdgeProviderAdapter.java` | Multiple modes |\n| Razorpay | Via webhooks | All payment types |\n| Juspay | Via webhooks | Orchestration |\n| ICICI UPI | `icici-upi-client` | UPI |\n| Axis UPI | `axis-upi-client` | UPI |\n| YBL UPI | `ybl-upi-client` | UPI |\n| RBL UPI | `rbl-upi-client` | UPI |\n| Digio | `DigioMandateRegisterProviderAdapter.java` | E-Mandates |\n| Cred Points | `CredPointsProviderAdapter.java` | Reward redemption |\n\n### Provider Selection Flow\n\n```\nRequest → ProviderDeciderRouter → LCM (if enabled) → Decision Tree → Provider Adapter\n```\n\n**Decision Tree:** JSON-based rules cached in `DecisionTreeObjectCache`\n\n---\n\n## 6. KEY ENTITIES (V2 Schema)\n\n### Core Entities\n| Entity | File | Purpose |\n|--------|------|---------|\n| OrderEntity | `entity/OrderEntity.java` | Order records |\n| PaymentV2Entity | `entity/v2/PaymentV2Entity.java` | Payment records |\n| PaymentAttemptV2Entity | `entity/v2/PaymentAttemptV2Entity.java` | Payment attempts |\n| RefundEntity | `entity/v2/RefundEntity.java` | Refunds |\n| FeeEntity | `entity/v2/FeeEntity.java` | Fee tracking |\n\n### Configuration Entities\n| Entity | Purpose |\n|--------|---------|\n| ClientEntity | Application clients |\n| ProviderAccountEntity | Provider accounts |\n| PaymentProviderEntity | Provider configs |\n| MasterConfigurationEntity | System configs |\n\n---\n\n## 7. DATABASE ARCHITECTURE\n\n### Master-Replica Pattern\n\n**Master:** Write operations\n**Replica:** Read operations (via `@ReplicaRepository`)\n\n**Configuration Files:**\n- `configuration/database/MasterDataSourceConfiguration.java`\n- `configuration/database/ReplicaDataSourceConfiguration.java`\n\n**Database:** `payments_multi_tenancy`\n**Connection Pool:** HikariCP\n**ORM:** JPA + Hibernate\n\n---\n\n## 8. CACHING LAYER\n\n### Caffeine (In-Memory)\n| Cache | Purpose |\n|-------|---------|\n| `ClientConfigurationCache` | Client settings |\n| `PaymentProviderCache` | Provider configs |\n| `ProviderAccountCache` | Provider accounts |\n| `DecisionTreeObjectCache` | Routing rules |\n| `CardBinCache` | Card BIN data |\n| `MerchantCache` | Merchant data |\n| `FeeCache` | Fee calculations |\n\n### Redis (Distributed)\n- **Client:** Redisson with Kryo5Codec\n- **Use:** Distributed locks, rate limiting, shared state\n\n---\n\n## 9. ASYNC PROCESSING\n\n### Kafka Topics\n- `payment-attempt-platform-metrics-pinot-out-new-1` (Analytics)\n- Events: `PaymentAttemptAnalyticsEvent`, `CardPaymentAttemptAnalyticsEvent`, etc.\n\n### SQS Queues\n| Queue | Purpose |\n|-------|---------|\n| `FORCE_PAYMENT_FAILURE_QUEUE` | Manual failure forcing |\n| `MANDATE_EXPIRY_CRON_QUEUE` | Mandate expiry |\n| `REFUND_RESCHEDULE_QUEUE` | Refund scheduling |\n| `ORDER_EXPIRY_QUEUE` | Order expiration |\n| `PENDENCY_AUTOMATION_QUEUE` | Pending transactions |\n\n### Eventi (Internal Events)\n- Internal event framework for system events\n- Async worker threads (4-16 configurable)\n\n---\n\n## 10. API ENDPOINTS\n\n### Primary Controllers (v2)\n| Endpoint | Controller | Purpose |\n|----------|------------|---------|\n| `/v2/orders/{orderId}/payments` | `PaymentV2Controller` | Bulk payment creation |\n| `/v2/payments/{paymentId}/attempts` | `PaymentAttemptV2Controller` | Payment attempts |\n| `/v1/webhooks` | `WebhookController` | Provider webhooks |\n\n### Webhook Controllers\n- `RazorpayWebhookController`\n- `JuspayWebhookController`\n- `ICICIWebhookController`\n- `YBLWebhookController`\n- `RBLUpiWebhookController`\n- `DigioWebhookController`\n\n---\n\n## 11. AUTHENTICATION & SECURITY\n\n### Request Filters (Order of Execution)\n1. `ApplicationContextBuilderFilter` - Build context from headers\n2. `PAMerchantAuthenticationFilter` - Partner merchant auth\n3. `PAPartnerAuthorizationFilter` - Partner authorization\n\n### Headers Required\n- Client ID (`${CLIENT_HEADER_KEY}`)\n- Merchant ID (`${MERCHANT_HEADER_KEY}`)\n- Device info (DEVICE_ID, OS, OS_VERSION, APP_VERSION)\n\n### Rate Limiting\n- Redisson-based distributed rate limiting\n- Config in `ClientRateLimiter.java`\n\n---\n\n## 12. KEY FILES TO STUDY\n\n### Must-Read Files (Priority Order)\n\n1. **Entry Point:**\n   - `DarwinApplication.java`\n\n2. **Core Workflows:**\n   - `v2/workflow/create/Workflow.java` (base pattern)\n   - `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java`\n   - `v2/workflow/create/payments/bulk/BulkPaymentCreateWorkflow.java`\n\n3. **State Machines:**\n   - `statemachine/payment/PaymentStateMachine.java`\n   - `statemachine/order/OrderStateMachine.java`\n\n4. **Provider Routing:**\n   - `planner/ProviderDeciderRouter.java`\n   - `planner/decisiontree/DecisionTreeWorkflow.java`\n\n5. **Provider Adapters:**\n   - `v2/workflow/create/providers/` (pick any adapter)\n\n6. **Entities:**\n   - `entity/OrderEntity.java`\n   - `entity/v2/PaymentV2Entity.java`\n   - `entity/v2/PaymentAttemptV2Entity.java`\n\n7. **Configuration:**\n   - `application.properties` (1300+ lines - scan for context)\n\n8. **Webhooks:**\n   - `controller/WebhookController.java`\n\n---\n\n## 13. INTERNAL SERVICE DEPENDENCIES\n\n| Service | Client Library | Purpose |\n|---------|---------------|---------|\n| User Service | `user-service-client:4.0.1` | User data |\n| Merchant Service | `merchant-service-client:1.0.3` | Merchant info |\n| Mandate Service | `mandate-java-client:1.0.4` | Recurring payments |\n| Arsenal | - | Instrument vault |\n| Falcon | - | Offers/promotions |\n| Genie | `genie-java-client` | Configuration |\n| Syndicate | - | Authentication |\n| LCM | - | Terminal resolution |\n| Fee Service | `fees:0.18.0` | Fee calculation |\n\n---\n\n## 14. STUDY PATH RECOMMENDATION\n\n### Week 1: Foundation\n- [ ] Understand project structure\n- [ ] Read `DarwinApplication.java`\n- [ ] Study `application.properties` (key sections)\n- [ ] Understand entity relationships\n\n### Week 2: Core Flow\n- [ ] Master `PaymentAttemptCreateWorkflow.java`\n- [ ] Study state machines\n- [ ] Understand provider routing\n\n### Week 3: Integrations\n- [ ] Study 2-3 provider adapters\n- [ ] Understand webhook handling\n- [ ] Learn caching patterns\n\n### Week 4: Advanced\n- [ ] Decision tree engine\n- [ ] Async processing (Kafka, SQS)\n- [ ] Error handling patterns\n\n---\n\n## 15. KEY CONCEPTS\n\n1. **Multi-Provider Orchestration** - Route to optimal provider based on rules\n2. **Decision Trees** - JSON-based routing logic\n3. **State Machines** - Event-driven entity lifecycle\n4. **Master-Replica DB** - Read/write separation\n5. **Workflow Pattern** - 7-step execution pipeline\n6. **Event-Driven Architecture** - Guava EventBus + Kafka\n\n---\n\n# DATA LAYER DEEP-DIVE\n\n## 16. ENTITY HIERARCHY & INHERITANCE\n\n### Base Classes\n```\nBaseEntity (id, created_at, updated_at, created_by, updated_by)\n    └── BaseExternalEntity (+ external_id UUID, version for optimistic locking)\n            ├── OrderEntity\n            ├── PaymentV2Entity\n            ├── PaymentAttemptV2Entity\n            ├── RefundEntity\n            ├── ClientEntity\n            └── CustomerEntity\n```\n\n### Key Entity Files\n| Entity | File | Key Fields |\n|--------|------|------------|\n| OrderEntity | `entity/OrderEntity.java` | clientReferenceId, amount, status, metadata (JSON) |\n| PaymentV2Entity | `entity/v2/PaymentV2Entity.java` | orderId, amount, paymentMode, instrumentDetail (JSON) |\n| PaymentAttemptV2Entity | `entity/v2/PaymentAttemptV2Entity.java` | paymentId, providerReferenceId, gatewayReferenceId, status |\n| RefundEntity | `entity/v2/RefundEntity.java` | orderId, paymentAttemptId, refundType, refundStatus |\n| ClientEntity | `entity/ClientEntity.java` | name, merchantId, settings (OneToMany) |\n\n### Entity Relationships\n```\nClientEntity (1) ──> (M) OrderEntity\nOrderEntity (1) ──> (M) PaymentV2Entity\nPaymentV2Entity (1) ──> (M) PaymentAttemptV2Entity\nPaymentAttemptV2Entity ──> PaymentProviderEntity\nPaymentAttemptV2Entity ──> ProviderAccountEntity\nOrderEntity (1) ──> (M) RefundEntity\nRefundEntity (1) ──> (M) RefundAttemptEntity\n```\n\n---\n\n## 17. MASTER-REPLICA DATABASE ARCHITECTURE\n\n### How Routing Works\n\n**Master (Writes):** `MasterDataSourceConfiguration.java`\n- EntityManagerFactory: `MasterEntityManagerFactory`\n- TransactionManager: `MasterTransactionManager`\n- Excludes beans with `@ReplicaRepository`\n\n**Replica (Reads):** `ReplicaDataSourceConfiguration.java`\n- EntityManagerFactory: `ReplicaEntityManagerFactory`\n- TransactionManager: `ReplicaTransactionManager`\n- Includes ONLY beans with `@ReplicaRepository`\n- Connection pool set to `readOnly=true`\n\n### Usage Pattern\n```java\n// Write to master (default)\n@Repository\npublic interface PaymentRepository extends JpaRepository<...> {}\n\n// Read from replica\n@Repository\n@ReplicaRepository  // <-- Annotation routes to replica\npublic class RefundEntityReplicaDAOImpl extends AbstractReplicaDAOImpl<...> {}\n```\n\n### HikariCP Connection Pools\n| Pool | Config | Purpose |\n|------|--------|---------|\n| hikari_master | masterMinimumIdle, masterMaximumPoolSize | Write operations |\n| hikari_replica | replicaMinimumIdle, replicaMaximumPoolSize, readOnly=true | Read operations |\n\nBoth pools have:\n- idleTimeout, connectionTimeout, maxLifetime\n- leakDetectionThreshold for debugging\n- MaintenanceManager integration for graceful shutdown\n\n---\n\n## 18. REPOSITORY & DAO PATTERNS\n\n### JPA Repository Pattern\n```java\n@Repository\npublic interface OrderRepository extends JpaRepository<OrderEntity, Long> {\n    // FETCH JOIN to prevent N+1 queries\n    @Query(\"SELECT o FROM OrderEntity o \"\n            + \"JOIN FETCH o.customerEntity \"\n            + \"JOIN FETCH o.clientEntity \"\n            + \"WHERE o.externalId = :externalId\")\n    Optional<OrderEntity> findByExternalId(@Param(\"externalId\") String externalId);\n\n    // Property path navigation\n    Optional<OrderEntity> findByClientReferenceIdAndClientEntity_ExternalId(\n            String clientReferenceId, String externalId);\n}\n```\n\n### DAO Pattern (Custom EntityManager)\n```java\n@Repository\npublic class PaymentAttemptDAOV2Impl {\n    @PersistenceContext\n    private EntityManager entityManager;\n\n    public List<PaymentAttemptV2Entity> findByOrderId(Long orderId) {\n        // Complex JPQL with manual EntityManager\n    }\n}\n```\n\n### DynamoDB DAO Pattern\n```java\n@RequiredArgsConstructor\npublic abstract class AbstractDynamoDBDAO<T> {\n    private final DynamoDBMapper dynamoDBMapper;\n\n    public void save(T entity) { dynamoDBMapper.save(entity); }\n    public T findByHashKey(Object hashKey) { return dynamoDBMapper.load(tClass, hashKey); }\n}\n```\n\n---\n\n## 19. JSON COLUMNS & CONVERTERS\n\n**Flexible Attribute Storage:**\n| Column | Converter | Entity |\n|--------|-----------|--------|\n| metadata | ObjectMetadataMapConverter | OrderEntity |\n| instrument_detail | PaymentInstrumentConverter | PaymentV2Entity |\n| instrument_detail | EnrichedPaymentInstrumentConverter | PaymentAttemptV2Entity |\n| routes | RoutesBreakupConverter | PaymentAttemptV2Entity |\n| payment_specific_detail | PaymentSpecificDetailConverter | PaymentV2Entity |\n\n```java\n@Column(name = \"metadata\")\n@Convert(converter = ObjectMetadataMapConverter.class)\nprivate Map<String, String> metaData;\n```\n\n---\n\n## 20. CACHING ARCHITECTURE\n\n### Caffeine Caches (In-Memory)\n| Cache Class | What It Caches | TTL |\n|-------------|----------------|-----|\n| ClientConfigurationCache | Client settings by ID, by externalId, by merchantId | 10-20 min |\n| PaymentProviderCache | Provider configurations | 15-25 min |\n| ProviderAccountCache | Provider account entities | 15-25 min |\n| DecisionTreeObjectCache | Routing decision trees | 180-190 min |\n| FeeCache | Fee configurations | 1 day |\n| CardBinCache | Card BIN details | Configurable |\n| MasterConfigurationCache | Feature flags, system settings | 10-20 min |\n| PaymentErrorMessageMappingCache | Error code to message mappings | Long |\n\n### Cache Pattern\n```java\n@DPCache(cacheName = \"client_configuration_cache\")\nprivate LoadingCache<Long, Map<ClientSettingKey, String>> idCache;\n\n@Override\npublic void buildCache() {\n    idCache = DPCacheBuilder.getBuilder()\n        .refreshAfterWrite(10, MINUTES)  // Lazy refresh\n        .build(this::loadClientSettings);  // Loader function\n}\n```\n\n### Jittered TTLs (Prevent Thundering Herd)\n```java\n// Returns 15-25 instead of fixed 15\nprivate Long generateRandomCacheRefreshInterval(int base) {\n    return base + random.nextInt(10) + 1;\n}\n```\n\n---\n\n## 21. DYNAMODB USAGE\n\n### What Goes Where\n| MySQL | DynamoDB |\n|-------|----------|\n| Orders, Payments, Attempts | Workflow context (TTL-based) |\n| Refunds, Fees | Native OTP details |\n| Clients, Customers | Redirect tracking |\n| Provider configs | Metadata audit trails |\n\n### DynamoDB Entity Example\n```java\n@DynamoDBTable(tableName = \"darwin_payment_attempt_workflow_context\")\npublic class PaymentAttemptWorkflowContextEntity {\n    @DynamoDBHashKey(attributeName = \"payment_attempt_external_id\")\n    private String paymentAttemptExternalId;\n\n    @DynamoDBRangeKey\n    @DynamoDBAttribute(attributeName = \"workflow_step\")\n    private WorkflowStep workflowStep;\n\n    @Builder.Default\n    private long ttl = LocalDateTime.now().plusDays(1).toEpochSecond(ZoneOffset.UTC);\n}\n```\n\n### DynamoDB Tables\n| Table | Partition Key | Sort Key | Purpose |\n|-------|---------------|----------|---------|\n| darwin_payment_attempt_workflow_context | payment_attempt_external_id | workflow_step | Workflow state |\n| darwin_payment_attempt_native_otp_detail | payment_attempt_external_id | - | OTP auth details |\n| darwin_payment_attempt_redirection_detail | payment_attempt_external_id | - | 3DS redirects |\n| darwin_payment_attempt_metadata_audit | payment_attempt_external_id | - | Audit trail |\n\n---\n\n## 22. OPTIMISTIC LOCKING & AUDIT\n\n### @Version for Optimistic Locking\n```java\n@Version\n@Column(name = \"version\")\nprivate Integer version;  // Auto-incremented on each update\n```\n\nPrevents concurrent modification - throws `OptimisticLockException` on conflict.\n\n### Audit Columns (Auto-Managed)\n```java\n@CreationTimestamp\n@Column(name = \"created_at\")\nprivate LocalDateTime createAt;\n\n@UpdateTimestamp\n@Column(name = \"updated_at\")\nprivate LocalDateTime updatedAt;\n\n@PrePersist\npublic void onCreate() {\n    createdBy = ApplicationContext.getApplicationName();\n}\n\n@PreUpdate\npublic void onUpdate() {\n    updatedBy = ApplicationContext.getApplicationName();\n}\n```\n\n---\n\n## 23. DATA LAYER ARCHITECTURE DIAGRAM\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                    Service Layer                        │\n├─────────────────────────────────────────────────────────┤\n│ JPA Repositories      │ Custom DAOs      │ DynamoDB DAOs │\n├─────────────────────────────────────────────────────────┤\n│     Spring Data JPA + Hibernate ORM                     │\n├──────────────────────┬──────────────────────────────────┤\n│   Master DataSource  │      Replica DataSource          │\n│   (Writes)           │      (Reads - @ReplicaRepository)│\n├──────────────────────┼──────────────────────────────────┤\n│ HikariCP Master Pool │   HikariCP Replica Pool          │\n├──────────────────────┴──────────────────────────────────┤\n│         MySQL (payments_multi_tenancy)                  │\n└─────────────────────────────────────────────────────────┘\n         │                              │\n┌────────▼────────┐          ┌──────────▼─────────┐\n│    DynamoDB     │          │  Caffeine Caches   │\n│ (Workflow/Audit)│          │  (Client/Provider) │\n└─────────────────┘          └────────────────────┘\n```\n\n---\n\n## 24. KEY DATA LAYER FILES TO STUDY\n\n### Entity Classes (Priority)\n1. `entity/commons/BaseEntity.java` - Base class pattern\n2. `entity/provider/BaseExternalEntity.java` - External ID + versioning\n3. `entity/OrderEntity.java` - Main order entity\n4. `entity/v2/PaymentAttemptV2Entity.java` - Payment attempt (most complex)\n\n### Database Configuration\n1. `configuration/database/MasterDataSourceConfiguration.java`\n2. `configuration/database/ReplicaDataSourceConfiguration.java`\n3. `configuration/database/annotation/ReplicaRepository.java`\n\n### Repositories\n1. `repository/OrderRepository.java` - FETCH JOIN examples\n2. `repository/PaymentAttemptRepository.java` - Complex queries\n\n### Caches\n1. `cache/ClientConfigurationCache.java` - Cache pattern example\n2. `configuration/CacheConfig.java` - Cache configuration\n\n### DynamoDB\n1. `dynamo/dao/AbstractDynamoDBDAO.java` - Base DAO pattern\n2. `dynamo/domain/PaymentAttemptWorkflowContextEntity.java` - DynamoDB entity\n\n---\n\n# PROVIDER INTEGRATION DEEP-DIVE\n\n## 25. PROVIDER ADAPTER ARCHITECTURE\n\n### Base Adapter Pattern\n**File:** `v2/workflow/create/providers/IPaymentProviderAdapter.java`\n\n```java\npublic abstract class IPaymentProviderAdapter<T, R> implements SelfReferencingBean {\n    protected final PaymentProviderKey paymentProviderKey;  // e.g., CASHFREE, CYBERSOURCE\n    private final InstrumentType instrumentType;            // e.g., CARD, UPI_APPS\n    private final OrderType orderType;                      // e.g., PAY, REFUND\n\n    // Core lifecycle methods\n    public abstract ProviderPaymentResponse createPaymentAttempt(context, customerEntity);\n    protected abstract Object syncPaymentAttemptWithProviderId(paymentAttemptEntity);\n    protected abstract ProviderRefundCreateResponse createRefund(refundAttemptEntity, context);\n    protected abstract R getAuthConfig(providerAccountEntity);\n}\n```\n\n### Factory Pattern for Adapter Selection\n**File:** `v2/workflow/create/providers/PaymentProviderFactory.java`\n\n```java\n@Component\npublic class PaymentProviderFactory {\n    // Multi-dimensional lookup: OrderType + ProviderKey + InstrumentType → Adapter\n    private Map<PaymentWorkflowKey, IPaymentProviderAdapter<?, ?>> paymentProviderMap;\n\n    // Secondary lookup: OrderType + ProviderKey → First adapter\n    private Table<OrderType, PaymentProviderKey, IPaymentProviderAdapter<?, ?>> paymentProviderByKey;\n\n    // 3DS variant support\n    private ThreeDSType threeDSType;  // 3DS1 vs 3DS2\n}\n```\n\n### Provider Response Structure\n```java\n@Data @Builder\npublic class ProviderPaymentResponse {\n    private Object providerResponseObject;     // Raw provider response\n    private String providerReferenceId;        // Provider's transaction ID\n    private String gatewayReferenceId;         // Gateway ID\n    private String providerStatus;             // Raw status (\"SUCCESS\")\n    private PaymentAttemptStatus status;       // Mapped internal status\n    private ProviderRequestStatus providerRequestStatus;  // REQUEST_SUCCESS, RETRY_ABLE_FAILURE\n    private ProviderError providerError;       // Error details if failed\n}\n```\n\n---\n\n## 26. DECISION TREE ROUTING\n\n### Router Strategy Pattern\n**File:** `planner/providerdecider/ProviderDeciderRouter.java`\n\n```java\n@Service\npublic class ProviderDeciderRouter {\n    public ProviderRoutingDecisionResult resolve(PaymentAttemptCreateContext context) {\n        // Priority 1: LCM routing (if instrument supported)\n        if (isInstrumentTypeSupportedInLCM(clientId, instrumentType)) {\n            return providerDeciderViaLCM.decideProvider(context);\n        }\n\n        // Priority 2: Decision Tree routing\n        if (isDecisionTreeEnabled) {\n            return providerDeciderV2.decideProvider(context);\n        }\n    }\n}\n```\n\n### Decision Tree Workflow\n**File:** `planner/providerdecider/ProviderDeciderV2.java`\n\n```\nRequest → Fetch Cached Decision Tree → Create DT Context → Execute Tree → Apply Dynamic Routing → Return Provider\n```\n\n**Decision Tree Factors:**\n- Client configuration\n- Instrument type (Card, UPI, NetBanking)\n- Card brand/BIN\n- Customer attributes\n- Order amount\n- Provider availability/downtime\n\n### Decision Tree Caching\n**File:** `cache/DecisionTreeObjectCache.java`\n\n| Cache | TTL | Content |\n|-------|-----|---------|\n| decision_tree_object_cache | 180-190 min | Parsed decision tree JSON + workflow |\n\n---\n\n## 27. PROVIDER ADAPTERS (24+ Implementations)\n\n### Adapter Directory Structure\n```\nv2/workflow/create/providers/\n├── IPaymentProviderAdapter.java          # Base abstract class\n├── PaymentProviderFactory.java           # Factory for adapter selection\n├── CashfreeProviderAdapter.java          # Cashfree base\n├── CashfreeCardProviderAdapter.java      # Cashfree cards\n├── CashfreeNetBankingProviderAdapter.java\n├── CashfreeUPIProviderAdapter.java\n├── CashfreeUPIAppsProviderAdapter.java\n├── cybersource/\n│   ├── CybersourceProviderAdapter.java   # Cybersource base (3DS)\n│   ├── CybersourceRequestBuilder.java    # Request construction\n│   └── CybersourceAuthorizeRequestBuilder.java\n├── PayuProviderAdapter.java\n├── PayuCardProviderAdapter.java\n├── PineLabsEdgeProviderAdapter.java\n├── CredPointsProviderAdapter.java\n├── RewardPointsProviderAdapter.java\n└── AuthTokenNativeProviderAdapter.java\n```\n\n### Cashfree Adapter Example\n**File:** `v2/workflow/create/providers/CashfreeProviderAdapter.java`\n\n```java\n@Component\npublic abstract class CashfreeProviderAdapter\n        extends IPaymentProviderAdapter<String, CashfreeAuthConfig> {\n\n    // Two-phase payment creation:\n    // 1. Create order at Cashfree\n    // 2. Create payment for that order\n\n    @Override\n    public ProviderPaymentResponse createPaymentAttempt(context, customer) {\n        // Phase 1: Create CF Order\n        Pair<BaseResponse<CreateOrderResponse>, ProviderError> orderResponse =\n            createCFOrder(context, authConfig);\n\n        // Phase 2: Create CF Payment\n        Pair<BaseResponse<CreatePaymentResponse>, ProviderError> paymentResponse =\n            createCFPayment(context, orderResponse.getLeft().getResponse(), authConfig);\n\n        return mapToProviderPaymentResponse(paymentResponse);\n    }\n}\n```\n\n### Cybersource Adapter (3DS Support)\n**File:** `v2/workflow/create/providers/cybersource/CybersourceProviderAdapter.java`\n\n```java\n@Component\npublic abstract class CybersourceProviderAdapter\n        extends I3DSPaymentProviderAdapter<String, AuthConfig> {\n\n    // Status code mappings\n    private static final List<String> FAILED_STATUSES = Arrays.asList(\n        \"101\", \"102\", \"104\", \"150\", \"200\", \"201\", ...  // 43 codes\n    );\n    private static final List<String> PROCESSING_STATUSES = Arrays.asList(\n        \"110\", \"475\", \"480\"\n    );\n\n    // 3DS2 redirection flow\n    protected void createRedirectionHtml(response, paymentAttemptEntity) {\n        if (authInfo.getSpecificationVersion().startsWith(\"2\")) {\n            // 3DS2 flow with step-up URL\n            html = authenticationService.createAuthenticationPageFor3ds2(\n                authInfo.getStepUpUrl(),\n                authInfo.getAccessToken(),\n                paymentAttemptEntity.getExternalId());\n        }\n    }\n}\n```\n\n---\n\n## 28. WEBHOOK HANDLING\n\n### Webhook Architecture\n```\nProvider → /webhooks/v2/{provider} → Provider-Specific Controller → WebhookService → State Machine Update\n```\n\n### Provider Webhook Controllers\n| Endpoint | Controller | Provider |\n|----------|------------|----------|\n| `/webhooks/v2/cashfree` | CashfreeWebhookController | Cashfree |\n| `/webhooks/v2/razorpay` | RazorpayWebhookController | Razorpay |\n| `/webhooks/v2/payu` | PayuWebhookController | PayU |\n| `/webhooks/v2/cybersource` | CybersourceWebhookController | Cybersource |\n| `/webhooks/v2/juspay` | JuspayWebhookController | Juspay |\n| `/webhooks/v2/ybl` | YBLWebhookController | Yes Bank UPI |\n| `/webhooks/v2/icici` | ICICIWebhookController | ICICI UPI |\n| `/webhooks/v2/rbl-upi` | RBLUpiWebhookController | RBL UPI |\n| `/webhooks/v2/digio` | DigioWebhookController | Digio (eMandate) |\n\n### Webhook Processing Flow\n**File:** `controller/v2/CashfreeWebhookController.java`\n\n```java\n@PostMapping\npublic void onWebhookReceive(@RequestBody CashfreeWebhook webhookRequest) {\n    switch (webhookRequest.getType()) {\n        case PAYMENT_SUCCESS_WEBHOOK:\n        case PAYMENT_FAILED_WEBHOOK:\n            // 1. Extract provider reference ID\n            String providerRefId = paymentWebhook.getData().getCfPaymentId();\n\n            // 2. Fetch payment attempt\n            PaymentAttempt attempt = paymentAttemptFetchWorkflow\n                .fetchByProviderReferenceId(providerRefId);\n\n            // 3. Audit webhook data\n            auditService.auditProviderData(webhookRequest, attempt.getId(), ...);\n\n            // 4. Sync status (triggers state machine)\n            break;\n\n        case REFUND_STATUS_WEBHOOK:\n            processRefundAttempt(webhookRequest);\n            break;\n    }\n}\n```\n\n### Idempotency Handling\n```java\n// In base adapter - only update if status actually changed\npublic void syncPaymentAttemptWithProvider(PaymentAttemptV2Entity entity) {\n    String currentStatus = entity.getProviderStatus();\n\n    Object providerResponse = syncPaymentAttemptWithProviderId(entity);\n\n    // Only audit and process if status changed\n    if (!Objects.equals(currentStatus, entity.getProviderStatus())) {\n        auditService.auditProviderData(...);\n    }\n}\n```\n\n---\n\n## 29. PROVIDER CONFIGURATION\n\n### Configuration Entities\n**File:** `entity/ProviderAccountEntity.java`\n\n```java\n@Entity @Table(name = \"provider_accounts\")\npublic class ProviderAccountEntity extends BaseEntity {\n    @ManyToOne\n    private PaymentProviderEntity paymentProvider;\n\n    private String providerAccountId;     // e.g., \"ACC_123456\"\n\n    @Lob\n    private byte[] accessToken;           // Encrypted credentials\n\n    private String endpoint;              // Provider API endpoint\n    private Boolean isProd;               // Production vs Sandbox\n    private Boolean active;\n    private String additionalConfig;      // JSON configuration\n    private String providerMid;           // Merchant ID at provider\n    private String settlementCategory;    // Settlement routing\n}\n```\n\n### Provider-Specific Configurations\n```java\n// Cashfree\n@Data\npublic class CashfreeProviderAccountConfiguration {\n    private String apiClientId;\n    private String apiVersion;\n    private ShortCircuitConfiguration shortCircuitConfiguration;\n}\n\n// Cybersource\n@Data\npublic class CybersourceProviderAccountConfiguration {\n    private String apiKey;\n    private String merchantId;\n    private Boolean enableRetries = false;\n    private Boolean enableCaptureWithAuth = true;\n    private Boolean enable3DS2 = true;\n    private Boolean enableRedirectionFlow = false;\n}\n```\n\n### Client-Provider Mapping\n**File:** `entity/ClientPaymentProviderConfigEntity.java`\n\n```java\n@Entity @Table(name = \"client_payment_provider_config\")\npublic class ClientPaymentProviderConfigEntity extends BaseEntity {\n    @ManyToOne private ClientEntity client;\n    @ManyToOne private PaymentProviderEntity paymentProvider;\n    private String providerConfig;  // JSON configuration per client\n}\n```\n\n---\n\n## 30. ERROR HANDLING & RETRY LOGIC\n\n### Error Classification\n```java\npublic enum ProviderRequestStatus {\n    REQUEST_SUCCESS,          // Payment processed\n    RETRY_ABLE_FAILURE,       // Timeout, rate limit - can retry\n    NON_RETRY_ABLE_FAILURE    // Invalid request - cannot retry\n}\n```\n\n### Provider Error Structure\n```java\n@Data @Builder\npublic class ProviderError {\n    private String message;           // User-friendly message\n    private String code;              // Provider error code\n    private Object providerResponse;  // Raw error response\n    private Boolean retryable;        // Retry classification\n}\n```\n\n### Error Code Mapping (Cybersource Example)\n```java\n// Failure codes (43 codes)\n\"101\", \"102\", \"104\", \"150\", \"200\", \"201\", \"202\", \"203\", ...\n\n// Processing/Pending codes\n\"110\" (Pending), \"475\" (Timeout), \"480\" (Processing)\n```\n\n### Retry Pattern\n```java\npublic ProviderPaymentResponse executePaymentAttempt(...) {\n    try {\n        return pilotMethod.apply(context, providerCustomer);\n    } catch (RateLimitException rle) {\n        return ProviderPaymentResponse.builder()\n            .providerRequestStatus(ProviderRequestStatus.RETRY_ABLE_FAILURE)\n            .providerError(ProviderError.builder()\n                .retryable(true).build())\n            .build();\n    } catch (AppException ae) {\n        return ProviderPaymentResponse.builder()\n            .providerRequestStatus(ProviderRequestStatus.NON_RETRY_ABLE_FAILURE)\n            .build();\n    }\n}\n```\n\n---\n\n## 31. ARCHITECTURAL PATTERNS SUMMARY\n\n| Pattern | Usage | File |\n|---------|-------|------|\n| **Factory** | Adapter selection by (OrderType, Provider, Instrument) | PaymentProviderFactory.java |\n| **Strategy** | LCM vs Decision Tree routing | ProviderDeciderRouter.java |\n| **Template Method** | Base adapter lifecycle | IPaymentProviderAdapter.java |\n| **Builder** | Complex request construction | CybersourceRequestBuilder.java |\n| **Decorator** | Provider-specific configuration | *ConfigValueDecoratorImpl.java |\n\n---\n\n## 32. KEY PROVIDER INTEGRATION FILES\n\n### Core Architecture\n1. `v2/workflow/create/providers/IPaymentProviderAdapter.java` - Base adapter\n2. `v2/workflow/create/providers/PaymentProviderFactory.java` - Factory\n3. `planner/providerdecider/ProviderDeciderRouter.java` - Routing strategy\n\n### Decision Tree\n1. `planner/providerdecider/ProviderDeciderV2.java` - DT workflow\n2. `planner/providerdecider/ProviderDeciderViaLCM.java` - LCM routing\n3. `cache/DecisionTreeObjectCache.java` - DT caching\n\n### Webhooks\n1. `controller/WebhookController.java` - Generic webhook endpoint\n2. `controller/v2/CashfreeWebhookController.java` - Cashfree webhooks\n3. `service/WebhookService.java` - Webhook processing\n\n### Provider Implementations\n1. `v2/workflow/create/providers/CashfreeProviderAdapter.java`\n2. `v2/workflow/create/providers/cybersource/CybersourceProviderAdapter.java`\n3. `v2/workflow/create/providers/PayuProviderAdapter.java`\n\n### Configuration\n1. `entity/ProviderAccountEntity.java` - Provider credentials\n2. `entity/PaymentProviderEntity.java` - Provider definition\n3. `entity/ClientPaymentProviderConfigEntity.java` - Client-provider mapping\n\n---\n\n# PAYMENT FLOW DEEP-DIVE\n\n## 33. THE 7-STEP WORKFLOW PIPELINE\n\n### Base Workflow Pattern (Template Method)\n**File:** `v2/workflow/create/Workflow.java`\n\n```java\npublic Response execute(Request request) {\n    // STEP 1: Validate inputs and enrich context\n    Context context = validateAndEnrichContext(request);\n\n    // STEP 2: Persist to relational DB (transactional)\n    persistIntent(context);\n\n    // STEP 3: Pre-persist event hooks\n    publishEntityPrePersistEvents(context);\n\n    // STEP 4: Persist to non-relational DB (DynamoDB)\n    persistNonRelationalIntent(context);\n\n    // STEP 5: Process (external provider calls)\n    process(context);\n\n    // STEP 6: Post-process and save results (transactional)\n    Response response = postProcess(context);\n\n    // STEP 7: Post-persist & publish events\n    postPersistNonRelationalDataStore(context);\n    publishEntityChangeEvents(context);\n\n    throwErrorIfRequired(context);\n    return response;\n}\n```\n\n---\n\n## 34. PAYMENTATTEMPTCREATEWORKFLOW DETAILED\n\n**File:** `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java`\n\n### Step 1: Validate & Enrich Context\n\n| Enricher | Purpose | Output |\n|----------|---------|--------|\n| `InstrumentTypeProcessorManager` | Validate & enrich payment instrument | `InstrumentTypeProcessorResult` |\n| `ProviderDeciderRouter.resolve()` | Route to provider via Decision Tree | `ProviderRoutingDecisionResult` |\n| `AuthTypeDeciderFactory` | Determine auth type (3DS, OTP, None) | `AuthType` |\n| `NativeProviderDecider` | Select native OTP provider | `ProviderAccountEntity` |\n| `SettlementRouteValidator` | Validate & enrich settlement routes | `RoutesBreakup` |\n| `MandateServiceDataManager` | Register mandate (if eMandate) | `Mandate` |\n\n### Context Object Structure\n```java\nPaymentAttemptCreateContext {\n    // Request/Response\n    CreatePaymentAttemptRequest request\n    PaymentAttemptResponse response\n\n    // Entities\n    PaymentAttemptV2Entity paymentAttemptEntity\n    PaymentV2Entity paymentEntity\n    OrderEntity orderEntity\n    CustomerEntity customerEntity\n    ClientEntity clientEntity\n\n    // Enriched Data\n    InstrumentTypeProcessorResult instrumentProcessorResult\n    ProviderAccountEntity providerAccountEntity\n    ProviderRoutingDecisionResult routingDecisionResult\n    AuthType authType\n    RoutesBreakup routesBreakup\n    ProviderPaymentResponse createResponse\n\n    // OTP/Auth Flow\n    Boolean isPlatformNativeOtpSupported\n    PaymentAttemptNativeOTPDetailEntity nativeOTPDetailEntity\n\n    // Error Collection\n    List<WorkflowInternalError> errors\n}\n```\n\n### Step 2: Persist Intent\n```java\n@Transactional(transactionManager = \"MasterTransactionManager\")\npublic void persistIntent(PaymentAttemptCreateContext context) {\n    // Create PaymentAttemptV2Entity\n    PaymentAttemptV2Entity entity = PaymentAttemptV2Entity.builder()\n        .externalId(PaymentAttemptUUIdGenerator.generate())\n        .status(PaymentAttemptStatus.CREATED)\n        .paymentEntity(paymentEntity)\n        .providerAccountEntity(providerAccountEntity)\n        .paymentMethod(instrumentResult.getPaymentMethod())\n        .instrumentDetail(instrumentResult.getEnrichedInstrument())\n        .routesBreakup(routesBreakup)\n        .build();\n\n    // Save to repository\n    paymentAttemptRepository.save(entity);\n\n    // Save fees\n    feeCreateWorkflow.persistIntent(feeContexts);\n\n    // Add attributes (DT_ID, DT_RESULT, etc.)\n    enrichAttributes(entity);\n}\n```\n\n### Step 5: Process (Provider Call)\n```java\npublic void process(PaymentAttemptCreateContext context) {\n    // Find adapter\n    IPaymentProviderAdapter adapter = paymentProviderFactory\n        .findPaymentProviderAdapter(orderType, providerKey, instrumentType, threeDSType);\n\n    // Execute provider call\n    ProviderPaymentResponse response = adapter.executePaymentAttempt(\n        context,\n        adapter::createPaymentAttempt,\n        FlowType.CREATE\n    );\n\n    // Check platform OTP capability\n    response = checkIfPlatformOtpEnabled(context, response);\n\n    context.setCreateResponse(response);\n}\n```\n\n### Step 6: Post-Process\n```java\n@Transactional\npublic PaymentAttemptResponse postProcess(PaymentAttemptCreateContext context) {\n    PaymentAttemptV2Entity entity = context.getPaymentAttemptEntity();\n    ProviderPaymentResponse response = context.getCreateResponse();\n\n    // Update from provider response\n    entity.setProviderStatus(response.getProviderStatus());\n    entity.setProviderReferenceId(response.getProviderReferenceId());\n    entity.setGatewayReferenceId(response.getGatewayReferenceId());\n\n    // Determine final status\n    if (response.getProviderRequestStatus() == REQUEST_SUCCESS) {\n        entity.setStatus(response.getStatus());\n    } else if (isEligiblePaymentMode) {\n        entity.setStatus(response.getStatus() == FAILED ? FAILED : PROCESSING);\n    }\n\n    paymentAttemptRepository.save(entity);\n    return mapper.toResponse(entity, response);\n}\n```\n\n### Step 7: Publish Events\n```java\npublic void publishEntityChangeEvents(PaymentAttemptCreateContext context) {\n    // Post to sync EventBus (triggers PaymentStateMachine)\n    syncBus.post(PaymentAttemptEventFactory.findEvent(paymentAttemptEntity));\n\n    // Post to async EventBus\n    asyncBus.post(PaymentAttemptEventFactory.findEvent(paymentAttemptEntity));\n\n    // Publish to multi-tenant event system\n    eventiService.publishEvent(paymentAttemptEntity);\n\n    // Add to sync manager for webhook updates\n    syncManager.addEntityForSync(paymentAttemptEntity);\n}\n```\n\n---\n\n## 35. STATE MACHINE IMPLEMENTATION\n\n### PaymentStateMachine\n**File:** `statemachine/payment/PaymentStateMachine.java`\n\n```\nEvent Subscriptions:\n├── @Subscribe onPaymentAttemptCreated\n│   └── Payment: FAILED → CREATED\n├── @Subscribe onPaymentAttemptFailed\n│   └── If all attempts failed: Payment → FAILED\n├── @Subscribe onPaymentAttemptCompleted\n│   └── Payment → COMPLETED (with optimistic lock retry)\n├── @Subscribe onPaymentAttemptAuthorized\n│   └── Payment → AUTHORIZED\n├── @Subscribe onPaymentAttemptProcessing\n│   └── Payment → PROCESSING\n├── @Subscribe onPaymentAttemptBlocked\n│   └── Payment → BLOCKED\n└── @Subscribe onAuthenticationSuccessful/Failed\n    └── Payment → AUTHENTICATION_SUCCESSFUL/FAILED\n```\n\n### OrderStateMachine\n**File:** `statemachine/order/OrderStateMachine.java`\n\n```\nEvent Subscriptions:\n├── @Subscribe onPaymentCreated\n│   └── Order → CREATED or AUTHLESS_READY_TO_PROCESS\n├── @Subscribe onPaymentFailed\n│   └── Order → FAILED\n├── @Subscribe onPaymentCompleted\n│   └── Order → COMPLETED (if all payments done)\n├── @Subscribe onPaymentAuthorized\n│   └── Order → AUTHORIZED\n└── @Subscribe onPaymentProcessing\n    └── Order → PROCESSING\n```\n\n### Terminal States\n| Entity | Terminal States |\n|--------|-----------------|\n| PaymentAttempt | COMPLETED, FAILED, FORCE_FAILED |\n| Payment | COMPLETED, FAILED, FORCE_FAILED, DISCARDED |\n| Order | COMPLETED, FAILED |\n\n### State Transition Guard\n```java\nprivate boolean shouldUpdatePaymentStatus(PaymentV2Entity entity) {\n    return !Arrays.asList(COMPLETED, FAILED, FORCE_FAILED, DISCARDED)\n        .contains(entity.getStatus());\n}\n```\n\n---\n\n## 36. END-TO-END PAYMENT FLOW\n\n```\n┌─────────────────────────────────────────────────────────────────────────┐\n│                         CLIENT REQUEST                                   │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  1. ORDER CREATION                                                       │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ OrderCreateWorkflow.execute()                                       │ │\n│  │ ├── validateAndEnrichContext() - Customer lookup, order validation │ │\n│  │ ├── persistIntent() - Save OrderEntity (status: CREATED)           │ │\n│  │ └── publishEvents() → OrderStateMachine                            │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  2. PAYMENT CREATION                                                     │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ BulkPaymentCreateWorkflow.execute()                                 │ │\n│  │ ├── validateAndEnrichContext() - Payment mode validation           │ │\n│  │ ├── persistIntent() - Save PaymentV2Entity (status: CREATED)       │ │\n│  │ └── publishEvents() → PaymentStateMachine                          │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  3. PAYMENT ATTEMPT CREATION (Core Flow)                                 │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ PaymentAttemptCreateWorkflow.execute()                              │ │\n│  │ ├── validateAndEnrichContext()                                     │ │\n│  │ │   ├── InstrumentTypeProcessorManager (Card/UPI/NetBanking)       │ │\n│  │ │   ├── ProviderDeciderRouter (Decision Tree routing)              │ │\n│  │ │   ├── AuthTypeDeciderFactory (3DS/OTP/None)                      │ │\n│  │ │   └── SettlementRouteValidator                                   │ │\n│  │ ├── persistIntent() - Save PaymentAttemptV2Entity                  │ │\n│  │ ├── persistNonRelationalIntent() - DynamoDB (OTP details)          │ │\n│  │ ├── process() - Provider API call via Adapter                      │ │\n│  │ ├── postProcess() - Update entity with provider response           │ │\n│  │ └── publishEvents() → PaymentStateMachine → OrderStateMachine      │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  4. PROVIDER API RESPONSE                                                │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ ProviderPaymentResponse contains:                                   │ │\n│  │ ├── providerStatus: \"SUCCESS\" / \"PENDING\" / \"FAILED\"               │ │\n│  │ ├── providerReferenceId: Provider's transaction ID                 │ │\n│  │ ├── status: PaymentAttemptStatus (mapped)                          │ │\n│  │ ├── transactionResponse:                                           │ │\n│  │ │   ├── authentication: { url, method } (for 3DS redirect)         │ │\n│  │ │   └── sdkParams: Native OTP/SDK details                          │ │\n│  │ └── providerError: Error details if failed                         │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n         ┌──────────────────────────┴──────────────────────────┐\n         ▼                                                      ▼\n┌─────────────────────────┐                    ┌─────────────────────────┐\n│  5A. 3DS/OTP FLOW       │                    │  5B. DIRECT SUCCESS     │\n│  ┌───────────────────┐  │                    │  ┌───────────────────┐  │\n│  │ Client performs   │  │                    │  │ Status: COMPLETED │  │\n│  │ authentication    │  │                    │  │ Payment done!     │  │\n│  │ (redirect/native) │  │                    │  └───────────────────┘  │\n│  └───────────────────┘  │                    └─────────────────────────┘\n│           │             │\n│           ▼             │\n│  ┌───────────────────┐  │\n│  │ Authenticate      │  │\n│  │ Workflow called   │  │\n│  │ with OTP/callback │  │\n│  └───────────────────┘  │\n└─────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  6. WEBHOOK / SYNC UPDATE                                                │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ Provider sends webhook OR SyncManager polls status                  │ │\n│  │ ├── WebhookController receives update                              │ │\n│  │ ├── adapter.syncPaymentAttemptWithWebhook()                        │ │\n│  │ ├── Update PaymentAttemptV2Entity status                           │ │\n│  │ └── publishEvents() → State machines cascade updates               │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  7. FINAL STATE                                                          │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ PaymentAttempt: COMPLETED ──► Payment: COMPLETED ──► Order: COMPLETED│\n│  │                                                                     │ │\n│  │ eventiService.publishEvent() → Client webhook notification          │ │\n│  │ eventiService.publishToPinot() → Analytics dashboard               │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## 37. 3DS / NATIVE OTP AUTHENTICATION\n\n### Native OTP Flow (Card Payments)\n```\n1. PaymentAttemptCreateWorkflow detects CARD + OTP-capable BIN\n2. wspService.isPlatformNativeOtpEnabled() returns true\n3. Provider returns redirect URL, but we override with SDK params\n4. CardNativeOTPSDKParamDetail created:\n   ├── authType: NATIVE_OTP\n   ├── challengeId: UUID\n   ├── fallbackUrl: Provider's original auth URL\n   └── submitOTPAllowed: true\n\n5. PaymentAttemptNativeOTPDetailEntity saved to DynamoDB\n6. Client submits OTP via PaymentAttemptAuthenticateWorkflow\n7. Provider validates OTP, returns success/failure\n8. State machines update payment/order status\n```\n\n### 3DS Redirect Flow\n```\n1. Provider returns authentication URL\n2. Client redirects to issuer's 3DS page\n3. User completes authentication\n4. Callback to return_url\n5. ValidateAuthenticationWorkflow processes callback\n6. Provider confirms authentication status\n7. State machines update accordingly\n```\n\n---\n\n## 38. INSTRUMENT PROCESSING\n\n### InstrumentTypeProcessorManager\n**File:** `processors/instrumenttype/InstrumentTypeProcessorManager.java`\n\n```java\n// Routes to specific processor based on instrument type\nIInstrumentTypeProcessor processor = processorByType.get(instrument.getType());\nreturn processor.validatePaymentInstrumentAndEnrich(instrument);\n```\n\n### Processor Implementations\n| Processor | InstrumentType | Enrichment |\n|-----------|----------------|------------|\n| `CardInstrumentTypeProcessor` | CARD | BIN lookup, issuer, card type |\n| `UPIPayInstrumentTypeProcessor` | UPI_APPS | VPA validation, provider |\n| `UPICollectInstrumentTypeProcessor` | UPI_COLLECT | QR code, timeout |\n| `NetBankingInstrumentTypeProcessor` | NET_BANKING | Bank code, issuer |\n| `EMandateInstrumentTypeProcessor` | NET_BANKING_WITH_PI | Mandate details |\n\n### InstrumentTypeProcessorResult\n```java\nInstrumentTypeProcessorResult<R, S> {\n    PaymentInstrumentGroup paymentMethod;  // CARD, UPI_PAY, etc.\n    R paymentSubMethodDetail;              // CardPaymentSubMethodDetail\n    S enrichedPaymentInstrument;           // CardEnrichedPaymentInstrument\n}\n```\n\n---\n\n## 39. DISTRIBUTED LOCKING\n\n### SequentialWorkflow Pattern\n**File:** `v2/workflow/create/SequentialWorkflow.java`\n\n```java\npublic Response execute(Request request) {\n    LockSetting lockSetting = fetchLockSetting();\n    String lockKey = evaluateLockKey(request, lockSetting.getLockKey());\n\n    // Acquire Redis distributed lock\n    Optional<RLock> lock = redisLockUtil.acquireLock(lockKey, flowType);\n\n    if (lock.isPresent() || !lockSetting.getIsLockMandatory()) {\n        try {\n            return super.execute(request);  // Run workflow\n        } finally {\n            lock.ifPresent(redisLockUtil::releaseLock);\n        }\n    }\n    throw Error.unable_to_acquire_lock.getBuilder().build();\n}\n```\n\n**Use Cases:**\n- Prevents concurrent payment attempts on same order\n- Ensures single webhook processing per transaction\n- Avoids race conditions in status updates\n\n---\n\n## 40. KEY PAYMENT FLOW FILES\n\n### Core Workflows\n1. `v2/workflow/create/Workflow.java` - Base template\n2. `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java` - Main flow\n3. `v2/workflow/create/payments/bulk/BulkPaymentCreateWorkflow.java` - Payment creation\n4. `v2/workflow/authenticate/PaymentAttemptAuthenticateWorkflow.java` - OTP auth\n\n### State Machines\n1. `statemachine/payment/PaymentStateMachine.java`\n2. `statemachine/order/OrderStateMachine.java`\n3. `statemachine/RefundStateMachine.java`\n\n### Instrument Processing\n1. `processors/instrumenttype/InstrumentTypeProcessorManager.java`\n2. `processors/instrumenttype/CardInstrumentTypeProcessor.java`\n3. `processors/instrumenttype/UPIPayInstrumentTypeProcessor.java`\n\n### Context & Events\n1. `v2/workflow/create/paymentattempts/PaymentAttemptCreateContext.java`\n2. `statemachine/payment/events/PaymentAttemptEventFactory.java`\n3. `statemachine/order/events/OrderEventFactory.java`\n\n---\n\n## 41. ARCHITECTURAL PATTERNS SUMMARY\n\n| Pattern | Implementation | Purpose |\n|---------|----------------|---------|\n| **Template Method** | `Workflow.execute()` 7-step pipeline | Consistent execution flow |\n| **Factory** | `PaymentProviderFactory`, `InstrumentTypeProcessorManager` | Dynamic component selection |\n| **Strategy** | `AuthTypeDeciderFactory`, `SdkTypeDeciderFactory` | Pluggable algorithms |\n| **Observer** | Guava EventBus, State Machines | Decoupled state transitions |\n| **Context Object** | `PaymentAttemptCreateContext` | Data flow through pipeline |\n| **Distributed Lock** | `SequentialWorkflow` + Redis | Concurrency control |\n| **Event Sourcing** | DynamoDB workflow context | Audit trail |\n\n---\n\n## 42. COMPLETE STUDY GUIDE SUMMARY\n\nYou now have a **42-section expert study guide** covering:\n\n### Foundation (Sections 1-15)\n- Tech stack, project structure, core concepts\n- API endpoints, authentication, dependencies\n\n### Data Layer Deep-Dive (Sections 16-24)\n- Entity hierarchy, Master-Replica DB\n- Repository patterns, caching, DynamoDB\n\n### Provider Integration Deep-Dive (Sections 25-32)\n- Adapter architecture, Decision Tree routing\n- Webhook handling, provider configuration\n- Error handling and retry logic\n\n### Payment Flow Deep-Dive (Sections 33-41)\n- 7-step workflow pipeline\n- State machine implementation\n- End-to-end payment flow\n- 3DS/OTP authentication\n- Instrument processing\n- Distributed locking\n","tool_use_id":"toolu_bdrk_013LawCuHHVJWp6JCM1VmnMh"}]},"uuid":"60de6fe5-9820-45db-a1c0-06de4b5e3ab4","timestamp":"2025-12-31T09:55:17.566Z","toolUseResult":{"plan":"# Payment Service (Darwin) - Expert Study Guide\n\nA comprehensive guide to understanding the payment-service repository.\n\n---\n\n## 1. OVERVIEW & TECH STACK\n\n**Project Name:** Darwin (internal name for payment-service)\n**Purpose:** Enterprise-grade payment processing microservice handling multi-provider payment orchestration\n\n| Technology | Version | Purpose |\n|------------|---------|---------|\n| Java | 17 | Runtime |\n| Spring Boot | 2.7.14 | Framework |\n| Gradle | 7.6 | Build |\n| MySQL | - | Primary Database (Master-Replica) |\n| DynamoDB | - | Audit/State Storage |\n| Redis (Redisson) | 3.19.1 | Distributed Cache |\n| Kafka | - | Event Streaming |\n| AWS SQS | - | Task Processing |\n\n**Server:** Port 9010, Context Path: `/payments`\n\n---\n\n## 2. PROJECT STRUCTURE\n\n```\npayment-service/\n├── src/main/java/in/dreamplug/darwin/\n│   ├── controller/         # REST API endpoints\n│   │   └── v2/             # V2 API controllers (primary)\n│   ├── service/            # Business logic services\n│   ├── v2/\n│   │   ├── service/        # V2 services\n│   │   └── workflow/       # Payment workflows (CRITICAL)\n│   │       └── create/\n│   │           ├── payments/       # Payment creation\n│   │           ├── paymentattempts/ # Payment attempt creation\n│   │           └── providers/      # Provider adapters (24+)\n│   ├── entity/             # JPA entities\n│   │   └── v2/             # V2 entities (primary)\n│   ├── repository/         # Data access layer\n│   ├── statemachine/       # Payment/Order state machines\n│   ├── planner/            # Decision tree routing\n│   ├── cache/              # Caching layer (Caffeine)\n│   ├── client/             # External service clients\n│   ├── provider/           # Legacy provider implementations\n│   ├── configuration/      # Spring configs\n│   │   └── database/       # DB configs (Master/Replica)\n│   ├── kafka/              # Kafka producers/consumers\n│   ├── sqs/                # SQS message processors\n│   ├── dynamo/             # DynamoDB DAOs\n│   ├── error/              # Error handling\n│   ├── dto/                # Data transfer objects\n│   └── commons/spring/filters/  # Auth/Context filters\n├── src/main/resources/\n│   └── application.properties  # Main config (1300+ lines)\n├── codepipeline/           # CI/CD configurations\n├── build.gradle            # Dependencies\n└── Dockerfile              # Container setup\n```\n\n---\n\n## 3. CORE PAYMENT FLOW (CRITICAL)\n\n### 3.1 Payment Lifecycle\n\n```\nOrder Created → Payments Created → Payment Attempt Created → Provider API Call → Webhook/Status Update\n```\n\n**Key Steps:**\n\n1. **Order Creation** - Client creates an order with amount, currency, metadata\n2. **Bulk Payment Creation** - Multiple payment records created for the order\n   - File: `v2/workflow/create/payments/bulk/BulkPaymentCreateWorkflow.java`\n3. **Payment Attempt Creation** - Actual payment attempt with provider routing\n   - File: `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java`\n4. **Provider Processing** - Provider adapter calls external payment gateway\n5. **State Machine Updates** - Events trigger state transitions\n\n### 3.2 Workflow Execution Pipeline\n\n```java\n// Base workflow pattern (Workflow.java)\n1. validateAndEnrichContext()  // Validate inputs, enrich data\n2. persistIntent()             // Save entities to MySQL\n3. persistNonRelationalIntent() // Save to DynamoDB\n4. process()                   // Call provider API\n5. postProcess()               // Transform results\n6. publishEntityChangeEvents() // Trigger state machines\n7. throwErrorIfRequired()      // Handle errors\n```\n\n### 3.3 Payment Attempt Data Enrichment\n\n1. **Instrument Validation** - `InstrumentTypeProcessorManager`\n2. **Provider Routing** - `ProviderDeciderRouter` → Decision Tree\n3. **Auth Type Decision** - `AuthTypeDeciderFactory` (3DS, OTP, None)\n4. **Settlement Validation** - `SettlementRouteValidator`\n\n---\n\n## 4. STATE MACHINES\n\n### 4.1 Payment State Machine\n**File:** `statemachine/payment/PaymentStateMachine.java`\n\n```\nCREATED → PROCESSING → AUTHORIZED → COMPLETED\n                   ↘ FAILED\n                   ↘ BLOCKED\n```\n\n**Terminal States:** COMPLETED, FAILED, FORCE_FAILED, DISCARDED\n\n### 4.2 Order State Machine\n**File:** `statemachine/order/OrderStateMachine.java`\n\n- Reacts to payment events\n- Updates order status based on payment outcomes\n\n### 4.3 Events (EventBus - Guava)\n- `PaymentAttemptCreatedEvent`\n- `PaymentAttemptCompletedEvent`\n- `PaymentAttemptFailedEvent`\n- `PaymentAttemptProcessingEvent`\n- `PaymentAttemptAuthorizedEvent`\n\n---\n\n## 5. PROVIDER INTEGRATIONS (24+ Providers)\n\n**Location:** `v2/workflow/create/providers/`\n\n| Provider | Adapter File | Payment Types |\n|----------|-------------|---------------|\n| Cybersource | `CybersourceProviderAdapter.java` | Cards, 3DS, E-Mandates |\n| Cashfree | `CashfreeProviderAdapter.java` + variants | Cards, UPI, NetBanking |\n| PayU | `PayuProviderAdapter.java` + variants | Cards, NetBanking |\n| Pine Labs | `PineLabsEdgeProviderAdapter.java` | Multiple modes |\n| Razorpay | Via webhooks | All payment types |\n| Juspay | Via webhooks | Orchestration |\n| ICICI UPI | `icici-upi-client` | UPI |\n| Axis UPI | `axis-upi-client` | UPI |\n| YBL UPI | `ybl-upi-client` | UPI |\n| RBL UPI | `rbl-upi-client` | UPI |\n| Digio | `DigioMandateRegisterProviderAdapter.java` | E-Mandates |\n| Cred Points | `CredPointsProviderAdapter.java` | Reward redemption |\n\n### Provider Selection Flow\n\n```\nRequest → ProviderDeciderRouter → LCM (if enabled) → Decision Tree → Provider Adapter\n```\n\n**Decision Tree:** JSON-based rules cached in `DecisionTreeObjectCache`\n\n---\n\n## 6. KEY ENTITIES (V2 Schema)\n\n### Core Entities\n| Entity | File | Purpose |\n|--------|------|---------|\n| OrderEntity | `entity/OrderEntity.java` | Order records |\n| PaymentV2Entity | `entity/v2/PaymentV2Entity.java` | Payment records |\n| PaymentAttemptV2Entity | `entity/v2/PaymentAttemptV2Entity.java` | Payment attempts |\n| RefundEntity | `entity/v2/RefundEntity.java` | Refunds |\n| FeeEntity | `entity/v2/FeeEntity.java` | Fee tracking |\n\n### Configuration Entities\n| Entity | Purpose |\n|--------|---------|\n| ClientEntity | Application clients |\n| ProviderAccountEntity | Provider accounts |\n| PaymentProviderEntity | Provider configs |\n| MasterConfigurationEntity | System configs |\n\n---\n\n## 7. DATABASE ARCHITECTURE\n\n### Master-Replica Pattern\n\n**Master:** Write operations\n**Replica:** Read operations (via `@ReplicaRepository`)\n\n**Configuration Files:**\n- `configuration/database/MasterDataSourceConfiguration.java`\n- `configuration/database/ReplicaDataSourceConfiguration.java`\n\n**Database:** `payments_multi_tenancy`\n**Connection Pool:** HikariCP\n**ORM:** JPA + Hibernate\n\n---\n\n## 8. CACHING LAYER\n\n### Caffeine (In-Memory)\n| Cache | Purpose |\n|-------|---------|\n| `ClientConfigurationCache` | Client settings |\n| `PaymentProviderCache` | Provider configs |\n| `ProviderAccountCache` | Provider accounts |\n| `DecisionTreeObjectCache` | Routing rules |\n| `CardBinCache` | Card BIN data |\n| `MerchantCache` | Merchant data |\n| `FeeCache` | Fee calculations |\n\n### Redis (Distributed)\n- **Client:** Redisson with Kryo5Codec\n- **Use:** Distributed locks, rate limiting, shared state\n\n---\n\n## 9. ASYNC PROCESSING\n\n### Kafka Topics\n- `payment-attempt-platform-metrics-pinot-out-new-1` (Analytics)\n- Events: `PaymentAttemptAnalyticsEvent`, `CardPaymentAttemptAnalyticsEvent`, etc.\n\n### SQS Queues\n| Queue | Purpose |\n|-------|---------|\n| `FORCE_PAYMENT_FAILURE_QUEUE` | Manual failure forcing |\n| `MANDATE_EXPIRY_CRON_QUEUE` | Mandate expiry |\n| `REFUND_RESCHEDULE_QUEUE` | Refund scheduling |\n| `ORDER_EXPIRY_QUEUE` | Order expiration |\n| `PENDENCY_AUTOMATION_QUEUE` | Pending transactions |\n\n### Eventi (Internal Events)\n- Internal event framework for system events\n- Async worker threads (4-16 configurable)\n\n---\n\n## 10. API ENDPOINTS\n\n### Primary Controllers (v2)\n| Endpoint | Controller | Purpose |\n|----------|------------|---------|\n| `/v2/orders/{orderId}/payments` | `PaymentV2Controller` | Bulk payment creation |\n| `/v2/payments/{paymentId}/attempts` | `PaymentAttemptV2Controller` | Payment attempts |\n| `/v1/webhooks` | `WebhookController` | Provider webhooks |\n\n### Webhook Controllers\n- `RazorpayWebhookController`\n- `JuspayWebhookController`\n- `ICICIWebhookController`\n- `YBLWebhookController`\n- `RBLUpiWebhookController`\n- `DigioWebhookController`\n\n---\n\n## 11. AUTHENTICATION & SECURITY\n\n### Request Filters (Order of Execution)\n1. `ApplicationContextBuilderFilter` - Build context from headers\n2. `PAMerchantAuthenticationFilter` - Partner merchant auth\n3. `PAPartnerAuthorizationFilter` - Partner authorization\n\n### Headers Required\n- Client ID (`${CLIENT_HEADER_KEY}`)\n- Merchant ID (`${MERCHANT_HEADER_KEY}`)\n- Device info (DEVICE_ID, OS, OS_VERSION, APP_VERSION)\n\n### Rate Limiting\n- Redisson-based distributed rate limiting\n- Config in `ClientRateLimiter.java`\n\n---\n\n## 12. KEY FILES TO STUDY\n\n### Must-Read Files (Priority Order)\n\n1. **Entry Point:**\n   - `DarwinApplication.java`\n\n2. **Core Workflows:**\n   - `v2/workflow/create/Workflow.java` (base pattern)\n   - `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java`\n   - `v2/workflow/create/payments/bulk/BulkPaymentCreateWorkflow.java`\n\n3. **State Machines:**\n   - `statemachine/payment/PaymentStateMachine.java`\n   - `statemachine/order/OrderStateMachine.java`\n\n4. **Provider Routing:**\n   - `planner/ProviderDeciderRouter.java`\n   - `planner/decisiontree/DecisionTreeWorkflow.java`\n\n5. **Provider Adapters:**\n   - `v2/workflow/create/providers/` (pick any adapter)\n\n6. **Entities:**\n   - `entity/OrderEntity.java`\n   - `entity/v2/PaymentV2Entity.java`\n   - `entity/v2/PaymentAttemptV2Entity.java`\n\n7. **Configuration:**\n   - `application.properties` (1300+ lines - scan for context)\n\n8. **Webhooks:**\n   - `controller/WebhookController.java`\n\n---\n\n## 13. INTERNAL SERVICE DEPENDENCIES\n\n| Service | Client Library | Purpose |\n|---------|---------------|---------|\n| User Service | `user-service-client:4.0.1` | User data |\n| Merchant Service | `merchant-service-client:1.0.3` | Merchant info |\n| Mandate Service | `mandate-java-client:1.0.4` | Recurring payments |\n| Arsenal | - | Instrument vault |\n| Falcon | - | Offers/promotions |\n| Genie | `genie-java-client` | Configuration |\n| Syndicate | - | Authentication |\n| LCM | - | Terminal resolution |\n| Fee Service | `fees:0.18.0` | Fee calculation |\n\n---\n\n## 14. STUDY PATH RECOMMENDATION\n\n### Week 1: Foundation\n- [ ] Understand project structure\n- [ ] Read `DarwinApplication.java`\n- [ ] Study `application.properties` (key sections)\n- [ ] Understand entity relationships\n\n### Week 2: Core Flow\n- [ ] Master `PaymentAttemptCreateWorkflow.java`\n- [ ] Study state machines\n- [ ] Understand provider routing\n\n### Week 3: Integrations\n- [ ] Study 2-3 provider adapters\n- [ ] Understand webhook handling\n- [ ] Learn caching patterns\n\n### Week 4: Advanced\n- [ ] Decision tree engine\n- [ ] Async processing (Kafka, SQS)\n- [ ] Error handling patterns\n\n---\n\n## 15. KEY CONCEPTS\n\n1. **Multi-Provider Orchestration** - Route to optimal provider based on rules\n2. **Decision Trees** - JSON-based routing logic\n3. **State Machines** - Event-driven entity lifecycle\n4. **Master-Replica DB** - Read/write separation\n5. **Workflow Pattern** - 7-step execution pipeline\n6. **Event-Driven Architecture** - Guava EventBus + Kafka\n\n---\n\n# DATA LAYER DEEP-DIVE\n\n## 16. ENTITY HIERARCHY & INHERITANCE\n\n### Base Classes\n```\nBaseEntity (id, created_at, updated_at, created_by, updated_by)\n    └── BaseExternalEntity (+ external_id UUID, version for optimistic locking)\n            ├── OrderEntity\n            ├── PaymentV2Entity\n            ├── PaymentAttemptV2Entity\n            ├── RefundEntity\n            ├── ClientEntity\n            └── CustomerEntity\n```\n\n### Key Entity Files\n| Entity | File | Key Fields |\n|--------|------|------------|\n| OrderEntity | `entity/OrderEntity.java` | clientReferenceId, amount, status, metadata (JSON) |\n| PaymentV2Entity | `entity/v2/PaymentV2Entity.java` | orderId, amount, paymentMode, instrumentDetail (JSON) |\n| PaymentAttemptV2Entity | `entity/v2/PaymentAttemptV2Entity.java` | paymentId, providerReferenceId, gatewayReferenceId, status |\n| RefundEntity | `entity/v2/RefundEntity.java` | orderId, paymentAttemptId, refundType, refundStatus |\n| ClientEntity | `entity/ClientEntity.java` | name, merchantId, settings (OneToMany) |\n\n### Entity Relationships\n```\nClientEntity (1) ──> (M) OrderEntity\nOrderEntity (1) ──> (M) PaymentV2Entity\nPaymentV2Entity (1) ──> (M) PaymentAttemptV2Entity\nPaymentAttemptV2Entity ──> PaymentProviderEntity\nPaymentAttemptV2Entity ──> ProviderAccountEntity\nOrderEntity (1) ──> (M) RefundEntity\nRefundEntity (1) ──> (M) RefundAttemptEntity\n```\n\n---\n\n## 17. MASTER-REPLICA DATABASE ARCHITECTURE\n\n### How Routing Works\n\n**Master (Writes):** `MasterDataSourceConfiguration.java`\n- EntityManagerFactory: `MasterEntityManagerFactory`\n- TransactionManager: `MasterTransactionManager`\n- Excludes beans with `@ReplicaRepository`\n\n**Replica (Reads):** `ReplicaDataSourceConfiguration.java`\n- EntityManagerFactory: `ReplicaEntityManagerFactory`\n- TransactionManager: `ReplicaTransactionManager`\n- Includes ONLY beans with `@ReplicaRepository`\n- Connection pool set to `readOnly=true`\n\n### Usage Pattern\n```java\n// Write to master (default)\n@Repository\npublic interface PaymentRepository extends JpaRepository<...> {}\n\n// Read from replica\n@Repository\n@ReplicaRepository  // <-- Annotation routes to replica\npublic class RefundEntityReplicaDAOImpl extends AbstractReplicaDAOImpl<...> {}\n```\n\n### HikariCP Connection Pools\n| Pool | Config | Purpose |\n|------|--------|---------|\n| hikari_master | masterMinimumIdle, masterMaximumPoolSize | Write operations |\n| hikari_replica | replicaMinimumIdle, replicaMaximumPoolSize, readOnly=true | Read operations |\n\nBoth pools have:\n- idleTimeout, connectionTimeout, maxLifetime\n- leakDetectionThreshold for debugging\n- MaintenanceManager integration for graceful shutdown\n\n---\n\n## 18. REPOSITORY & DAO PATTERNS\n\n### JPA Repository Pattern\n```java\n@Repository\npublic interface OrderRepository extends JpaRepository<OrderEntity, Long> {\n    // FETCH JOIN to prevent N+1 queries\n    @Query(\"SELECT o FROM OrderEntity o \"\n            + \"JOIN FETCH o.customerEntity \"\n            + \"JOIN FETCH o.clientEntity \"\n            + \"WHERE o.externalId = :externalId\")\n    Optional<OrderEntity> findByExternalId(@Param(\"externalId\") String externalId);\n\n    // Property path navigation\n    Optional<OrderEntity> findByClientReferenceIdAndClientEntity_ExternalId(\n            String clientReferenceId, String externalId);\n}\n```\n\n### DAO Pattern (Custom EntityManager)\n```java\n@Repository\npublic class PaymentAttemptDAOV2Impl {\n    @PersistenceContext\n    private EntityManager entityManager;\n\n    public List<PaymentAttemptV2Entity> findByOrderId(Long orderId) {\n        // Complex JPQL with manual EntityManager\n    }\n}\n```\n\n### DynamoDB DAO Pattern\n```java\n@RequiredArgsConstructor\npublic abstract class AbstractDynamoDBDAO<T> {\n    private final DynamoDBMapper dynamoDBMapper;\n\n    public void save(T entity) { dynamoDBMapper.save(entity); }\n    public T findByHashKey(Object hashKey) { return dynamoDBMapper.load(tClass, hashKey); }\n}\n```\n\n---\n\n## 19. JSON COLUMNS & CONVERTERS\n\n**Flexible Attribute Storage:**\n| Column | Converter | Entity |\n|--------|-----------|--------|\n| metadata | ObjectMetadataMapConverter | OrderEntity |\n| instrument_detail | PaymentInstrumentConverter | PaymentV2Entity |\n| instrument_detail | EnrichedPaymentInstrumentConverter | PaymentAttemptV2Entity |\n| routes | RoutesBreakupConverter | PaymentAttemptV2Entity |\n| payment_specific_detail | PaymentSpecificDetailConverter | PaymentV2Entity |\n\n```java\n@Column(name = \"metadata\")\n@Convert(converter = ObjectMetadataMapConverter.class)\nprivate Map<String, String> metaData;\n```\n\n---\n\n## 20. CACHING ARCHITECTURE\n\n### Caffeine Caches (In-Memory)\n| Cache Class | What It Caches | TTL |\n|-------------|----------------|-----|\n| ClientConfigurationCache | Client settings by ID, by externalId, by merchantId | 10-20 min |\n| PaymentProviderCache | Provider configurations | 15-25 min |\n| ProviderAccountCache | Provider account entities | 15-25 min |\n| DecisionTreeObjectCache | Routing decision trees | 180-190 min |\n| FeeCache | Fee configurations | 1 day |\n| CardBinCache | Card BIN details | Configurable |\n| MasterConfigurationCache | Feature flags, system settings | 10-20 min |\n| PaymentErrorMessageMappingCache | Error code to message mappings | Long |\n\n### Cache Pattern\n```java\n@DPCache(cacheName = \"client_configuration_cache\")\nprivate LoadingCache<Long, Map<ClientSettingKey, String>> idCache;\n\n@Override\npublic void buildCache() {\n    idCache = DPCacheBuilder.getBuilder()\n        .refreshAfterWrite(10, MINUTES)  // Lazy refresh\n        .build(this::loadClientSettings);  // Loader function\n}\n```\n\n### Jittered TTLs (Prevent Thundering Herd)\n```java\n// Returns 15-25 instead of fixed 15\nprivate Long generateRandomCacheRefreshInterval(int base) {\n    return base + random.nextInt(10) + 1;\n}\n```\n\n---\n\n## 21. DYNAMODB USAGE\n\n### What Goes Where\n| MySQL | DynamoDB |\n|-------|----------|\n| Orders, Payments, Attempts | Workflow context (TTL-based) |\n| Refunds, Fees | Native OTP details |\n| Clients, Customers | Redirect tracking |\n| Provider configs | Metadata audit trails |\n\n### DynamoDB Entity Example\n```java\n@DynamoDBTable(tableName = \"darwin_payment_attempt_workflow_context\")\npublic class PaymentAttemptWorkflowContextEntity {\n    @DynamoDBHashKey(attributeName = \"payment_attempt_external_id\")\n    private String paymentAttemptExternalId;\n\n    @DynamoDBRangeKey\n    @DynamoDBAttribute(attributeName = \"workflow_step\")\n    private WorkflowStep workflowStep;\n\n    @Builder.Default\n    private long ttl = LocalDateTime.now().plusDays(1).toEpochSecond(ZoneOffset.UTC);\n}\n```\n\n### DynamoDB Tables\n| Table | Partition Key | Sort Key | Purpose |\n|-------|---------------|----------|---------|\n| darwin_payment_attempt_workflow_context | payment_attempt_external_id | workflow_step | Workflow state |\n| darwin_payment_attempt_native_otp_detail | payment_attempt_external_id | - | OTP auth details |\n| darwin_payment_attempt_redirection_detail | payment_attempt_external_id | - | 3DS redirects |\n| darwin_payment_attempt_metadata_audit | payment_attempt_external_id | - | Audit trail |\n\n---\n\n## 22. OPTIMISTIC LOCKING & AUDIT\n\n### @Version for Optimistic Locking\n```java\n@Version\n@Column(name = \"version\")\nprivate Integer version;  // Auto-incremented on each update\n```\n\nPrevents concurrent modification - throws `OptimisticLockException` on conflict.\n\n### Audit Columns (Auto-Managed)\n```java\n@CreationTimestamp\n@Column(name = \"created_at\")\nprivate LocalDateTime createAt;\n\n@UpdateTimestamp\n@Column(name = \"updated_at\")\nprivate LocalDateTime updatedAt;\n\n@PrePersist\npublic void onCreate() {\n    createdBy = ApplicationContext.getApplicationName();\n}\n\n@PreUpdate\npublic void onUpdate() {\n    updatedBy = ApplicationContext.getApplicationName();\n}\n```\n\n---\n\n## 23. DATA LAYER ARCHITECTURE DIAGRAM\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                    Service Layer                        │\n├─────────────────────────────────────────────────────────┤\n│ JPA Repositories      │ Custom DAOs      │ DynamoDB DAOs │\n├─────────────────────────────────────────────────────────┤\n│     Spring Data JPA + Hibernate ORM                     │\n├──────────────────────┬──────────────────────────────────┤\n│   Master DataSource  │      Replica DataSource          │\n│   (Writes)           │      (Reads - @ReplicaRepository)│\n├──────────────────────┼──────────────────────────────────┤\n│ HikariCP Master Pool │   HikariCP Replica Pool          │\n├──────────────────────┴──────────────────────────────────┤\n│         MySQL (payments_multi_tenancy)                  │\n└─────────────────────────────────────────────────────────┘\n         │                              │\n┌────────▼────────┐          ┌──────────▼─────────┐\n│    DynamoDB     │          │  Caffeine Caches   │\n│ (Workflow/Audit)│          │  (Client/Provider) │\n└─────────────────┘          └────────────────────┘\n```\n\n---\n\n## 24. KEY DATA LAYER FILES TO STUDY\n\n### Entity Classes (Priority)\n1. `entity/commons/BaseEntity.java` - Base class pattern\n2. `entity/provider/BaseExternalEntity.java` - External ID + versioning\n3. `entity/OrderEntity.java` - Main order entity\n4. `entity/v2/PaymentAttemptV2Entity.java` - Payment attempt (most complex)\n\n### Database Configuration\n1. `configuration/database/MasterDataSourceConfiguration.java`\n2. `configuration/database/ReplicaDataSourceConfiguration.java`\n3. `configuration/database/annotation/ReplicaRepository.java`\n\n### Repositories\n1. `repository/OrderRepository.java` - FETCH JOIN examples\n2. `repository/PaymentAttemptRepository.java` - Complex queries\n\n### Caches\n1. `cache/ClientConfigurationCache.java` - Cache pattern example\n2. `configuration/CacheConfig.java` - Cache configuration\n\n### DynamoDB\n1. `dynamo/dao/AbstractDynamoDBDAO.java` - Base DAO pattern\n2. `dynamo/domain/PaymentAttemptWorkflowContextEntity.java` - DynamoDB entity\n\n---\n\n# PROVIDER INTEGRATION DEEP-DIVE\n\n## 25. PROVIDER ADAPTER ARCHITECTURE\n\n### Base Adapter Pattern\n**File:** `v2/workflow/create/providers/IPaymentProviderAdapter.java`\n\n```java\npublic abstract class IPaymentProviderAdapter<T, R> implements SelfReferencingBean {\n    protected final PaymentProviderKey paymentProviderKey;  // e.g., CASHFREE, CYBERSOURCE\n    private final InstrumentType instrumentType;            // e.g., CARD, UPI_APPS\n    private final OrderType orderType;                      // e.g., PAY, REFUND\n\n    // Core lifecycle methods\n    public abstract ProviderPaymentResponse createPaymentAttempt(context, customerEntity);\n    protected abstract Object syncPaymentAttemptWithProviderId(paymentAttemptEntity);\n    protected abstract ProviderRefundCreateResponse createRefund(refundAttemptEntity, context);\n    protected abstract R getAuthConfig(providerAccountEntity);\n}\n```\n\n### Factory Pattern for Adapter Selection\n**File:** `v2/workflow/create/providers/PaymentProviderFactory.java`\n\n```java\n@Component\npublic class PaymentProviderFactory {\n    // Multi-dimensional lookup: OrderType + ProviderKey + InstrumentType → Adapter\n    private Map<PaymentWorkflowKey, IPaymentProviderAdapter<?, ?>> paymentProviderMap;\n\n    // Secondary lookup: OrderType + ProviderKey → First adapter\n    private Table<OrderType, PaymentProviderKey, IPaymentProviderAdapter<?, ?>> paymentProviderByKey;\n\n    // 3DS variant support\n    private ThreeDSType threeDSType;  // 3DS1 vs 3DS2\n}\n```\n\n### Provider Response Structure\n```java\n@Data @Builder\npublic class ProviderPaymentResponse {\n    private Object providerResponseObject;     // Raw provider response\n    private String providerReferenceId;        // Provider's transaction ID\n    private String gatewayReferenceId;         // Gateway ID\n    private String providerStatus;             // Raw status (\"SUCCESS\")\n    private PaymentAttemptStatus status;       // Mapped internal status\n    private ProviderRequestStatus providerRequestStatus;  // REQUEST_SUCCESS, RETRY_ABLE_FAILURE\n    private ProviderError providerError;       // Error details if failed\n}\n```\n\n---\n\n## 26. DECISION TREE ROUTING\n\n### Router Strategy Pattern\n**File:** `planner/providerdecider/ProviderDeciderRouter.java`\n\n```java\n@Service\npublic class ProviderDeciderRouter {\n    public ProviderRoutingDecisionResult resolve(PaymentAttemptCreateContext context) {\n        // Priority 1: LCM routing (if instrument supported)\n        if (isInstrumentTypeSupportedInLCM(clientId, instrumentType)) {\n            return providerDeciderViaLCM.decideProvider(context);\n        }\n\n        // Priority 2: Decision Tree routing\n        if (isDecisionTreeEnabled) {\n            return providerDeciderV2.decideProvider(context);\n        }\n    }\n}\n```\n\n### Decision Tree Workflow\n**File:** `planner/providerdecider/ProviderDeciderV2.java`\n\n```\nRequest → Fetch Cached Decision Tree → Create DT Context → Execute Tree → Apply Dynamic Routing → Return Provider\n```\n\n**Decision Tree Factors:**\n- Client configuration\n- Instrument type (Card, UPI, NetBanking)\n- Card brand/BIN\n- Customer attributes\n- Order amount\n- Provider availability/downtime\n\n### Decision Tree Caching\n**File:** `cache/DecisionTreeObjectCache.java`\n\n| Cache | TTL | Content |\n|-------|-----|---------|\n| decision_tree_object_cache | 180-190 min | Parsed decision tree JSON + workflow |\n\n---\n\n## 27. PROVIDER ADAPTERS (24+ Implementations)\n\n### Adapter Directory Structure\n```\nv2/workflow/create/providers/\n├── IPaymentProviderAdapter.java          # Base abstract class\n├── PaymentProviderFactory.java           # Factory for adapter selection\n├── CashfreeProviderAdapter.java          # Cashfree base\n├── CashfreeCardProviderAdapter.java      # Cashfree cards\n├── CashfreeNetBankingProviderAdapter.java\n├── CashfreeUPIProviderAdapter.java\n├── CashfreeUPIAppsProviderAdapter.java\n├── cybersource/\n│   ├── CybersourceProviderAdapter.java   # Cybersource base (3DS)\n│   ├── CybersourceRequestBuilder.java    # Request construction\n│   └── CybersourceAuthorizeRequestBuilder.java\n├── PayuProviderAdapter.java\n├── PayuCardProviderAdapter.java\n├── PineLabsEdgeProviderAdapter.java\n├── CredPointsProviderAdapter.java\n├── RewardPointsProviderAdapter.java\n└── AuthTokenNativeProviderAdapter.java\n```\n\n### Cashfree Adapter Example\n**File:** `v2/workflow/create/providers/CashfreeProviderAdapter.java`\n\n```java\n@Component\npublic abstract class CashfreeProviderAdapter\n        extends IPaymentProviderAdapter<String, CashfreeAuthConfig> {\n\n    // Two-phase payment creation:\n    // 1. Create order at Cashfree\n    // 2. Create payment for that order\n\n    @Override\n    public ProviderPaymentResponse createPaymentAttempt(context, customer) {\n        // Phase 1: Create CF Order\n        Pair<BaseResponse<CreateOrderResponse>, ProviderError> orderResponse =\n            createCFOrder(context, authConfig);\n\n        // Phase 2: Create CF Payment\n        Pair<BaseResponse<CreatePaymentResponse>, ProviderError> paymentResponse =\n            createCFPayment(context, orderResponse.getLeft().getResponse(), authConfig);\n\n        return mapToProviderPaymentResponse(paymentResponse);\n    }\n}\n```\n\n### Cybersource Adapter (3DS Support)\n**File:** `v2/workflow/create/providers/cybersource/CybersourceProviderAdapter.java`\n\n```java\n@Component\npublic abstract class CybersourceProviderAdapter\n        extends I3DSPaymentProviderAdapter<String, AuthConfig> {\n\n    // Status code mappings\n    private static final List<String> FAILED_STATUSES = Arrays.asList(\n        \"101\", \"102\", \"104\", \"150\", \"200\", \"201\", ...  // 43 codes\n    );\n    private static final List<String> PROCESSING_STATUSES = Arrays.asList(\n        \"110\", \"475\", \"480\"\n    );\n\n    // 3DS2 redirection flow\n    protected void createRedirectionHtml(response, paymentAttemptEntity) {\n        if (authInfo.getSpecificationVersion().startsWith(\"2\")) {\n            // 3DS2 flow with step-up URL\n            html = authenticationService.createAuthenticationPageFor3ds2(\n                authInfo.getStepUpUrl(),\n                authInfo.getAccessToken(),\n                paymentAttemptEntity.getExternalId());\n        }\n    }\n}\n```\n\n---\n\n## 28. WEBHOOK HANDLING\n\n### Webhook Architecture\n```\nProvider → /webhooks/v2/{provider} → Provider-Specific Controller → WebhookService → State Machine Update\n```\n\n### Provider Webhook Controllers\n| Endpoint | Controller | Provider |\n|----------|------------|----------|\n| `/webhooks/v2/cashfree` | CashfreeWebhookController | Cashfree |\n| `/webhooks/v2/razorpay` | RazorpayWebhookController | Razorpay |\n| `/webhooks/v2/payu` | PayuWebhookController | PayU |\n| `/webhooks/v2/cybersource` | CybersourceWebhookController | Cybersource |\n| `/webhooks/v2/juspay` | JuspayWebhookController | Juspay |\n| `/webhooks/v2/ybl` | YBLWebhookController | Yes Bank UPI |\n| `/webhooks/v2/icici` | ICICIWebhookController | ICICI UPI |\n| `/webhooks/v2/rbl-upi` | RBLUpiWebhookController | RBL UPI |\n| `/webhooks/v2/digio` | DigioWebhookController | Digio (eMandate) |\n\n### Webhook Processing Flow\n**File:** `controller/v2/CashfreeWebhookController.java`\n\n```java\n@PostMapping\npublic void onWebhookReceive(@RequestBody CashfreeWebhook webhookRequest) {\n    switch (webhookRequest.getType()) {\n        case PAYMENT_SUCCESS_WEBHOOK:\n        case PAYMENT_FAILED_WEBHOOK:\n            // 1. Extract provider reference ID\n            String providerRefId = paymentWebhook.getData().getCfPaymentId();\n\n            // 2. Fetch payment attempt\n            PaymentAttempt attempt = paymentAttemptFetchWorkflow\n                .fetchByProviderReferenceId(providerRefId);\n\n            // 3. Audit webhook data\n            auditService.auditProviderData(webhookRequest, attempt.getId(), ...);\n\n            // 4. Sync status (triggers state machine)\n            break;\n\n        case REFUND_STATUS_WEBHOOK:\n            processRefundAttempt(webhookRequest);\n            break;\n    }\n}\n```\n\n### Idempotency Handling\n```java\n// In base adapter - only update if status actually changed\npublic void syncPaymentAttemptWithProvider(PaymentAttemptV2Entity entity) {\n    String currentStatus = entity.getProviderStatus();\n\n    Object providerResponse = syncPaymentAttemptWithProviderId(entity);\n\n    // Only audit and process if status changed\n    if (!Objects.equals(currentStatus, entity.getProviderStatus())) {\n        auditService.auditProviderData(...);\n    }\n}\n```\n\n---\n\n## 29. PROVIDER CONFIGURATION\n\n### Configuration Entities\n**File:** `entity/ProviderAccountEntity.java`\n\n```java\n@Entity @Table(name = \"provider_accounts\")\npublic class ProviderAccountEntity extends BaseEntity {\n    @ManyToOne\n    private PaymentProviderEntity paymentProvider;\n\n    private String providerAccountId;     // e.g., \"ACC_123456\"\n\n    @Lob\n    private byte[] accessToken;           // Encrypted credentials\n\n    private String endpoint;              // Provider API endpoint\n    private Boolean isProd;               // Production vs Sandbox\n    private Boolean active;\n    private String additionalConfig;      // JSON configuration\n    private String providerMid;           // Merchant ID at provider\n    private String settlementCategory;    // Settlement routing\n}\n```\n\n### Provider-Specific Configurations\n```java\n// Cashfree\n@Data\npublic class CashfreeProviderAccountConfiguration {\n    private String apiClientId;\n    private String apiVersion;\n    private ShortCircuitConfiguration shortCircuitConfiguration;\n}\n\n// Cybersource\n@Data\npublic class CybersourceProviderAccountConfiguration {\n    private String apiKey;\n    private String merchantId;\n    private Boolean enableRetries = false;\n    private Boolean enableCaptureWithAuth = true;\n    private Boolean enable3DS2 = true;\n    private Boolean enableRedirectionFlow = false;\n}\n```\n\n### Client-Provider Mapping\n**File:** `entity/ClientPaymentProviderConfigEntity.java`\n\n```java\n@Entity @Table(name = \"client_payment_provider_config\")\npublic class ClientPaymentProviderConfigEntity extends BaseEntity {\n    @ManyToOne private ClientEntity client;\n    @ManyToOne private PaymentProviderEntity paymentProvider;\n    private String providerConfig;  // JSON configuration per client\n}\n```\n\n---\n\n## 30. ERROR HANDLING & RETRY LOGIC\n\n### Error Classification\n```java\npublic enum ProviderRequestStatus {\n    REQUEST_SUCCESS,          // Payment processed\n    RETRY_ABLE_FAILURE,       // Timeout, rate limit - can retry\n    NON_RETRY_ABLE_FAILURE    // Invalid request - cannot retry\n}\n```\n\n### Provider Error Structure\n```java\n@Data @Builder\npublic class ProviderError {\n    private String message;           // User-friendly message\n    private String code;              // Provider error code\n    private Object providerResponse;  // Raw error response\n    private Boolean retryable;        // Retry classification\n}\n```\n\n### Error Code Mapping (Cybersource Example)\n```java\n// Failure codes (43 codes)\n\"101\", \"102\", \"104\", \"150\", \"200\", \"201\", \"202\", \"203\", ...\n\n// Processing/Pending codes\n\"110\" (Pending), \"475\" (Timeout), \"480\" (Processing)\n```\n\n### Retry Pattern\n```java\npublic ProviderPaymentResponse executePaymentAttempt(...) {\n    try {\n        return pilotMethod.apply(context, providerCustomer);\n    } catch (RateLimitException rle) {\n        return ProviderPaymentResponse.builder()\n            .providerRequestStatus(ProviderRequestStatus.RETRY_ABLE_FAILURE)\n            .providerError(ProviderError.builder()\n                .retryable(true).build())\n            .build();\n    } catch (AppException ae) {\n        return ProviderPaymentResponse.builder()\n            .providerRequestStatus(ProviderRequestStatus.NON_RETRY_ABLE_FAILURE)\n            .build();\n    }\n}\n```\n\n---\n\n## 31. ARCHITECTURAL PATTERNS SUMMARY\n\n| Pattern | Usage | File |\n|---------|-------|------|\n| **Factory** | Adapter selection by (OrderType, Provider, Instrument) | PaymentProviderFactory.java |\n| **Strategy** | LCM vs Decision Tree routing | ProviderDeciderRouter.java |\n| **Template Method** | Base adapter lifecycle | IPaymentProviderAdapter.java |\n| **Builder** | Complex request construction | CybersourceRequestBuilder.java |\n| **Decorator** | Provider-specific configuration | *ConfigValueDecoratorImpl.java |\n\n---\n\n## 32. KEY PROVIDER INTEGRATION FILES\n\n### Core Architecture\n1. `v2/workflow/create/providers/IPaymentProviderAdapter.java` - Base adapter\n2. `v2/workflow/create/providers/PaymentProviderFactory.java` - Factory\n3. `planner/providerdecider/ProviderDeciderRouter.java` - Routing strategy\n\n### Decision Tree\n1. `planner/providerdecider/ProviderDeciderV2.java` - DT workflow\n2. `planner/providerdecider/ProviderDeciderViaLCM.java` - LCM routing\n3. `cache/DecisionTreeObjectCache.java` - DT caching\n\n### Webhooks\n1. `controller/WebhookController.java` - Generic webhook endpoint\n2. `controller/v2/CashfreeWebhookController.java` - Cashfree webhooks\n3. `service/WebhookService.java` - Webhook processing\n\n### Provider Implementations\n1. `v2/workflow/create/providers/CashfreeProviderAdapter.java`\n2. `v2/workflow/create/providers/cybersource/CybersourceProviderAdapter.java`\n3. `v2/workflow/create/providers/PayuProviderAdapter.java`\n\n### Configuration\n1. `entity/ProviderAccountEntity.java` - Provider credentials\n2. `entity/PaymentProviderEntity.java` - Provider definition\n3. `entity/ClientPaymentProviderConfigEntity.java` - Client-provider mapping\n\n---\n\n# PAYMENT FLOW DEEP-DIVE\n\n## 33. THE 7-STEP WORKFLOW PIPELINE\n\n### Base Workflow Pattern (Template Method)\n**File:** `v2/workflow/create/Workflow.java`\n\n```java\npublic Response execute(Request request) {\n    // STEP 1: Validate inputs and enrich context\n    Context context = validateAndEnrichContext(request);\n\n    // STEP 2: Persist to relational DB (transactional)\n    persistIntent(context);\n\n    // STEP 3: Pre-persist event hooks\n    publishEntityPrePersistEvents(context);\n\n    // STEP 4: Persist to non-relational DB (DynamoDB)\n    persistNonRelationalIntent(context);\n\n    // STEP 5: Process (external provider calls)\n    process(context);\n\n    // STEP 6: Post-process and save results (transactional)\n    Response response = postProcess(context);\n\n    // STEP 7: Post-persist & publish events\n    postPersistNonRelationalDataStore(context);\n    publishEntityChangeEvents(context);\n\n    throwErrorIfRequired(context);\n    return response;\n}\n```\n\n---\n\n## 34. PAYMENTATTEMPTCREATEWORKFLOW DETAILED\n\n**File:** `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java`\n\n### Step 1: Validate & Enrich Context\n\n| Enricher | Purpose | Output |\n|----------|---------|--------|\n| `InstrumentTypeProcessorManager` | Validate & enrich payment instrument | `InstrumentTypeProcessorResult` |\n| `ProviderDeciderRouter.resolve()` | Route to provider via Decision Tree | `ProviderRoutingDecisionResult` |\n| `AuthTypeDeciderFactory` | Determine auth type (3DS, OTP, None) | `AuthType` |\n| `NativeProviderDecider` | Select native OTP provider | `ProviderAccountEntity` |\n| `SettlementRouteValidator` | Validate & enrich settlement routes | `RoutesBreakup` |\n| `MandateServiceDataManager` | Register mandate (if eMandate) | `Mandate` |\n\n### Context Object Structure\n```java\nPaymentAttemptCreateContext {\n    // Request/Response\n    CreatePaymentAttemptRequest request\n    PaymentAttemptResponse response\n\n    // Entities\n    PaymentAttemptV2Entity paymentAttemptEntity\n    PaymentV2Entity paymentEntity\n    OrderEntity orderEntity\n    CustomerEntity customerEntity\n    ClientEntity clientEntity\n\n    // Enriched Data\n    InstrumentTypeProcessorResult instrumentProcessorResult\n    ProviderAccountEntity providerAccountEntity\n    ProviderRoutingDecisionResult routingDecisionResult\n    AuthType authType\n    RoutesBreakup routesBreakup\n    ProviderPaymentResponse createResponse\n\n    // OTP/Auth Flow\n    Boolean isPlatformNativeOtpSupported\n    PaymentAttemptNativeOTPDetailEntity nativeOTPDetailEntity\n\n    // Error Collection\n    List<WorkflowInternalError> errors\n}\n```\n\n### Step 2: Persist Intent\n```java\n@Transactional(transactionManager = \"MasterTransactionManager\")\npublic void persistIntent(PaymentAttemptCreateContext context) {\n    // Create PaymentAttemptV2Entity\n    PaymentAttemptV2Entity entity = PaymentAttemptV2Entity.builder()\n        .externalId(PaymentAttemptUUIdGenerator.generate())\n        .status(PaymentAttemptStatus.CREATED)\n        .paymentEntity(paymentEntity)\n        .providerAccountEntity(providerAccountEntity)\n        .paymentMethod(instrumentResult.getPaymentMethod())\n        .instrumentDetail(instrumentResult.getEnrichedInstrument())\n        .routesBreakup(routesBreakup)\n        .build();\n\n    // Save to repository\n    paymentAttemptRepository.save(entity);\n\n    // Save fees\n    feeCreateWorkflow.persistIntent(feeContexts);\n\n    // Add attributes (DT_ID, DT_RESULT, etc.)\n    enrichAttributes(entity);\n}\n```\n\n### Step 5: Process (Provider Call)\n```java\npublic void process(PaymentAttemptCreateContext context) {\n    // Find adapter\n    IPaymentProviderAdapter adapter = paymentProviderFactory\n        .findPaymentProviderAdapter(orderType, providerKey, instrumentType, threeDSType);\n\n    // Execute provider call\n    ProviderPaymentResponse response = adapter.executePaymentAttempt(\n        context,\n        adapter::createPaymentAttempt,\n        FlowType.CREATE\n    );\n\n    // Check platform OTP capability\n    response = checkIfPlatformOtpEnabled(context, response);\n\n    context.setCreateResponse(response);\n}\n```\n\n### Step 6: Post-Process\n```java\n@Transactional\npublic PaymentAttemptResponse postProcess(PaymentAttemptCreateContext context) {\n    PaymentAttemptV2Entity entity = context.getPaymentAttemptEntity();\n    ProviderPaymentResponse response = context.getCreateResponse();\n\n    // Update from provider response\n    entity.setProviderStatus(response.getProviderStatus());\n    entity.setProviderReferenceId(response.getProviderReferenceId());\n    entity.setGatewayReferenceId(response.getGatewayReferenceId());\n\n    // Determine final status\n    if (response.getProviderRequestStatus() == REQUEST_SUCCESS) {\n        entity.setStatus(response.getStatus());\n    } else if (isEligiblePaymentMode) {\n        entity.setStatus(response.getStatus() == FAILED ? FAILED : PROCESSING);\n    }\n\n    paymentAttemptRepository.save(entity);\n    return mapper.toResponse(entity, response);\n}\n```\n\n### Step 7: Publish Events\n```java\npublic void publishEntityChangeEvents(PaymentAttemptCreateContext context) {\n    // Post to sync EventBus (triggers PaymentStateMachine)\n    syncBus.post(PaymentAttemptEventFactory.findEvent(paymentAttemptEntity));\n\n    // Post to async EventBus\n    asyncBus.post(PaymentAttemptEventFactory.findEvent(paymentAttemptEntity));\n\n    // Publish to multi-tenant event system\n    eventiService.publishEvent(paymentAttemptEntity);\n\n    // Add to sync manager for webhook updates\n    syncManager.addEntityForSync(paymentAttemptEntity);\n}\n```\n\n---\n\n## 35. STATE MACHINE IMPLEMENTATION\n\n### PaymentStateMachine\n**File:** `statemachine/payment/PaymentStateMachine.java`\n\n```\nEvent Subscriptions:\n├── @Subscribe onPaymentAttemptCreated\n│   └── Payment: FAILED → CREATED\n├── @Subscribe onPaymentAttemptFailed\n│   └── If all attempts failed: Payment → FAILED\n├── @Subscribe onPaymentAttemptCompleted\n│   └── Payment → COMPLETED (with optimistic lock retry)\n├── @Subscribe onPaymentAttemptAuthorized\n│   └── Payment → AUTHORIZED\n├── @Subscribe onPaymentAttemptProcessing\n│   └── Payment → PROCESSING\n├── @Subscribe onPaymentAttemptBlocked\n│   └── Payment → BLOCKED\n└── @Subscribe onAuthenticationSuccessful/Failed\n    └── Payment → AUTHENTICATION_SUCCESSFUL/FAILED\n```\n\n### OrderStateMachine\n**File:** `statemachine/order/OrderStateMachine.java`\n\n```\nEvent Subscriptions:\n├── @Subscribe onPaymentCreated\n│   └── Order → CREATED or AUTHLESS_READY_TO_PROCESS\n├── @Subscribe onPaymentFailed\n│   └── Order → FAILED\n├── @Subscribe onPaymentCompleted\n│   └── Order → COMPLETED (if all payments done)\n├── @Subscribe onPaymentAuthorized\n│   └── Order → AUTHORIZED\n└── @Subscribe onPaymentProcessing\n    └── Order → PROCESSING\n```\n\n### Terminal States\n| Entity | Terminal States |\n|--------|-----------------|\n| PaymentAttempt | COMPLETED, FAILED, FORCE_FAILED |\n| Payment | COMPLETED, FAILED, FORCE_FAILED, DISCARDED |\n| Order | COMPLETED, FAILED |\n\n### State Transition Guard\n```java\nprivate boolean shouldUpdatePaymentStatus(PaymentV2Entity entity) {\n    return !Arrays.asList(COMPLETED, FAILED, FORCE_FAILED, DISCARDED)\n        .contains(entity.getStatus());\n}\n```\n\n---\n\n## 36. END-TO-END PAYMENT FLOW\n\n```\n┌─────────────────────────────────────────────────────────────────────────┐\n│                         CLIENT REQUEST                                   │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  1. ORDER CREATION                                                       │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ OrderCreateWorkflow.execute()                                       │ │\n│  │ ├── validateAndEnrichContext() - Customer lookup, order validation │ │\n│  │ ├── persistIntent() - Save OrderEntity (status: CREATED)           │ │\n│  │ └── publishEvents() → OrderStateMachine                            │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  2. PAYMENT CREATION                                                     │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ BulkPaymentCreateWorkflow.execute()                                 │ │\n│  │ ├── validateAndEnrichContext() - Payment mode validation           │ │\n│  │ ├── persistIntent() - Save PaymentV2Entity (status: CREATED)       │ │\n│  │ └── publishEvents() → PaymentStateMachine                          │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  3. PAYMENT ATTEMPT CREATION (Core Flow)                                 │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ PaymentAttemptCreateWorkflow.execute()                              │ │\n│  │ ├── validateAndEnrichContext()                                     │ │\n│  │ │   ├── InstrumentTypeProcessorManager (Card/UPI/NetBanking)       │ │\n│  │ │   ├── ProviderDeciderRouter (Decision Tree routing)              │ │\n│  │ │   ├── AuthTypeDeciderFactory (3DS/OTP/None)                      │ │\n│  │ │   └── SettlementRouteValidator                                   │ │\n│  │ ├── persistIntent() - Save PaymentAttemptV2Entity                  │ │\n│  │ ├── persistNonRelationalIntent() - DynamoDB (OTP details)          │ │\n│  │ ├── process() - Provider API call via Adapter                      │ │\n│  │ ├── postProcess() - Update entity with provider response           │ │\n│  │ └── publishEvents() → PaymentStateMachine → OrderStateMachine      │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  4. PROVIDER API RESPONSE                                                │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ ProviderPaymentResponse contains:                                   │ │\n│  │ ├── providerStatus: \"SUCCESS\" / \"PENDING\" / \"FAILED\"               │ │\n│  │ ├── providerReferenceId: Provider's transaction ID                 │ │\n│  │ ├── status: PaymentAttemptStatus (mapped)                          │ │\n│  │ ├── transactionResponse:                                           │ │\n│  │ │   ├── authentication: { url, method } (for 3DS redirect)         │ │\n│  │ │   └── sdkParams: Native OTP/SDK details                          │ │\n│  │ └── providerError: Error details if failed                         │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n         ┌──────────────────────────┴──────────────────────────┐\n         ▼                                                      ▼\n┌─────────────────────────┐                    ┌─────────────────────────┐\n│  5A. 3DS/OTP FLOW       │                    │  5B. DIRECT SUCCESS     │\n│  ┌───────────────────┐  │                    │  ┌───────────────────┐  │\n│  │ Client performs   │  │                    │  │ Status: COMPLETED │  │\n│  │ authentication    │  │                    │  │ Payment done!     │  │\n│  │ (redirect/native) │  │                    │  └───────────────────┘  │\n│  └───────────────────┘  │                    └─────────────────────────┘\n│           │             │\n│           ▼             │\n│  ┌───────────────────┐  │\n│  │ Authenticate      │  │\n│  │ Workflow called   │  │\n│  │ with OTP/callback │  │\n│  └───────────────────┘  │\n└─────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  6. WEBHOOK / SYNC UPDATE                                                │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ Provider sends webhook OR SyncManager polls status                  │ │\n│  │ ├── WebhookController receives update                              │ │\n│  │ ├── adapter.syncPaymentAttemptWithWebhook()                        │ │\n│  │ ├── Update PaymentAttemptV2Entity status                           │ │\n│  │ └── publishEvents() → State machines cascade updates               │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  7. FINAL STATE                                                          │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ PaymentAttempt: COMPLETED ──► Payment: COMPLETED ──► Order: COMPLETED│\n│  │                                                                     │ │\n│  │ eventiService.publishEvent() → Client webhook notification          │ │\n│  │ eventiService.publishToPinot() → Analytics dashboard               │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## 37. 3DS / NATIVE OTP AUTHENTICATION\n\n### Native OTP Flow (Card Payments)\n```\n1. PaymentAttemptCreateWorkflow detects CARD + OTP-capable BIN\n2. wspService.isPlatformNativeOtpEnabled() returns true\n3. Provider returns redirect URL, but we override with SDK params\n4. CardNativeOTPSDKParamDetail created:\n   ├── authType: NATIVE_OTP\n   ├── challengeId: UUID\n   ├── fallbackUrl: Provider's original auth URL\n   └── submitOTPAllowed: true\n\n5. PaymentAttemptNativeOTPDetailEntity saved to DynamoDB\n6. Client submits OTP via PaymentAttemptAuthenticateWorkflow\n7. Provider validates OTP, returns success/failure\n8. State machines update payment/order status\n```\n\n### 3DS Redirect Flow\n```\n1. Provider returns authentication URL\n2. Client redirects to issuer's 3DS page\n3. User completes authentication\n4. Callback to return_url\n5. ValidateAuthenticationWorkflow processes callback\n6. Provider confirms authentication status\n7. State machines update accordingly\n```\n\n---\n\n## 38. INSTRUMENT PROCESSING\n\n### InstrumentTypeProcessorManager\n**File:** `processors/instrumenttype/InstrumentTypeProcessorManager.java`\n\n```java\n// Routes to specific processor based on instrument type\nIInstrumentTypeProcessor processor = processorByType.get(instrument.getType());\nreturn processor.validatePaymentInstrumentAndEnrich(instrument);\n```\n\n### Processor Implementations\n| Processor | InstrumentType | Enrichment |\n|-----------|----------------|------------|\n| `CardInstrumentTypeProcessor` | CARD | BIN lookup, issuer, card type |\n| `UPIPayInstrumentTypeProcessor` | UPI_APPS | VPA validation, provider |\n| `UPICollectInstrumentTypeProcessor` | UPI_COLLECT | QR code, timeout |\n| `NetBankingInstrumentTypeProcessor` | NET_BANKING | Bank code, issuer |\n| `EMandateInstrumentTypeProcessor` | NET_BANKING_WITH_PI | Mandate details |\n\n### InstrumentTypeProcessorResult\n```java\nInstrumentTypeProcessorResult<R, S> {\n    PaymentInstrumentGroup paymentMethod;  // CARD, UPI_PAY, etc.\n    R paymentSubMethodDetail;              // CardPaymentSubMethodDetail\n    S enrichedPaymentInstrument;           // CardEnrichedPaymentInstrument\n}\n```\n\n---\n\n## 39. DISTRIBUTED LOCKING\n\n### SequentialWorkflow Pattern\n**File:** `v2/workflow/create/SequentialWorkflow.java`\n\n```java\npublic Response execute(Request request) {\n    LockSetting lockSetting = fetchLockSetting();\n    String lockKey = evaluateLockKey(request, lockSetting.getLockKey());\n\n    // Acquire Redis distributed lock\n    Optional<RLock> lock = redisLockUtil.acquireLock(lockKey, flowType);\n\n    if (lock.isPresent() || !lockSetting.getIsLockMandatory()) {\n        try {\n            return super.execute(request);  // Run workflow\n        } finally {\n            lock.ifPresent(redisLockUtil::releaseLock);\n        }\n    }\n    throw Error.unable_to_acquire_lock.getBuilder().build();\n}\n```\n\n**Use Cases:**\n- Prevents concurrent payment attempts on same order\n- Ensures single webhook processing per transaction\n- Avoids race conditions in status updates\n\n---\n\n## 40. KEY PAYMENT FLOW FILES\n\n### Core Workflows\n1. `v2/workflow/create/Workflow.java` - Base template\n2. `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java` - Main flow\n3. `v2/workflow/create/payments/bulk/BulkPaymentCreateWorkflow.java` - Payment creation\n4. `v2/workflow/authenticate/PaymentAttemptAuthenticateWorkflow.java` - OTP auth\n\n### State Machines\n1. `statemachine/payment/PaymentStateMachine.java`\n2. `statemachine/order/OrderStateMachine.java`\n3. `statemachine/RefundStateMachine.java`\n\n### Instrument Processing\n1. `processors/instrumenttype/InstrumentTypeProcessorManager.java`\n2. `processors/instrumenttype/CardInstrumentTypeProcessor.java`\n3. `processors/instrumenttype/UPIPayInstrumentTypeProcessor.java`\n\n### Context & Events\n1. `v2/workflow/create/paymentattempts/PaymentAttemptCreateContext.java`\n2. `statemachine/payment/events/PaymentAttemptEventFactory.java`\n3. `statemachine/order/events/OrderEventFactory.java`\n\n---\n\n## 41. ARCHITECTURAL PATTERNS SUMMARY\n\n| Pattern | Implementation | Purpose |\n|---------|----------------|---------|\n| **Template Method** | `Workflow.execute()` 7-step pipeline | Consistent execution flow |\n| **Factory** | `PaymentProviderFactory`, `InstrumentTypeProcessorManager` | Dynamic component selection |\n| **Strategy** | `AuthTypeDeciderFactory`, `SdkTypeDeciderFactory` | Pluggable algorithms |\n| **Observer** | Guava EventBus, State Machines | Decoupled state transitions |\n| **Context Object** | `PaymentAttemptCreateContext` | Data flow through pipeline |\n| **Distributed Lock** | `SequentialWorkflow` + Redis | Concurrency control |\n| **Event Sourcing** | DynamoDB workflow context | Audit trail |\n\n---\n\n## 42. COMPLETE STUDY GUIDE SUMMARY\n\nYou now have a **42-section expert study guide** covering:\n\n### Foundation (Sections 1-15)\n- Tech stack, project structure, core concepts\n- API endpoints, authentication, dependencies\n\n### Data Layer Deep-Dive (Sections 16-24)\n- Entity hierarchy, Master-Replica DB\n- Repository patterns, caching, DynamoDB\n\n### Provider Integration Deep-Dive (Sections 25-32)\n- Adapter architecture, Decision Tree routing\n- Webhook handling, provider configuration\n- Error handling and retry logic\n\n### Payment Flow Deep-Dive (Sections 33-41)\n- 7-step workflow pipeline\n- State machine implementation\n- End-to-end payment flow\n- 3DS/OTP authentication\n- Instrument processing\n- Distributed locking\n","isAgent":false,"filePath":"/Users/kiranbiliyawala/.claude/plans/distributed-marinating-mango.md"}}
{"parentUuid":"60de6fe5-9820-45db-a1c0-06de4b5e3ab4","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01CdpsXsJiS5jxQE1VFeNhZ6","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The study guide has been approved. This was a research/exploration task, not an implementation task, so there's nothing to implement. The user now has a comprehensive 42-section expert study guide for the payment-service repository.\n\nLet me provide a final summary for the user.","signature":"EsEDCkgICxABGAIqQJmiqGbggm8Ou23IGZRHqJnsgLzNA0dp1IX7TAZw7kAuyOPLfMWtT3nPTauMhiG9G3XwpkTzF55sYGdfSbQ+/qISDEC1HCIiju3okgAQPhoMmONgWJhHJMaKjnFXIjBtkNONzpVvoMZJASao8V5LHEwNHYWU/hfcCJ+Ay5RSZrrC2NMU49RNBmj5aDmz3dIqpgKLwXyT8DhV5yaEU1vNW006fqGfzdgeuzjhbnouQ7q13k1nXXyDGVXDiWZp21N6rU81CVQRE2Pmw8stltN88NbEL/8xLBNHth3SQI27SCrMWeAnNpWDGVNnZJQ2JGPytgpoGDULz9NrfYP9QARbvmJjgjkUP719Zn5fUmhEZdx+baqTwCQuUb/m4iGcpRImSz+5aFaiIeDFrhJSiiShz+6JDrBc9xEqhvgFYMkMj9x6SSAsqpe2FKc+QpGcn1uFGSCehEzf+LJvtlubHiinvluQ06gX4u/bPFRRfi/NlLAw2oe73o1nnF0qhJ6rSFS7+YX0TPnL48C639iyakmGVSLYKr33qa65jksM4NRDmF/BTmBj3pY2WcLJrpu0pCIKnsbIWPl9H+8YAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":16684,"cache_read_input_tokens":125222,"cache_creation":{"ephemeral_5m_input_tokens":16684,"ephemeral_1h_input_tokens":0},"output_tokens":1}},"type":"assistant","uuid":"4337c479-3c82-4e66-a9f2-0b59374504dc","timestamp":"2025-12-31T09:55:27.671Z"}
{"parentUuid":"4337c479-3c82-4e66-a9f2-0b59374504dc","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01CdpsXsJiS5jxQE1VFeNhZ6","type":"message","role":"assistant","content":[{"type":"text","text":"Your **42-section expert study guide** for the payment-service (Darwin) repository is now complete and saved at:\n\n```\n/Users/kiranbiliyawala/.claude/plans/distributed-marinating-mango.md\n```\n\n## What You Now Have\n\n| Section Range | Topic | Sections |\n|--------------|-------|----------|\n| **Foundation** | Tech stack, structure, APIs | 1-15 |\n| **Data Layer** | Entities, DB architecture, caching | 16-24 |\n| **Provider Integration** | Adapters, Decision Tree, webhooks | 25-32 |\n| **Payment Flow** | Workflows, state machines, E2E flow | 33-42 |\n\n## Recommended Next Steps\n\n1. **Start with `DarwinApplication.java`** - Understand the entry point\n2. **Read `PaymentAttemptCreateWorkflow.java`** - The core payment flow\n3. **Study `PaymentStateMachine.java`** - How state transitions work\n4. **Pick one provider adapter** (e.g., `CashfreeProviderAdapter`) - Understand integration pattern\n\nFeel free to ask me specific questions as you study the codebase - I can help you trace through any flow, explain any pattern, or dive deeper into any component!"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":16684,"cache_read_input_tokens":125222,"cache_creation":{"ephemeral_5m_input_tokens":16684,"ephemeral_1h_input_tokens":0},"output_tokens":368}},"type":"assistant","uuid":"94cd9026-f72d-418f-a9d5-0f4c98250b17","timestamp":"2025-12-31T09:55:32.725Z"}
{"type":"file-history-snapshot","messageId":"333b6ac7-26fd-4722-980d-e319ce733bba","snapshot":{"messageId":"333b6ac7-26fd-4722-980d-e319ce733bba","trackedFileBackups":{"/Users/kiranbiliyawala/.claude/plans/distributed-marinating-mango.md":{"backupFileName":"c92f53c9f6085692@v2","version":2,"backupTime":"2025-12-31T09:58:40.829Z"}},"timestamp":"2025-12-31T09:58:40.824Z"},"isSnapshotUpdate":false}
{"parentUuid":"94cd9026-f72d-418f-a9d5-0f4c98250b17","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","type":"user","message":{"role":"user","content":"let's document the everything - whole analysis, study materials, and plan. so that we can resume this over multiple\n days/sessions. if required create multiple documents, directories etc"},"uuid":"333b6ac7-26fd-4722-980d-e319ce733bba","timestamp":"2025-12-31T09:58:40.818Z","thinkingMetadata":{"level":"high","disabled":false,"triggers":[]},"todos":[]}
{"parentUuid":"333b6ac7-26fd-4722-980d-e319ce733bba","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01RJCQX2EB3ksqHiDs5X3SQ2","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user wants to create comprehensive documentation that can be used across multiple sessions. This means I should create a well-organized directory structure with multiple documents covering all the analysis. Let me create:\n\n1. A main directory for the documentation\n2. Multiple markdown files organized by topic\n3. A README as the main entry point\n4. Detailed documents for each major area\n\nLet me create this structure:\n- /Users/kiranbiliyawala/code/cred/payments/payment-service/docs/study-guide/\n  - README.md (main entry point)\n  - 01-overview.md (tech stack, project structure)\n  - 02-data-layer.md (entities, database, caching)\n  - 03-provider-integration.md (adapters, webhooks, decision tree)\n  - 04-payment-flow.md (workflows, state machines)\n  - 05-key-files-reference.md (quick reference for all important files)\n  - 06-study-path.md (recommended learning path)","signature":"Eo0ICkgICxABGAIqQDEy6kuSjWnVskYufyY+iiFtM+CTXLjknn+T5yjtizPEF/1frVOgd0H2r7iwUZaPxhY/O/EVv8Y5SSzuaV7NP6wSDLKCGCV7YByjiSjKoRoMMsiIy9nD6hK83ie3IjAO5dcJvL9TnCjDKBPz/jTtmNo0whw+5b/xIKlWnQxbVHHyJYuU3Pa/pJyy5SZazBUq8gYX1AvtluwzronoN1+uVVEzztdfFHUIScfgfP7HLJK3ckb0fpfdG3YVTtZ4zeopHiuB7oW1OllOSCrZWuHwQNZhEAftpgaFqPiKEr5+LW64sXpd8etEb1QKo9gNZmuhOohofGgLxFkc+myFGLMvB8dOpbOqgO4RGxMglrYd09GIQOWyqSRYpQ5O3vzdy2zNfz5EojWyYk4X9IjLJCXNmTRx2CY4Zmj4me79SpnQh0Sk0XLN0ciEmzUdDmBLu0S/q1b1KVi/n1K1otH7iWV4NlgESZEGviSSLtazonPFN31+4VdH77uP2SE+Wa03ix5lG2rvgwMU1l8DX1jqTJt7QXS3pRb5OU2nl98axkR+GMGlyBsLU9geeqykXOylwtda90SOBhbpsM/VMlKpWuIUve+wbi5Vife2sPtzdP1cUUlNafacVMgHM52GDqZgOaB37DXzSPvnb8TykaYcCsIBP7Fd0dCRe7ZnSmtgfD7XGTgsoTA8vVPCJ7RLnmOU0u0pOs00oe136lfTUeo4j+AbYzKCIqchdTkjNRPS+MuVR7Mr0MyObe3pGi5mZd/SYnzpJDivjLFbYZvy+Ox1YSncrEpX9JhqeikC6ifDhTqQ4yHGH8XiT87r8+qY+re7g9m/VxP8PR21oMs30gyEGikIct1mXmbHfCmvX8jtfwvrKdF1wgA+TQhCbg+eZCVB2kheqpJu3Ic9dxWZXBLzwPbWLmRIKa/n4A0aq8N7UDHcsIIWNi5s3yhMC1C4L4Pv/2MqWBdRWCuB268ikesmYb995b889Pwm22oP6OKVHdulSyUke4VipXDUdXqaOI5Ugq9bzy5B0aQbU/ylvRomMPupQmUjqkVeWFOGjkUYu+q/1O/6OiGW4faKOoX2nq0lP1iFBx1OGciyYMViWEHHqFZcfdua52dJJMqTP+e9DmuXHEhUQsAwExxEMFLXJz7tXm6kJzV+gTN2JBob/zdvCcBFMuUp/97GdVGYIxHjsas2AEg0qKOQwB2p5iy5DAy3PW/B/STX8/W12eMyCk7QWPjzh2uGlQ53IdSmgHvGhxXr4en4RUhsHrEJZ1pqUg2asU2b2YFwgbK9SXZmSvVomi1LSw5fD7vl+vk9qdERn2iVmSqb6wKuWB6tt7M63ccNweKduBbHcj/ACJDtbtV6FwwBBGuey8sYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":122977,"cache_read_input_tokens":19463,"cache_creation":{"ephemeral_5m_input_tokens":122977,"ephemeral_1h_input_tokens":0},"output_tokens":3}},"type":"assistant","uuid":"4986e6c1-a31b-43b0-923c-918e2183ef31","timestamp":"2025-12-31T09:59:16.516Z"}
{"parentUuid":"4986e6c1-a31b-43b0-923c-918e2183ef31","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01RJCQX2EB3ksqHiDs5X3SQ2","type":"message","role":"assistant","content":[{"type":"text","text":"I'll create a comprehensive documentation structure that you can reference across multiple sessions."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":122977,"cache_read_input_tokens":19463,"cache_creation":{"ephemeral_5m_input_tokens":122977,"ephemeral_1h_input_tokens":0},"output_tokens":3}},"type":"assistant","uuid":"3d8da63c-80de-4d02-be19-8f93d94b6077","timestamp":"2025-12-31T09:59:16.999Z"}
{"parentUuid":"3d8da63c-80de-4d02-be19-8f93d94b6077","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01RJCQX2EB3ksqHiDs5X3SQ2","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_bdrk_01AooQuq8rjTgapyafMNjhFS","name":"Bash","input":{"command":"mkdir -p /Users/kiranbiliyawala/code/cred/payments/payment-service/docs/study-guide","description":"Create study guide directory"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":122977,"cache_read_input_tokens":19463,"cache_creation":{"ephemeral_5m_input_tokens":122977,"ephemeral_1h_input_tokens":0},"output_tokens":357}},"type":"assistant","uuid":"7a8ff218-7474-4279-a419-6201e577da4f","timestamp":"2025-12-31T09:59:17.502Z"}
{"parentUuid":"7a8ff218-7474-4279-a419-6201e577da4f","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01AooQuq8rjTgapyafMNjhFS","type":"tool_result","content":"  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n\r  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0\r100   120    0   120    0     0    415      0 --:--:-- --:--:-- --:--:--   415","is_error":false}]},"uuid":"89b44f11-52ad-49ce-ab20-dde5d0015477","timestamp":"2025-12-31T09:59:17.937Z","toolUseResult":{"stdout":"  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n\r  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0\r100   120    0   120    0     0    415      0 --:--:-- --:--:-- --:--:--   415","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"89b44f11-52ad-49ce-ab20-dde5d0015477","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01TnLju3VYMkGzZ3QbLsu2kz","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Good, the directory was created. Now let me create multiple documentation files in parallel for efficiency.","signature":"EpUCCkgICxABGAIqQHPrtH3Z/m2f40+yBz2MRJr+K/FI/nrLs5v15P1OLjPS8hU/KKrQ928NnNKFG97GssskIEU1+PWk6ioE7qU8sRMSDMrKltvAiG/y1ZcAVhoMLIb+SwcJtJs143YUIjCK6Fx/Nrnz3GgL68rOlUysrjXbBO6yzO6HxvmVHZi6sOIJ0AqondKVYSX2dvzf+uAqe4K+1xBygx4vF3fOB2ZcQQ6sNEpcH96Cs/UYoG05synXuxYeyaVHfZG/pBGt6AnPfTJgA0ro421egwjM88uJpdT979qMY3ap9LFpeMuxZKiK6TLCDHEq7vihaMsk5Rs2lx19a/On3y31Lsl+j/OLCsqtr5mG3T++BPo1phgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":482,"cache_read_input_tokens":142440,"cache_creation":{"ephemeral_5m_input_tokens":482,"ephemeral_1h_input_tokens":0},"output_tokens":1}},"type":"assistant","uuid":"8ffdf1c2-5662-4f42-8695-36bf69881fb5","timestamp":"2025-12-31T09:59:51.040Z"}
{"parentUuid":"8ffdf1c2-5662-4f42-8695-36bf69881fb5","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01TnLju3VYMkGzZ3QbLsu2kz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_bdrk_01N8jjGrZ4TKgoLqawivEycG","name":"Write","input":{"file_path":"/Users/kiranbiliyawala/code/cred/payments/payment-service/docs/study-guide/README.md","content":"# Payment Service (Darwin) - Expert Study Guide\n\n> **Purpose:** Comprehensive documentation for becoming an expert on the payment-service codebase.\n> **Last Updated:** December 31, 2025\n> **Estimated Study Time:** 4 weeks\n\n---\n\n## Quick Navigation\n\n| Document | Description | When to Read |\n|----------|-------------|--------------|\n| [01-overview.md](./01-overview.md) | Tech stack, project structure, core concepts | Week 1 |\n| [02-data-layer.md](./02-data-layer.md) | Entities, database architecture, caching, DynamoDB | Week 2 |\n| [03-provider-integration.md](./03-provider-integration.md) | Provider adapters, webhooks, decision tree routing | Week 3 |\n| [04-payment-flow.md](./04-payment-flow.md) | Workflows, state machines, end-to-end flow | Week 4 |\n| [05-key-files-reference.md](./05-key-files-reference.md) | Quick reference for all critical files | Anytime |\n| [06-study-path.md](./06-study-path.md) | Recommended learning path with checkboxes | Track progress |\n\n---\n\n## Executive Summary\n\n**Darwin** is an enterprise-grade payment processing microservice built with:\n\n| Technology | Version | Purpose |\n|------------|---------|---------|\n| Java | 17 | Runtime |\n| Spring Boot | 2.7.14 | Framework |\n| MySQL | - | Primary DB (Master-Replica) |\n| DynamoDB | - | Workflow state, audit |\n| Redis | 3.19.1 | Distributed cache/locks |\n| Kafka | - | Event streaming |\n| AWS SQS | - | Async task processing |\n\n**Server:** Port `9010`, Context Path: `/payments`\n\n---\n\n## Architecture at a Glance\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                        API Layer                                 │\n│  Controllers (v2): Order, Payment, PaymentAttempt, Webhook      │\n└──────────────────────────────┬──────────────────────────────────┘\n                               │\n┌──────────────────────────────▼──────────────────────────────────┐\n│                      Workflow Layer                              │\n│  7-Step Pipeline: Validate → Persist → Process → PostProcess    │\n└──────────────────────────────┬──────────────────────────────────┘\n                               │\n┌──────────────────────────────▼──────────────────────────────────┐\n│                   Provider Integration                           │\n│  24+ Adapters: Cashfree, Cybersource, PayU, Razorpay, UPI...   │\n│  Decision Tree Routing → Provider Selection                      │\n└──────────────────────────────┬──────────────────────────────────┘\n                               │\n┌──────────────────────────────▼──────────────────────────────────┐\n│                     State Machines                               │\n│  EventBus → PaymentStateMachine → OrderStateMachine             │\n└──────────────────────────────┬──────────────────────────────────┘\n                               │\n┌──────────────────────────────▼──────────────────────────────────┐\n│                      Data Layer                                  │\n│  MySQL (Master/Replica) │ DynamoDB │ Redis │ Caffeine Cache     │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## Core Payment Flow (30-Second Overview)\n\n```\n1. Client → POST /v2/orders         → OrderCreateWorkflow\n2. Client → POST /v2/payments       → BulkPaymentCreateWorkflow\n3. Client → POST /v2/attempts       → PaymentAttemptCreateWorkflow\n                                           │\n                                           ├── Instrument Enrichment\n                                           ├── Provider Routing (Decision Tree)\n                                           ├── Provider API Call\n                                           └── State Machine Events\n                                           │\n4. Provider → Webhook               → Status Update → State Cascade\n5. Final State: Order COMPLETED\n```\n\n---\n\n## Key Patterns to Understand\n\n| Pattern | Where Used | Why It Matters |\n|---------|-----------|----------------|\n| **7-Step Workflow** | All create workflows | Core execution pipeline |\n| **State Machines** | Payment, Order, Refund | Event-driven state transitions |\n| **Factory Pattern** | Provider adapters | Dynamic provider selection |\n| **Decision Tree** | Provider routing | Rule-based provider selection |\n| **Master-Replica** | Database | Read/write separation |\n| **Distributed Lock** | Sequential workflows | Concurrency control |\n\n---\n\n## How to Use This Guide\n\n### First Session (2-3 hours)\n1. Read this README completely\n2. Read [01-overview.md](./01-overview.md)\n3. Explore `DarwinApplication.java` in the codebase\n4. Run the service locally if possible\n\n### Subsequent Sessions\n1. Check [06-study-path.md](./06-study-path.md) for where you left off\n2. Follow the week-by-week progression\n3. Use [05-key-files-reference.md](./05-key-files-reference.md) as quick lookup\n\n### When Working on Specific Features\n- Payment issues → [04-payment-flow.md](./04-payment-flow.md)\n- Provider integration → [03-provider-integration.md](./03-provider-integration.md)\n- Database/caching → [02-data-layer.md](./02-data-layer.md)\n\n---\n\n## Directory Structure Quick Reference\n\n```\nsrc/main/java/in/dreamplug/darwin/\n├── controller/v2/          # REST endpoints\n├── v2/workflow/create/     # Core workflows (CRITICAL)\n│   ├── paymentattempts/    # Payment attempt creation\n│   ├── payments/           # Payment creation\n│   └── providers/          # 24+ provider adapters\n├── statemachine/           # State machines\n│   ├── payment/            # PaymentStateMachine\n│   └── order/              # OrderStateMachine\n├── entity/v2/              # JPA entities\n├── repository/             # Data access\n├── cache/                  # Caffeine caches\n├── planner/                # Decision tree routing\n└── configuration/          # Spring configs\n```\n\n---\n\n## Resume Points\n\nUse these markers to quickly resume your study:\n\n- [ ] **CHECKPOINT 1:** Completed Overview (01-overview.md)\n- [ ] **CHECKPOINT 2:** Completed Data Layer (02-data-layer.md)\n- [ ] **CHECKPOINT 3:** Completed Provider Integration (03-provider-integration.md)\n- [ ] **CHECKPOINT 4:** Completed Payment Flow (04-payment-flow.md)\n- [ ] **CHECKPOINT 5:** Expert Level - Can trace any payment flow\n\n---\n\n## Contact & Resources\n\n- **Codebase:** `/Users/kiranbiliyawala/code/cred/payments/payment-service`\n- **Main Config:** `src/main/resources/application.properties` (1300+ lines)\n- **Build:** `./gradlew build`\n- **Run:** `./gradlew bootRun`\n\n---\n\n*Generated by Claude Code - December 2025*\n"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":482,"cache_read_input_tokens":142440,"cache_creation":{"ephemeral_5m_input_tokens":482,"ephemeral_1h_input_tokens":0},"output_tokens":1941}},"type":"assistant","uuid":"62adc9b9-efa0-404c-b2cd-1e0b64b999e4","timestamp":"2025-12-31T10:00:15.454Z"}
{"type":"file-history-snapshot","messageId":"62adc9b9-efa0-404c-b2cd-1e0b64b999e4","snapshot":{"messageId":"333b6ac7-26fd-4722-980d-e319ce733bba","trackedFileBackups":{"/Users/kiranbiliyawala/.claude/plans/distributed-marinating-mango.md":{"backupFileName":"c92f53c9f6085692@v2","version":2,"backupTime":"2025-12-31T09:58:40.829Z"},"docs/study-guide/README.md":{"backupFileName":"3fd18aad0b0250d2@v1","version":1,"backupTime":"2025-12-31T10:00:15.742Z"}},"timestamp":"2025-12-31T09:58:40.824Z"},"isSnapshotUpdate":true}
{"parentUuid":"62adc9b9-efa0-404c-b2cd-1e0b64b999e4","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01N8jjGrZ4TKgoLqawivEycG","type":"tool_result","content":"File created successfully at: /Users/kiranbiliyawala/code/cred/payments/payment-service/docs/study-guide/README.md"}]},"uuid":"d9f0e45b-ed42-45e8-9780-1c11a0683ec6","timestamp":"2025-12-31T10:00:15.737Z","toolUseResult":{"type":"create","filePath":"/Users/kiranbiliyawala/code/cred/payments/payment-service/docs/study-guide/README.md","content":"# Payment Service (Darwin) - Expert Study Guide\n\n> **Purpose:** Comprehensive documentation for becoming an expert on the payment-service codebase.\n> **Last Updated:** December 31, 2025\n> **Estimated Study Time:** 4 weeks\n\n---\n\n## Quick Navigation\n\n| Document | Description | When to Read |\n|----------|-------------|--------------|\n| [01-overview.md](./01-overview.md) | Tech stack, project structure, core concepts | Week 1 |\n| [02-data-layer.md](./02-data-layer.md) | Entities, database architecture, caching, DynamoDB | Week 2 |\n| [03-provider-integration.md](./03-provider-integration.md) | Provider adapters, webhooks, decision tree routing | Week 3 |\n| [04-payment-flow.md](./04-payment-flow.md) | Workflows, state machines, end-to-end flow | Week 4 |\n| [05-key-files-reference.md](./05-key-files-reference.md) | Quick reference for all critical files | Anytime |\n| [06-study-path.md](./06-study-path.md) | Recommended learning path with checkboxes | Track progress |\n\n---\n\n## Executive Summary\n\n**Darwin** is an enterprise-grade payment processing microservice built with:\n\n| Technology | Version | Purpose |\n|------------|---------|---------|\n| Java | 17 | Runtime |\n| Spring Boot | 2.7.14 | Framework |\n| MySQL | - | Primary DB (Master-Replica) |\n| DynamoDB | - | Workflow state, audit |\n| Redis | 3.19.1 | Distributed cache/locks |\n| Kafka | - | Event streaming |\n| AWS SQS | - | Async task processing |\n\n**Server:** Port `9010`, Context Path: `/payments`\n\n---\n\n## Architecture at a Glance\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                        API Layer                                 │\n│  Controllers (v2): Order, Payment, PaymentAttempt, Webhook      │\n└──────────────────────────────┬──────────────────────────────────┘\n                               │\n┌──────────────────────────────▼──────────────────────────────────┐\n│                      Workflow Layer                              │\n│  7-Step Pipeline: Validate → Persist → Process → PostProcess    │\n└──────────────────────────────┬──────────────────────────────────┘\n                               │\n┌──────────────────────────────▼──────────────────────────────────┐\n│                   Provider Integration                           │\n│  24+ Adapters: Cashfree, Cybersource, PayU, Razorpay, UPI...   │\n│  Decision Tree Routing → Provider Selection                      │\n└──────────────────────────────┬──────────────────────────────────┘\n                               │\n┌──────────────────────────────▼──────────────────────────────────┐\n│                     State Machines                               │\n│  EventBus → PaymentStateMachine → OrderStateMachine             │\n└──────────────────────────────┬──────────────────────────────────┘\n                               │\n┌──────────────────────────────▼──────────────────────────────────┐\n│                      Data Layer                                  │\n│  MySQL (Master/Replica) │ DynamoDB │ Redis │ Caffeine Cache     │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## Core Payment Flow (30-Second Overview)\n\n```\n1. Client → POST /v2/orders         → OrderCreateWorkflow\n2. Client → POST /v2/payments       → BulkPaymentCreateWorkflow\n3. Client → POST /v2/attempts       → PaymentAttemptCreateWorkflow\n                                           │\n                                           ├── Instrument Enrichment\n                                           ├── Provider Routing (Decision Tree)\n                                           ├── Provider API Call\n                                           └── State Machine Events\n                                           │\n4. Provider → Webhook               → Status Update → State Cascade\n5. Final State: Order COMPLETED\n```\n\n---\n\n## Key Patterns to Understand\n\n| Pattern | Where Used | Why It Matters |\n|---------|-----------|----------------|\n| **7-Step Workflow** | All create workflows | Core execution pipeline |\n| **State Machines** | Payment, Order, Refund | Event-driven state transitions |\n| **Factory Pattern** | Provider adapters | Dynamic provider selection |\n| **Decision Tree** | Provider routing | Rule-based provider selection |\n| **Master-Replica** | Database | Read/write separation |\n| **Distributed Lock** | Sequential workflows | Concurrency control |\n\n---\n\n## How to Use This Guide\n\n### First Session (2-3 hours)\n1. Read this README completely\n2. Read [01-overview.md](./01-overview.md)\n3. Explore `DarwinApplication.java` in the codebase\n4. Run the service locally if possible\n\n### Subsequent Sessions\n1. Check [06-study-path.md](./06-study-path.md) for where you left off\n2. Follow the week-by-week progression\n3. Use [05-key-files-reference.md](./05-key-files-reference.md) as quick lookup\n\n### When Working on Specific Features\n- Payment issues → [04-payment-flow.md](./04-payment-flow.md)\n- Provider integration → [03-provider-integration.md](./03-provider-integration.md)\n- Database/caching → [02-data-layer.md](./02-data-layer.md)\n\n---\n\n## Directory Structure Quick Reference\n\n```\nsrc/main/java/in/dreamplug/darwin/\n├── controller/v2/          # REST endpoints\n├── v2/workflow/create/     # Core workflows (CRITICAL)\n│   ├── paymentattempts/    # Payment attempt creation\n│   ├── payments/           # Payment creation\n│   └── providers/          # 24+ provider adapters\n├── statemachine/           # State machines\n│   ├── payment/            # PaymentStateMachine\n│   └── order/              # OrderStateMachine\n├── entity/v2/              # JPA entities\n├── repository/             # Data access\n├── cache/                  # Caffeine caches\n├── planner/                # Decision tree routing\n└── configuration/          # Spring configs\n```\n\n---\n\n## Resume Points\n\nUse these markers to quickly resume your study:\n\n- [ ] **CHECKPOINT 1:** Completed Overview (01-overview.md)\n- [ ] **CHECKPOINT 2:** Completed Data Layer (02-data-layer.md)\n- [ ] **CHECKPOINT 3:** Completed Provider Integration (03-provider-integration.md)\n- [ ] **CHECKPOINT 4:** Completed Payment Flow (04-payment-flow.md)\n- [ ] **CHECKPOINT 5:** Expert Level - Can trace any payment flow\n\n---\n\n## Contact & Resources\n\n- **Codebase:** `/Users/kiranbiliyawala/code/cred/payments/payment-service`\n- **Main Config:** `src/main/resources/application.properties` (1300+ lines)\n- **Build:** `./gradlew build`\n- **Run:** `./gradlew bootRun`\n\n---\n\n*Generated by Claude Code - December 2025*\n","structuredPatch":[],"originalFile":null}}
{"parentUuid":"d9f0e45b-ed42-45e8-9780-1c11a0683ec6","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01Ld5ePWooQW12MhXHYYnNhV","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Good, the README was created. Now let me create the rest of the documentation files. I'll create them in parallel for efficiency.","signature":"EqwCCkgICxABGAIqQBEVkgDe6VVFJ1EAfhyOWpKxztr1Hg+Hv2GKZdugjEp74t64dF5VNsPw55b1DlXejxC/qXYyW+qvzGbaJW6tvegSDK1ET2NIptAE0PhLTRoMHfJym8hJ6vaxyoXnIjAfurKuWnpTSDsumPC1sjjPly8m/qI0/qyXLwFsqL51izuM6gO14PwjlWW4aIzqxbkqkQGs4sVUX34e5WHHZJeQagU9uL6IOR7Q+D8rYBu4B0zowIZdsN/YJVmNP6oUb/qxB++OulxSpeENWeivrM3PoXG901GTG2dR7srTohQSMasG2dI3bJpA9vr3EAE/vVOxYugEXvBzN7T4O+FFsHXbMK+WoE32gmFURtQ+aeaDtVNv5CGANnY2vLh/lx64L+CU3A4oGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":2098,"cache_read_input_tokens":142922,"cache_creation":{"ephemeral_5m_input_tokens":2098,"ephemeral_1h_input_tokens":0},"output_tokens":1}},"type":"assistant","uuid":"e4fadb37-daa5-4394-86fc-d59936436ef3","timestamp":"2025-12-31T10:00:23.860Z"}
{"parentUuid":"e4fadb37-daa5-4394-86fc-d59936436ef3","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01Ld5ePWooQW12MhXHYYnNhV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_bdrk_015rKwquMzUDqcNhWno363iT","name":"Write","input":{"file_path":"/Users/kiranbiliyawala/code/cred/payments/payment-service/docs/study-guide/01-overview.md","content":"# 01 - Overview & Architecture\n\n> **Reading Time:** 45 minutes\n> **Prerequisites:** None\n> **Next:** [02-data-layer.md](./02-data-layer.md)\n\n---\n\n## Table of Contents\n1. [Technology Stack](#technology-stack)\n2. [Project Structure](#project-structure)\n3. [Core Concepts](#core-concepts)\n4. [API Endpoints](#api-endpoints)\n5. [Authentication & Security](#authentication--security)\n6. [Internal Service Dependencies](#internal-service-dependencies)\n7. [Configuration](#configuration)\n\n---\n\n## Technology Stack\n\n### Core Technologies\n\n| Technology | Version | Purpose |\n|------------|---------|---------|\n| **Java** | 17 | Runtime (Amazon Corretto) |\n| **Spring Boot** | 2.7.14 | Application framework |\n| **Gradle** | 7.6 | Build tool |\n| **MySQL** | - | Primary database |\n| **DynamoDB** | - | Workflow state storage |\n| **Redis (Redisson)** | 3.19.1 | Distributed cache & locks |\n| **Kafka** | - | Event streaming |\n| **AWS SQS** | - | Async task processing |\n| **Hibernate** | 5.x | ORM |\n| **HikariCP** | - | Connection pooling |\n\n### Key Libraries\n\n| Library | Version | Purpose |\n|---------|---------|---------|\n| Lombok | - | Boilerplate reduction |\n| MapStruct | 1.4.2 | Object mapping |\n| Guava | - | EventBus, collections |\n| Jackson | - | JSON processing |\n| JaCoCo | - | Code coverage |\n| Caffeine | - | In-memory caching |\n\n### Server Configuration\n\n```properties\nserver.port=9010\nserver.servlet.context-path=/payments\n```\n\n---\n\n## Project Structure\n\n### Root Directory\n```\npayment-service/\n├── src/\n│   ├── main/\n│   │   ├── java/in/dreamplug/darwin/    # Main source code\n│   │   └── resources/\n│   │       └── application.properties    # Main config (1300+ lines)\n│   └── test/                             # Test code\n├── codepipeline/                         # CI/CD configs\n├── build.gradle                          # Dependencies\n├── Dockerfile                            # Container setup\n├── README.md                             # Project readme\n└── settings.gradle                       # Gradle settings\n```\n\n### Source Code Structure\n\n```\nsrc/main/java/in/dreamplug/darwin/\n│\n├── DarwinApplication.java           # Entry point\n│\n├── controller/                      # REST Controllers\n│   ├── v2/                          # V2 API (Primary)\n│   │   ├── order/                   # Order endpoints\n│   │   ├── payment/                 # Payment endpoints\n│   │   └── paymentattempt/          # Payment attempt endpoints\n│   ├── WebhookController.java       # Generic webhooks\n│   └── admin/                       # Admin endpoints\n│\n├── service/                         # Business logic\n│   ├── PaymentProviderService.java\n│   ├── WebhookService.java\n│   └── ...\n│\n├── v2/                              # V2 Implementation\n│   ├── service/                     # V2 services\n│   └── workflow/                    # CRITICAL: Workflows\n│       └── create/\n│           ├── Workflow.java             # Base workflow\n│           ├── payments/                 # Payment workflows\n│           ├── paymentattempts/          # Attempt workflows\n│           └── providers/                # 24+ provider adapters\n│\n├── entity/                          # JPA Entities\n│   ├── commons/                     # Base entities\n│   │   └── BaseEntity.java\n│   ├── provider/                    # Provider entities\n│   │   └── BaseExternalEntity.java\n│   ├── v2/                          # V2 entities (Primary)\n│   │   ├── PaymentV2Entity.java\n│   │   ├── PaymentAttemptV2Entity.java\n│   │   ├── RefundEntity.java\n│   │   └── FeeEntity.java\n│   ├── OrderEntity.java\n│   ├── ClientEntity.java\n│   ├── CustomerEntity.java\n│   └── ProviderAccountEntity.java\n│\n├── repository/                      # Data access layer\n│   ├── OrderRepository.java\n│   ├── PaymentRepository.java\n│   ├── PaymentAttemptRepository.java\n│   └── read_only_repository/        # Replica repositories\n│\n├── statemachine/                    # State machines\n│   ├── payment/                     # Payment state machine\n│   │   └── PaymentStateMachine.java\n│   ├── order/                       # Order state machine\n│   │   └── OrderStateMachine.java\n│   └── RefundStateMachine.java\n│\n├── planner/                         # Decision tree routing\n│   └── providerdecider/\n│       ├── ProviderDeciderRouter.java\n│       ├── ProviderDeciderV2.java\n│       └── ProviderDeciderViaLCM.java\n│\n├── cache/                           # Caching layer\n│   ├── ClientConfigurationCache.java\n│   ├── PaymentProviderCache.java\n│   ├── DecisionTreeObjectCache.java\n│   └── ...\n│\n├── client/                          # External service clients\n│   ├── arsenal/                     # Instrument vault\n│   ├── fee/                         # Fee service\n│   ├── lcm/                         # Lending cloud manager\n│   └── ...\n│\n├── configuration/                   # Spring configs\n│   ├── database/                    # Database configs\n│   │   ├── MasterDataSourceConfiguration.java\n│   │   └── ReplicaDataSourceConfiguration.java\n│   ├── CacheConfig.java\n│   └── RedissonAutoConfiguration.java\n│\n├── kafka/                           # Kafka integration\n│   ├── MessagingConfigs.java\n│   └── dto/                         # Kafka event DTOs\n│\n├── sqs/                             # SQS integration\n│   ├── DarwinSQSMessageProcessor.java\n│   └── ...\n│\n├── dynamo/                          # DynamoDB integration\n│   ├── dao/                         # DynamoDB DAOs\n│   └── domain/                      # DynamoDB entities\n│\n├── error/                           # Error handling\n│   ├── Error.java                   # Error enum\n│   └── ProviderException.java\n│\n├── dto/                             # Data transfer objects\n│\n├── commons/spring/filters/          # Request filters\n│   ├── ApplicationContextBuilderFilter.java\n│   └── PAMerchantAuthenticationFilter.java\n│\n└── processors/                      # Processors\n    └── instrumenttype/              # Instrument processors\n        ├── InstrumentTypeProcessorManager.java\n        ├── CardInstrumentTypeProcessor.java\n        └── UPIPayInstrumentTypeProcessor.java\n```\n\n---\n\n## Core Concepts\n\n### 1. Payment Hierarchy\n\n```\nOrder (1)\n    └── Payment (M)\n            └── PaymentAttempt (M)\n                    └── RefundAttempt (M via Refund)\n```\n\n- **Order:** Top-level transaction container\n- **Payment:** Represents a payment mode (card, UPI, etc.)\n- **PaymentAttempt:** Actual provider call\n- **Refund:** Reversal of a payment attempt\n\n### 2. Entity Lifecycle (State Machine)\n\n```\nCREATED → PROCESSING → AUTHORIZED → COMPLETED\n                   ↘ FAILED\n                   ↘ BLOCKED\n```\n\n### 3. Workflow Pattern\n\nAll creation operations follow a 7-step workflow:\n\n```java\n1. validateAndEnrichContext()    // Validate & enrich data\n2. persistIntent()               // Save to MySQL (transactional)\n3. publishEntityPrePersistEvents() // Pre-persist hooks\n4. persistNonRelationalIntent()  // Save to DynamoDB\n5. process()                     // Provider API call\n6. postProcess()                 // Update with response (transactional)\n7. publishEntityChangeEvents()   // Trigger state machines\n```\n\n### 4. Provider Routing\n\n```\nRequest → ProviderDeciderRouter\n              │\n              ├── LCM (Lending Cloud Manager) - if supported\n              │\n              └── Decision Tree - JSON rules\n                      │\n                      └── Provider Adapter Selection\n```\n\n### 5. Event-Driven Architecture\n\n```\nWorkflow completes\n    │\n    └── EventBus.post(PaymentAttemptEvent)\n            │\n            ├── PaymentStateMachine.onEvent()\n            │       └── Updates Payment status\n            │               │\n            │               └── EventBus.post(PaymentEvent)\n            │                       │\n            │                       └── OrderStateMachine.onEvent()\n            │                               └── Updates Order status\n            │\n            └── EventiService.publishEvent()\n                    └── External notifications\n```\n\n---\n\n## API Endpoints\n\n### Primary Endpoints (V2)\n\n| Method | Endpoint | Controller | Purpose |\n|--------|----------|------------|---------|\n| POST | `/v2/orders` | OrderV2Controller | Create order |\n| GET | `/v2/orders/{orderId}` | OrderV2Controller | Get order |\n| POST | `/v2/orders/{orderId}/payments` | PaymentV2Controller | Bulk create payments |\n| POST | `/v2/payments/{paymentId}/attempts` | PaymentAttemptV2Controller | Create payment attempt |\n| POST | `/v2/payments/by-order-id/{orderId}/attempts` | PaymentAttemptV2Controller | Create attempt by order |\n| POST | `/v1/webhooks` | WebhookController | Generic webhook |\n\n### Provider Webhook Endpoints\n\n| Endpoint | Controller | Provider |\n|----------|------------|----------|\n| `/webhooks/v2/cashfree` | CashfreeWebhookController | Cashfree |\n| `/webhooks/v2/razorpay` | RazorpayWebhookController | Razorpay |\n| `/webhooks/v2/payu` | PayuWebhookController | PayU |\n| `/webhooks/v2/juspay` | JuspayWebhookController | Juspay |\n| `/webhooks/v2/cybersource` | CybersourceWebhookController | Cybersource |\n| `/webhooks/v2/ybl` | YBLWebhookController | Yes Bank UPI |\n| `/webhooks/v2/icici` | ICICIWebhookController | ICICI UPI |\n| `/webhooks/v2/rbl-upi` | RBLUpiWebhookController | RBL UPI |\n| `/webhooks/v2/digio` | DigioWebhookController | Digio (eMandate) |\n\n### Admin Endpoints\n\n| Endpoint | Purpose |\n|----------|---------|\n| `/v1/admin/orders/*` | Order management |\n| `/v1/admin/payment-attempts/*` | Payment attempt management |\n| `/v1/admin/refunds/*` | Refund management |\n\n---\n\n## Authentication & Security\n\n### Request Filters (Execution Order)\n\n1. **ApplicationContextBuilderFilter**\n   - Builds application context from headers\n   - Validates Client ID or Merchant ID\n   - Enriches with device info\n\n2. **PAMerchantAuthenticationFilter**\n   - Partner merchant authentication\n   - Validates access token with Syndicate service\n\n3. **PAPartnerAuthorizationFilter**\n   - Partner authorization validation\n\n### Required Headers\n\n| Header | Purpose | Required |\n|--------|---------|----------|\n| `${CLIENT_HEADER_KEY}` | Client identifier | Yes (or Merchant) |\n| `${MERCHANT_HEADER_KEY}` | Merchant identifier | Yes (or Client) |\n| `DEVICE_ID` | Device identifier | Optional |\n| `OS` | Operating system | Optional |\n| `OS_VERSION` | OS version | Optional |\n| `APP_VERSION` | App version | Optional |\n\n### Rate Limiting\n\n- Redisson-based distributed rate limiting\n- Configuration in `ClientRateLimiter.java`\n- Stored in `ProviderRateLimitConfigRepository`\n\n---\n\n## Internal Service Dependencies\n\n| Service | Client Library | Purpose |\n|---------|---------------|---------|\n| **User Service** | `user-service-client:4.0.1` | User data retrieval |\n| **Merchant Service** | `merchant-service-client:1.0.3` | Merchant info |\n| **Mandate Service** | `mandate-java-client:1.0.4` | Recurring payments |\n| **Arsenal** | Custom client | Instrument vault (tokenization) |\n| **Falcon** | Custom client | Offers/promotions |\n| **Genie** | `genie-java-client` | Configuration service |\n| **Syndicate** | Custom client | Authentication |\n| **LCM** | Custom client | Terminal resolution |\n| **Fee Service** | `fees:0.18.0` | Fee calculation |\n| **Narad** | Custom client | Dynamic routing |\n| **Invoker** | Custom client | Task invocation |\n| **Leia** | Custom client | ID generation |\n| **Vault** | Custom client | Token vaulting |\n\n---\n\n## Configuration\n\n### Main Configuration File\n\n**Location:** `src/main/resources/application.properties` (1300+ lines)\n\n### Key Configuration Sections\n\n```properties\n# Server\nserver.port=9010\nserver.servlet.context-path=/payments\n\n# Database - Master\nspring.datasource.url=jdbc:mysql://${DB_HOST}:3306/${DB_NAME}\nspring.datasource.username=${DB_USER}\nspring.datasource.password=${DB_PASSWORD}\n\n# Database - Replica\nreplica.datasource.url=jdbc:mysql://${REPLICA_DB_HOST}:3306/${REPLICA_DB_NAME}\n\n# Redis\naws.elastiCache.url=${REDIS_ADDRESS:127.0.0.1}\naws.elastiCache.port=${REDIS_PORT:6379}\n\n# Kafka\nmessaging.kafka.enabled=true\nmessaging.kafka.topic=payment-attempt-platform-metrics-pinot-out-new-1\n\n# SQS Queues\nsqs.force-payment-failure-queue=...\nsqs.mandate-expiry-cron-queue=...\nsqs.refund-reschedule-queue=...\nsqs.order-expiry-queue=...\n```\n\n### Environment Variables\n\n| Variable | Description | Default |\n|----------|-------------|---------|\n| `DB_HOST` | MySQL master host | stage-master-db.stg.dreamplug.net |\n| `DB_NAME` | Database name | payments_multi_tenancy |\n| `REPLICA_DB_HOST` | MySQL replica host | - |\n| `REDIS_ADDRESS` | Redis address | 127.0.0.1 |\n| `REDIS_PORT` | Redis port | 6379 |\n| `DP_RUN_ENV` | Deployment environment | - |\n\n---\n\n## Entry Point\n\n**File:** `src/main/java/in/dreamplug/darwin/DarwinApplication.java`\n\n```java\n@SpringBootApplication\n@EnableRetry\n@EntityScan(basePackages = {\"in.dreamplug\"})\n@EnableAspectJAutoProxy(exposeProxy = true)\n@EnableScheduling\n@ComponentScan(basePackages = {\"in.dreamplug\"})\npublic class DarwinApplication {\n    public static void main(String[] args) {\n        TimeZone.setDefault(TimeZone.getTimeZone(\"UTC\"));\n        SpringApplication.run(DarwinApplication.class, args);\n    }\n}\n```\n\n**Key Annotations:**\n- `@EnableRetry` - Spring Retry support\n- `@EnableAspectJAutoProxy` - AOP proxying (for self-referencing beans)\n- `@EnableScheduling` - Scheduled tasks\n- `@EntityScan` - JPA entity scanning\n\n---\n\n## Quick Reference: First Files to Study\n\n1. **Entry Point:** `DarwinApplication.java`\n2. **Base Workflow:** `v2/workflow/create/Workflow.java`\n3. **Payment Attempt:** `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java`\n4. **State Machine:** `statemachine/payment/PaymentStateMachine.java`\n5. **Provider Routing:** `planner/providerdecider/ProviderDeciderRouter.java`\n6. **Config:** `application.properties` (scan first 200 lines)\n\n---\n\n## Next Steps\n\nAfter completing this overview:\n1. [ ] Explore `DarwinApplication.java`\n2. [ ] Run `./gradlew build` to ensure the project compiles\n3. [ ] Review `application.properties` structure\n4. [ ] Proceed to [02-data-layer.md](./02-data-layer.md)\n\n---\n\n*Next: [02 - Data Layer Deep-Dive](./02-data-layer.md)*\n"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":2098,"cache_read_input_tokens":142922,"cache_creation":{"ephemeral_5m_input_tokens":2098,"ephemeral_1h_input_tokens":0},"output_tokens":1}},"type":"assistant","uuid":"ad2820f9-6bf4-4f7d-addb-8b98d1e70fe4","timestamp":"2025-12-31T10:01:26.496Z"}
{"parentUuid":"ad2820f9-6bf4-4f7d-addb-8b98d1e70fe4","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01Ld5ePWooQW12MhXHYYnNhV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_bdrk_01ViKbeFd9T39zgx5kLLeMTP","name":"Write","input":{"file_path":"/Users/kiranbiliyawala/code/cred/payments/payment-service/docs/study-guide/02-data-layer.md","content":"# 02 - Data Layer Deep-Dive\n\n> **Reading Time:** 60 minutes\n> **Prerequisites:** [01-overview.md](./01-overview.md)\n> **Next:** [03-provider-integration.md](./03-provider-integration.md)\n\n---\n\n## Table of Contents\n1. [Entity Hierarchy](#entity-hierarchy)\n2. [Master-Replica Architecture](#master-replica-architecture)\n3. [Repository Patterns](#repository-patterns)\n4. [JSON Columns & Converters](#json-columns--converters)\n5. [Caching Architecture](#caching-architecture)\n6. [DynamoDB Usage](#dynamodb-usage)\n7. [Optimistic Locking & Audit](#optimistic-locking--audit)\n\n---\n\n## Entity Hierarchy\n\n### Base Classes\n\n```\nBaseEntity\n    │\n    ├── id (Long, auto-generated)\n    ├── created_at (LocalDateTime)\n    ├── updated_at (LocalDateTime)\n    ├── created_by (String)\n    └── updated_by (String)\n            │\n            └── BaseExternalEntity\n                    │\n                    ├── external_id (UUID String)\n                    └── version (Integer, optimistic locking)\n```\n\n### BaseEntity\n**File:** `entity/commons/BaseEntity.java`\n\n```java\n@Getter @Setter\n@MappedSuperclass\npublic class BaseEntity {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @CreationTimestamp\n    @Column(name = \"created_at\")\n    private LocalDateTime createAt = LocalDateTime.now();\n\n    @UpdateTimestamp\n    @Column(name = \"updated_at\")\n    private LocalDateTime updatedAt = LocalDateTime.now();\n\n    @Column(name = \"created_by\")\n    private String createdBy;\n\n    @Column(name = \"updated_by\")\n    private String updatedBy;\n\n    @PrePersist\n    public void onCreate() {\n        createdBy = ApplicationContext.getApplicationName();\n    }\n\n    @PreUpdate\n    public void onUpdate() {\n        updatedBy = ApplicationContext.getApplicationName();\n    }\n}\n```\n\n### BaseExternalEntity\n**File:** `entity/provider/BaseExternalEntity.java`\n\n```java\n@MappedSuperclass\npublic class BaseExternalEntity extends BaseEntity {\n    @Column(name = \"external_id\", length = 36)\n    private String externalId;\n\n    @Version\n    @Column(name = \"version\")\n    private Integer version;\n\n    @PrePersist\n    public void onCreate() {\n        super.onCreate();\n        externalId = UUID.randomUUID().toString();\n    }\n}\n```\n\n### Entity Inheritance Diagram\n\n```\nBaseEntity\n    │\n    └── BaseExternalEntity\n            │\n            ├── OrderEntity\n            ├── PaymentV2Entity\n            ├── PaymentAttemptV2Entity\n            ├── RefundEntity\n            ├── RefundAttemptEntity\n            ├── FeeEntity\n            ├── ClientEntity\n            ├── CustomerEntity\n            ├── PaymentProviderEntity\n            └── ClientRefundRequestEntity\n```\n\n---\n\n## Core Entities\n\n### OrderEntity\n**File:** `entity/OrderEntity.java`\n\n```java\n@Entity @Table(name = \"orders\")\npublic class OrderEntity extends BaseExternalEntity {\n    @Column(name = \"client_reference_id\")\n    private String clientReferenceId;\n\n    @Column(name = \"amount\")\n    private BigDecimal amount;\n\n    @Column(name = \"intent_amount\")\n    private BigDecimal intentAmount;\n\n    @Enumerated(EnumType.STRING)\n    private OrderType type;\n\n    @Enumerated(EnumType.STRING)\n    private OrderStatus status;\n\n    @ManyToOne\n    @JoinColumn(name = \"client_id\")\n    private ClientEntity clientEntity;\n\n    @ManyToOne(fetch = FetchType.EAGER)\n    @JoinColumn(name = \"customer_id\")\n    private CustomerEntity customerEntity;\n\n    @Convert(converter = ObjectMetadataMapConverter.class)\n    private Map<String, String> metaData;\n\n    @OneToMany(cascade = {CascadeType.MERGE, CascadeType.PERSIST})\n    @JoinColumn(name = \"order_id\")\n    private Set<OrderAttributeEntity> attributeEntities;\n\n    @OneToOne(fetch = FetchType.LAZY, mappedBy = \"orderEntity\")\n    private OrderUdfEntity orderUdfEntity;\n}\n```\n\n### PaymentV2Entity\n**File:** `entity/v2/PaymentV2Entity.java`\n\n```java\n@Entity @Table(name = \"payments\")\n@Inheritance(strategy = InheritanceType.JOINED)\npublic class PaymentV2Entity extends BaseExternalEntity {\n    @ManyToOne\n    @JoinColumn(name = \"order_id\")\n    private OrderEntity orderEntity;\n\n    private BigDecimal amount;\n\n    @Enumerated(EnumType.STRING)\n    private PaymentStatus status;\n\n    @Enumerated(EnumType.STRING)\n    private PaymentMode paymentMode;\n\n    @Enumerated(EnumType.STRING)\n    private CurrencyName currency;\n\n    private BigDecimal conversionRate;\n    private BigDecimal currencyValue;\n    private String clientReferenceId;\n\n    @Convert(converter = PaymentInstrumentConverter.class)\n    private PaymentInstrument instrumentDetail;\n\n    @Convert(converter = PaymentSpecificDetailConverter.class)\n    private PaymentSpecificDetail paymentSpecificDetail;\n}\n```\n\n### PaymentAttemptV2Entity\n**File:** `entity/v2/PaymentAttemptV2Entity.java`\n\n```java\n@Entity @Table(name = \"payment_attempts\")\n@Inheritance(strategy = InheritanceType.JOINED)\npublic class PaymentAttemptV2Entity extends BaseExternalEntity {\n    // Duplicate column for direct queries without JOIN\n    @Column(name = \"order_id\")\n    private Long orderId;\n\n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"order_id\", updatable = false, insertable = false)\n    private OrderEntity orderEntity;\n\n    @ManyToOne\n    @JoinColumn(name = \"payment_id\")\n    private PaymentV2Entity paymentEntity;\n\n    @ManyToOne\n    @JoinColumn(name = \"payment_provider_id\")\n    private PaymentProviderEntity paymentProviderEntity;\n\n    @ManyToOne\n    @JoinColumn(name = \"provider_account_id\")\n    private ProviderAccountEntity providerAccountEntity;\n\n    private String providerReferenceId;\n    private String gatewayReferenceId;\n\n    @Enumerated(EnumType.STRING)\n    private PaymentInstrumentGroup paymentMethod;\n\n    @Enumerated(EnumType.STRING)\n    private PaymentAttemptStatus status;\n\n    private String errorCode;\n    private String errorMessage;\n    private String providerStatus;\n\n    @Convert(converter = EnrichedPaymentInstrumentConverter.class)\n    private EnrichedPaymentInstrument instrumentDetail;\n\n    @Convert(converter = RoutesBreakupConverter.class)\n    private RoutesBreakup routesBreakup;\n\n    @OneToMany(cascade = {CascadeType.MERGE, CascadeType.PERSIST})\n    @JoinColumn(name = \"payment_attempt_id\")\n    private Set<PaymentAttemptAttributeEntity> attributeEntities;\n\n    @PrePersist\n    public void onCreate() {\n        super.onCreate();\n        if (StringUtils.isEmpty(externalId)) {\n            externalId = PaymentAttemptUUIdGenerator.generate();\n        }\n    }\n}\n```\n\n### Entity Relationships Diagram\n\n```\nClientEntity (1) ────────────────> (M) OrderEntity\n                                        │\nCustomerEntity (1) ─────────────────────┤\n                                        │\n                                        │ (1)\n                                        │\n                                        ▼ (M)\n                                   PaymentV2Entity\n                                        │\n                                        │ (1)\n                                        │\n                                        ▼ (M)\n                               PaymentAttemptV2Entity\n                                        │\n        ┌───────────────────────────────┼───────────────────────────────┐\n        │                               │                               │\n        ▼                               ▼                               ▼\nPaymentProviderEntity          ProviderAccountEntity              RefundEntity\n                                                                        │\n                                                                        ▼ (M)\n                                                                 RefundAttemptEntity\n```\n\n---\n\n## Master-Replica Architecture\n\n### Configuration Files\n\n**Master:** `configuration/database/MasterDataSourceConfiguration.java`\n**Replica:** `configuration/database/ReplicaDataSourceConfiguration.java`\n**Annotation:** `configuration/database/annotation/ReplicaRepository.java`\n\n### How Routing Works\n\n```java\n// Master Configuration - EXCLUDES @ReplicaRepository\n@EnableJpaRepositories(\n    basePackages = {REPO_PATH, DAO_PATH},\n    excludeFilters = @ComponentScan.Filter(ReplicaRepository.class),\n    entityManagerFactoryRef = MASTER_ENTITY_MANAGER_FACTORY,\n    transactionManagerRef = MASTER_TRANSACTION_MANAGER\n)\n\n// Replica Configuration - INCLUDES ONLY @ReplicaRepository\n@EnableJpaRepositories(\n    basePackages = {REPO_PATH, DAO_PATH},\n    includeFilters = @ComponentScan.Filter(ReplicaRepository.class),\n    entityManagerFactoryRef = REPLICA_ENTITY_MANAGER_FACTORY,\n    transactionManagerRef = REPLICA_TRANSACTION_MANAGER\n)\n```\n\n### Usage Pattern\n\n```java\n// Default - writes to Master\n@Repository\npublic interface PaymentRepository extends JpaRepository<PaymentV2Entity, Long> {\n    // Uses MasterEntityManager\n}\n\n// Explicit Replica - reads from Replica\n@Repository\n@ReplicaRepository\npublic class RefundEntityReplicaDAOImpl extends AbstractReplicaDAOImpl<RefundEntity, Long> {\n    // Uses ReplicaEntityManager\n}\n```\n\n### HikariCP Pool Configuration\n\n| Pool | Setting | Purpose |\n|------|---------|---------|\n| **hikari_master** | `masterMinimumIdle`, `masterMaximumPoolSize` | Write operations |\n| **hikari_replica** | `replicaMinimumIdle`, `replicaMaximumPoolSize`, `readOnly=true` | Read operations |\n\n**Common Settings:**\n- `idleTimeout` - Close idle connections\n- `connectionTimeout` - Wait for connection\n- `maxLifetime` - Recycle connections\n- `leakDetectionThreshold` - Detect connection leaks\n\n### HikariCP Configuration Example\n\n```java\nHikariConfig hikariConfig = new HikariConfig();\nhikariConfig.setIdleTimeout(hikariIdleTimeout);\nhikariConfig.setConnectionTimeout(hikariConnectionTimeout);\nhikariConfig.setMinimumIdle(masterMinimumIdle);\nhikariConfig.setMaximumPoolSize(masterMaximumPoolSize);\nhikariConfig.setMaxLifetime(maxLifeTime);\nhikariConfig.setPoolName(\"hikari_master\");\nhikariConfig.setLeakDetectionThreshold(leakDetectionThreshold);\nhikariConfig.setJdbcUrl(url);\n```\n\n---\n\n## Repository Patterns\n\n### JPA Repository Pattern\n\n```java\n@Repository\npublic interface OrderRepository extends JpaRepository<OrderEntity, Long> {\n\n    // FETCH JOIN to prevent N+1 queries\n    @Query(\"SELECT o FROM OrderEntity o \"\n            + \"JOIN FETCH o.customerEntity \"\n            + \"JOIN FETCH o.clientEntity \"\n            + \"LEFT JOIN FETCH o.orderUdfEntity \"\n            + \"WHERE o.externalId = :externalId\")\n    Optional<OrderEntity> findByExternalId(@Param(\"externalId\") String externalId);\n\n    // Property path navigation\n    Optional<OrderEntity> findByClientReferenceIdAndClientEntity_ExternalId(\n            String clientReferenceId, String externalId);\n\n    // List by tag\n    List<OrderEntity> findByTagId(String tagId);\n}\n```\n\n### DAO Pattern (Custom EntityManager)\n\n```java\n@Repository\npublic class PaymentAttemptDAOV2Impl {\n    @PersistenceContext\n    private EntityManager entityManager;\n\n    public List<PaymentAttemptV2Entity> findByOrderIdWithFetchJoin(Long orderId) {\n        return entityManager.createQuery(\n            \"SELECT pa FROM PaymentAttemptV2Entity pa \"\n            + \"JOIN FETCH pa.paymentEntity \"\n            + \"JOIN FETCH pa.paymentProviderEntity \"\n            + \"WHERE pa.orderId = :orderId\",\n            PaymentAttemptV2Entity.class)\n            .setParameter(\"orderId\", orderId)\n            .getResultList();\n    }\n}\n```\n\n### Key Repository Methods\n\n| Repository | Key Methods |\n|------------|-------------|\n| `OrderRepository` | `findByExternalId`, `findByClientReferenceIdAndClientEntity_ExternalId` |\n| `PaymentRepository` | `findByExternalId`, `findByOrderEntity_ExternalId` |\n| `PaymentAttemptRepository` | `findByExternalId`, `findByProviderReferenceId` |\n| `RefundRepository` | `findByOrderEntity_Id`, `findByClientRefundRequestEntity_Id` |\n\n---\n\n## JSON Columns & Converters\n\n### Converter Pattern\n\n```java\n@Column(name = \"metadata\")\n@Convert(converter = ObjectMetadataMapConverter.class)\nprivate Map<String, String> metaData;\n```\n\n### Available Converters\n\n| Column | Converter | Entity | Java Type |\n|--------|-----------|--------|-----------|\n| `metadata` | `ObjectMetadataMapConverter` | OrderEntity | `Map<String, String>` |\n| `instrument_detail` | `PaymentInstrumentConverter` | PaymentV2Entity | `PaymentInstrument` |\n| `instrument_detail` | `EnrichedPaymentInstrumentConverter` | PaymentAttemptV2Entity | `EnrichedPaymentInstrument` |\n| `payment_specific_detail` | `PaymentSpecificDetailConverter` | PaymentV2Entity | `PaymentSpecificDetail` |\n| `routes` | `RoutesBreakupConverter` | PaymentAttemptV2Entity | `RoutesBreakup` |\n| `additional_info` | `ClientRefundAdditionalInfoConverter` | ClientRefundRequestEntity | `ClientRefundAdditionalInfo` |\n\n---\n\n## Caching Architecture\n\n### Caffeine Caches\n\n| Cache Class | What It Caches | TTL | Max Size |\n|-------------|----------------|-----|----------|\n| `ClientConfigurationCache` | Client settings by ID/externalId/merchantId | 10-20 min | - |\n| `PaymentProviderCache` | Provider configurations | 15-25 min | - |\n| `ProviderAccountCache` | Provider account entities | 15-25 min | - |\n| `DecisionTreeObjectCache` | Decision tree JSON + workflow | 180-190 min | - |\n| `FeeCache` | Fee configurations by feeId | 1 day | 500 |\n| `CardBinCache` | Card BIN details by hash | Configurable | - |\n| `MasterConfigurationCache` | Feature flags, system settings | 10-20 min | - |\n| `PaymentErrorMessageMappingCache` | Error code to message | Long | - |\n| `NativeOTPSupportedProviderCache` | OTP-capable providers | - | - |\n\n### Cache Implementation Pattern\n\n```java\n@Component\npublic class ClientConfigurationCache extends AbstractDPManagedCache {\n\n    @DPCache(cacheName = \"client_configuration_cache\")\n    private LoadingCache<Long, Map<ClientSettingKey, String>> idCache;\n\n    @Override\n    public void buildCache() {\n        idCache = DPCacheBuilder.getBuilder()\n            .refreshAfterWrite(\n                generateRandomCacheRefreshInterval(10), // 10-20 min jitter\n                TimeUnit.MINUTES)\n            .build(this::loadClientSettings);\n    }\n\n    private Map<ClientSettingKey, String> loadClientSettings(Long clientId) {\n        ClientEntity client = clientRepository.findById(clientId)\n            .orElseThrow(() -> Error.invalid_client_id.getBuilder().build());\n        return client.getSettings().stream()\n            .collect(Collectors.toMap(\n                ClientSettingsEntity::getSettingKey,\n                ClientSettingsEntity::getSettingValue));\n    }\n}\n```\n\n### Jittered TTLs (Thundering Herd Prevention)\n\n```java\nprivate Long generateRandomCacheRefreshInterval(int base) {\n    SecureRandom random = new SecureRandom();\n    return Long.valueOf(base + random.nextInt(10) + 1);\n}\n// base=10 → returns 11-20\n// base=15 → returns 16-25\n```\n\n---\n\n## DynamoDB Usage\n\n### What Goes Where\n\n| MySQL (Relational) | DynamoDB (NoSQL) |\n|--------------------|------------------|\n| Orders, Payments, Attempts | Workflow context (TTL-based) |\n| Refunds, Fees | Native OTP details |\n| Clients, Customers | Redirect tracking |\n| Provider configs | Metadata audit trails |\n\n### DynamoDB Tables\n\n| Table | Hash Key | Sort Key | TTL | Purpose |\n|-------|----------|----------|-----|---------|\n| `darwin_payment_attempt_workflow_context` | payment_attempt_external_id | workflow_step | 1 day | Workflow state |\n| `darwin_payment_attempt_native_otp_detail` | payment_attempt_external_id | - | 1 day | OTP auth |\n| `darwin_payment_attempt_redirection_detail` | payment_attempt_external_id | - | 1 day | 3DS redirects |\n| `darwin_payment_attempt_metadata_audit` | payment_attempt_external_id | - | - | Audit trail |\n\n### DynamoDB Entity Example\n\n```java\n@Data @Builder\n@DynamoDBTable(tableName = \"darwin_payment_attempt_workflow_context\")\npublic class PaymentAttemptWorkflowContextEntity {\n\n    @DynamoDBHashKey(attributeName = \"payment_attempt_external_id\")\n    private String paymentAttemptExternalId;\n\n    @DynamoDBRangeKey\n    @DynamoDBAttribute(attributeName = \"workflow_step\")\n    private WorkflowStep workflowStep;\n\n    @Builder.Default\n    private long ttl = LocalDateTime.now()\n        .plusDays(1)\n        .toEpochSecond(ZoneOffset.UTC);\n\n    @DynamoDBAttribute(attributeName = \"data\")\n    private String data;\n\n    @DynamoDBTypeConverted(converter = LocalDateTimeConverter.class)\n    @DynamoDBAttribute(attributeName = \"event_at\")\n    private LocalDateTime eventAt;\n}\n```\n\n### DynamoDB DAO Pattern\n\n```java\n@RequiredArgsConstructor\npublic abstract class AbstractDynamoDBDAO<T> {\n    private final Class<T> tClass;\n    private final DynamoDBMapper dynamoDBMapper;\n\n    public void save(T entity) {\n        dynamoDBMapper.save(entity);\n    }\n\n    public void saveIfNotExists(T entity, List<String> uniqueKeys) {\n        DynamoDBSaveExpression saveExpression = new DynamoDBSaveExpression();\n        Map<String, ExpectedAttributeValue> expected = new HashMap<>();\n        uniqueKeys.forEach(key ->\n            expected.put(key, new ExpectedAttributeValue().withExists(false)));\n        saveExpression.setExpected(expected);\n        dynamoDBMapper.save(entity, saveExpression);\n    }\n\n    public T findByHashKey(Object hashKey) {\n        return dynamoDBMapper.load(tClass, hashKey);\n    }\n}\n```\n\n---\n\n## Optimistic Locking & Audit\n\n### @Version for Optimistic Locking\n\n```java\n@Version\n@Column(name = \"version\")\nprivate Integer version;\n```\n\n**Behavior:**\n- Hibernate auto-increments on each update\n- Throws `OptimisticLockException` on concurrent modification\n- Prevents lost updates in concurrent scenarios\n\n### Audit Columns\n\n```java\n@CreationTimestamp\n@Column(name = \"created_at\")\nprivate LocalDateTime createAt;\n\n@UpdateTimestamp\n@Column(name = \"updated_at\")\nprivate LocalDateTime updatedAt;\n\n@PrePersist\npublic void onCreate() {\n    createdBy = ApplicationContext.getApplicationName();\n}\n\n@PreUpdate\npublic void onUpdate() {\n    updatedBy = ApplicationContext.getApplicationName();\n}\n```\n\n### Soft Delete Pattern\n\nSome entities use soft delete:\n\n```java\n@Column(name = \"is_deleted\")\nprivate Boolean deleted = Boolean.FALSE;\n```\n\nUsed in: `ClientEntity`, `CustomerEntity`\n\n---\n\n## Data Layer Architecture Diagram\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                     Service Layer                            │\n├─────────────────────────────────────────────────────────────┤\n│  JPA Repositories    │  Custom DAOs    │  DynamoDB DAOs     │\n├─────────────────────────────────────────────────────────────┤\n│            Spring Data JPA + Hibernate ORM                   │\n├────────────────────────┬────────────────────────────────────┤\n│   Master DataSource    │      Replica DataSource            │\n│   (Writes)             │      (Reads - @ReplicaRepository)  │\n├────────────────────────┼────────────────────────────────────┤\n│  HikariCP Master Pool  │    HikariCP Replica Pool           │\n├────────────────────────┴────────────────────────────────────┤\n│              MySQL (payments_multi_tenancy)                  │\n└─────────────────────────────────────────────────────────────┘\n          │                                    │\n┌─────────▼─────────┐              ┌───────────▼───────────┐\n│     DynamoDB      │              │   Caffeine Caches     │\n│  (Workflow/Audit) │              │  (Client/Provider)    │\n└───────────────────┘              └───────────────────────┘\n```\n\n---\n\n## Key Files to Study\n\n### Entity Classes\n1. `entity/commons/BaseEntity.java`\n2. `entity/provider/BaseExternalEntity.java`\n3. `entity/OrderEntity.java`\n4. `entity/v2/PaymentAttemptV2Entity.java`\n\n### Database Configuration\n1. `configuration/database/MasterDataSourceConfiguration.java`\n2. `configuration/database/ReplicaDataSourceConfiguration.java`\n3. `configuration/database/annotation/ReplicaRepository.java`\n\n### Repositories\n1. `repository/OrderRepository.java`\n2. `repository/PaymentAttemptRepository.java`\n\n### Caches\n1. `cache/ClientConfigurationCache.java`\n2. `configuration/CacheConfig.java`\n\n### DynamoDB\n1. `dynamo/dao/AbstractDynamoDBDAO.java`\n2. `dynamo/domain/PaymentAttemptWorkflowContextEntity.java`\n\n---\n\n## Checkpoint\n\nAfter completing this section:\n- [ ] Understand entity hierarchy (BaseEntity → BaseExternalEntity)\n- [ ] Know how Master-Replica routing works\n- [ ] Understand caching patterns with jittered TTLs\n- [ ] Know when to use MySQL vs DynamoDB\n- [ ] Proceed to [03-provider-integration.md](./03-provider-integration.md)\n\n---\n\n*Next: [03 - Provider Integration](./03-provider-integration.md)*\n"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":2098,"cache_read_input_tokens":142922,"cache_creation":{"ephemeral_5m_input_tokens":2098,"ephemeral_1h_input_tokens":0},"output_tokens":10569}},"type":"assistant","uuid":"5b1db7d2-0896-47a3-8632-d963779b9979","timestamp":"2025-12-31T10:02:48.631Z"}
{"type":"file-history-snapshot","messageId":"ad2820f9-6bf4-4f7d-addb-8b98d1e70fe4","snapshot":{"messageId":"333b6ac7-26fd-4722-980d-e319ce733bba","trackedFileBackups":{"/Users/kiranbiliyawala/.claude/plans/distributed-marinating-mango.md":{"backupFileName":"c92f53c9f6085692@v2","version":2,"backupTime":"2025-12-31T09:58:40.829Z"},"docs/study-guide/README.md":{"backupFileName":"3fd18aad0b0250d2@v1","version":1,"backupTime":"2025-12-31T10:00:15.742Z"},"docs/study-guide/01-overview.md":{"backupFileName":"676b1c94834531cf@v1","version":1,"backupTime":"2025-12-31T10:02:50.120Z"}},"timestamp":"2025-12-31T09:58:40.824Z"},"isSnapshotUpdate":true}
{"parentUuid":"5b1db7d2-0896-47a3-8632-d963779b9979","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_015rKwquMzUDqcNhWno363iT","type":"tool_result","content":"File created successfully at: /Users/kiranbiliyawala/code/cred/payments/payment-service/docs/study-guide/01-overview.md"}]},"uuid":"e68b0729-0f34-4379-a269-83ded4b0f95d","timestamp":"2025-12-31T10:02:50.114Z","toolUseResult":{"type":"create","filePath":"/Users/kiranbiliyawala/code/cred/payments/payment-service/docs/study-guide/01-overview.md","content":"# 01 - Overview & Architecture\n\n> **Reading Time:** 45 minutes\n> **Prerequisites:** None\n> **Next:** [02-data-layer.md](./02-data-layer.md)\n\n---\n\n## Table of Contents\n1. [Technology Stack](#technology-stack)\n2. [Project Structure](#project-structure)\n3. [Core Concepts](#core-concepts)\n4. [API Endpoints](#api-endpoints)\n5. [Authentication & Security](#authentication--security)\n6. [Internal Service Dependencies](#internal-service-dependencies)\n7. [Configuration](#configuration)\n\n---\n\n## Technology Stack\n\n### Core Technologies\n\n| Technology | Version | Purpose |\n|------------|---------|---------|\n| **Java** | 17 | Runtime (Amazon Corretto) |\n| **Spring Boot** | 2.7.14 | Application framework |\n| **Gradle** | 7.6 | Build tool |\n| **MySQL** | - | Primary database |\n| **DynamoDB** | - | Workflow state storage |\n| **Redis (Redisson)** | 3.19.1 | Distributed cache & locks |\n| **Kafka** | - | Event streaming |\n| **AWS SQS** | - | Async task processing |\n| **Hibernate** | 5.x | ORM |\n| **HikariCP** | - | Connection pooling |\n\n### Key Libraries\n\n| Library | Version | Purpose |\n|---------|---------|---------|\n| Lombok | - | Boilerplate reduction |\n| MapStruct | 1.4.2 | Object mapping |\n| Guava | - | EventBus, collections |\n| Jackson | - | JSON processing |\n| JaCoCo | - | Code coverage |\n| Caffeine | - | In-memory caching |\n\n### Server Configuration\n\n```properties\nserver.port=9010\nserver.servlet.context-path=/payments\n```\n\n---\n\n## Project Structure\n\n### Root Directory\n```\npayment-service/\n├── src/\n│   ├── main/\n│   │   ├── java/in/dreamplug/darwin/    # Main source code\n│   │   └── resources/\n│   │       └── application.properties    # Main config (1300+ lines)\n│   └── test/                             # Test code\n├── codepipeline/                         # CI/CD configs\n├── build.gradle                          # Dependencies\n├── Dockerfile                            # Container setup\n├── README.md                             # Project readme\n└── settings.gradle                       # Gradle settings\n```\n\n### Source Code Structure\n\n```\nsrc/main/java/in/dreamplug/darwin/\n│\n├── DarwinApplication.java           # Entry point\n│\n├── controller/                      # REST Controllers\n│   ├── v2/                          # V2 API (Primary)\n│   │   ├── order/                   # Order endpoints\n│   │   ├── payment/                 # Payment endpoints\n│   │   └── paymentattempt/          # Payment attempt endpoints\n│   ├── WebhookController.java       # Generic webhooks\n│   └── admin/                       # Admin endpoints\n│\n├── service/                         # Business logic\n│   ├── PaymentProviderService.java\n│   ├── WebhookService.java\n│   └── ...\n│\n├── v2/                              # V2 Implementation\n│   ├── service/                     # V2 services\n│   └── workflow/                    # CRITICAL: Workflows\n│       └── create/\n│           ├── Workflow.java             # Base workflow\n│           ├── payments/                 # Payment workflows\n│           ├── paymentattempts/          # Attempt workflows\n│           └── providers/                # 24+ provider adapters\n│\n├── entity/                          # JPA Entities\n│   ├── commons/                     # Base entities\n│   │   └── BaseEntity.java\n│   ├── provider/                    # Provider entities\n│   │   └── BaseExternalEntity.java\n│   ├── v2/                          # V2 entities (Primary)\n│   │   ├── PaymentV2Entity.java\n│   │   ├── PaymentAttemptV2Entity.java\n│   │   ├── RefundEntity.java\n│   │   └── FeeEntity.java\n│   ├── OrderEntity.java\n│   ├── ClientEntity.java\n│   ├── CustomerEntity.java\n│   └── ProviderAccountEntity.java\n│\n├── repository/                      # Data access layer\n│   ├── OrderRepository.java\n│   ├── PaymentRepository.java\n│   ├── PaymentAttemptRepository.java\n│   └── read_only_repository/        # Replica repositories\n│\n├── statemachine/                    # State machines\n│   ├── payment/                     # Payment state machine\n│   │   └── PaymentStateMachine.java\n│   ├── order/                       # Order state machine\n│   │   └── OrderStateMachine.java\n│   └── RefundStateMachine.java\n│\n├── planner/                         # Decision tree routing\n│   └── providerdecider/\n│       ├── ProviderDeciderRouter.java\n│       ├── ProviderDeciderV2.java\n│       └── ProviderDeciderViaLCM.java\n│\n├── cache/                           # Caching layer\n│   ├── ClientConfigurationCache.java\n│   ├── PaymentProviderCache.java\n│   ├── DecisionTreeObjectCache.java\n│   └── ...\n│\n├── client/                          # External service clients\n│   ├── arsenal/                     # Instrument vault\n│   ├── fee/                         # Fee service\n│   ├── lcm/                         # Lending cloud manager\n│   └── ...\n│\n├── configuration/                   # Spring configs\n│   ├── database/                    # Database configs\n│   │   ├── MasterDataSourceConfiguration.java\n│   │   └── ReplicaDataSourceConfiguration.java\n│   ├── CacheConfig.java\n│   └── RedissonAutoConfiguration.java\n│\n├── kafka/                           # Kafka integration\n│   ├── MessagingConfigs.java\n│   └── dto/                         # Kafka event DTOs\n│\n├── sqs/                             # SQS integration\n│   ├── DarwinSQSMessageProcessor.java\n│   └── ...\n│\n├── dynamo/                          # DynamoDB integration\n│   ├── dao/                         # DynamoDB DAOs\n│   └── domain/                      # DynamoDB entities\n│\n├── error/                           # Error handling\n│   ├── Error.java                   # Error enum\n│   └── ProviderException.java\n│\n├── dto/                             # Data transfer objects\n│\n├── commons/spring/filters/          # Request filters\n│   ├── ApplicationContextBuilderFilter.java\n│   └── PAMerchantAuthenticationFilter.java\n│\n└── processors/                      # Processors\n    └── instrumenttype/              # Instrument processors\n        ├── InstrumentTypeProcessorManager.java\n        ├── CardInstrumentTypeProcessor.java\n        └── UPIPayInstrumentTypeProcessor.java\n```\n\n---\n\n## Core Concepts\n\n### 1. Payment Hierarchy\n\n```\nOrder (1)\n    └── Payment (M)\n            └── PaymentAttempt (M)\n                    └── RefundAttempt (M via Refund)\n```\n\n- **Order:** Top-level transaction container\n- **Payment:** Represents a payment mode (card, UPI, etc.)\n- **PaymentAttempt:** Actual provider call\n- **Refund:** Reversal of a payment attempt\n\n### 2. Entity Lifecycle (State Machine)\n\n```\nCREATED → PROCESSING → AUTHORIZED → COMPLETED\n                   ↘ FAILED\n                   ↘ BLOCKED\n```\n\n### 3. Workflow Pattern\n\nAll creation operations follow a 7-step workflow:\n\n```java\n1. validateAndEnrichContext()    // Validate & enrich data\n2. persistIntent()               // Save to MySQL (transactional)\n3. publishEntityPrePersistEvents() // Pre-persist hooks\n4. persistNonRelationalIntent()  // Save to DynamoDB\n5. process()                     // Provider API call\n6. postProcess()                 // Update with response (transactional)\n7. publishEntityChangeEvents()   // Trigger state machines\n```\n\n### 4. Provider Routing\n\n```\nRequest → ProviderDeciderRouter\n              │\n              ├── LCM (Lending Cloud Manager) - if supported\n              │\n              └── Decision Tree - JSON rules\n                      │\n                      └── Provider Adapter Selection\n```\n\n### 5. Event-Driven Architecture\n\n```\nWorkflow completes\n    │\n    └── EventBus.post(PaymentAttemptEvent)\n            │\n            ├── PaymentStateMachine.onEvent()\n            │       └── Updates Payment status\n            │               │\n            │               └── EventBus.post(PaymentEvent)\n            │                       │\n            │                       └── OrderStateMachine.onEvent()\n            │                               └── Updates Order status\n            │\n            └── EventiService.publishEvent()\n                    └── External notifications\n```\n\n---\n\n## API Endpoints\n\n### Primary Endpoints (V2)\n\n| Method | Endpoint | Controller | Purpose |\n|--------|----------|------------|---------|\n| POST | `/v2/orders` | OrderV2Controller | Create order |\n| GET | `/v2/orders/{orderId}` | OrderV2Controller | Get order |\n| POST | `/v2/orders/{orderId}/payments` | PaymentV2Controller | Bulk create payments |\n| POST | `/v2/payments/{paymentId}/attempts` | PaymentAttemptV2Controller | Create payment attempt |\n| POST | `/v2/payments/by-order-id/{orderId}/attempts` | PaymentAttemptV2Controller | Create attempt by order |\n| POST | `/v1/webhooks` | WebhookController | Generic webhook |\n\n### Provider Webhook Endpoints\n\n| Endpoint | Controller | Provider |\n|----------|------------|----------|\n| `/webhooks/v2/cashfree` | CashfreeWebhookController | Cashfree |\n| `/webhooks/v2/razorpay` | RazorpayWebhookController | Razorpay |\n| `/webhooks/v2/payu` | PayuWebhookController | PayU |\n| `/webhooks/v2/juspay` | JuspayWebhookController | Juspay |\n| `/webhooks/v2/cybersource` | CybersourceWebhookController | Cybersource |\n| `/webhooks/v2/ybl` | YBLWebhookController | Yes Bank UPI |\n| `/webhooks/v2/icici` | ICICIWebhookController | ICICI UPI |\n| `/webhooks/v2/rbl-upi` | RBLUpiWebhookController | RBL UPI |\n| `/webhooks/v2/digio` | DigioWebhookController | Digio (eMandate) |\n\n### Admin Endpoints\n\n| Endpoint | Purpose |\n|----------|---------|\n| `/v1/admin/orders/*` | Order management |\n| `/v1/admin/payment-attempts/*` | Payment attempt management |\n| `/v1/admin/refunds/*` | Refund management |\n\n---\n\n## Authentication & Security\n\n### Request Filters (Execution Order)\n\n1. **ApplicationContextBuilderFilter**\n   - Builds application context from headers\n   - Validates Client ID or Merchant ID\n   - Enriches with device info\n\n2. **PAMerchantAuthenticationFilter**\n   - Partner merchant authentication\n   - Validates access token with Syndicate service\n\n3. **PAPartnerAuthorizationFilter**\n   - Partner authorization validation\n\n### Required Headers\n\n| Header | Purpose | Required |\n|--------|---------|----------|\n| `${CLIENT_HEADER_KEY}` | Client identifier | Yes (or Merchant) |\n| `${MERCHANT_HEADER_KEY}` | Merchant identifier | Yes (or Client) |\n| `DEVICE_ID` | Device identifier | Optional |\n| `OS` | Operating system | Optional |\n| `OS_VERSION` | OS version | Optional |\n| `APP_VERSION` | App version | Optional |\n\n### Rate Limiting\n\n- Redisson-based distributed rate limiting\n- Configuration in `ClientRateLimiter.java`\n- Stored in `ProviderRateLimitConfigRepository`\n\n---\n\n## Internal Service Dependencies\n\n| Service | Client Library | Purpose |\n|---------|---------------|---------|\n| **User Service** | `user-service-client:4.0.1` | User data retrieval |\n| **Merchant Service** | `merchant-service-client:1.0.3` | Merchant info |\n| **Mandate Service** | `mandate-java-client:1.0.4` | Recurring payments |\n| **Arsenal** | Custom client | Instrument vault (tokenization) |\n| **Falcon** | Custom client | Offers/promotions |\n| **Genie** | `genie-java-client` | Configuration service |\n| **Syndicate** | Custom client | Authentication |\n| **LCM** | Custom client | Terminal resolution |\n| **Fee Service** | `fees:0.18.0` | Fee calculation |\n| **Narad** | Custom client | Dynamic routing |\n| **Invoker** | Custom client | Task invocation |\n| **Leia** | Custom client | ID generation |\n| **Vault** | Custom client | Token vaulting |\n\n---\n\n## Configuration\n\n### Main Configuration File\n\n**Location:** `src/main/resources/application.properties` (1300+ lines)\n\n### Key Configuration Sections\n\n```properties\n# Server\nserver.port=9010\nserver.servlet.context-path=/payments\n\n# Database - Master\nspring.datasource.url=jdbc:mysql://${DB_HOST}:3306/${DB_NAME}\nspring.datasource.username=${DB_USER}\nspring.datasource.password=${DB_PASSWORD}\n\n# Database - Replica\nreplica.datasource.url=jdbc:mysql://${REPLICA_DB_HOST}:3306/${REPLICA_DB_NAME}\n\n# Redis\naws.elastiCache.url=${REDIS_ADDRESS:127.0.0.1}\naws.elastiCache.port=${REDIS_PORT:6379}\n\n# Kafka\nmessaging.kafka.enabled=true\nmessaging.kafka.topic=payment-attempt-platform-metrics-pinot-out-new-1\n\n# SQS Queues\nsqs.force-payment-failure-queue=...\nsqs.mandate-expiry-cron-queue=...\nsqs.refund-reschedule-queue=...\nsqs.order-expiry-queue=...\n```\n\n### Environment Variables\n\n| Variable | Description | Default |\n|----------|-------------|---------|\n| `DB_HOST` | MySQL master host | stage-master-db.stg.dreamplug.net |\n| `DB_NAME` | Database name | payments_multi_tenancy |\n| `REPLICA_DB_HOST` | MySQL replica host | - |\n| `REDIS_ADDRESS` | Redis address | 127.0.0.1 |\n| `REDIS_PORT` | Redis port | 6379 |\n| `DP_RUN_ENV` | Deployment environment | - |\n\n---\n\n## Entry Point\n\n**File:** `src/main/java/in/dreamplug/darwin/DarwinApplication.java`\n\n```java\n@SpringBootApplication\n@EnableRetry\n@EntityScan(basePackages = {\"in.dreamplug\"})\n@EnableAspectJAutoProxy(exposeProxy = true)\n@EnableScheduling\n@ComponentScan(basePackages = {\"in.dreamplug\"})\npublic class DarwinApplication {\n    public static void main(String[] args) {\n        TimeZone.setDefault(TimeZone.getTimeZone(\"UTC\"));\n        SpringApplication.run(DarwinApplication.class, args);\n    }\n}\n```\n\n**Key Annotations:**\n- `@EnableRetry` - Spring Retry support\n- `@EnableAspectJAutoProxy` - AOP proxying (for self-referencing beans)\n- `@EnableScheduling` - Scheduled tasks\n- `@EntityScan` - JPA entity scanning\n\n---\n\n## Quick Reference: First Files to Study\n\n1. **Entry Point:** `DarwinApplication.java`\n2. **Base Workflow:** `v2/workflow/create/Workflow.java`\n3. **Payment Attempt:** `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java`\n4. **State Machine:** `statemachine/payment/PaymentStateMachine.java`\n5. **Provider Routing:** `planner/providerdecider/ProviderDeciderRouter.java`\n6. **Config:** `application.properties` (scan first 200 lines)\n\n---\n\n## Next Steps\n\nAfter completing this overview:\n1. [ ] Explore `DarwinApplication.java`\n2. [ ] Run `./gradlew build` to ensure the project compiles\n3. [ ] Review `application.properties` structure\n4. [ ] Proceed to [02-data-layer.md](./02-data-layer.md)\n\n---\n\n*Next: [02 - Data Layer Deep-Dive](./02-data-layer.md)*\n","structuredPatch":[],"originalFile":null}}
{"type":"file-history-snapshot","messageId":"5b1db7d2-0896-47a3-8632-d963779b9979","snapshot":{"messageId":"333b6ac7-26fd-4722-980d-e319ce733bba","trackedFileBackups":{"/Users/kiranbiliyawala/.claude/plans/distributed-marinating-mango.md":{"backupFileName":"c92f53c9f6085692@v2","version":2,"backupTime":"2025-12-31T09:58:40.829Z"},"docs/study-guide/README.md":{"backupFileName":"3fd18aad0b0250d2@v1","version":1,"backupTime":"2025-12-31T10:00:15.742Z"},"docs/study-guide/01-overview.md":{"backupFileName":"676b1c94834531cf@v1","version":1,"backupTime":"2025-12-31T10:02:50.120Z"},"docs/study-guide/02-data-layer.md":{"backupFileName":"bc4de0d863c98472@v1","version":1,"backupTime":"2025-12-31T10:02:50.268Z"}},"timestamp":"2025-12-31T09:58:40.824Z"},"isSnapshotUpdate":true}
{"parentUuid":"e68b0729-0f34-4379-a269-83ded4b0f95d","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01ViKbeFd9T39zgx5kLLeMTP","type":"tool_result","content":"File created successfully at: /Users/kiranbiliyawala/code/cred/payments/payment-service/docs/study-guide/02-data-layer.md"}]},"uuid":"f0e75aaa-0043-4558-8004-d7fb5d256116","timestamp":"2025-12-31T10:02:50.253Z","toolUseResult":{"type":"create","filePath":"/Users/kiranbiliyawala/code/cred/payments/payment-service/docs/study-guide/02-data-layer.md","content":"# 02 - Data Layer Deep-Dive\n\n> **Reading Time:** 60 minutes\n> **Prerequisites:** [01-overview.md](./01-overview.md)\n> **Next:** [03-provider-integration.md](./03-provider-integration.md)\n\n---\n\n## Table of Contents\n1. [Entity Hierarchy](#entity-hierarchy)\n2. [Master-Replica Architecture](#master-replica-architecture)\n3. [Repository Patterns](#repository-patterns)\n4. [JSON Columns & Converters](#json-columns--converters)\n5. [Caching Architecture](#caching-architecture)\n6. [DynamoDB Usage](#dynamodb-usage)\n7. [Optimistic Locking & Audit](#optimistic-locking--audit)\n\n---\n\n## Entity Hierarchy\n\n### Base Classes\n\n```\nBaseEntity\n    │\n    ├── id (Long, auto-generated)\n    ├── created_at (LocalDateTime)\n    ├── updated_at (LocalDateTime)\n    ├── created_by (String)\n    └── updated_by (String)\n            │\n            └── BaseExternalEntity\n                    │\n                    ├── external_id (UUID String)\n                    └── version (Integer, optimistic locking)\n```\n\n### BaseEntity\n**File:** `entity/commons/BaseEntity.java`\n\n```java\n@Getter @Setter\n@MappedSuperclass\npublic class BaseEntity {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @CreationTimestamp\n    @Column(name = \"created_at\")\n    private LocalDateTime createAt = LocalDateTime.now();\n\n    @UpdateTimestamp\n    @Column(name = \"updated_at\")\n    private LocalDateTime updatedAt = LocalDateTime.now();\n\n    @Column(name = \"created_by\")\n    private String createdBy;\n\n    @Column(name = \"updated_by\")\n    private String updatedBy;\n\n    @PrePersist\n    public void onCreate() {\n        createdBy = ApplicationContext.getApplicationName();\n    }\n\n    @PreUpdate\n    public void onUpdate() {\n        updatedBy = ApplicationContext.getApplicationName();\n    }\n}\n```\n\n### BaseExternalEntity\n**File:** `entity/provider/BaseExternalEntity.java`\n\n```java\n@MappedSuperclass\npublic class BaseExternalEntity extends BaseEntity {\n    @Column(name = \"external_id\", length = 36)\n    private String externalId;\n\n    @Version\n    @Column(name = \"version\")\n    private Integer version;\n\n    @PrePersist\n    public void onCreate() {\n        super.onCreate();\n        externalId = UUID.randomUUID().toString();\n    }\n}\n```\n\n### Entity Inheritance Diagram\n\n```\nBaseEntity\n    │\n    └── BaseExternalEntity\n            │\n            ├── OrderEntity\n            ├── PaymentV2Entity\n            ├── PaymentAttemptV2Entity\n            ├── RefundEntity\n            ├── RefundAttemptEntity\n            ├── FeeEntity\n            ├── ClientEntity\n            ├── CustomerEntity\n            ├── PaymentProviderEntity\n            └── ClientRefundRequestEntity\n```\n\n---\n\n## Core Entities\n\n### OrderEntity\n**File:** `entity/OrderEntity.java`\n\n```java\n@Entity @Table(name = \"orders\")\npublic class OrderEntity extends BaseExternalEntity {\n    @Column(name = \"client_reference_id\")\n    private String clientReferenceId;\n\n    @Column(name = \"amount\")\n    private BigDecimal amount;\n\n    @Column(name = \"intent_amount\")\n    private BigDecimal intentAmount;\n\n    @Enumerated(EnumType.STRING)\n    private OrderType type;\n\n    @Enumerated(EnumType.STRING)\n    private OrderStatus status;\n\n    @ManyToOne\n    @JoinColumn(name = \"client_id\")\n    private ClientEntity clientEntity;\n\n    @ManyToOne(fetch = FetchType.EAGER)\n    @JoinColumn(name = \"customer_id\")\n    private CustomerEntity customerEntity;\n\n    @Convert(converter = ObjectMetadataMapConverter.class)\n    private Map<String, String> metaData;\n\n    @OneToMany(cascade = {CascadeType.MERGE, CascadeType.PERSIST})\n    @JoinColumn(name = \"order_id\")\n    private Set<OrderAttributeEntity> attributeEntities;\n\n    @OneToOne(fetch = FetchType.LAZY, mappedBy = \"orderEntity\")\n    private OrderUdfEntity orderUdfEntity;\n}\n```\n\n### PaymentV2Entity\n**File:** `entity/v2/PaymentV2Entity.java`\n\n```java\n@Entity @Table(name = \"payments\")\n@Inheritance(strategy = InheritanceType.JOINED)\npublic class PaymentV2Entity extends BaseExternalEntity {\n    @ManyToOne\n    @JoinColumn(name = \"order_id\")\n    private OrderEntity orderEntity;\n\n    private BigDecimal amount;\n\n    @Enumerated(EnumType.STRING)\n    private PaymentStatus status;\n\n    @Enumerated(EnumType.STRING)\n    private PaymentMode paymentMode;\n\n    @Enumerated(EnumType.STRING)\n    private CurrencyName currency;\n\n    private BigDecimal conversionRate;\n    private BigDecimal currencyValue;\n    private String clientReferenceId;\n\n    @Convert(converter = PaymentInstrumentConverter.class)\n    private PaymentInstrument instrumentDetail;\n\n    @Convert(converter = PaymentSpecificDetailConverter.class)\n    private PaymentSpecificDetail paymentSpecificDetail;\n}\n```\n\n### PaymentAttemptV2Entity\n**File:** `entity/v2/PaymentAttemptV2Entity.java`\n\n```java\n@Entity @Table(name = \"payment_attempts\")\n@Inheritance(strategy = InheritanceType.JOINED)\npublic class PaymentAttemptV2Entity extends BaseExternalEntity {\n    // Duplicate column for direct queries without JOIN\n    @Column(name = \"order_id\")\n    private Long orderId;\n\n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"order_id\", updatable = false, insertable = false)\n    private OrderEntity orderEntity;\n\n    @ManyToOne\n    @JoinColumn(name = \"payment_id\")\n    private PaymentV2Entity paymentEntity;\n\n    @ManyToOne\n    @JoinColumn(name = \"payment_provider_id\")\n    private PaymentProviderEntity paymentProviderEntity;\n\n    @ManyToOne\n    @JoinColumn(name = \"provider_account_id\")\n    private ProviderAccountEntity providerAccountEntity;\n\n    private String providerReferenceId;\n    private String gatewayReferenceId;\n\n    @Enumerated(EnumType.STRING)\n    private PaymentInstrumentGroup paymentMethod;\n\n    @Enumerated(EnumType.STRING)\n    private PaymentAttemptStatus status;\n\n    private String errorCode;\n    private String errorMessage;\n    private String providerStatus;\n\n    @Convert(converter = EnrichedPaymentInstrumentConverter.class)\n    private EnrichedPaymentInstrument instrumentDetail;\n\n    @Convert(converter = RoutesBreakupConverter.class)\n    private RoutesBreakup routesBreakup;\n\n    @OneToMany(cascade = {CascadeType.MERGE, CascadeType.PERSIST})\n    @JoinColumn(name = \"payment_attempt_id\")\n    private Set<PaymentAttemptAttributeEntity> attributeEntities;\n\n    @PrePersist\n    public void onCreate() {\n        super.onCreate();\n        if (StringUtils.isEmpty(externalId)) {\n            externalId = PaymentAttemptUUIdGenerator.generate();\n        }\n    }\n}\n```\n\n### Entity Relationships Diagram\n\n```\nClientEntity (1) ────────────────> (M) OrderEntity\n                                        │\nCustomerEntity (1) ─────────────────────┤\n                                        │\n                                        │ (1)\n                                        │\n                                        ▼ (M)\n                                   PaymentV2Entity\n                                        │\n                                        │ (1)\n                                        │\n                                        ▼ (M)\n                               PaymentAttemptV2Entity\n                                        │\n        ┌───────────────────────────────┼───────────────────────────────┐\n        │                               │                               │\n        ▼                               ▼                               ▼\nPaymentProviderEntity          ProviderAccountEntity              RefundEntity\n                                                                        │\n                                                                        ▼ (M)\n                                                                 RefundAttemptEntity\n```\n\n---\n\n## Master-Replica Architecture\n\n### Configuration Files\n\n**Master:** `configuration/database/MasterDataSourceConfiguration.java`\n**Replica:** `configuration/database/ReplicaDataSourceConfiguration.java`\n**Annotation:** `configuration/database/annotation/ReplicaRepository.java`\n\n### How Routing Works\n\n```java\n// Master Configuration - EXCLUDES @ReplicaRepository\n@EnableJpaRepositories(\n    basePackages = {REPO_PATH, DAO_PATH},\n    excludeFilters = @ComponentScan.Filter(ReplicaRepository.class),\n    entityManagerFactoryRef = MASTER_ENTITY_MANAGER_FACTORY,\n    transactionManagerRef = MASTER_TRANSACTION_MANAGER\n)\n\n// Replica Configuration - INCLUDES ONLY @ReplicaRepository\n@EnableJpaRepositories(\n    basePackages = {REPO_PATH, DAO_PATH},\n    includeFilters = @ComponentScan.Filter(ReplicaRepository.class),\n    entityManagerFactoryRef = REPLICA_ENTITY_MANAGER_FACTORY,\n    transactionManagerRef = REPLICA_TRANSACTION_MANAGER\n)\n```\n\n### Usage Pattern\n\n```java\n// Default - writes to Master\n@Repository\npublic interface PaymentRepository extends JpaRepository<PaymentV2Entity, Long> {\n    // Uses MasterEntityManager\n}\n\n// Explicit Replica - reads from Replica\n@Repository\n@ReplicaRepository\npublic class RefundEntityReplicaDAOImpl extends AbstractReplicaDAOImpl<RefundEntity, Long> {\n    // Uses ReplicaEntityManager\n}\n```\n\n### HikariCP Pool Configuration\n\n| Pool | Setting | Purpose |\n|------|---------|---------|\n| **hikari_master** | `masterMinimumIdle`, `masterMaximumPoolSize` | Write operations |\n| **hikari_replica** | `replicaMinimumIdle`, `replicaMaximumPoolSize`, `readOnly=true` | Read operations |\n\n**Common Settings:**\n- `idleTimeout` - Close idle connections\n- `connectionTimeout` - Wait for connection\n- `maxLifetime` - Recycle connections\n- `leakDetectionThreshold` - Detect connection leaks\n\n### HikariCP Configuration Example\n\n```java\nHikariConfig hikariConfig = new HikariConfig();\nhikariConfig.setIdleTimeout(hikariIdleTimeout);\nhikariConfig.setConnectionTimeout(hikariConnectionTimeout);\nhikariConfig.setMinimumIdle(masterMinimumIdle);\nhikariConfig.setMaximumPoolSize(masterMaximumPoolSize);\nhikariConfig.setMaxLifetime(maxLifeTime);\nhikariConfig.setPoolName(\"hikari_master\");\nhikariConfig.setLeakDetectionThreshold(leakDetectionThreshold);\nhikariConfig.setJdbcUrl(url);\n```\n\n---\n\n## Repository Patterns\n\n### JPA Repository Pattern\n\n```java\n@Repository\npublic interface OrderRepository extends JpaRepository<OrderEntity, Long> {\n\n    // FETCH JOIN to prevent N+1 queries\n    @Query(\"SELECT o FROM OrderEntity o \"\n            + \"JOIN FETCH o.customerEntity \"\n            + \"JOIN FETCH o.clientEntity \"\n            + \"LEFT JOIN FETCH o.orderUdfEntity \"\n            + \"WHERE o.externalId = :externalId\")\n    Optional<OrderEntity> findByExternalId(@Param(\"externalId\") String externalId);\n\n    // Property path navigation\n    Optional<OrderEntity> findByClientReferenceIdAndClientEntity_ExternalId(\n            String clientReferenceId, String externalId);\n\n    // List by tag\n    List<OrderEntity> findByTagId(String tagId);\n}\n```\n\n### DAO Pattern (Custom EntityManager)\n\n```java\n@Repository\npublic class PaymentAttemptDAOV2Impl {\n    @PersistenceContext\n    private EntityManager entityManager;\n\n    public List<PaymentAttemptV2Entity> findByOrderIdWithFetchJoin(Long orderId) {\n        return entityManager.createQuery(\n            \"SELECT pa FROM PaymentAttemptV2Entity pa \"\n            + \"JOIN FETCH pa.paymentEntity \"\n            + \"JOIN FETCH pa.paymentProviderEntity \"\n            + \"WHERE pa.orderId = :orderId\",\n            PaymentAttemptV2Entity.class)\n            .setParameter(\"orderId\", orderId)\n            .getResultList();\n    }\n}\n```\n\n### Key Repository Methods\n\n| Repository | Key Methods |\n|------------|-------------|\n| `OrderRepository` | `findByExternalId`, `findByClientReferenceIdAndClientEntity_ExternalId` |\n| `PaymentRepository` | `findByExternalId`, `findByOrderEntity_ExternalId` |\n| `PaymentAttemptRepository` | `findByExternalId`, `findByProviderReferenceId` |\n| `RefundRepository` | `findByOrderEntity_Id`, `findByClientRefundRequestEntity_Id` |\n\n---\n\n## JSON Columns & Converters\n\n### Converter Pattern\n\n```java\n@Column(name = \"metadata\")\n@Convert(converter = ObjectMetadataMapConverter.class)\nprivate Map<String, String> metaData;\n```\n\n### Available Converters\n\n| Column | Converter | Entity | Java Type |\n|--------|-----------|--------|-----------|\n| `metadata` | `ObjectMetadataMapConverter` | OrderEntity | `Map<String, String>` |\n| `instrument_detail` | `PaymentInstrumentConverter` | PaymentV2Entity | `PaymentInstrument` |\n| `instrument_detail` | `EnrichedPaymentInstrumentConverter` | PaymentAttemptV2Entity | `EnrichedPaymentInstrument` |\n| `payment_specific_detail` | `PaymentSpecificDetailConverter` | PaymentV2Entity | `PaymentSpecificDetail` |\n| `routes` | `RoutesBreakupConverter` | PaymentAttemptV2Entity | `RoutesBreakup` |\n| `additional_info` | `ClientRefundAdditionalInfoConverter` | ClientRefundRequestEntity | `ClientRefundAdditionalInfo` |\n\n---\n\n## Caching Architecture\n\n### Caffeine Caches\n\n| Cache Class | What It Caches | TTL | Max Size |\n|-------------|----------------|-----|----------|\n| `ClientConfigurationCache` | Client settings by ID/externalId/merchantId | 10-20 min | - |\n| `PaymentProviderCache` | Provider configurations | 15-25 min | - |\n| `ProviderAccountCache` | Provider account entities | 15-25 min | - |\n| `DecisionTreeObjectCache` | Decision tree JSON + workflow | 180-190 min | - |\n| `FeeCache` | Fee configurations by feeId | 1 day | 500 |\n| `CardBinCache` | Card BIN details by hash | Configurable | - |\n| `MasterConfigurationCache` | Feature flags, system settings | 10-20 min | - |\n| `PaymentErrorMessageMappingCache` | Error code to message | Long | - |\n| `NativeOTPSupportedProviderCache` | OTP-capable providers | - | - |\n\n### Cache Implementation Pattern\n\n```java\n@Component\npublic class ClientConfigurationCache extends AbstractDPManagedCache {\n\n    @DPCache(cacheName = \"client_configuration_cache\")\n    private LoadingCache<Long, Map<ClientSettingKey, String>> idCache;\n\n    @Override\n    public void buildCache() {\n        idCache = DPCacheBuilder.getBuilder()\n            .refreshAfterWrite(\n                generateRandomCacheRefreshInterval(10), // 10-20 min jitter\n                TimeUnit.MINUTES)\n            .build(this::loadClientSettings);\n    }\n\n    private Map<ClientSettingKey, String> loadClientSettings(Long clientId) {\n        ClientEntity client = clientRepository.findById(clientId)\n            .orElseThrow(() -> Error.invalid_client_id.getBuilder().build());\n        return client.getSettings().stream()\n            .collect(Collectors.toMap(\n                ClientSettingsEntity::getSettingKey,\n                ClientSettingsEntity::getSettingValue));\n    }\n}\n```\n\n### Jittered TTLs (Thundering Herd Prevention)\n\n```java\nprivate Long generateRandomCacheRefreshInterval(int base) {\n    SecureRandom random = new SecureRandom();\n    return Long.valueOf(base + random.nextInt(10) + 1);\n}\n// base=10 → returns 11-20\n// base=15 → returns 16-25\n```\n\n---\n\n## DynamoDB Usage\n\n### What Goes Where\n\n| MySQL (Relational) | DynamoDB (NoSQL) |\n|--------------------|------------------|\n| Orders, Payments, Attempts | Workflow context (TTL-based) |\n| Refunds, Fees | Native OTP details |\n| Clients, Customers | Redirect tracking |\n| Provider configs | Metadata audit trails |\n\n### DynamoDB Tables\n\n| Table | Hash Key | Sort Key | TTL | Purpose |\n|-------|----------|----------|-----|---------|\n| `darwin_payment_attempt_workflow_context` | payment_attempt_external_id | workflow_step | 1 day | Workflow state |\n| `darwin_payment_attempt_native_otp_detail` | payment_attempt_external_id | - | 1 day | OTP auth |\n| `darwin_payment_attempt_redirection_detail` | payment_attempt_external_id | - | 1 day | 3DS redirects |\n| `darwin_payment_attempt_metadata_audit` | payment_attempt_external_id | - | - | Audit trail |\n\n### DynamoDB Entity Example\n\n```java\n@Data @Builder\n@DynamoDBTable(tableName = \"darwin_payment_attempt_workflow_context\")\npublic class PaymentAttemptWorkflowContextEntity {\n\n    @DynamoDBHashKey(attributeName = \"payment_attempt_external_id\")\n    private String paymentAttemptExternalId;\n\n    @DynamoDBRangeKey\n    @DynamoDBAttribute(attributeName = \"workflow_step\")\n    private WorkflowStep workflowStep;\n\n    @Builder.Default\n    private long ttl = LocalDateTime.now()\n        .plusDays(1)\n        .toEpochSecond(ZoneOffset.UTC);\n\n    @DynamoDBAttribute(attributeName = \"data\")\n    private String data;\n\n    @DynamoDBTypeConverted(converter = LocalDateTimeConverter.class)\n    @DynamoDBAttribute(attributeName = \"event_at\")\n    private LocalDateTime eventAt;\n}\n```\n\n### DynamoDB DAO Pattern\n\n```java\n@RequiredArgsConstructor\npublic abstract class AbstractDynamoDBDAO<T> {\n    private final Class<T> tClass;\n    private final DynamoDBMapper dynamoDBMapper;\n\n    public void save(T entity) {\n        dynamoDBMapper.save(entity);\n    }\n\n    public void saveIfNotExists(T entity, List<String> uniqueKeys) {\n        DynamoDBSaveExpression saveExpression = new DynamoDBSaveExpression();\n        Map<String, ExpectedAttributeValue> expected = new HashMap<>();\n        uniqueKeys.forEach(key ->\n            expected.put(key, new ExpectedAttributeValue().withExists(false)));\n        saveExpression.setExpected(expected);\n        dynamoDBMapper.save(entity, saveExpression);\n    }\n\n    public T findByHashKey(Object hashKey) {\n        return dynamoDBMapper.load(tClass, hashKey);\n    }\n}\n```\n\n---\n\n## Optimistic Locking & Audit\n\n### @Version for Optimistic Locking\n\n```java\n@Version\n@Column(name = \"version\")\nprivate Integer version;\n```\n\n**Behavior:**\n- Hibernate auto-increments on each update\n- Throws `OptimisticLockException` on concurrent modification\n- Prevents lost updates in concurrent scenarios\n\n### Audit Columns\n\n```java\n@CreationTimestamp\n@Column(name = \"created_at\")\nprivate LocalDateTime createAt;\n\n@UpdateTimestamp\n@Column(name = \"updated_at\")\nprivate LocalDateTime updatedAt;\n\n@PrePersist\npublic void onCreate() {\n    createdBy = ApplicationContext.getApplicationName();\n}\n\n@PreUpdate\npublic void onUpdate() {\n    updatedBy = ApplicationContext.getApplicationName();\n}\n```\n\n### Soft Delete Pattern\n\nSome entities use soft delete:\n\n```java\n@Column(name = \"is_deleted\")\nprivate Boolean deleted = Boolean.FALSE;\n```\n\nUsed in: `ClientEntity`, `CustomerEntity`\n\n---\n\n## Data Layer Architecture Diagram\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                     Service Layer                            │\n├─────────────────────────────────────────────────────────────┤\n│  JPA Repositories    │  Custom DAOs    │  DynamoDB DAOs     │\n├─────────────────────────────────────────────────────────────┤\n│            Spring Data JPA + Hibernate ORM                   │\n├────────────────────────┬────────────────────────────────────┤\n│   Master DataSource    │      Replica DataSource            │\n│   (Writes)             │      (Reads - @ReplicaRepository)  │\n├────────────────────────┼────────────────────────────────────┤\n│  HikariCP Master Pool  │    HikariCP Replica Pool           │\n├────────────────────────┴────────────────────────────────────┤\n│              MySQL (payments_multi_tenancy)                  │\n└─────────────────────────────────────────────────────────────┘\n          │                                    │\n┌─────────▼─────────┐              ┌───────────▼───────────┐\n│     DynamoDB      │              │   Caffeine Caches     │\n│  (Workflow/Audit) │              │  (Client/Provider)    │\n└───────────────────┘              └───────────────────────┘\n```\n\n---\n\n## Key Files to Study\n\n### Entity Classes\n1. `entity/commons/BaseEntity.java`\n2. `entity/provider/BaseExternalEntity.java`\n3. `entity/OrderEntity.java`\n4. `entity/v2/PaymentAttemptV2Entity.java`\n\n### Database Configuration\n1. `configuration/database/MasterDataSourceConfiguration.java`\n2. `configuration/database/ReplicaDataSourceConfiguration.java`\n3. `configuration/database/annotation/ReplicaRepository.java`\n\n### Repositories\n1. `repository/OrderRepository.java`\n2. `repository/PaymentAttemptRepository.java`\n\n### Caches\n1. `cache/ClientConfigurationCache.java`\n2. `configuration/CacheConfig.java`\n\n### DynamoDB\n1. `dynamo/dao/AbstractDynamoDBDAO.java`\n2. `dynamo/domain/PaymentAttemptWorkflowContextEntity.java`\n\n---\n\n## Checkpoint\n\nAfter completing this section:\n- [ ] Understand entity hierarchy (BaseEntity → BaseExternalEntity)\n- [ ] Know how Master-Replica routing works\n- [ ] Understand caching patterns with jittered TTLs\n- [ ] Know when to use MySQL vs DynamoDB\n- [ ] Proceed to [03-provider-integration.md](./03-provider-integration.md)\n\n---\n\n*Next: [03 - Provider Integration](./03-provider-integration.md)*\n","structuredPatch":[],"originalFile":null}}
{"parentUuid":null,"logicalParentUuid":"f0e75aaa-0043-4558-8004-d7fb5d256116","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","type":"system","subtype":"compact_boundary","content":"Conversation compacted","isMeta":false,"timestamp":"2025-12-31T10:03:32.777Z","uuid":"2d0211c6-17ba-46c4-b1a6-91ad31ddea2a","level":"info","compactMetadata":{"trigger":"auto","preTokens":155597}}
{"parentUuid":"2d0211c6-17ba-46c4-b1a6-91ad31ddea2a","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","type":"user","message":{"role":"user","content":"This session is being continued from a previous conversation that ran out of context. The conversation is summarized below:\nAnalysis:\nLet me analyze the conversation chronologically to capture all important details:\n\n1. **Initial Request**: User asked for help understanding the payment-service repository step by step as a deep study to become an expert.\n\n2. **Phase 1 - Initial Exploration**: I launched 3 parallel exploration agents to analyze:\n   - Overall architecture and structure\n   - Core payment logic and business flows\n   - Data layer and integrations\n\n3. **Exploration Results**: The agents returned comprehensive information about:\n   - Project structure (Java 17, Spring Boot 2.7.14, MySQL Master-Replica, DynamoDB, Redis, Kafka)\n   - Core payment flows (Order → Payment → PaymentAttempt → Provider)\n   - 24+ payment provider integrations\n   - State machine architecture\n   - Caching patterns\n   - Database architecture\n\n4. **Plan File Created**: I created a comprehensive study guide at `/Users/kiranbiliyawala/.claude/plans/distributed-marinating-mango.md`\n\n5. **User Selected Deep-Dives**:\n   - First choice: \"Data Layer\" - I explored and documented entities, repositories, caching, DynamoDB\n   - Second choice: \"Provider Integration\" - I explored provider adapters, decision tree routing, webhooks\n   - Third choice: \"Payment Flow\" - I explored workflows, state machines, end-to-end flows\n\n6. **Documentation Created**: The plan file grew to 42 comprehensive sections covering all aspects of the codebase.\n\n7. **Final Request**: User asked to \"document everything - whole analysis, study materials, and plan\" so they can resume across multiple sessions, creating multiple documents/directories as needed.\n\n8. **Documentation Structure Started**: I began creating a structured documentation in:\n   `/Users/kiranbiliyawala/code/cred/payments/payment-service/docs/study-guide/`\n   - Created README.md (main entry point)\n   - Created 01-overview.md (tech stack, project structure)\n   - Created 02-data-layer.md (entities, database, caching)\n   - Still need to create: 03-provider-integration.md, 04-payment-flow.md, 05-key-files-reference.md, 06-study-path.md\n\nKey technical details discovered:\n- Payment service is called \"Darwin\" internally\n- Uses 7-step workflow pipeline pattern\n- Guava EventBus for state machine events\n- Master-Replica DB routing via @ReplicaRepository annotation\n- Caffeine caching with jittered TTLs\n- DynamoDB for workflow state and OTP details\n- Decision tree routing for provider selection\n- 24+ provider adapters (Cashfree, Cybersource, PayU, Razorpay, etc.)\n\nThe current work was interrupted while creating the documentation files. I had created README.md, 01-overview.md, and 02-data-layer.md but still needed to create 03-provider-integration.md, 04-payment-flow.md, 05-key-files-reference.md, and 06-study-path.md.\n\nSummary:\n1. Primary Request and Intent:\n   The user requested help understanding the payment-service repository step by step as a \"deep study to become an expert.\" They wanted comprehensive documentation covering all aspects of the codebase. After the initial exploration and creation of a study guide, the user explicitly requested: \"let's document the everything - whole analysis, study materials, and plan. so that we can resume this over multiple days/sessions. if required create multiple documents, directories etc\"\n\n2. Key Technical Concepts:\n   - **Tech Stack**: Java 17, Spring Boot 2.7.14, Gradle 7.6, MySQL (Master-Replica), DynamoDB, Redis (Redisson 3.19.1), Kafka, AWS SQS\n   - **Project Name**: Darwin (internal name for payment-service)\n   - **Server Config**: Port 9010, Context Path: `/payments`\n   - **7-Step Workflow Pipeline**: validateAndEnrichContext → persistIntent → publishEntityPrePersistEvents → persistNonRelationalIntent → process → postProcess → publishEntityChangeEvents\n   - **State Machines**: PaymentStateMachine, OrderStateMachine, RefundStateMachine using Guava EventBus\n   - **Entity Hierarchy**: BaseEntity → BaseExternalEntity → (OrderEntity, PaymentV2Entity, PaymentAttemptV2Entity, etc.)\n   - **Master-Replica DB Routing**: @ReplicaRepository annotation for read operations\n   - **Caching**: Caffeine in-memory caches with jittered TTLs (thundering herd prevention)\n   - **Provider Routing**: Decision Tree + LCM (Lending Cloud Manager) via ProviderDeciderRouter\n   - **24+ Provider Adapters**: Cashfree, Cybersource, PayU, Razorpay, Juspay, ICICI UPI, Axis UPI, YBL UPI, RBL UPI, Digio, etc.\n   - **Optimistic Locking**: @Version annotation on BaseExternalEntity\n\n3. Files and Code Sections:\n   - **Plan File**: `/Users/kiranbiliyawala/.claude/plans/distributed-marinating-mango.md`\n     - Complete 42-section expert study guide covering all aspects of the codebase\n     - Contains architecture diagrams, code patterns, file references\n   \n   - **Documentation Directory Created**: `/Users/kiranbiliyawala/code/cred/payments/payment-service/docs/study-guide/`\n   \n   - **README.md** (created):\n     - Main entry point with navigation, architecture diagram, quick reference\n     - Contains checkpoint markers for resume points\n   \n   - **01-overview.md** (created):\n     - Tech stack, project structure, core concepts\n     - API endpoints, authentication, service dependencies\n     - Entry point: `DarwinApplication.java`\n   \n   - **02-data-layer.md** (created):\n     - Entity hierarchy, Master-Replica architecture\n     - Repository patterns, JSON converters, caching, DynamoDB usage\n   \n   - **Key source files identified**:\n     - `DarwinApplication.java` - Entry point\n     - `v2/workflow/create/Workflow.java` - Base workflow pattern\n     - `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java` - Core payment flow\n     - `statemachine/payment/PaymentStateMachine.java` - Payment state management\n     - `planner/providerdecider/ProviderDeciderRouter.java` - Provider routing\n     - `v2/workflow/create/providers/IPaymentProviderAdapter.java` - Base adapter\n     - `entity/commons/BaseEntity.java`, `entity/provider/BaseExternalEntity.java` - Base entities\n\n4. Errors and fixes:\n   - No errors encountered during this session. The work was exploratory and documentation-focused.\n\n5. Problem Solving:\n   - Solved the challenge of comprehensively documenting a large codebase by:\n     - Using parallel exploration agents to cover different aspects\n     - Creating a structured 42-section study guide\n     - Organizing documentation into multiple files for easier navigation\n     - Adding checkpoint markers for session resumption\n\n6. All user messages:\n   - \"help me understand this repository step by step as a deep study to become the expert\" (interrupted)\n   - \"help me understand this repository step by step as a deep study to become the expert\"\n   - User selected \"Data Layer\" when asked which area to deep-dive first\n   - User selected \"Provider Integration\" for next deep-dive\n   - User selected \"Add Payment Flow\" for final deep-dive\n   - \"let's document the everything - whole analysis, study materials, and plan. so that we can resume this over multiple days/sessions. if required create multiple documents, directories etc\"\n\n7. Pending Tasks:\n   - Create `03-provider-integration.md` - Provider adapters, webhooks, decision tree routing\n   - Create `04-payment-flow.md` - Workflows, state machines, end-to-end flow\n   - Create `05-key-files-reference.md` - Quick reference for all critical files\n   - Create `06-study-path.md` - Recommended learning path with checkboxes\n\n8. Current Work:\n   Creating comprehensive documentation structure for the payment-service repository. Successfully created:\n   - Directory: `/Users/kiranbiliyawala/code/cred/payments/payment-service/docs/study-guide/`\n   - `README.md` - Main navigation and overview\n   - `01-overview.md` - Tech stack and architecture\n   - `02-data-layer.md` - Data layer deep-dive\n   \n   Was in the process of creating remaining documentation files when the summary was requested.\n\n9. Optional Next Step:\n   Continue creating the remaining documentation files per user's request: \"let's document the everything - whole analysis, study materials, and plan. so that we can resume this over multiple days/sessions.\"\n   \n   Next files to create:\n   - `03-provider-integration.md`\n   - `04-payment-flow.md`\n   - `05-key-files-reference.md`\n   - `06-study-path.md`.\nPlease continue the conversation from where we left it off without asking the user any further questions. Continue with the last task that you were asked to work on."},"isVisibleInTranscriptOnly":true,"isCompactSummary":true,"uuid":"a8eb7056-86a8-4d85-969e-b7a346810f24","timestamp":"2025-12-31T10:03:32.777Z"}
{"parentUuid":"a8eb7056-86a8-4d85-969e-b7a346810f24","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01KyvAv3ZU2CaxqbifNte8bu","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user wants me to continue creating the documentation files. I had already created:\n1. README.md\n2. 01-overview.md\n3. 02-data-layer.md\n\nI still need to create:\n1. 03-provider-integration.md\n2. 04-payment-flow.md\n3. 05-key-files-reference.md\n4. 06-study-path.md\n\nLet me continue creating these files based on the comprehensive study guide in the plan file. I'll create them in parallel since they're independent of each other.","signature":"EtQECkgICxABGAIqQOC6SNs30+HqFQTTREqe9DqV0EMFIsWQi2AjFlDFhekFG/Dnn9tbwfMtCbhAvzEalWecxIS2W5okg1hsMcdi5PcSDEJNrYYV3/2b+xwSbxoMs8/KVlzUeY+Kmz9pIjD++LHAasc245fqMkrAbbvzHA5t29aEtOCKNBxAhAVdjIkYaA2XVT003NMm1KTVX1UquQNqHbYKgvUuqsnOZds7OHBgL8kSLsZ7L1dFdgUx7porrv4BQRh7MjIfBKhi8fxchoCy4iZlVwQWhIU4zOugqTART45FD3YbBH6NL7HkhuP79wKOD+rtCelmpI/zxi9hgPJH1rgEsWDGX/d9CITeQnuPS9cJ4sQi2wvn8sURBwNS+UVKfXHeDjgJ82QMtObgjPbOJXZoeEIUXmhdZetwRC8C8ZkR/1Y4F4ZsEMDdQVe2VQq0CtP+MK8ZotxNzDMJJfIfMGP/Q91N8NlMDNmhDo8vhPIKfsmJpyN8tHwwuo3rO9dMfOGzAQV7/ZVAAXkaGCU1iATSE2JgkWq9DhgZpyc6IwYBBjdGQL0oIeiLU0cz5KtYupO7txjj+56pH0X5Ju+1mDOFbpl9O/XpLFW1RGvShGPONJzeK1V9DYYGNB9aODZviT9cH3nKQGVEKancXSaUiT8GYJ+wPXJtCQpfHBaKX1ukYeQIPnpy2DA3Tk738wqn2tB804KQuC3Sw5WbBZfqFDOm+3DsuDgiqXV6ufqNdIx7oPNXKq8jBBlfAdCvA4h0rS1tXHLonDvZHwP9rNaVONwoFrjPObsYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":36648,"cache_read_input_tokens":22528,"cache_creation":{"ephemeral_5m_input_tokens":36648,"ephemeral_1h_input_tokens":0},"output_tokens":3}},"type":"assistant","uuid":"066a8503-497b-4329-901c-7958157f886f","timestamp":"2025-12-31T10:03:39.335Z"}
{"parentUuid":"066a8503-497b-4329-901c-7958157f886f","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01KyvAv3ZU2CaxqbifNte8bu","type":"message","role":"assistant","content":[{"type":"text","text":"Continuing with the documentation. I need to create the remaining files:\n- `03-provider-integration.md`\n- `04-payment-flow.md`\n- `05-key-files-reference.md`\n- `06-study-path.md`"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":36648,"cache_read_input_tokens":22528,"cache_creation":{"ephemeral_5m_input_tokens":36648,"ephemeral_1h_input_tokens":0},"output_tokens":3}},"type":"assistant","uuid":"15c46317-a2fa-494d-a10f-b9853f105896","timestamp":"2025-12-31T10:03:40.058Z"}
{"parentUuid":"15c46317-a2fa-494d-a10f-b9853f105896","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01KyvAv3ZU2CaxqbifNte8bu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_bdrk_01Doh52dowH9yEGp7oK8pkNR","name":"Write","input":{"file_path":"/Users/kiranbiliyawala/code/cred/payments/payment-service/docs/study-guide/03-provider-integration.md","content":"# 03 - Provider Integration Deep-Dive\n\n> **Reading Time:** 75 minutes\n> **Prerequisites:** [02-data-layer.md](./02-data-layer.md)\n> **Next:** [04-payment-flow.md](./04-payment-flow.md)\n\n---\n\n## Table of Contents\n1. [Provider Adapter Architecture](#provider-adapter-architecture)\n2. [Factory Pattern for Adapter Selection](#factory-pattern-for-adapter-selection)\n3. [Decision Tree Routing](#decision-tree-routing)\n4. [Provider Implementations](#provider-implementations)\n5. [Webhook Handling](#webhook-handling)\n6. [Provider Configuration](#provider-configuration)\n7. [Error Handling & Retry Logic](#error-handling--retry-logic)\n\n---\n\n## Provider Adapter Architecture\n\n### Base Adapter Pattern\n**File:** `v2/workflow/create/providers/IPaymentProviderAdapter.java`\n\n```java\npublic abstract class IPaymentProviderAdapter<T, R> implements SelfReferencingBean {\n    protected final PaymentProviderKey paymentProviderKey;  // e.g., CASHFREE, CYBERSOURCE\n    private final InstrumentType instrumentType;            // e.g., CARD, UPI_APPS\n    private final OrderType orderType;                      // e.g., PAY, REFUND\n\n    // Core lifecycle methods\n    public abstract ProviderPaymentResponse createPaymentAttempt(context, customerEntity);\n    protected abstract Object syncPaymentAttemptWithProviderId(paymentAttemptEntity);\n    protected abstract ProviderRefundCreateResponse createRefund(refundAttemptEntity, context);\n    protected abstract R getAuthConfig(providerAccountEntity);\n}\n```\n\n### Provider Response Structure\n\n```java\n@Data @Builder\npublic class ProviderPaymentResponse {\n    private Object providerResponseObject;     // Raw provider response\n    private String providerReferenceId;        // Provider's transaction ID\n    private String gatewayReferenceId;         // Gateway ID\n    private String providerStatus;             // Raw status (\"SUCCESS\")\n    private PaymentAttemptStatus status;       // Mapped internal status\n    private ProviderRequestStatus providerRequestStatus;  // REQUEST_SUCCESS, RETRY_ABLE_FAILURE\n    private ProviderError providerError;       // Error details if failed\n}\n```\n\n### Adapter Inheritance Diagram\n\n```\nIPaymentProviderAdapter<T, R>\n    │\n    ├── CashfreeProviderAdapter\n    │       ├── CashfreeCardProviderAdapter\n    │       ├── CashfreeNetBankingProviderAdapter\n    │       ├── CashfreeUPIProviderAdapter\n    │       └── CashfreeUPIAppsProviderAdapter\n    │\n    ├── I3DSPaymentProviderAdapter\n    │       └── CybersourceProviderAdapter\n    │               ├── CybersourceCardProviderAdapter\n    │               └── CybersourceEMandateProviderAdapter\n    │\n    ├── PayuProviderAdapter\n    │       └── PayuCardProviderAdapter\n    │\n    ├── PineLabsEdgeProviderAdapter\n    │\n    ├── CredPointsProviderAdapter\n    │\n    └── AuthTokenNativeProviderAdapter\n```\n\n---\n\n## Factory Pattern for Adapter Selection\n\n### PaymentProviderFactory\n**File:** `v2/workflow/create/providers/PaymentProviderFactory.java`\n\n```java\n@Component\npublic class PaymentProviderFactory {\n    // Multi-dimensional lookup: OrderType + ProviderKey + InstrumentType → Adapter\n    private Map<PaymentWorkflowKey, IPaymentProviderAdapter<?, ?>> paymentProviderMap;\n\n    // Secondary lookup: OrderType + ProviderKey → First adapter\n    private Table<OrderType, PaymentProviderKey, IPaymentProviderAdapter<?, ?>> paymentProviderByKey;\n\n    // 3DS variant support\n    private ThreeDSType threeDSType;  // 3DS1 vs 3DS2\n\n    public IPaymentProviderAdapter<?, ?> findPaymentProviderAdapter(\n            OrderType orderType,\n            PaymentProviderKey providerKey,\n            InstrumentType instrumentType,\n            ThreeDSType threeDSType) {\n\n        PaymentWorkflowKey key = new PaymentWorkflowKey(\n            orderType, providerKey, instrumentType, threeDSType);\n\n        return paymentProviderMap.get(key);\n    }\n}\n```\n\n### PaymentWorkflowKey Structure\n\n```java\n@Value\npublic class PaymentWorkflowKey {\n    OrderType orderType;           // PAY, REFUND\n    PaymentProviderKey providerKey; // CASHFREE, CYBERSOURCE, etc.\n    InstrumentType instrumentType;  // CARD, UPI_APPS, NET_BANKING\n    ThreeDSType threeDSType;        // THREE_DS_1, THREE_DS_2, NONE\n}\n```\n\n---\n\n## Decision Tree Routing\n\n### Router Strategy Pattern\n**File:** `planner/providerdecider/ProviderDeciderRouter.java`\n\n```java\n@Service\npublic class ProviderDeciderRouter {\n    public ProviderRoutingDecisionResult resolve(PaymentAttemptCreateContext context) {\n        // Priority 1: LCM routing (if instrument supported)\n        if (isInstrumentTypeSupportedInLCM(clientId, instrumentType)) {\n            return providerDeciderViaLCM.decideProvider(context);\n        }\n\n        // Priority 2: Decision Tree routing\n        if (isDecisionTreeEnabled) {\n            return providerDeciderV2.decideProvider(context);\n        }\n\n        throw Error.provider_routing_failed.getBuilder().build();\n    }\n}\n```\n\n### Routing Flow Diagram\n\n```\nRequest\n    │\n    ▼\n┌─────────────────────────────┐\n│   ProviderDeciderRouter     │\n└─────────────────────────────┘\n    │\n    ├── Is LCM supported for instrument?\n    │       │\n    │       YES ──► ProviderDeciderViaLCM\n    │                   │\n    │                   └── Call LCM service for terminal resolution\n    │\n    NO\n    │\n    ▼\n┌─────────────────────────────┐\n│   ProviderDeciderV2         │\n│   (Decision Tree Routing)   │\n└─────────────────────────────┘\n    │\n    ├── Fetch cached Decision Tree\n    ├── Build DT Context from request\n    ├── Execute tree rules\n    ├── Apply dynamic routing (Narad)\n    │\n    ▼\n┌─────────────────────────────┐\n│  ProviderRoutingDecisionResult │\n│  ├── providerKey             │\n│  ├── providerAccountEntity   │\n│  ├── decisionTreeId          │\n│  └── routingMetadata         │\n└─────────────────────────────┘\n```\n\n### Decision Tree Caching\n**File:** `cache/DecisionTreeObjectCache.java`\n\n```java\n@Component\npublic class DecisionTreeObjectCache extends AbstractDPManagedCache {\n\n    @DPCache(cacheName = \"decision_tree_object_cache\")\n    private LoadingCache<Long, DecisionTreeWithWorkflow> cache;\n\n    @Override\n    public void buildCache() {\n        cache = DPCacheBuilder.getBuilder()\n            .refreshAfterWrite(\n                generateRandomCacheRefreshInterval(180),  // 180-190 min\n                TimeUnit.MINUTES)\n            .build(this::loadDecisionTree);\n    }\n\n    private DecisionTreeWithWorkflow loadDecisionTree(Long treeId) {\n        // Load JSON, parse rules, build workflow\n    }\n}\n```\n\n### Decision Tree Factors\n\n| Factor | Description |\n|--------|-------------|\n| Client ID | Which merchant/client |\n| Instrument Type | Card, UPI, NetBanking |\n| Card Brand | Visa, Mastercard, RuPay |\n| Card BIN | First 6-8 digits |\n| Card Type | Credit, Debit |\n| Amount | Transaction amount |\n| Currency | INR, USD |\n| Customer Attributes | VIP, risk score |\n| Provider Health | Uptime, success rate |\n\n---\n\n## Provider Implementations\n\n### Directory Structure\n\n```\nv2/workflow/create/providers/\n├── IPaymentProviderAdapter.java          # Base abstract class\n├── I3DSPaymentProviderAdapter.java       # 3DS base class\n├── PaymentProviderFactory.java           # Factory\n│\n├── CashfreeProviderAdapter.java          # Cashfree base\n├── CashfreeCardProviderAdapter.java\n├── CashfreeNetBankingProviderAdapter.java\n├── CashfreeUPIProviderAdapter.java\n├── CashfreeUPIAppsProviderAdapter.java\n│\n├── cybersource/\n│   ├── CybersourceProviderAdapter.java   # Cybersource base (3DS)\n│   ├── CybersourceRequestBuilder.java\n│   └── CybersourceAuthorizeRequestBuilder.java\n│\n├── PayuProviderAdapter.java\n├── PayuCardProviderAdapter.java\n│\n├── PineLabsEdgeProviderAdapter.java\n├── CredPointsProviderAdapter.java\n├── RewardPointsProviderAdapter.java\n└── AuthTokenNativeProviderAdapter.java\n```\n\n### Supported Providers\n\n| Provider | Payment Types | Key Features |\n|----------|---------------|--------------|\n| **Cashfree** | Cards, UPI, NetBanking | Two-phase order+payment |\n| **Cybersource** | Cards, 3DS, E-Mandates | 3DS1/3DS2, step-up auth |\n| **PayU** | Cards, NetBanking | Hash-based auth |\n| **Pine Labs** | Multiple modes | Edge integration |\n| **Razorpay** | All types | Via webhooks |\n| **Juspay** | Orchestration | Gateway aggregator |\n| **ICICI UPI** | UPI | Direct bank integration |\n| **Axis UPI** | UPI | Direct bank integration |\n| **YBL UPI** | UPI | Yes Bank |\n| **RBL UPI** | UPI | RBL Bank |\n| **Digio** | E-Mandates | eNACH registration |\n| **Cred Points** | Rewards | Point redemption |\n\n### Cashfree Adapter Example\n**File:** `v2/workflow/create/providers/CashfreeProviderAdapter.java`\n\n```java\n@Component\npublic abstract class CashfreeProviderAdapter\n        extends IPaymentProviderAdapter<String, CashfreeAuthConfig> {\n\n    @Override\n    public ProviderPaymentResponse createPaymentAttempt(\n            PaymentAttemptCreateContext context,\n            CustomerEntity customer) {\n\n        CashfreeAuthConfig authConfig = getAuthConfig(context.getProviderAccountEntity());\n\n        // Phase 1: Create Cashfree Order\n        Pair<BaseResponse<CreateOrderResponse>, ProviderError> orderResponse =\n            createCFOrder(context, authConfig);\n\n        if (orderResponse.getRight() != null) {\n            return buildErrorResponse(orderResponse.getRight());\n        }\n\n        // Phase 2: Create Cashfree Payment\n        Pair<BaseResponse<CreatePaymentResponse>, ProviderError> paymentResponse =\n            createCFPayment(context, orderResponse.getLeft().getResponse(), authConfig);\n\n        return mapToProviderPaymentResponse(paymentResponse);\n    }\n\n    protected abstract Pair<BaseResponse<CreatePaymentResponse>, ProviderError>\n        createCFPayment(context, orderResponse, authConfig);\n}\n```\n\n### Cybersource Adapter (3DS Support)\n**File:** `v2/workflow/create/providers/cybersource/CybersourceProviderAdapter.java`\n\n```java\n@Component\npublic abstract class CybersourceProviderAdapter\n        extends I3DSPaymentProviderAdapter<String, AuthConfig> {\n\n    // Status code mappings\n    private static final List<String> FAILED_STATUSES = Arrays.asList(\n        \"101\", \"102\", \"104\", \"150\", \"200\", \"201\", \"202\", \"203\",\n        \"204\", \"205\", \"207\", \"208\", \"209\", \"210\", \"211\", \"221\",\n        \"222\", \"230\", \"231\", \"232\", \"233\", \"234\", \"236\", \"240\",\n        \"250\", \"475\", \"476\", \"481\", \"520\", \"700\", \"701\", \"702\",\n        \"703\", \"704\", \"750\", \"751\", \"752\", \"777\"\n    );\n\n    private static final List<String> PROCESSING_STATUSES = Arrays.asList(\n        \"110\", \"475\", \"480\"\n    );\n\n    @Override\n    public ProviderPaymentResponse createPaymentAttempt(context, customer) {\n        // Build authorization request\n        CreatePaymentRequest request = cybersourceRequestBuilder\n            .buildAuthorizationRequest(context, customer);\n\n        // Execute API call\n        PtsV2PaymentsPost201Response response = apiClient.createPayment(request);\n\n        // Handle 3DS if required\n        if (requires3DS(response)) {\n            return handle3DSResponse(response, context);\n        }\n\n        return mapToProviderPaymentResponse(response);\n    }\n\n    // 3DS2 redirection flow\n    protected void createRedirectionHtml(response, paymentAttemptEntity) {\n        AuthenticationInfo authInfo = response.getConsumerAuthenticationInformation();\n\n        if (authInfo.getSpecificationVersion().startsWith(\"2\")) {\n            // 3DS2 flow with step-up URL\n            String html = authenticationService.createAuthenticationPageFor3ds2(\n                authInfo.getStepUpUrl(),\n                authInfo.getAccessToken(),\n                paymentAttemptEntity.getExternalId());\n\n            saveRedirectionDetail(paymentAttemptEntity, html);\n        }\n    }\n}\n```\n\n---\n\n## Webhook Handling\n\n### Webhook Architecture\n\n```\nProvider sends webhook\n         │\n         ▼\n┌─────────────────────────────────────┐\n│   /webhooks/v2/{provider}           │\n│   Provider-Specific Controller       │\n└─────────────────────────────────────┘\n         │\n         ▼\n┌─────────────────────────────────────┐\n│   Signature Verification            │\n│   (Provider-specific)               │\n└─────────────────────────────────────┘\n         │\n         ▼\n┌─────────────────────────────────────┐\n│   WebhookService                    │\n│   ├── Find PaymentAttempt           │\n│   ├── Audit webhook data            │\n│   └── Sync status with provider     │\n└─────────────────────────────────────┘\n         │\n         ▼\n┌─────────────────────────────────────┐\n│   State Machine Events              │\n│   ├── PaymentStateMachine           │\n│   └── OrderStateMachine             │\n└─────────────────────────────────────┘\n```\n\n### Webhook Controllers\n\n| Endpoint | Controller | Provider |\n|----------|------------|----------|\n| `/webhooks/v2/cashfree` | CashfreeWebhookController | Cashfree |\n| `/webhooks/v2/razorpay` | RazorpayWebhookController | Razorpay |\n| `/webhooks/v2/payu` | PayuWebhookController | PayU |\n| `/webhooks/v2/cybersource` | CybersourceWebhookController | Cybersource |\n| `/webhooks/v2/juspay` | JuspayWebhookController | Juspay |\n| `/webhooks/v2/ybl` | YBLWebhookController | Yes Bank UPI |\n| `/webhooks/v2/icici` | ICICIWebhookController | ICICI UPI |\n| `/webhooks/v2/rbl-upi` | RBLUpiWebhookController | RBL UPI |\n| `/webhooks/v2/digio` | DigioWebhookController | Digio |\n\n### Cashfree Webhook Example\n**File:** `controller/v2/CashfreeWebhookController.java`\n\n```java\n@RestController\n@RequestMapping(\"/webhooks/v2/cashfree\")\npublic class CashfreeWebhookController {\n\n    @PostMapping\n    public void onWebhookReceive(@RequestBody CashfreeWebhook webhookRequest) {\n        switch (webhookRequest.getType()) {\n            case PAYMENT_SUCCESS_WEBHOOK:\n            case PAYMENT_FAILED_WEBHOOK:\n                processPaymentWebhook(webhookRequest);\n                break;\n\n            case REFUND_STATUS_WEBHOOK:\n                processRefundWebhook(webhookRequest);\n                break;\n        }\n    }\n\n    private void processPaymentWebhook(CashfreeWebhook webhook) {\n        PaymentWebhookData data = webhook.getData();\n        String providerRefId = data.getCfPaymentId();\n\n        // 1. Fetch payment attempt by provider reference\n        PaymentAttemptV2Entity attempt = paymentAttemptFetchWorkflow\n            .fetchByProviderReferenceId(providerRefId);\n\n        // 2. Audit webhook data\n        auditService.auditProviderData(\n            webhook,\n            attempt.getId(),\n            AuditType.WEBHOOK);\n\n        // 3. Sync status (triggers state machine)\n        cashfreeProviderAdapter.syncPaymentAttemptWithWebhook(\n            attempt,\n            webhook);\n    }\n}\n```\n\n### Idempotency Handling\n\n```java\n// In base adapter - only process if status changed\npublic void syncPaymentAttemptWithProvider(PaymentAttemptV2Entity entity) {\n    String previousStatus = entity.getProviderStatus();\n\n    Object providerResponse = syncPaymentAttemptWithProviderId(entity);\n\n    // Only audit and trigger events if status actually changed\n    if (!Objects.equals(previousStatus, entity.getProviderStatus())) {\n        auditService.auditProviderData(providerResponse, entity.getId(), SYNC);\n        publishStatusChangeEvent(entity);\n    }\n}\n```\n\n---\n\n## Provider Configuration\n\n### ProviderAccountEntity\n**File:** `entity/ProviderAccountEntity.java`\n\n```java\n@Entity @Table(name = \"provider_accounts\")\npublic class ProviderAccountEntity extends BaseEntity {\n\n    @ManyToOne\n    @JoinColumn(name = \"payment_provider_id\")\n    private PaymentProviderEntity paymentProvider;\n\n    @Column(name = \"provider_account_id\")\n    private String providerAccountId;     // e.g., \"ACC_123456\"\n\n    @Lob\n    @Column(name = \"access_token\")\n    private byte[] accessToken;           // Encrypted credentials\n\n    @Column(name = \"endpoint\")\n    private String endpoint;              // Provider API endpoint\n\n    @Column(name = \"is_prod\")\n    private Boolean isProd;               // Production vs Sandbox\n\n    @Column(name = \"active\")\n    private Boolean active;\n\n    @Column(name = \"additional_config\")\n    private String additionalConfig;      // JSON configuration\n\n    @Column(name = \"provider_mid\")\n    private String providerMid;           // Merchant ID at provider\n\n    @Column(name = \"settlement_category\")\n    private String settlementCategory;    // Settlement routing\n}\n```\n\n### PaymentProviderEntity\n**File:** `entity/PaymentProviderEntity.java`\n\n```java\n@Entity @Table(name = \"payment_providers\")\npublic class PaymentProviderEntity extends BaseEntity {\n\n    @Column(name = \"name\")\n    private String name;                  // \"Cashfree\", \"Cybersource\"\n\n    @Enumerated(EnumType.STRING)\n    @Column(name = \"key\")\n    private PaymentProviderKey key;       // CASHFREE, CYBERSOURCE\n\n    @Column(name = \"active\")\n    private Boolean active;\n\n    @Convert(converter = SupportedInstrumentTypesConverter.class)\n    @Column(name = \"supported_instrument_types\")\n    private List<InstrumentType> supportedInstrumentTypes;\n}\n```\n\n### Provider-Specific Configurations\n\n```java\n// Cashfree Configuration\n@Data\npublic class CashfreeProviderAccountConfiguration {\n    private String apiClientId;\n    private String apiVersion;\n    private ShortCircuitConfiguration shortCircuitConfiguration;\n}\n\n// Cybersource Configuration\n@Data\npublic class CybersourceProviderAccountConfiguration {\n    private String apiKey;\n    private String merchantId;\n    private Boolean enableRetries = false;\n    private Boolean enableCaptureWithAuth = true;\n    private Boolean enable3DS2 = true;\n    private Boolean enableRedirectionFlow = false;\n    private Integer timeout = 30000;\n}\n\n// PayU Configuration\n@Data\npublic class PayuProviderAccountConfiguration {\n    private String merchantKey;\n    private String merchantSalt;\n    private String hashVersion;\n}\n```\n\n### Client-Provider Mapping\n**File:** `entity/ClientPaymentProviderConfigEntity.java`\n\n```java\n@Entity @Table(name = \"client_payment_provider_config\")\npublic class ClientPaymentProviderConfigEntity extends BaseEntity {\n\n    @ManyToOne\n    @JoinColumn(name = \"client_id\")\n    private ClientEntity client;\n\n    @ManyToOne\n    @JoinColumn(name = \"payment_provider_id\")\n    private PaymentProviderEntity paymentProvider;\n\n    @Column(name = \"provider_config\")\n    private String providerConfig;  // JSON - client-specific overrides\n\n    @Column(name = \"active\")\n    private Boolean active;\n}\n```\n\n---\n\n## Error Handling & Retry Logic\n\n### Error Classification\n\n```java\npublic enum ProviderRequestStatus {\n    REQUEST_SUCCESS,          // Payment processed successfully\n    RETRY_ABLE_FAILURE,       // Timeout, rate limit - can retry\n    NON_RETRY_ABLE_FAILURE    // Invalid request - cannot retry\n}\n```\n\n### Provider Error Structure\n\n```java\n@Data @Builder\npublic class ProviderError {\n    private String message;           // User-friendly message\n    private String code;              // Provider error code\n    private Object providerResponse;  // Raw error response\n    private Boolean retryable;        // Retry classification\n}\n```\n\n### Status Code Mapping (Cybersource)\n\n| Category | Codes | Meaning |\n|----------|-------|---------|\n| **Success** | 100 | Approved |\n| **Processing** | 110, 475, 480 | Pending, Timeout |\n| **Decline** | 200-236 | Various declines |\n| **System Error** | 150, 250, 520 | Internal errors |\n| **Authentication** | 475, 476 | 3DS issues |\n\n### Retry Pattern\n\n```java\npublic ProviderPaymentResponse executePaymentAttempt(\n        PaymentAttemptCreateContext context,\n        BiFunction<PaymentAttemptCreateContext, ProviderCustomer,\n                   ProviderPaymentResponse> pilotMethod,\n        FlowType flowType) {\n    try {\n        return pilotMethod.apply(context, providerCustomer);\n\n    } catch (RateLimitException rle) {\n        // Retryable - provider rate limited us\n        return ProviderPaymentResponse.builder()\n            .providerRequestStatus(RETRY_ABLE_FAILURE)\n            .providerError(ProviderError.builder()\n                .message(\"Rate limited, please retry\")\n                .retryable(true)\n                .build())\n            .build();\n\n    } catch (SocketTimeoutException ste) {\n        // Retryable - network timeout\n        return ProviderPaymentResponse.builder()\n            .providerRequestStatus(RETRY_ABLE_FAILURE)\n            .status(PaymentAttemptStatus.PROCESSING)\n            .build();\n\n    } catch (AppException ae) {\n        // Non-retryable - validation error\n        return ProviderPaymentResponse.builder()\n            .providerRequestStatus(NON_RETRY_ABLE_FAILURE)\n            .providerError(ProviderError.builder()\n                .message(ae.getMessage())\n                .retryable(false)\n                .build())\n            .build();\n    }\n}\n```\n\n### Circuit Breaker Configuration\n\n```java\n@Data\npublic class ShortCircuitConfiguration {\n    private Boolean enabled = false;\n    private Integer failureThreshold = 5;     // Failures before opening\n    private Integer successThreshold = 3;      // Successes to close\n    private Long waitDurationMs = 60000;       // Wait before half-open\n    private Integer permittedCalls = 10;       // Calls in half-open state\n}\n```\n\n---\n\n## Key Provider Integration Files\n\n### Core Architecture\n1. `v2/workflow/create/providers/IPaymentProviderAdapter.java` - Base adapter\n2. `v2/workflow/create/providers/PaymentProviderFactory.java` - Factory\n3. `planner/providerdecider/ProviderDeciderRouter.java` - Routing strategy\n\n### Decision Tree\n1. `planner/providerdecider/ProviderDeciderV2.java` - DT workflow\n2. `planner/providerdecider/ProviderDeciderViaLCM.java` - LCM routing\n3. `cache/DecisionTreeObjectCache.java` - DT caching\n\n### Webhooks\n1. `controller/WebhookController.java` - Generic webhook endpoint\n2. `controller/v2/CashfreeWebhookController.java` - Cashfree webhooks\n3. `service/WebhookService.java` - Webhook processing\n\n### Provider Implementations\n1. `v2/workflow/create/providers/CashfreeProviderAdapter.java`\n2. `v2/workflow/create/providers/cybersource/CybersourceProviderAdapter.java`\n3. `v2/workflow/create/providers/PayuProviderAdapter.java`\n\n### Configuration\n1. `entity/ProviderAccountEntity.java` - Provider credentials\n2. `entity/PaymentProviderEntity.java` - Provider definition\n3. `entity/ClientPaymentProviderConfigEntity.java` - Client-provider mapping\n\n---\n\n## Checkpoint\n\nAfter completing this section:\n- [ ] Understand adapter pattern and factory selection\n- [ ] Know how decision tree routing works\n- [ ] Understand webhook processing flow\n- [ ] Know error classification and retry patterns\n- [ ] Proceed to [04-payment-flow.md](./04-payment-flow.md)\n\n---\n\n*Next: [04 - Payment Flow](./04-payment-flow.md)*\n"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":36648,"cache_read_input_tokens":22528,"cache_creation":{"ephemeral_5m_input_tokens":36648,"ephemeral_1h_input_tokens":0},"output_tokens":3}},"type":"assistant","uuid":"3e04c7be-5f47-4406-8447-0e3c76af4a5f","timestamp":"2025-12-31T10:05:16.896Z"}
{"parentUuid":"3e04c7be-5f47-4406-8447-0e3c76af4a5f","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01KyvAv3ZU2CaxqbifNte8bu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_bdrk_01R6KinaZ5eGsp5tSEAZ9YK7","name":"Write","input":{"file_path":"/Users/kiranbiliyawala/code/cred/payments/payment-service/docs/study-guide/04-payment-flow.md","content":"# 04 - Payment Flow Deep-Dive\n\n> **Reading Time:** 90 minutes\n> **Prerequisites:** [03-provider-integration.md](./03-provider-integration.md)\n> **Next:** [05-key-files-reference.md](./05-key-files-reference.md)\n\n---\n\n## Table of Contents\n1. [The 7-Step Workflow Pipeline](#the-7-step-workflow-pipeline)\n2. [PaymentAttemptCreateWorkflow Detailed](#paymentattemptcreateworkflow-detailed)\n3. [State Machine Implementation](#state-machine-implementation)\n4. [End-to-End Payment Flow](#end-to-end-payment-flow)\n5. [3DS / Native OTP Authentication](#3ds--native-otp-authentication)\n6. [Instrument Processing](#instrument-processing)\n7. [Distributed Locking](#distributed-locking)\n8. [Event-Driven Architecture](#event-driven-architecture)\n\n---\n\n## The 7-Step Workflow Pipeline\n\n### Base Workflow Pattern (Template Method)\n**File:** `v2/workflow/create/Workflow.java`\n\n```java\npublic abstract class Workflow<Request, Response, Context> {\n\n    public Response execute(Request request) {\n        // STEP 1: Validate inputs and enrich context\n        Context context = validateAndEnrichContext(request);\n\n        // STEP 2: Persist to relational DB (transactional)\n        persistIntent(context);\n\n        // STEP 3: Pre-persist event hooks\n        publishEntityPrePersistEvents(context);\n\n        // STEP 4: Persist to non-relational DB (DynamoDB)\n        persistNonRelationalIntent(context);\n\n        // STEP 5: Process (external provider calls)\n        process(context);\n\n        // STEP 6: Post-process and save results (transactional)\n        Response response = postProcess(context);\n\n        // STEP 7: Post-persist & publish events\n        postPersistNonRelationalDataStore(context);\n        publishEntityChangeEvents(context);\n\n        throwErrorIfRequired(context);\n        return response;\n    }\n\n    // Abstract methods for subclasses to implement\n    protected abstract Context validateAndEnrichContext(Request request);\n    protected abstract void persistIntent(Context context);\n    protected abstract void process(Context context);\n    protected abstract Response postProcess(Context context);\n    protected abstract void publishEntityChangeEvents(Context context);\n}\n```\n\n### Step-by-Step Breakdown\n\n| Step | Method | Purpose | Transaction |\n|------|--------|---------|-------------|\n| 1 | `validateAndEnrichContext()` | Validate inputs, enrich with external data | None |\n| 2 | `persistIntent()` | Save entities to MySQL | Master TX |\n| 3 | `publishEntityPrePersistEvents()` | Pre-persist hooks | None |\n| 4 | `persistNonRelationalIntent()` | Save to DynamoDB | None |\n| 5 | `process()` | Call external provider APIs | None |\n| 6 | `postProcess()` | Update entities with response | Master TX |\n| 7 | `publishEntityChangeEvents()` | Trigger state machines, events | None |\n\n---\n\n## PaymentAttemptCreateWorkflow Detailed\n\n**File:** `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java`\n\n### Step 1: Validate & Enrich Context\n\n```java\n@Override\nprotected PaymentAttemptCreateContext validateAndEnrichContext(\n        CreatePaymentAttemptRequest request) {\n\n    PaymentAttemptCreateContext context = new PaymentAttemptCreateContext();\n    context.setRequest(request);\n\n    // 1. Fetch related entities\n    PaymentV2Entity payment = paymentRepository.findByExternalId(request.getPaymentId());\n    OrderEntity order = payment.getOrderEntity();\n    CustomerEntity customer = order.getCustomerEntity();\n    ClientEntity client = order.getClientEntity();\n\n    context.setPaymentEntity(payment);\n    context.setOrderEntity(order);\n    context.setCustomerEntity(customer);\n    context.setClientEntity(client);\n\n    // 2. Validate & enrich instrument\n    InstrumentTypeProcessorResult result = instrumentTypeProcessorManager\n        .validatePaymentInstrumentAndEnrich(request.getPaymentInstrument());\n    context.setInstrumentProcessorResult(result);\n\n    // 3. Route to provider via Decision Tree\n    ProviderRoutingDecisionResult routingResult = providerDeciderRouter\n        .resolve(context);\n    context.setRoutingDecisionResult(routingResult);\n    context.setProviderAccountEntity(routingResult.getProviderAccountEntity());\n\n    // 4. Determine auth type (3DS, OTP, None)\n    AuthType authType = authTypeDeciderFactory\n        .decideAuthType(context);\n    context.setAuthType(authType);\n\n    // 5. Validate settlement routes\n    RoutesBreakup routes = settlementRouteValidator\n        .validateAndEnrich(context);\n    context.setRoutesBreakup(routes);\n\n    // 6. Register mandate if eMandate flow\n    if (isEMandateFlow(context)) {\n        mandateServiceDataManager.registerMandate(context);\n    }\n\n    return context;\n}\n```\n\n### Enrichment Pipeline\n\n| Enricher | Input | Output |\n|----------|-------|--------|\n| `InstrumentTypeProcessorManager` | PaymentInstrument | BIN data, issuer, card type |\n| `ProviderDeciderRouter` | Context | Provider + Account |\n| `AuthTypeDeciderFactory` | Context | 3DS / OTP / None |\n| `NativeProviderDecider` | Context | Native OTP provider |\n| `SettlementRouteValidator` | Context | Routes breakup |\n| `MandateServiceDataManager` | Context | Mandate registration |\n\n### Context Object Structure\n\n```java\n@Data\npublic class PaymentAttemptCreateContext {\n    // Request/Response\n    private CreatePaymentAttemptRequest request;\n    private PaymentAttemptResponse response;\n\n    // Entities\n    private PaymentAttemptV2Entity paymentAttemptEntity;\n    private PaymentV2Entity paymentEntity;\n    private OrderEntity orderEntity;\n    private CustomerEntity customerEntity;\n    private ClientEntity clientEntity;\n\n    // Enriched Data\n    private InstrumentTypeProcessorResult instrumentProcessorResult;\n    private ProviderAccountEntity providerAccountEntity;\n    private ProviderRoutingDecisionResult routingDecisionResult;\n    private AuthType authType;\n    private RoutesBreakup routesBreakup;\n    private ProviderPaymentResponse createResponse;\n\n    // OTP/Auth Flow\n    private Boolean isPlatformNativeOtpSupported;\n    private PaymentAttemptNativeOTPDetailEntity nativeOTPDetailEntity;\n\n    // Error Collection\n    private List<WorkflowInternalError> errors = new ArrayList<>();\n}\n```\n\n### Step 2: Persist Intent\n\n```java\n@Override\n@Transactional(transactionManager = \"MasterTransactionManager\")\nprotected void persistIntent(PaymentAttemptCreateContext context) {\n\n    // Build PaymentAttemptV2Entity\n    PaymentAttemptV2Entity entity = PaymentAttemptV2Entity.builder()\n        .externalId(PaymentAttemptUUIdGenerator.generate())\n        .status(PaymentAttemptStatus.CREATED)\n        .paymentEntity(context.getPaymentEntity())\n        .orderId(context.getOrderEntity().getId())\n        .paymentProviderEntity(context.getRoutingDecisionResult().getPaymentProvider())\n        .providerAccountEntity(context.getProviderAccountEntity())\n        .paymentMethod(context.getInstrumentProcessorResult().getPaymentMethod())\n        .instrumentDetail(context.getInstrumentProcessorResult().getEnrichedInstrument())\n        .routesBreakup(context.getRoutesBreakup())\n        .build();\n\n    // Save to repository\n    paymentAttemptRepository.save(entity);\n    context.setPaymentAttemptEntity(entity);\n\n    // Save fees\n    List<FeeContext> feeContexts = buildFeeContexts(context);\n    feeCreateWorkflow.persistIntent(feeContexts);\n\n    // Add attributes (metadata)\n    enrichAttributes(entity, context);\n}\n\nprivate void enrichAttributes(PaymentAttemptV2Entity entity,\n                              PaymentAttemptCreateContext context) {\n    Set<PaymentAttemptAttributeEntity> attributes = new HashSet<>();\n\n    // Decision tree tracking\n    attributes.add(new PaymentAttemptAttributeEntity(\n        DT_ID, context.getRoutingDecisionResult().getDecisionTreeId()));\n    attributes.add(new PaymentAttemptAttributeEntity(\n        DT_RESULT, context.getRoutingDecisionResult().getDecisionPath()));\n\n    // Provider metadata\n    attributes.add(new PaymentAttemptAttributeEntity(\n        PROVIDER_KEY, context.getProviderAccountEntity().getPaymentProvider().getKey()));\n\n    entity.setAttributeEntities(attributes);\n}\n```\n\n### Step 5: Process (Provider Call)\n\n```java\n@Override\nprotected void process(PaymentAttemptCreateContext context) {\n\n    // Find the right adapter\n    IPaymentProviderAdapter adapter = paymentProviderFactory.findPaymentProviderAdapter(\n        context.getOrderEntity().getType(),           // PAY, REFUND\n        context.getRoutingDecisionResult().getProviderKey(),  // CASHFREE, etc.\n        context.getInstrumentProcessorResult().getInstrumentType(),  // CARD, UPI\n        context.getAuthType().getThreeDSType()        // 3DS1, 3DS2, NONE\n    );\n\n    // Execute provider call\n    ProviderPaymentResponse response = adapter.executePaymentAttempt(\n        context,\n        adapter::createPaymentAttempt,  // Method reference\n        FlowType.CREATE\n    );\n\n    // Check platform OTP capability\n    response = checkIfPlatformOtpEnabled(context, response);\n\n    context.setCreateResponse(response);\n}\n\nprivate ProviderPaymentResponse checkIfPlatformOtpEnabled(\n        PaymentAttemptCreateContext context,\n        ProviderPaymentResponse response) {\n\n    // If provider returned redirect but we support native OTP\n    if (response.getStatus() == AUTHENTICATION_REQUIRED\n            && context.getIsPlatformNativeOtpSupported()) {\n\n        // Override with SDK params for native OTP\n        CardNativeOTPSDKParamDetail sdkParams = CardNativeOTPSDKParamDetail.builder()\n            .authType(AuthType.NATIVE_OTP)\n            .challengeId(UUID.randomUUID().toString())\n            .fallbackUrl(response.getTransactionResponse().getAuthentication().getUrl())\n            .submitOTPAllowed(true)\n            .build();\n\n        response.getTransactionResponse().setSdkParams(sdkParams);\n    }\n\n    return response;\n}\n```\n\n### Step 6: Post-Process\n\n```java\n@Override\n@Transactional(transactionManager = \"MasterTransactionManager\")\nprotected PaymentAttemptResponse postProcess(PaymentAttemptCreateContext context) {\n\n    PaymentAttemptV2Entity entity = context.getPaymentAttemptEntity();\n    ProviderPaymentResponse response = context.getCreateResponse();\n\n    // Update from provider response\n    entity.setProviderStatus(response.getProviderStatus());\n    entity.setProviderReferenceId(response.getProviderReferenceId());\n    entity.setGatewayReferenceId(response.getGatewayReferenceId());\n\n    // Set error details if failed\n    if (response.getProviderError() != null) {\n        entity.setErrorCode(response.getProviderError().getCode());\n        entity.setErrorMessage(response.getProviderError().getMessage());\n    }\n\n    // Determine final status\n    if (response.getProviderRequestStatus() == REQUEST_SUCCESS) {\n        entity.setStatus(response.getStatus());\n    } else if (isEligibleForRetry(context)) {\n        // Set to PROCESSING for async status check\n        entity.setStatus(response.getStatus() == FAILED ? FAILED : PROCESSING);\n    }\n\n    // Save updated entity\n    paymentAttemptRepository.save(entity);\n\n    // Audit provider response\n    auditService.auditProviderData(\n        response.getProviderResponseObject(),\n        entity.getId(),\n        AuditType.CREATE_RESPONSE);\n\n    return mapper.toResponse(entity, response);\n}\n```\n\n### Step 7: Publish Events\n\n```java\n@Override\nprotected void publishEntityChangeEvents(PaymentAttemptCreateContext context) {\n    PaymentAttemptV2Entity entity = context.getPaymentAttemptEntity();\n\n    // 1. Post to synchronous EventBus (triggers PaymentStateMachine)\n    PaymentAttemptEvent event = PaymentAttemptEventFactory.findEvent(entity);\n    syncEventBus.post(event);\n\n    // 2. Post to asynchronous EventBus\n    asyncEventBus.post(event);\n\n    // 3. Publish to multi-tenant event system (client webhooks)\n    eventiService.publishEvent(entity);\n\n    // 4. Publish to analytics (Pinot)\n    eventiService.publishToPinot(buildAnalyticsEvent(entity));\n\n    // 5. Add to sync manager for webhook updates\n    paymentAttemptSyncManager.addEntityForSync(entity);\n}\n```\n\n---\n\n## State Machine Implementation\n\n### PaymentStateMachine\n**File:** `statemachine/payment/PaymentStateMachine.java`\n\n```java\n@Component\npublic class PaymentStateMachine {\n\n    @Subscribe\n    public void onPaymentAttemptCreated(PaymentAttemptCreatedEvent event) {\n        PaymentV2Entity payment = event.getPaymentAttemptEntity().getPaymentEntity();\n\n        if (payment.getStatus() == FAILED) {\n            // First attempt - change from FAILED to CREATED\n            payment.setStatus(CREATED);\n            paymentRepository.save(payment);\n            postPaymentEvent(payment, PaymentCreatedEvent.class);\n        }\n    }\n\n    @Subscribe\n    public void onPaymentAttemptFailed(PaymentAttemptFailedEvent event) {\n        PaymentV2Entity payment = event.getPaymentAttemptEntity().getPaymentEntity();\n\n        // Check if all attempts failed\n        boolean allAttemptsFailed = paymentAttemptRepository\n            .findByPaymentEntity_Id(payment.getId())\n            .stream()\n            .allMatch(a -> TERMINAL_FAILED_STATUSES.contains(a.getStatus()));\n\n        if (allAttemptsFailed && shouldUpdatePaymentStatus(payment)) {\n            payment.setStatus(FAILED);\n            paymentRepository.save(payment);\n            postPaymentEvent(payment, PaymentFailedEvent.class);\n        }\n    }\n\n    @Subscribe\n    @Retryable(maxAttempts = 3)  // Handle optimistic lock\n    public void onPaymentAttemptCompleted(PaymentAttemptCompletedEvent event) {\n        PaymentV2Entity payment = event.getPaymentAttemptEntity().getPaymentEntity();\n\n        if (shouldUpdatePaymentStatus(payment)) {\n            payment.setStatus(COMPLETED);\n            paymentRepository.save(payment);\n            postPaymentEvent(payment, PaymentCompletedEvent.class);\n        }\n    }\n\n    @Subscribe\n    public void onPaymentAttemptAuthorized(PaymentAttemptAuthorizedEvent event) {\n        PaymentV2Entity payment = event.getPaymentAttemptEntity().getPaymentEntity();\n\n        if (shouldUpdatePaymentStatus(payment)) {\n            payment.setStatus(AUTHORIZED);\n            paymentRepository.save(payment);\n            postPaymentEvent(payment, PaymentAuthorizedEvent.class);\n        }\n    }\n\n    @Subscribe\n    public void onPaymentAttemptProcessing(PaymentAttemptProcessingEvent event) {\n        PaymentV2Entity payment = event.getPaymentAttemptEntity().getPaymentEntity();\n\n        if (shouldUpdatePaymentStatus(payment)) {\n            payment.setStatus(PROCESSING);\n            paymentRepository.save(payment);\n            postPaymentEvent(payment, PaymentProcessingEvent.class);\n        }\n    }\n\n    private boolean shouldUpdatePaymentStatus(PaymentV2Entity entity) {\n        return !TERMINAL_STATUSES.contains(entity.getStatus());\n    }\n\n    private static final Set<PaymentStatus> TERMINAL_STATUSES = Set.of(\n        COMPLETED, FAILED, FORCE_FAILED, DISCARDED\n    );\n}\n```\n\n### OrderStateMachine\n**File:** `statemachine/order/OrderStateMachine.java`\n\n```java\n@Component\npublic class OrderStateMachine {\n\n    @Subscribe\n    public void onPaymentCreated(PaymentCreatedEvent event) {\n        OrderEntity order = event.getPaymentEntity().getOrderEntity();\n\n        if (order.getStatus() == OrderStatus.CREATED) {\n            // Check if authless flow\n            if (isAuthlessFlow(order)) {\n                order.setStatus(OrderStatus.AUTHLESS_READY_TO_PROCESS);\n            }\n            orderRepository.save(order);\n        }\n    }\n\n    @Subscribe\n    public void onPaymentFailed(PaymentFailedEvent event) {\n        OrderEntity order = event.getPaymentEntity().getOrderEntity();\n\n        // Check if all payments failed\n        boolean allPaymentsFailed = order.getPayments().stream()\n            .allMatch(p -> FAILED_STATUSES.contains(p.getStatus()));\n\n        if (allPaymentsFailed && shouldUpdateOrderStatus(order)) {\n            order.setStatus(OrderStatus.FAILED);\n            orderRepository.save(order);\n        }\n    }\n\n    @Subscribe\n    public void onPaymentCompleted(PaymentCompletedEvent event) {\n        OrderEntity order = event.getPaymentEntity().getOrderEntity();\n\n        // Check if all payments completed\n        boolean allPaymentsCompleted = order.getPayments().stream()\n            .allMatch(p -> p.getStatus() == PaymentStatus.COMPLETED);\n\n        if (allPaymentsCompleted && shouldUpdateOrderStatus(order)) {\n            order.setStatus(OrderStatus.COMPLETED);\n            orderRepository.save(order);\n        }\n    }\n\n    @Subscribe\n    public void onPaymentAuthorized(PaymentAuthorizedEvent event) {\n        OrderEntity order = event.getPaymentEntity().getOrderEntity();\n\n        if (shouldUpdateOrderStatus(order)) {\n            order.setStatus(OrderStatus.AUTHORIZED);\n            orderRepository.save(order);\n        }\n    }\n\n    @Subscribe\n    public void onPaymentProcessing(PaymentProcessingEvent event) {\n        OrderEntity order = event.getPaymentEntity().getOrderEntity();\n\n        if (shouldUpdateOrderStatus(order)) {\n            order.setStatus(OrderStatus.PROCESSING);\n            orderRepository.save(order);\n        }\n    }\n}\n```\n\n### State Transition Diagram\n\n```\nPaymentAttempt States:\n┌──────────────────────────────────────────────────────────────────┐\n│  CREATED ──► PROCESSING ──► AUTHORIZED ──► COMPLETED            │\n│      │           │              │                                │\n│      └───────────┴──────────────┴────► FAILED                   │\n│                                        FORCE_FAILED             │\n│                                        BLOCKED                  │\n└──────────────────────────────────────────────────────────────────┘\n\nPayment States:\n┌──────────────────────────────────────────────────────────────────┐\n│  CREATED ──► PROCESSING ──► AUTHORIZED ──► COMPLETED            │\n│      │           │              │                                │\n│      └───────────┴──────────────┴────► FAILED                   │\n│                                        FORCE_FAILED             │\n│                                        DISCARDED                │\n└──────────────────────────────────────────────────────────────────┘\n\nOrder States:\n┌──────────────────────────────────────────────────────────────────┐\n│  CREATED ──► PROCESSING ──► AUTHORIZED ──► COMPLETED            │\n│      │           │              │                                │\n│      └───────────┴──────────────┴────► FAILED                   │\n└──────────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## End-to-End Payment Flow\n\n### Complete Flow Diagram\n\n```\n┌─────────────────────────────────────────────────────────────────────────┐\n│                         CLIENT REQUEST                                   │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  1. ORDER CREATION                                                       │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ POST /v2/orders                                                     │ │\n│  │ OrderCreateWorkflow.execute()                                       │ │\n│  │ ├── validateAndEnrichContext() - Customer lookup, order validation │ │\n│  │ ├── persistIntent() - Save OrderEntity (status: CREATED)           │ │\n│  │ └── publishEvents() → OrderStateMachine                            │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  2. PAYMENT CREATION                                                     │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ POST /v2/orders/{orderId}/payments                                  │ │\n│  │ BulkPaymentCreateWorkflow.execute()                                 │ │\n│  │ ├── validateAndEnrichContext() - Payment mode validation           │ │\n│  │ ├── persistIntent() - Save PaymentV2Entity (status: CREATED)       │ │\n│  │ └── publishEvents() → PaymentStateMachine → OrderStateMachine      │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  3. PAYMENT ATTEMPT CREATION (Core Flow)                                 │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ POST /v2/payments/{paymentId}/attempts                              │ │\n│  │ PaymentAttemptCreateWorkflow.execute()                              │ │\n│  │ ├── validateAndEnrichContext()                                     │ │\n│  │ │   ├── InstrumentTypeProcessorManager (Card/UPI/NetBanking)       │ │\n│  │ │   ├── ProviderDeciderRouter (Decision Tree routing)              │ │\n│  │ │   ├── AuthTypeDeciderFactory (3DS/OTP/None)                      │ │\n│  │ │   └── SettlementRouteValidator                                   │ │\n│  │ ├── persistIntent() - Save PaymentAttemptV2Entity                  │ │\n│  │ ├── persistNonRelationalIntent() - DynamoDB (OTP details)          │ │\n│  │ ├── process() - Provider API call via Adapter                      │ │\n│  │ ├── postProcess() - Update entity with provider response           │ │\n│  │ └── publishEvents() → PaymentStateMachine → OrderStateMachine      │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n         ┌──────────────────────────┴──────────────────────────┐\n         ▼                                                      ▼\n┌─────────────────────────┐                    ┌─────────────────────────┐\n│  4A. 3DS/OTP FLOW       │                    │  4B. DIRECT SUCCESS     │\n│  ┌───────────────────┐  │                    │  ┌───────────────────┐  │\n│  │ Status:           │  │                    │  │ Status: COMPLETED │  │\n│  │ AUTHENTICATION_   │  │                    │  │ Payment done!     │  │\n│  │ REQUIRED          │  │                    │  └───────────────────┘  │\n│  └───────────────────┘  │                    └─────────────────────────┘\n│           │             │\n│           ▼             │\n│  Client performs auth   │\n│  (redirect/native OTP)  │\n│           │             │\n│           ▼             │\n│  POST /v2/authenticate  │\n│  PaymentAttempt         │\n│  AuthenticateWorkflow   │\n└─────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  5. WEBHOOK / SYNC UPDATE                                                │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ Provider sends webhook OR SyncManager polls status                  │ │\n│  │ ├── WebhookController receives update                              │ │\n│  │ ├── adapter.syncPaymentAttemptWithWebhook()                        │ │\n│  │ ├── Update PaymentAttemptV2Entity status                           │ │\n│  │ └── publishEvents() → State machines cascade updates               │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  6. FINAL STATE                                                          │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ PaymentAttempt: COMPLETED ──► Payment: COMPLETED ──► Order: COMPLETED│\n│  │                                                                     │ │\n│  │ eventiService.publishEvent() → Client webhook notification          │ │\n│  │ eventiService.publishToPinot() → Analytics dashboard               │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## 3DS / Native OTP Authentication\n\n### Native OTP Flow (Card Payments)\n\n```\n1. PaymentAttemptCreateWorkflow detects CARD + OTP-capable BIN\n         │\n         ▼\n2. wspService.isPlatformNativeOtpEnabled() returns true\n         │\n         ▼\n3. Provider returns redirect URL, but we override with SDK params\n         │\n         ▼\n4. CardNativeOTPSDKParamDetail created:\n   ├── authType: NATIVE_OTP\n   ├── challengeId: UUID\n   ├── fallbackUrl: Provider's original auth URL\n   └── submitOTPAllowed: true\n         │\n         ▼\n5. PaymentAttemptNativeOTPDetailEntity saved to DynamoDB\n         │\n         ▼\n6. Client submits OTP via PaymentAttemptAuthenticateWorkflow\n         │\n         ▼\n7. Provider validates OTP, returns success/failure\n         │\n         ▼\n8. State machines update payment/order status\n```\n\n### DynamoDB Entity for OTP\n\n```java\n@Data @Builder\n@DynamoDBTable(tableName = \"darwin_payment_attempt_native_otp_detail\")\npublic class PaymentAttemptNativeOTPDetailEntity {\n\n    @DynamoDBHashKey(attributeName = \"payment_attempt_external_id\")\n    private String paymentAttemptExternalId;\n\n    @DynamoDBAttribute(attributeName = \"challenge_id\")\n    private String challengeId;\n\n    @DynamoDBAttribute(attributeName = \"auth_type\")\n    private String authType;\n\n    @DynamoDBAttribute(attributeName = \"fallback_url\")\n    private String fallbackUrl;\n\n    @DynamoDBAttribute(attributeName = \"otp_submitted\")\n    private Boolean otpSubmitted;\n\n    @Builder.Default\n    private long ttl = LocalDateTime.now()\n        .plusDays(1)\n        .toEpochSecond(ZoneOffset.UTC);\n}\n```\n\n### 3DS Redirect Flow\n\n```\n1. Provider returns authentication URL\n         │\n         ▼\n2. Client redirects to issuer's 3DS page\n         │\n         ▼\n3. User completes authentication on issuer page\n         │\n         ▼\n4. Issuer redirects to return_url with callback data\n         │\n         ▼\n5. ValidateAuthenticationWorkflow processes callback\n         │\n         ▼\n6. Provider confirms authentication status\n         │\n         ▼\n7. State machines update accordingly\n```\n\n### Authentication Workflow\n**File:** `v2/workflow/authenticate/PaymentAttemptAuthenticateWorkflow.java`\n\n```java\n@Override\nprotected void process(PaymentAttemptAuthenticateContext context) {\n    PaymentAttemptV2Entity entity = context.getPaymentAttemptEntity();\n\n    // Find adapter\n    IPaymentProviderAdapter adapter = paymentProviderFactory\n        .findPaymentProviderAdapter(...);\n\n    // Submit OTP or process callback\n    if (context.isNativeOtpFlow()) {\n        adapter.submitOTP(entity, context.getOtp());\n    } else {\n        adapter.validateAuthentication(entity, context.getCallbackData());\n    }\n\n    // Sync status with provider\n    adapter.syncPaymentAttemptWithProviderId(entity);\n}\n```\n\n---\n\n## Instrument Processing\n\n### InstrumentTypeProcessorManager\n**File:** `processors/instrumenttype/InstrumentTypeProcessorManager.java`\n\n```java\n@Component\npublic class InstrumentTypeProcessorManager {\n\n    private Map<InstrumentType, IInstrumentTypeProcessor<?, ?, ?>> processorByType;\n\n    public InstrumentTypeProcessorResult validatePaymentInstrumentAndEnrich(\n            PaymentInstrument instrument) {\n\n        IInstrumentTypeProcessor processor = processorByType.get(instrument.getType());\n\n        if (processor == null) {\n            throw Error.unsupported_instrument_type.getBuilder().build();\n        }\n\n        return processor.validatePaymentInstrumentAndEnrich(instrument);\n    }\n}\n```\n\n### Processor Implementations\n\n| Processor | InstrumentType | Enrichment |\n|-----------|----------------|------------|\n| `CardInstrumentTypeProcessor` | CARD | BIN lookup, issuer, card type, network |\n| `UPIPayInstrumentTypeProcessor` | UPI_APPS | VPA validation, provider |\n| `UPICollectInstrumentTypeProcessor` | UPI_COLLECT | QR code, timeout |\n| `NetBankingInstrumentTypeProcessor` | NET_BANKING | Bank code, issuer |\n| `EMandateInstrumentTypeProcessor` | NET_BANKING_WITH_PI | Mandate details |\n\n### Card Instrument Processing\n**File:** `processors/instrumenttype/CardInstrumentTypeProcessor.java`\n\n```java\n@Component\npublic class CardInstrumentTypeProcessor\n        implements IInstrumentTypeProcessor<CardPaymentInstrument,\n                                           CardPaymentSubMethodDetail,\n                                           CardEnrichedPaymentInstrument> {\n\n    @Override\n    public InstrumentTypeProcessorResult<CardPaymentSubMethodDetail,\n                                         CardEnrichedPaymentInstrument>\n            validatePaymentInstrumentAndEnrich(CardPaymentInstrument instrument) {\n\n        // 1. Fetch card from Arsenal (tokenized vault)\n        CardVaultResponse cardData = arsenalClient.fetchCard(instrument.getToken());\n\n        // 2. Lookup BIN data\n        CardBinDetail binDetail = cardBinCache.getBinDetail(cardData.getBin());\n\n        // 3. Build enriched instrument\n        CardEnrichedPaymentInstrument enriched = CardEnrichedPaymentInstrument.builder()\n            .token(instrument.getToken())\n            .bin(cardData.getBin())\n            .last4(cardData.getLast4())\n            .cardType(binDetail.getCardType())        // CREDIT, DEBIT\n            .cardBrand(binDetail.getCardBrand())      // VISA, MASTERCARD\n            .issuingBank(binDetail.getIssuingBank())\n            .cardNetwork(binDetail.getNetwork())\n            .isInternational(binDetail.isInternational())\n            .build();\n\n        // 4. Determine payment method\n        PaymentInstrumentGroup method = binDetail.getCardType() == CREDIT\n            ? CREDIT_CARD : DEBIT_CARD;\n\n        return InstrumentTypeProcessorResult.builder()\n            .paymentMethod(method)\n            .paymentSubMethodDetail(buildSubMethodDetail(binDetail))\n            .enrichedPaymentInstrument(enriched)\n            .build();\n    }\n}\n```\n\n### InstrumentTypeProcessorResult\n\n```java\n@Data @Builder\npublic class InstrumentTypeProcessorResult<SubMethod, Enriched> {\n    private PaymentInstrumentGroup paymentMethod;  // CARD, UPI_PAY, NET_BANKING\n    private SubMethod paymentSubMethodDetail;       // CardPaymentSubMethodDetail\n    private Enriched enrichedPaymentInstrument;     // CardEnrichedPaymentInstrument\n    private InstrumentType instrumentType;          // CARD, UPI_APPS\n}\n```\n\n---\n\n## Distributed Locking\n\n### SequentialWorkflow Pattern\n**File:** `v2/workflow/create/SequentialWorkflow.java`\n\n```java\npublic abstract class SequentialWorkflow<Request, Response, Context>\n        extends Workflow<Request, Response, Context> {\n\n    @Override\n    public Response execute(Request request) {\n        LockSetting lockSetting = fetchLockSetting();\n        String lockKey = evaluateLockKey(request, lockSetting.getLockKey());\n\n        Optional<RLock> lock = Optional.empty();\n\n        try {\n            // Acquire Redis distributed lock\n            lock = redisLockUtil.acquireLock(lockKey, flowType);\n\n            if (lock.isPresent() || !lockSetting.getIsLockMandatory()) {\n                return super.execute(request);  // Run workflow\n            }\n\n            throw Error.unable_to_acquire_lock.getBuilder().build();\n\n        } finally {\n            lock.ifPresent(redisLockUtil::releaseLock);\n        }\n    }\n\n    protected abstract String evaluateLockKey(Request request, String keyTemplate);\n}\n```\n\n### Lock Settings\n\n```java\n@Data\npublic class LockSetting {\n    private String lockKey;           // Template: \"order:{orderId}\"\n    private Boolean isLockMandatory;  // Fail if can't acquire\n    private Long waitTimeMs;          // Time to wait for lock\n    private Long leaseTimeMs;         // Auto-release after\n}\n```\n\n### Use Cases\n\n| Workflow | Lock Key | Purpose |\n|----------|----------|---------|\n| PaymentAttemptCreate | `order:{orderId}` | Prevent concurrent attempts |\n| WebhookProcess | `attempt:{attemptId}` | Single webhook processing |\n| RefundCreate | `attempt:{attemptId}` | Sequential refunds |\n\n---\n\n## Event-Driven Architecture\n\n### Guava EventBus Setup\n\n```java\n@Configuration\npublic class EventBusConfiguration {\n\n    @Bean\n    public EventBus syncEventBus() {\n        return new EventBus(\"sync-payment-events\");\n    }\n\n    @Bean\n    public AsyncEventBus asyncEventBus() {\n        return new AsyncEventBus(\"async-payment-events\",\n            Executors.newFixedThreadPool(10));\n    }\n}\n```\n\n### Event Factory Pattern\n**File:** `statemachine/payment/events/PaymentAttemptEventFactory.java`\n\n```java\npublic class PaymentAttemptEventFactory {\n\n    public static PaymentAttemptEvent findEvent(PaymentAttemptV2Entity entity) {\n        switch (entity.getStatus()) {\n            case CREATED:\n                return new PaymentAttemptCreatedEvent(entity);\n            case PROCESSING:\n                return new PaymentAttemptProcessingEvent(entity);\n            case AUTHORIZED:\n                return new PaymentAttemptAuthorizedEvent(entity);\n            case COMPLETED:\n                return new PaymentAttemptCompletedEvent(entity);\n            case FAILED:\n            case FORCE_FAILED:\n                return new PaymentAttemptFailedEvent(entity);\n            case BLOCKED:\n                return new PaymentAttemptBlockedEvent(entity);\n            default:\n                return new PaymentAttemptUnknownEvent(entity);\n        }\n    }\n}\n```\n\n### Event Flow Diagram\n\n```\nPaymentAttemptCreateWorkflow\n         │\n         │ publishEntityChangeEvents()\n         │\n         ▼\n    syncEventBus.post(PaymentAttemptEvent)\n         │\n         ├────────────────────────────────────────┐\n         │                                        │\n         ▼                                        ▼\n┌─────────────────────┐              ┌─────────────────────┐\n│ PaymentStateMachine │              │ asyncEventBus.post()│\n│ @Subscribe methods  │              │ (Background tasks)  │\n└─────────────────────┘              └─────────────────────┘\n         │\n         │ Updates Payment status\n         │ postPaymentEvent(PaymentEvent)\n         │\n         ▼\n    syncEventBus.post(PaymentEvent)\n         │\n         ▼\n┌─────────────────────┐\n│ OrderStateMachine   │\n│ @Subscribe methods  │\n└─────────────────────┘\n         │\n         │ Updates Order status\n         │\n         ▼\n    Final state cascade complete\n```\n\n---\n\n## Key Payment Flow Files\n\n### Core Workflows\n1. `v2/workflow/create/Workflow.java` - Base template\n2. `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java` - Main flow\n3. `v2/workflow/create/payments/bulk/BulkPaymentCreateWorkflow.java` - Payment creation\n4. `v2/workflow/authenticate/PaymentAttemptAuthenticateWorkflow.java` - OTP auth\n\n### State Machines\n1. `statemachine/payment/PaymentStateMachine.java`\n2. `statemachine/order/OrderStateMachine.java`\n3. `statemachine/RefundStateMachine.java`\n\n### Instrument Processing\n1. `processors/instrumenttype/InstrumentTypeProcessorManager.java`\n2. `processors/instrumenttype/CardInstrumentTypeProcessor.java`\n3. `processors/instrumenttype/UPIPayInstrumentTypeProcessor.java`\n\n### Context & Events\n1. `v2/workflow/create/paymentattempts/PaymentAttemptCreateContext.java`\n2. `statemachine/payment/events/PaymentAttemptEventFactory.java`\n3. `statemachine/order/events/OrderEventFactory.java`\n\n### Locking & Sequencing\n1. `v2/workflow/create/SequentialWorkflow.java`\n2. `commons/lock/RedisLockUtil.java`\n\n---\n\n## Checkpoint\n\nAfter completing this section:\n- [ ] Understand the 7-step workflow pipeline\n- [ ] Know how PaymentAttemptCreateWorkflow works step by step\n- [ ] Understand state machine event cascading\n- [ ] Know 3DS and Native OTP authentication flows\n- [ ] Understand instrument processing\n- [ ] Know distributed locking patterns\n- [ ] Proceed to [05-key-files-reference.md](./05-key-files-reference.md)\n\n---\n\n*Next: [05 - Key Files Reference](./05-key-files-reference.md)*\n"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":36648,"cache_read_input_tokens":22528,"cache_creation":{"ephemeral_5m_input_tokens":36648,"ephemeral_1h_input_tokens":0},"output_tokens":3}},"type":"assistant","uuid":"d722c1f0-6b59-4870-a39f-8b48b7fbd67d","timestamp":"2025-12-31T10:07:35.194Z"}
{"parentUuid":"d722c1f0-6b59-4870-a39f-8b48b7fbd67d","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01KyvAv3ZU2CaxqbifNte8bu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_bdrk_01Ly9Nj5WyWVDTp6j5Jd2jnr","name":"Write","input":{"file_path":"/Users/kiranbiliyawala/code/cred/payments/payment-service/docs/study-guide/05-key-files-reference.md","content":"# 05 - Key Files Reference\n\n> **Purpose:** Quick lookup for all critical files in the codebase\n> **Usage:** Use this as a reference when debugging or exploring specific areas\n> **Next:** [06-study-path.md](./06-study-path.md)\n\n---\n\n## Table of Contents\n1. [Entry Point & Configuration](#entry-point--configuration)\n2. [Controllers (API Layer)](#controllers-api-layer)\n3. [Workflows (Business Logic)](#workflows-business-logic)\n4. [State Machines](#state-machines)\n5. [Entities (Data Model)](#entities-data-model)\n6. [Repositories (Data Access)](#repositories-data-access)\n7. [Provider Adapters](#provider-adapters)\n8. [Caches](#caches)\n9. [Processors](#processors)\n10. [Configuration Classes](#configuration-classes)\n11. [External Clients](#external-clients)\n12. [DynamoDB](#dynamodb)\n13. [Kafka & SQS](#kafka--sqs)\n14. [Filters & Security](#filters--security)\n15. [Error Handling](#error-handling)\n\n---\n\n## Entry Point & Configuration\n\n| File | Path | Purpose |\n|------|------|---------|\n| **DarwinApplication.java** | `DarwinApplication.java` | Main Spring Boot entry point |\n| **application.properties** | `src/main/resources/application.properties` | Main config (1300+ lines) |\n| **build.gradle** | `build.gradle` | Dependencies and build config |\n\n### DarwinApplication.java Key Annotations\n```java\n@SpringBootApplication\n@EnableRetry              // Spring Retry support\n@EntityScan(basePackages = {\"in.dreamplug\"})\n@EnableAspectJAutoProxy(exposeProxy = true)  // AOP proxying\n@EnableScheduling         // Scheduled tasks\n@ComponentScan(basePackages = {\"in.dreamplug\"})\n```\n\n---\n\n## Controllers (API Layer)\n\n### Primary V2 Controllers\n\n| Controller | Path | Endpoints |\n|------------|------|-----------|\n| **OrderV2Controller** | `controller/v2/order/OrderV2Controller.java` | Create/Get orders |\n| **PaymentV2Controller** | `controller/v2/payment/PaymentV2Controller.java` | Bulk payment creation |\n| **PaymentAttemptV2Controller** | `controller/v2/paymentattempt/PaymentAttemptV2Controller.java` | Payment attempts |\n\n### Webhook Controllers\n\n| Controller | Path | Provider |\n|------------|------|----------|\n| **WebhookController** | `controller/WebhookController.java` | Generic |\n| **CashfreeWebhookController** | `controller/v2/CashfreeWebhookController.java` | Cashfree |\n| **RazorpayWebhookController** | `controller/v2/RazorpayWebhookController.java` | Razorpay |\n| **PayuWebhookController** | `controller/v2/PayuWebhookController.java` | PayU |\n| **CybersourceWebhookController** | `controller/v2/CybersourceWebhookController.java` | Cybersource |\n| **JuspayWebhookController** | `controller/v2/JuspayWebhookController.java` | Juspay |\n| **YBLWebhookController** | `controller/v2/YBLWebhookController.java` | Yes Bank UPI |\n| **ICICIWebhookController** | `controller/v2/ICICIWebhookController.java` | ICICI UPI |\n| **RBLUpiWebhookController** | `controller/v2/RBLUpiWebhookController.java` | RBL UPI |\n| **DigioWebhookController** | `controller/v2/DigioWebhookController.java` | Digio |\n\n### Admin Controllers\n\n| Controller | Path | Purpose |\n|------------|------|---------|\n| **AdminOrderController** | `controller/admin/AdminOrderController.java` | Order management |\n| **AdminPaymentAttemptController** | `controller/admin/AdminPaymentAttemptController.java` | Attempt management |\n| **AdminRefundController** | `controller/admin/AdminRefundController.java` | Refund management |\n\n---\n\n## Workflows (Business Logic)\n\n### Base Workflows\n\n| File | Path | Purpose |\n|------|------|---------|\n| **Workflow.java** | `v2/workflow/create/Workflow.java` | Base 7-step template |\n| **SequentialWorkflow.java** | `v2/workflow/create/SequentialWorkflow.java` | With distributed locking |\n\n### Order Workflows\n\n| File | Path | Purpose |\n|------|------|---------|\n| **OrderCreateWorkflow** | `v2/workflow/create/order/OrderCreateWorkflow.java` | Order creation |\n| **OrderFetchWorkflow** | `v2/workflow/fetch/OrderFetchWorkflow.java` | Order retrieval |\n\n### Payment Workflows\n\n| File | Path | Purpose |\n|------|------|---------|\n| **BulkPaymentCreateWorkflow** | `v2/workflow/create/payments/bulk/BulkPaymentCreateWorkflow.java` | Bulk payment creation |\n| **PaymentFetchWorkflow** | `v2/workflow/fetch/PaymentFetchWorkflow.java` | Payment retrieval |\n\n### Payment Attempt Workflows\n\n| File | Path | Purpose |\n|------|------|---------|\n| **PaymentAttemptCreateWorkflow** | `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java` | **CRITICAL** - Main payment flow |\n| **PaymentAttemptCreateContext** | `v2/workflow/create/paymentattempts/PaymentAttemptCreateContext.java` | Context object |\n| **PaymentAttemptFetchWorkflow** | `v2/workflow/fetch/PaymentAttemptFetchWorkflow.java` | Attempt retrieval |\n| **PaymentAttemptSyncWorkflow** | `v2/workflow/sync/PaymentAttemptSyncWorkflow.java` | Status sync |\n\n### Authentication Workflows\n\n| File | Path | Purpose |\n|------|------|---------|\n| **PaymentAttemptAuthenticateWorkflow** | `v2/workflow/authenticate/PaymentAttemptAuthenticateWorkflow.java` | OTP/3DS auth |\n| **ValidateAuthenticationWorkflow** | `v2/workflow/authenticate/ValidateAuthenticationWorkflow.java` | Auth validation |\n\n### Refund Workflows\n\n| File | Path | Purpose |\n|------|------|---------|\n| **RefundCreateWorkflow** | `v2/workflow/create/refund/RefundCreateWorkflow.java` | Refund creation |\n| **RefundAttemptCreateWorkflow** | `v2/workflow/create/refund/RefundAttemptCreateWorkflow.java` | Refund attempt |\n\n---\n\n## State Machines\n\n| File | Path | Purpose |\n|------|------|---------|\n| **PaymentStateMachine** | `statemachine/payment/PaymentStateMachine.java` | Payment state transitions |\n| **OrderStateMachine** | `statemachine/order/OrderStateMachine.java` | Order state transitions |\n| **RefundStateMachine** | `statemachine/RefundStateMachine.java` | Refund state transitions |\n\n### Event Classes\n\n| File | Path | Purpose |\n|------|------|---------|\n| **PaymentAttemptEventFactory** | `statemachine/payment/events/PaymentAttemptEventFactory.java` | Event factory |\n| **PaymentAttemptCreatedEvent** | `statemachine/payment/events/PaymentAttemptCreatedEvent.java` | Created event |\n| **PaymentAttemptCompletedEvent** | `statemachine/payment/events/PaymentAttemptCompletedEvent.java` | Completed event |\n| **PaymentAttemptFailedEvent** | `statemachine/payment/events/PaymentAttemptFailedEvent.java` | Failed event |\n\n---\n\n## Entities (Data Model)\n\n### Base Entities\n\n| File | Path | Purpose |\n|------|------|---------|\n| **BaseEntity** | `entity/commons/BaseEntity.java` | Base with id, timestamps, audit |\n| **BaseExternalEntity** | `entity/provider/BaseExternalEntity.java` | + external_id, version |\n\n### Core Entities\n\n| File | Path | Table |\n|------|------|-------|\n| **OrderEntity** | `entity/OrderEntity.java` | `orders` |\n| **PaymentV2Entity** | `entity/v2/PaymentV2Entity.java` | `payments` |\n| **PaymentAttemptV2Entity** | `entity/v2/PaymentAttemptV2Entity.java` | `payment_attempts` |\n| **RefundEntity** | `entity/v2/RefundEntity.java` | `refunds` |\n| **RefundAttemptEntity** | `entity/v2/RefundAttemptEntity.java` | `refund_attempts` |\n| **FeeEntity** | `entity/v2/FeeEntity.java` | `fees` |\n\n### Configuration Entities\n\n| File | Path | Table |\n|------|------|-------|\n| **ClientEntity** | `entity/ClientEntity.java` | `clients` |\n| **CustomerEntity** | `entity/CustomerEntity.java` | `customers` |\n| **PaymentProviderEntity** | `entity/PaymentProviderEntity.java` | `payment_providers` |\n| **ProviderAccountEntity** | `entity/ProviderAccountEntity.java` | `provider_accounts` |\n| **MasterConfigurationEntity** | `entity/MasterConfigurationEntity.java` | `master_configurations` |\n\n### Attribute Entities\n\n| File | Path | Purpose |\n|------|------|---------|\n| **OrderAttributeEntity** | `entity/OrderAttributeEntity.java` | Order metadata |\n| **PaymentAttemptAttributeEntity** | `entity/PaymentAttemptAttributeEntity.java` | Attempt metadata |\n\n---\n\n## Repositories (Data Access)\n\n### JPA Repositories\n\n| File | Path | Entity |\n|------|------|--------|\n| **OrderRepository** | `repository/OrderRepository.java` | OrderEntity |\n| **PaymentRepository** | `repository/PaymentRepository.java` | PaymentV2Entity |\n| **PaymentAttemptRepository** | `repository/PaymentAttemptRepository.java` | PaymentAttemptV2Entity |\n| **RefundRepository** | `repository/RefundRepository.java` | RefundEntity |\n| **ClientRepository** | `repository/ClientRepository.java` | ClientEntity |\n| **CustomerRepository** | `repository/CustomerRepository.java` | CustomerEntity |\n| **PaymentProviderRepository** | `repository/PaymentProviderRepository.java` | PaymentProviderEntity |\n| **ProviderAccountRepository** | `repository/ProviderAccountRepository.java` | ProviderAccountEntity |\n\n### Custom DAOs\n\n| File | Path | Purpose |\n|------|------|---------|\n| **PaymentAttemptDAOV2Impl** | `repository/dao/PaymentAttemptDAOV2Impl.java` | Complex queries |\n| **RefundEntityReplicaDAOImpl** | `repository/read_only_repository/RefundEntityReplicaDAOImpl.java` | Replica reads |\n\n---\n\n## Provider Adapters\n\n### Base Classes\n\n| File | Path | Purpose |\n|------|------|---------|\n| **IPaymentProviderAdapter** | `v2/workflow/create/providers/IPaymentProviderAdapter.java` | Base adapter |\n| **I3DSPaymentProviderAdapter** | `v2/workflow/create/providers/I3DSPaymentProviderAdapter.java` | 3DS support |\n| **PaymentProviderFactory** | `v2/workflow/create/providers/PaymentProviderFactory.java` | Factory |\n\n### Provider Implementations\n\n| File | Path | Provider |\n|------|------|----------|\n| **CashfreeProviderAdapter** | `v2/workflow/create/providers/CashfreeProviderAdapter.java` | Cashfree base |\n| **CashfreeCardProviderAdapter** | `v2/workflow/create/providers/CashfreeCardProviderAdapter.java` | Cashfree cards |\n| **CashfreeUPIProviderAdapter** | `v2/workflow/create/providers/CashfreeUPIProviderAdapter.java` | Cashfree UPI |\n| **CybersourceProviderAdapter** | `v2/workflow/create/providers/cybersource/CybersourceProviderAdapter.java` | Cybersource |\n| **CybersourceRequestBuilder** | `v2/workflow/create/providers/cybersource/CybersourceRequestBuilder.java` | Request builder |\n| **PayuProviderAdapter** | `v2/workflow/create/providers/PayuProviderAdapter.java` | PayU |\n| **PineLabsEdgeProviderAdapter** | `v2/workflow/create/providers/PineLabsEdgeProviderAdapter.java` | Pine Labs |\n| **CredPointsProviderAdapter** | `v2/workflow/create/providers/CredPointsProviderAdapter.java` | CRED Points |\n\n### Provider Routing\n\n| File | Path | Purpose |\n|------|------|---------|\n| **ProviderDeciderRouter** | `planner/providerdecider/ProviderDeciderRouter.java` | Main router |\n| **ProviderDeciderV2** | `planner/providerdecider/ProviderDeciderV2.java` | Decision tree |\n| **ProviderDeciderViaLCM** | `planner/providerdecider/ProviderDeciderViaLCM.java` | LCM routing |\n\n---\n\n## Caches\n\n| File | Path | What It Caches |\n|------|------|----------------|\n| **ClientConfigurationCache** | `cache/ClientConfigurationCache.java` | Client settings |\n| **PaymentProviderCache** | `cache/PaymentProviderCache.java` | Provider configs |\n| **ProviderAccountCache** | `cache/ProviderAccountCache.java` | Provider accounts |\n| **DecisionTreeObjectCache** | `cache/DecisionTreeObjectCache.java` | Routing rules |\n| **CardBinCache** | `cache/CardBinCache.java` | Card BIN data |\n| **MerchantCache** | `cache/MerchantCache.java` | Merchant data |\n| **FeeCache** | `cache/FeeCache.java` | Fee configurations |\n| **MasterConfigurationCache** | `cache/MasterConfigurationCache.java` | Feature flags |\n| **PaymentErrorMessageMappingCache** | `cache/PaymentErrorMessageMappingCache.java` | Error messages |\n\n---\n\n## Processors\n\n### Instrument Processors\n\n| File | Path | Instrument |\n|------|------|------------|\n| **InstrumentTypeProcessorManager** | `processors/instrumenttype/InstrumentTypeProcessorManager.java` | Manager |\n| **CardInstrumentTypeProcessor** | `processors/instrumenttype/CardInstrumentTypeProcessor.java` | Cards |\n| **UPIPayInstrumentTypeProcessor** | `processors/instrumenttype/UPIPayInstrumentTypeProcessor.java` | UPI Pay |\n| **UPICollectInstrumentTypeProcessor** | `processors/instrumenttype/UPICollectInstrumentTypeProcessor.java` | UPI Collect |\n| **NetBankingInstrumentTypeProcessor** | `processors/instrumenttype/NetBankingInstrumentTypeProcessor.java` | NetBanking |\n\n### Auth Deciders\n\n| File | Path | Purpose |\n|------|------|---------|\n| **AuthTypeDeciderFactory** | `v2/workflow/create/paymentattempts/enrichment/AuthTypeDeciderFactory.java` | Auth type |\n| **SdkTypeDeciderFactory** | `v2/workflow/create/paymentattempts/enrichment/SdkTypeDeciderFactory.java` | SDK type |\n| **NativeProviderDecider** | `v2/workflow/create/paymentattempts/enrichment/NativeProviderDecider.java` | Native OTP |\n\n---\n\n## Configuration Classes\n\n### Database Configuration\n\n| File | Path | Purpose |\n|------|------|---------|\n| **MasterDataSourceConfiguration** | `configuration/database/MasterDataSourceConfiguration.java` | Master DB |\n| **ReplicaDataSourceConfiguration** | `configuration/database/ReplicaDataSourceConfiguration.java` | Replica DB |\n| **ReplicaRepository** | `configuration/database/annotation/ReplicaRepository.java` | Annotation |\n\n### Cache Configuration\n\n| File | Path | Purpose |\n|------|------|---------|\n| **CacheConfig** | `configuration/CacheConfig.java` | Caffeine setup |\n| **RedissonAutoConfiguration** | `configuration/RedissonAutoConfiguration.java` | Redis setup |\n\n### Other Configuration\n\n| File | Path | Purpose |\n|------|------|---------|\n| **EventBusConfiguration** | `configuration/EventBusConfiguration.java` | Guava EventBus |\n| **KafkaConfiguration** | `configuration/KafkaConfiguration.java` | Kafka setup |\n| **DynamoDBConfiguration** | `configuration/DynamoDBConfiguration.java` | DynamoDB setup |\n\n---\n\n## External Clients\n\n| File | Path | Service |\n|------|------|---------|\n| **ArsenalClient** | `client/arsenal/ArsenalClient.java` | Token vault |\n| **FalconClient** | `client/falcon/FalconClient.java` | Offers |\n| **LCMClient** | `client/lcm/LCMClient.java` | Terminal resolution |\n| **SyndicateClient** | `client/syndicate/SyndicateClient.java` | Authentication |\n| **NaradClient** | `client/narad/NaradClient.java` | Dynamic routing |\n| **InvokerClient** | `client/invoker/InvokerClient.java` | Task invocation |\n| **LeiaClient** | `client/leia/LeiaClient.java` | ID generation |\n| **VaultClient** | `client/vault/VaultClient.java` | Token vaulting |\n\n---\n\n## DynamoDB\n\n### DAOs\n\n| File | Path | Purpose |\n|------|------|---------|\n| **AbstractDynamoDBDAO** | `dynamo/dao/AbstractDynamoDBDAO.java` | Base DAO |\n| **PaymentAttemptWorkflowContextDAO** | `dynamo/dao/PaymentAttemptWorkflowContextDAO.java` | Workflow state |\n| **PaymentAttemptNativeOTPDetailDAO** | `dynamo/dao/PaymentAttemptNativeOTPDetailDAO.java` | OTP details |\n| **PaymentAttemptRedirectionDetailDAO** | `dynamo/dao/PaymentAttemptRedirectionDetailDAO.java` | 3DS redirects |\n\n### Entities\n\n| File | Path | Table |\n|------|------|-------|\n| **PaymentAttemptWorkflowContextEntity** | `dynamo/domain/PaymentAttemptWorkflowContextEntity.java` | `darwin_payment_attempt_workflow_context` |\n| **PaymentAttemptNativeOTPDetailEntity** | `dynamo/domain/PaymentAttemptNativeOTPDetailEntity.java` | `darwin_payment_attempt_native_otp_detail` |\n| **PaymentAttemptRedirectionDetailEntity** | `dynamo/domain/PaymentAttemptRedirectionDetailEntity.java` | `darwin_payment_attempt_redirection_detail` |\n| **PaymentAttemptMetadataAuditEntity** | `dynamo/domain/PaymentAttemptMetadataAuditEntity.java` | `darwin_payment_attempt_metadata_audit` |\n\n---\n\n## Kafka & SQS\n\n### Kafka\n\n| File | Path | Purpose |\n|------|------|---------|\n| **MessagingConfigs** | `kafka/MessagingConfigs.java` | Kafka config |\n| **PaymentAttemptAnalyticsEvent** | `kafka/dto/PaymentAttemptAnalyticsEvent.java` | Analytics event |\n| **CardPaymentAttemptAnalyticsEvent** | `kafka/dto/CardPaymentAttemptAnalyticsEvent.java` | Card analytics |\n\n### SQS\n\n| File | Path | Purpose |\n|------|------|---------|\n| **DarwinSQSMessageProcessor** | `sqs/DarwinSQSMessageProcessor.java` | Message processor |\n| **ForcePaymentFailureProcessor** | `sqs/ForcePaymentFailureProcessor.java` | Force failure |\n| **RefundRescheduleProcessor** | `sqs/RefundRescheduleProcessor.java` | Refund scheduling |\n| **OrderExpiryProcessor** | `sqs/OrderExpiryProcessor.java` | Order expiry |\n\n---\n\n## Filters & Security\n\n| File | Path | Purpose |\n|------|------|---------|\n| **ApplicationContextBuilderFilter** | `commons/spring/filters/ApplicationContextBuilderFilter.java` | Context building |\n| **PAMerchantAuthenticationFilter** | `commons/spring/filters/PAMerchantAuthenticationFilter.java` | Merchant auth |\n| **PAPartnerAuthorizationFilter** | `commons/spring/filters/PAPartnerAuthorizationFilter.java` | Partner auth |\n\n---\n\n## Error Handling\n\n| File | Path | Purpose |\n|------|------|---------|\n| **Error.java** | `error/Error.java` | Error enum |\n| **ProviderException** | `error/ProviderException.java` | Provider errors |\n| **AppException** | `error/AppException.java` | Application errors |\n| **GlobalExceptionHandler** | `error/GlobalExceptionHandler.java` | Exception handler |\n\n---\n\n## Quick Lookup by Topic\n\n### \"Where is X handled?\"\n\n| Topic | Key File |\n|-------|----------|\n| Payment creation | `PaymentAttemptCreateWorkflow.java` |\n| Provider selection | `ProviderDeciderRouter.java` |\n| 3DS authentication | `CybersourceProviderAdapter.java` |\n| State transitions | `PaymentStateMachine.java` |\n| Order status | `OrderStateMachine.java` |\n| Card BIN lookup | `CardInstrumentTypeProcessor.java` |\n| Client config | `ClientConfigurationCache.java` |\n| Webhooks | `*WebhookController.java` |\n| Database routing | `MasterDataSourceConfiguration.java` |\n| Distributed locks | `SequentialWorkflow.java` |\n\n---\n\n*Next: [06 - Study Path](./06-study-path.md)*\n"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":36648,"cache_read_input_tokens":22528,"cache_creation":{"ephemeral_5m_input_tokens":36648,"ephemeral_1h_input_tokens":0},"output_tokens":3}},"type":"assistant","uuid":"0c030493-98d8-4260-96d0-4badc78aadb1","timestamp":"2025-12-31T10:08:39.202Z"}
{"parentUuid":"0c030493-98d8-4260-96d0-4badc78aadb1","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01KyvAv3ZU2CaxqbifNte8bu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_bdrk_0117FQhLqZPXPSwRS5hait8u","name":"Write","input":{"file_path":"/Users/kiranbiliyawala/code/cred/payments/payment-service/docs/study-guide/06-study-path.md","content":"# 06 - Study Path\n\n> **Purpose:** Track your progress through the codebase learning journey\n> **Usage:** Check off items as you complete them\n> **Estimated Time:** 4 weeks (part-time study)\n\n---\n\n## How to Use This Guide\n\n1. Work through each week sequentially\n2. Check off items as you complete them\n3. Use this file to resume after breaks\n4. Refer to specific docs when working on related features\n\n---\n\n## Week 1: Foundation\n\n### Day 1-2: Setup & Overview\n\n- [ ] Read [README.md](./README.md) completely\n- [ ] Read [01-overview.md](./01-overview.md)\n- [ ] Clone and build the project (`./gradlew build`)\n- [ ] Explore `DarwinApplication.java`\n- [ ] Scan `application.properties` (first 200 lines)\n\n### Day 3-4: Project Structure\n\n- [ ] Map the directory structure mentally\n- [ ] Identify the V2 package as primary\n- [ ] Understand controller → service → workflow pattern\n- [ ] Review API endpoints table\n\n### Day 5: Core Concepts\n\n- [ ] Understand Order → Payment → PaymentAttempt hierarchy\n- [ ] Learn the 7-step workflow pattern\n- [ ] Study entity lifecycle states\n- [ ] Review internal service dependencies\n\n### Week 1 Checkpoint\n\n- [ ] **CHECKPOINT 1:** Can explain the tech stack\n- [ ] **CHECKPOINT 1:** Know the project structure\n- [ ] **CHECKPOINT 1:** Understand core payment hierarchy\n\n---\n\n## Week 2: Data Layer\n\n### Day 1-2: Entities\n\n- [ ] Read [02-data-layer.md](./02-data-layer.md)\n- [ ] Study `BaseEntity.java` and `BaseExternalEntity.java`\n- [ ] Review `OrderEntity.java` structure\n- [ ] Study `PaymentV2Entity.java` and relationships\n- [ ] Understand `PaymentAttemptV2Entity.java` (most complex)\n\n### Day 3: Database Architecture\n\n- [ ] Understand Master-Replica routing\n- [ ] Study `MasterDataSourceConfiguration.java`\n- [ ] Study `ReplicaDataSourceConfiguration.java`\n- [ ] Learn `@ReplicaRepository` usage\n\n### Day 4: Repositories & Queries\n\n- [ ] Review `OrderRepository.java` FETCH JOIN patterns\n- [ ] Study `PaymentAttemptRepository.java`\n- [ ] Understand DAO pattern with custom EntityManager\n\n### Day 5: Caching & DynamoDB\n\n- [ ] Study `ClientConfigurationCache.java`\n- [ ] Understand jittered TTL pattern\n- [ ] Review DynamoDB tables and entities\n- [ ] Study `AbstractDynamoDBDAO.java`\n\n### Week 2 Checkpoint\n\n- [ ] **CHECKPOINT 2:** Can explain entity hierarchy\n- [ ] **CHECKPOINT 2:** Know Master-Replica routing\n- [ ] **CHECKPOINT 2:** Understand caching patterns\n- [ ] **CHECKPOINT 2:** Know when MySQL vs DynamoDB\n\n---\n\n## Week 3: Provider Integration\n\n### Day 1-2: Adapter Architecture\n\n- [ ] Read [03-provider-integration.md](./03-provider-integration.md)\n- [ ] Study `IPaymentProviderAdapter.java`\n- [ ] Understand `PaymentProviderFactory.java`\n- [ ] Review adapter inheritance diagram\n\n### Day 3: Decision Tree Routing\n\n- [ ] Study `ProviderDeciderRouter.java`\n- [ ] Understand LCM vs Decision Tree routing\n- [ ] Review `DecisionTreeObjectCache.java`\n- [ ] Study decision factors\n\n### Day 4: Provider Implementations\n\n- [ ] Study `CashfreeProviderAdapter.java`\n- [ ] Review `CybersourceProviderAdapter.java` (3DS)\n- [ ] Understand two-phase payment creation\n- [ ] Study provider response mapping\n\n### Day 5: Webhooks\n\n- [ ] Review `WebhookController.java`\n- [ ] Study `CashfreeWebhookController.java`\n- [ ] Understand idempotency handling\n- [ ] Review webhook → state machine flow\n\n### Week 3 Checkpoint\n\n- [ ] **CHECKPOINT 3:** Can explain adapter pattern\n- [ ] **CHECKPOINT 3:** Know how provider routing works\n- [ ] **CHECKPOINT 3:** Understand webhook processing\n- [ ] **CHECKPOINT 3:** Know error handling patterns\n\n---\n\n## Week 4: Payment Flow & Advanced\n\n### Day 1-2: Workflow Deep-Dive\n\n- [ ] Read [04-payment-flow.md](./04-payment-flow.md)\n- [ ] Study `Workflow.java` template\n- [ ] Master `PaymentAttemptCreateWorkflow.java`\n- [ ] Understand context enrichment pipeline\n\n### Day 3: State Machines\n\n- [ ] Study `PaymentStateMachine.java`\n- [ ] Study `OrderStateMachine.java`\n- [ ] Understand event cascading\n- [ ] Review terminal states\n\n### Day 4: Authentication Flows\n\n- [ ] Understand 3DS redirect flow\n- [ ] Study Native OTP flow\n- [ ] Review `PaymentAttemptAuthenticateWorkflow.java`\n- [ ] Study DynamoDB OTP storage\n\n### Day 5: Advanced Patterns\n\n- [ ] Study `SequentialWorkflow.java` (distributed locks)\n- [ ] Review Guava EventBus setup\n- [ ] Understand instrument processing\n- [ ] Study async processing (Kafka, SQS)\n\n### Week 4 Checkpoint\n\n- [ ] **CHECKPOINT 4:** Can trace payment creation flow\n- [ ] **CHECKPOINT 4:** Understand state machine cascading\n- [ ] **CHECKPOINT 4:** Know authentication flows\n- [ ] **CHECKPOINT 4:** Understand distributed locking\n\n---\n\n## Expert Level Challenges\n\nAfter completing the 4 weeks, attempt these challenges:\n\n### Challenge 1: Trace a Card Payment\n\n- [ ] Start from `PaymentAttemptV2Controller`\n- [ ] Follow through `PaymentAttemptCreateWorkflow`\n- [ ] Trace provider adapter selection\n- [ ] Follow 3DS flow if triggered\n- [ ] Track state machine events\n- [ ] End at final order status\n\n### Challenge 2: Add a New Provider\n\n- [ ] Identify extension points\n- [ ] Create adapter extending `IPaymentProviderAdapter`\n- [ ] Register in `PaymentProviderFactory`\n- [ ] Add webhook controller\n- [ ] Implement status mapping\n\n### Challenge 3: Debug a Failed Payment\n\n- [ ] Find payment attempt by external_id\n- [ ] Check provider_status and error_code\n- [ ] Review DynamoDB workflow context\n- [ ] Check state machine logs\n- [ ] Identify root cause\n\n### Challenge 4: Optimize a Query\n\n- [ ] Identify N+1 query in codebase\n- [ ] Add FETCH JOIN\n- [ ] Consider caching\n- [ ] Evaluate replica usage\n\n### Expert Checkpoint\n\n- [ ] **CHECKPOINT 5:** Can trace any payment flow end-to-end\n- [ ] **CHECKPOINT 5:** Can debug production issues\n- [ ] **CHECKPOINT 5:** Can design new features\n- [ ] **CHECKPOINT 5:** Can optimize performance\n\n---\n\n## Quick Reference During Work\n\n### When Working On...\n\n| Task | Start Here |\n|------|------------|\n| Payment issues | [04-payment-flow.md](./04-payment-flow.md) |\n| Provider issues | [03-provider-integration.md](./03-provider-integration.md) |\n| Database issues | [02-data-layer.md](./02-data-layer.md) |\n| File lookup | [05-key-files-reference.md](./05-key-files-reference.md) |\n| General overview | [01-overview.md](./01-overview.md) |\n\n### Common Debug Paths\n\n```\nPayment stuck in PROCESSING:\n1. Check PaymentAttemptV2Entity.status\n2. Check provider_status\n3. Check DynamoDB workflow context\n4. Check PaymentStateMachine logs\n\nWebhook not processed:\n1. Check WebhookController logs\n2. Verify signature validation\n3. Check idempotency (status changed?)\n4. Check state machine subscription\n\nProvider routing failed:\n1. Check ProviderDeciderRouter logs\n2. Verify decision tree cache\n3. Check client configuration\n4. Verify provider account active\n\nCache stale data:\n1. Check cache TTL configuration\n2. Verify cache key generation\n3. Check for refresh triggers\n4. Consider manual invalidation\n```\n\n---\n\n## Progress Summary\n\n| Week | Status | Completion Date |\n|------|--------|-----------------|\n| Week 1: Foundation | ☐ Not Started | |\n| Week 2: Data Layer | ☐ Not Started | |\n| Week 3: Provider Integration | ☐ Not Started | |\n| Week 4: Payment Flow | ☐ Not Started | |\n| Expert Challenges | ☐ Not Started | |\n\n---\n\n## Notes Section\n\nUse this space to add your own notes as you study:\n\n### Week 1 Notes\n```\n[Your notes here]\n```\n\n### Week 2 Notes\n```\n[Your notes here]\n```\n\n### Week 3 Notes\n```\n[Your notes here]\n```\n\n### Week 4 Notes\n```\n[Your notes here]\n```\n\n### Questions to Research\n```\n[Your questions here]\n```\n\n### Key Insights\n```\n[Your insights here]\n```\n\n---\n\n*Good luck on your journey to becoming a Darwin expert!*\n\n---\n\n*Generated by Claude Code - December 2025*\n"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":36648,"cache_read_input_tokens":22528,"cache_creation":{"ephemeral_5m_input_tokens":36648,"ephemeral_1h_input_tokens":0},"output_tokens":25653}},"type":"assistant","uuid":"21c3962d-37ed-4406-95f8-35c6f05ec59f","timestamp":"2025-12-31T10:09:15.603Z"}
{"type":"file-history-snapshot","messageId":"3e04c7be-5f47-4406-8447-0e3c76af4a5f","snapshot":{"messageId":"333b6ac7-26fd-4722-980d-e319ce733bba","trackedFileBackups":{"/Users/kiranbiliyawala/.claude/plans/distributed-marinating-mango.md":{"backupFileName":"c92f53c9f6085692@v2","version":2,"backupTime":"2025-12-31T09:58:40.829Z"},"docs/study-guide/README.md":{"backupFileName":"3fd18aad0b0250d2@v1","version":1,"backupTime":"2025-12-31T10:00:15.742Z"},"docs/study-guide/01-overview.md":{"backupFileName":"676b1c94834531cf@v1","version":1,"backupTime":"2025-12-31T10:02:50.120Z"},"docs/study-guide/02-data-layer.md":{"backupFileName":"bc4de0d863c98472@v1","version":1,"backupTime":"2025-12-31T10:02:50.268Z"},"docs/study-guide/03-provider-integration.md":{"backupFileName":"ec08d6b3a8bf7e15@v1","version":1,"backupTime":"2025-12-31T10:09:17.968Z"}},"timestamp":"2025-12-31T09:58:40.824Z"},"isSnapshotUpdate":true}
{"parentUuid":"21c3962d-37ed-4406-95f8-35c6f05ec59f","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01Doh52dowH9yEGp7oK8pkNR","type":"tool_result","content":"File created successfully at: /Users/kiranbiliyawala/code/cred/payments/payment-service/docs/study-guide/03-provider-integration.md"}]},"uuid":"e0fcd16e-0129-4068-be6f-82b86d569298","timestamp":"2025-12-31T10:09:17.959Z","toolUseResult":{"type":"create","filePath":"/Users/kiranbiliyawala/code/cred/payments/payment-service/docs/study-guide/03-provider-integration.md","content":"# 03 - Provider Integration Deep-Dive\n\n> **Reading Time:** 75 minutes\n> **Prerequisites:** [02-data-layer.md](./02-data-layer.md)\n> **Next:** [04-payment-flow.md](./04-payment-flow.md)\n\n---\n\n## Table of Contents\n1. [Provider Adapter Architecture](#provider-adapter-architecture)\n2. [Factory Pattern for Adapter Selection](#factory-pattern-for-adapter-selection)\n3. [Decision Tree Routing](#decision-tree-routing)\n4. [Provider Implementations](#provider-implementations)\n5. [Webhook Handling](#webhook-handling)\n6. [Provider Configuration](#provider-configuration)\n7. [Error Handling & Retry Logic](#error-handling--retry-logic)\n\n---\n\n## Provider Adapter Architecture\n\n### Base Adapter Pattern\n**File:** `v2/workflow/create/providers/IPaymentProviderAdapter.java`\n\n```java\npublic abstract class IPaymentProviderAdapter<T, R> implements SelfReferencingBean {\n    protected final PaymentProviderKey paymentProviderKey;  // e.g., CASHFREE, CYBERSOURCE\n    private final InstrumentType instrumentType;            // e.g., CARD, UPI_APPS\n    private final OrderType orderType;                      // e.g., PAY, REFUND\n\n    // Core lifecycle methods\n    public abstract ProviderPaymentResponse createPaymentAttempt(context, customerEntity);\n    protected abstract Object syncPaymentAttemptWithProviderId(paymentAttemptEntity);\n    protected abstract ProviderRefundCreateResponse createRefund(refundAttemptEntity, context);\n    protected abstract R getAuthConfig(providerAccountEntity);\n}\n```\n\n### Provider Response Structure\n\n```java\n@Data @Builder\npublic class ProviderPaymentResponse {\n    private Object providerResponseObject;     // Raw provider response\n    private String providerReferenceId;        // Provider's transaction ID\n    private String gatewayReferenceId;         // Gateway ID\n    private String providerStatus;             // Raw status (\"SUCCESS\")\n    private PaymentAttemptStatus status;       // Mapped internal status\n    private ProviderRequestStatus providerRequestStatus;  // REQUEST_SUCCESS, RETRY_ABLE_FAILURE\n    private ProviderError providerError;       // Error details if failed\n}\n```\n\n### Adapter Inheritance Diagram\n\n```\nIPaymentProviderAdapter<T, R>\n    │\n    ├── CashfreeProviderAdapter\n    │       ├── CashfreeCardProviderAdapter\n    │       ├── CashfreeNetBankingProviderAdapter\n    │       ├── CashfreeUPIProviderAdapter\n    │       └── CashfreeUPIAppsProviderAdapter\n    │\n    ├── I3DSPaymentProviderAdapter\n    │       └── CybersourceProviderAdapter\n    │               ├── CybersourceCardProviderAdapter\n    │               └── CybersourceEMandateProviderAdapter\n    │\n    ├── PayuProviderAdapter\n    │       └── PayuCardProviderAdapter\n    │\n    ├── PineLabsEdgeProviderAdapter\n    │\n    ├── CredPointsProviderAdapter\n    │\n    └── AuthTokenNativeProviderAdapter\n```\n\n---\n\n## Factory Pattern for Adapter Selection\n\n### PaymentProviderFactory\n**File:** `v2/workflow/create/providers/PaymentProviderFactory.java`\n\n```java\n@Component\npublic class PaymentProviderFactory {\n    // Multi-dimensional lookup: OrderType + ProviderKey + InstrumentType → Adapter\n    private Map<PaymentWorkflowKey, IPaymentProviderAdapter<?, ?>> paymentProviderMap;\n\n    // Secondary lookup: OrderType + ProviderKey → First adapter\n    private Table<OrderType, PaymentProviderKey, IPaymentProviderAdapter<?, ?>> paymentProviderByKey;\n\n    // 3DS variant support\n    private ThreeDSType threeDSType;  // 3DS1 vs 3DS2\n\n    public IPaymentProviderAdapter<?, ?> findPaymentProviderAdapter(\n            OrderType orderType,\n            PaymentProviderKey providerKey,\n            InstrumentType instrumentType,\n            ThreeDSType threeDSType) {\n\n        PaymentWorkflowKey key = new PaymentWorkflowKey(\n            orderType, providerKey, instrumentType, threeDSType);\n\n        return paymentProviderMap.get(key);\n    }\n}\n```\n\n### PaymentWorkflowKey Structure\n\n```java\n@Value\npublic class PaymentWorkflowKey {\n    OrderType orderType;           // PAY, REFUND\n    PaymentProviderKey providerKey; // CASHFREE, CYBERSOURCE, etc.\n    InstrumentType instrumentType;  // CARD, UPI_APPS, NET_BANKING\n    ThreeDSType threeDSType;        // THREE_DS_1, THREE_DS_2, NONE\n}\n```\n\n---\n\n## Decision Tree Routing\n\n### Router Strategy Pattern\n**File:** `planner/providerdecider/ProviderDeciderRouter.java`\n\n```java\n@Service\npublic class ProviderDeciderRouter {\n    public ProviderRoutingDecisionResult resolve(PaymentAttemptCreateContext context) {\n        // Priority 1: LCM routing (if instrument supported)\n        if (isInstrumentTypeSupportedInLCM(clientId, instrumentType)) {\n            return providerDeciderViaLCM.decideProvider(context);\n        }\n\n        // Priority 2: Decision Tree routing\n        if (isDecisionTreeEnabled) {\n            return providerDeciderV2.decideProvider(context);\n        }\n\n        throw Error.provider_routing_failed.getBuilder().build();\n    }\n}\n```\n\n### Routing Flow Diagram\n\n```\nRequest\n    │\n    ▼\n┌─────────────────────────────┐\n│   ProviderDeciderRouter     │\n└─────────────────────────────┘\n    │\n    ├── Is LCM supported for instrument?\n    │       │\n    │       YES ──► ProviderDeciderViaLCM\n    │                   │\n    │                   └── Call LCM service for terminal resolution\n    │\n    NO\n    │\n    ▼\n┌─────────────────────────────┐\n│   ProviderDeciderV2         │\n│   (Decision Tree Routing)   │\n└─────────────────────────────┘\n    │\n    ├── Fetch cached Decision Tree\n    ├── Build DT Context from request\n    ├── Execute tree rules\n    ├── Apply dynamic routing (Narad)\n    │\n    ▼\n┌─────────────────────────────┐\n│  ProviderRoutingDecisionResult │\n│  ├── providerKey             │\n│  ├── providerAccountEntity   │\n│  ├── decisionTreeId          │\n│  └── routingMetadata         │\n└─────────────────────────────┘\n```\n\n### Decision Tree Caching\n**File:** `cache/DecisionTreeObjectCache.java`\n\n```java\n@Component\npublic class DecisionTreeObjectCache extends AbstractDPManagedCache {\n\n    @DPCache(cacheName = \"decision_tree_object_cache\")\n    private LoadingCache<Long, DecisionTreeWithWorkflow> cache;\n\n    @Override\n    public void buildCache() {\n        cache = DPCacheBuilder.getBuilder()\n            .refreshAfterWrite(\n                generateRandomCacheRefreshInterval(180),  // 180-190 min\n                TimeUnit.MINUTES)\n            .build(this::loadDecisionTree);\n    }\n\n    private DecisionTreeWithWorkflow loadDecisionTree(Long treeId) {\n        // Load JSON, parse rules, build workflow\n    }\n}\n```\n\n### Decision Tree Factors\n\n| Factor | Description |\n|--------|-------------|\n| Client ID | Which merchant/client |\n| Instrument Type | Card, UPI, NetBanking |\n| Card Brand | Visa, Mastercard, RuPay |\n| Card BIN | First 6-8 digits |\n| Card Type | Credit, Debit |\n| Amount | Transaction amount |\n| Currency | INR, USD |\n| Customer Attributes | VIP, risk score |\n| Provider Health | Uptime, success rate |\n\n---\n\n## Provider Implementations\n\n### Directory Structure\n\n```\nv2/workflow/create/providers/\n├── IPaymentProviderAdapter.java          # Base abstract class\n├── I3DSPaymentProviderAdapter.java       # 3DS base class\n├── PaymentProviderFactory.java           # Factory\n│\n├── CashfreeProviderAdapter.java          # Cashfree base\n├── CashfreeCardProviderAdapter.java\n├── CashfreeNetBankingProviderAdapter.java\n├── CashfreeUPIProviderAdapter.java\n├── CashfreeUPIAppsProviderAdapter.java\n│\n├── cybersource/\n│   ├── CybersourceProviderAdapter.java   # Cybersource base (3DS)\n│   ├── CybersourceRequestBuilder.java\n│   └── CybersourceAuthorizeRequestBuilder.java\n│\n├── PayuProviderAdapter.java\n├── PayuCardProviderAdapter.java\n│\n├── PineLabsEdgeProviderAdapter.java\n├── CredPointsProviderAdapter.java\n├── RewardPointsProviderAdapter.java\n└── AuthTokenNativeProviderAdapter.java\n```\n\n### Supported Providers\n\n| Provider | Payment Types | Key Features |\n|----------|---------------|--------------|\n| **Cashfree** | Cards, UPI, NetBanking | Two-phase order+payment |\n| **Cybersource** | Cards, 3DS, E-Mandates | 3DS1/3DS2, step-up auth |\n| **PayU** | Cards, NetBanking | Hash-based auth |\n| **Pine Labs** | Multiple modes | Edge integration |\n| **Razorpay** | All types | Via webhooks |\n| **Juspay** | Orchestration | Gateway aggregator |\n| **ICICI UPI** | UPI | Direct bank integration |\n| **Axis UPI** | UPI | Direct bank integration |\n| **YBL UPI** | UPI | Yes Bank |\n| **RBL UPI** | UPI | RBL Bank |\n| **Digio** | E-Mandates | eNACH registration |\n| **Cred Points** | Rewards | Point redemption |\n\n### Cashfree Adapter Example\n**File:** `v2/workflow/create/providers/CashfreeProviderAdapter.java`\n\n```java\n@Component\npublic abstract class CashfreeProviderAdapter\n        extends IPaymentProviderAdapter<String, CashfreeAuthConfig> {\n\n    @Override\n    public ProviderPaymentResponse createPaymentAttempt(\n            PaymentAttemptCreateContext context,\n            CustomerEntity customer) {\n\n        CashfreeAuthConfig authConfig = getAuthConfig(context.getProviderAccountEntity());\n\n        // Phase 1: Create Cashfree Order\n        Pair<BaseResponse<CreateOrderResponse>, ProviderError> orderResponse =\n            createCFOrder(context, authConfig);\n\n        if (orderResponse.getRight() != null) {\n            return buildErrorResponse(orderResponse.getRight());\n        }\n\n        // Phase 2: Create Cashfree Payment\n        Pair<BaseResponse<CreatePaymentResponse>, ProviderError> paymentResponse =\n            createCFPayment(context, orderResponse.getLeft().getResponse(), authConfig);\n\n        return mapToProviderPaymentResponse(paymentResponse);\n    }\n\n    protected abstract Pair<BaseResponse<CreatePaymentResponse>, ProviderError>\n        createCFPayment(context, orderResponse, authConfig);\n}\n```\n\n### Cybersource Adapter (3DS Support)\n**File:** `v2/workflow/create/providers/cybersource/CybersourceProviderAdapter.java`\n\n```java\n@Component\npublic abstract class CybersourceProviderAdapter\n        extends I3DSPaymentProviderAdapter<String, AuthConfig> {\n\n    // Status code mappings\n    private static final List<String> FAILED_STATUSES = Arrays.asList(\n        \"101\", \"102\", \"104\", \"150\", \"200\", \"201\", \"202\", \"203\",\n        \"204\", \"205\", \"207\", \"208\", \"209\", \"210\", \"211\", \"221\",\n        \"222\", \"230\", \"231\", \"232\", \"233\", \"234\", \"236\", \"240\",\n        \"250\", \"475\", \"476\", \"481\", \"520\", \"700\", \"701\", \"702\",\n        \"703\", \"704\", \"750\", \"751\", \"752\", \"777\"\n    );\n\n    private static final List<String> PROCESSING_STATUSES = Arrays.asList(\n        \"110\", \"475\", \"480\"\n    );\n\n    @Override\n    public ProviderPaymentResponse createPaymentAttempt(context, customer) {\n        // Build authorization request\n        CreatePaymentRequest request = cybersourceRequestBuilder\n            .buildAuthorizationRequest(context, customer);\n\n        // Execute API call\n        PtsV2PaymentsPost201Response response = apiClient.createPayment(request);\n\n        // Handle 3DS if required\n        if (requires3DS(response)) {\n            return handle3DSResponse(response, context);\n        }\n\n        return mapToProviderPaymentResponse(response);\n    }\n\n    // 3DS2 redirection flow\n    protected void createRedirectionHtml(response, paymentAttemptEntity) {\n        AuthenticationInfo authInfo = response.getConsumerAuthenticationInformation();\n\n        if (authInfo.getSpecificationVersion().startsWith(\"2\")) {\n            // 3DS2 flow with step-up URL\n            String html = authenticationService.createAuthenticationPageFor3ds2(\n                authInfo.getStepUpUrl(),\n                authInfo.getAccessToken(),\n                paymentAttemptEntity.getExternalId());\n\n            saveRedirectionDetail(paymentAttemptEntity, html);\n        }\n    }\n}\n```\n\n---\n\n## Webhook Handling\n\n### Webhook Architecture\n\n```\nProvider sends webhook\n         │\n         ▼\n┌─────────────────────────────────────┐\n│   /webhooks/v2/{provider}           │\n│   Provider-Specific Controller       │\n└─────────────────────────────────────┘\n         │\n         ▼\n┌─────────────────────────────────────┐\n│   Signature Verification            │\n│   (Provider-specific)               │\n└─────────────────────────────────────┘\n         │\n         ▼\n┌─────────────────────────────────────┐\n│   WebhookService                    │\n│   ├── Find PaymentAttempt           │\n│   ├── Audit webhook data            │\n│   └── Sync status with provider     │\n└─────────────────────────────────────┘\n         │\n         ▼\n┌─────────────────────────────────────┐\n│   State Machine Events              │\n│   ├── PaymentStateMachine           │\n│   └── OrderStateMachine             │\n└─────────────────────────────────────┘\n```\n\n### Webhook Controllers\n\n| Endpoint | Controller | Provider |\n|----------|------------|----------|\n| `/webhooks/v2/cashfree` | CashfreeWebhookController | Cashfree |\n| `/webhooks/v2/razorpay` | RazorpayWebhookController | Razorpay |\n| `/webhooks/v2/payu` | PayuWebhookController | PayU |\n| `/webhooks/v2/cybersource` | CybersourceWebhookController | Cybersource |\n| `/webhooks/v2/juspay` | JuspayWebhookController | Juspay |\n| `/webhooks/v2/ybl` | YBLWebhookController | Yes Bank UPI |\n| `/webhooks/v2/icici` | ICICIWebhookController | ICICI UPI |\n| `/webhooks/v2/rbl-upi` | RBLUpiWebhookController | RBL UPI |\n| `/webhooks/v2/digio` | DigioWebhookController | Digio |\n\n### Cashfree Webhook Example\n**File:** `controller/v2/CashfreeWebhookController.java`\n\n```java\n@RestController\n@RequestMapping(\"/webhooks/v2/cashfree\")\npublic class CashfreeWebhookController {\n\n    @PostMapping\n    public void onWebhookReceive(@RequestBody CashfreeWebhook webhookRequest) {\n        switch (webhookRequest.getType()) {\n            case PAYMENT_SUCCESS_WEBHOOK:\n            case PAYMENT_FAILED_WEBHOOK:\n                processPaymentWebhook(webhookRequest);\n                break;\n\n            case REFUND_STATUS_WEBHOOK:\n                processRefundWebhook(webhookRequest);\n                break;\n        }\n    }\n\n    private void processPaymentWebhook(CashfreeWebhook webhook) {\n        PaymentWebhookData data = webhook.getData();\n        String providerRefId = data.getCfPaymentId();\n\n        // 1. Fetch payment attempt by provider reference\n        PaymentAttemptV2Entity attempt = paymentAttemptFetchWorkflow\n            .fetchByProviderReferenceId(providerRefId);\n\n        // 2. Audit webhook data\n        auditService.auditProviderData(\n            webhook,\n            attempt.getId(),\n            AuditType.WEBHOOK);\n\n        // 3. Sync status (triggers state machine)\n        cashfreeProviderAdapter.syncPaymentAttemptWithWebhook(\n            attempt,\n            webhook);\n    }\n}\n```\n\n### Idempotency Handling\n\n```java\n// In base adapter - only process if status changed\npublic void syncPaymentAttemptWithProvider(PaymentAttemptV2Entity entity) {\n    String previousStatus = entity.getProviderStatus();\n\n    Object providerResponse = syncPaymentAttemptWithProviderId(entity);\n\n    // Only audit and trigger events if status actually changed\n    if (!Objects.equals(previousStatus, entity.getProviderStatus())) {\n        auditService.auditProviderData(providerResponse, entity.getId(), SYNC);\n        publishStatusChangeEvent(entity);\n    }\n}\n```\n\n---\n\n## Provider Configuration\n\n### ProviderAccountEntity\n**File:** `entity/ProviderAccountEntity.java`\n\n```java\n@Entity @Table(name = \"provider_accounts\")\npublic class ProviderAccountEntity extends BaseEntity {\n\n    @ManyToOne\n    @JoinColumn(name = \"payment_provider_id\")\n    private PaymentProviderEntity paymentProvider;\n\n    @Column(name = \"provider_account_id\")\n    private String providerAccountId;     // e.g., \"ACC_123456\"\n\n    @Lob\n    @Column(name = \"access_token\")\n    private byte[] accessToken;           // Encrypted credentials\n\n    @Column(name = \"endpoint\")\n    private String endpoint;              // Provider API endpoint\n\n    @Column(name = \"is_prod\")\n    private Boolean isProd;               // Production vs Sandbox\n\n    @Column(name = \"active\")\n    private Boolean active;\n\n    @Column(name = \"additional_config\")\n    private String additionalConfig;      // JSON configuration\n\n    @Column(name = \"provider_mid\")\n    private String providerMid;           // Merchant ID at provider\n\n    @Column(name = \"settlement_category\")\n    private String settlementCategory;    // Settlement routing\n}\n```\n\n### PaymentProviderEntity\n**File:** `entity/PaymentProviderEntity.java`\n\n```java\n@Entity @Table(name = \"payment_providers\")\npublic class PaymentProviderEntity extends BaseEntity {\n\n    @Column(name = \"name\")\n    private String name;                  // \"Cashfree\", \"Cybersource\"\n\n    @Enumerated(EnumType.STRING)\n    @Column(name = \"key\")\n    private PaymentProviderKey key;       // CASHFREE, CYBERSOURCE\n\n    @Column(name = \"active\")\n    private Boolean active;\n\n    @Convert(converter = SupportedInstrumentTypesConverter.class)\n    @Column(name = \"supported_instrument_types\")\n    private List<InstrumentType> supportedInstrumentTypes;\n}\n```\n\n### Provider-Specific Configurations\n\n```java\n// Cashfree Configuration\n@Data\npublic class CashfreeProviderAccountConfiguration {\n    private String apiClientId;\n    private String apiVersion;\n    private ShortCircuitConfiguration shortCircuitConfiguration;\n}\n\n// Cybersource Configuration\n@Data\npublic class CybersourceProviderAccountConfiguration {\n    private String apiKey;\n    private String merchantId;\n    private Boolean enableRetries = false;\n    private Boolean enableCaptureWithAuth = true;\n    private Boolean enable3DS2 = true;\n    private Boolean enableRedirectionFlow = false;\n    private Integer timeout = 30000;\n}\n\n// PayU Configuration\n@Data\npublic class PayuProviderAccountConfiguration {\n    private String merchantKey;\n    private String merchantSalt;\n    private String hashVersion;\n}\n```\n\n### Client-Provider Mapping\n**File:** `entity/ClientPaymentProviderConfigEntity.java`\n\n```java\n@Entity @Table(name = \"client_payment_provider_config\")\npublic class ClientPaymentProviderConfigEntity extends BaseEntity {\n\n    @ManyToOne\n    @JoinColumn(name = \"client_id\")\n    private ClientEntity client;\n\n    @ManyToOne\n    @JoinColumn(name = \"payment_provider_id\")\n    private PaymentProviderEntity paymentProvider;\n\n    @Column(name = \"provider_config\")\n    private String providerConfig;  // JSON - client-specific overrides\n\n    @Column(name = \"active\")\n    private Boolean active;\n}\n```\n\n---\n\n## Error Handling & Retry Logic\n\n### Error Classification\n\n```java\npublic enum ProviderRequestStatus {\n    REQUEST_SUCCESS,          // Payment processed successfully\n    RETRY_ABLE_FAILURE,       // Timeout, rate limit - can retry\n    NON_RETRY_ABLE_FAILURE    // Invalid request - cannot retry\n}\n```\n\n### Provider Error Structure\n\n```java\n@Data @Builder\npublic class ProviderError {\n    private String message;           // User-friendly message\n    private String code;              // Provider error code\n    private Object providerResponse;  // Raw error response\n    private Boolean retryable;        // Retry classification\n}\n```\n\n### Status Code Mapping (Cybersource)\n\n| Category | Codes | Meaning |\n|----------|-------|---------|\n| **Success** | 100 | Approved |\n| **Processing** | 110, 475, 480 | Pending, Timeout |\n| **Decline** | 200-236 | Various declines |\n| **System Error** | 150, 250, 520 | Internal errors |\n| **Authentication** | 475, 476 | 3DS issues |\n\n### Retry Pattern\n\n```java\npublic ProviderPaymentResponse executePaymentAttempt(\n        PaymentAttemptCreateContext context,\n        BiFunction<PaymentAttemptCreateContext, ProviderCustomer,\n                   ProviderPaymentResponse> pilotMethod,\n        FlowType flowType) {\n    try {\n        return pilotMethod.apply(context, providerCustomer);\n\n    } catch (RateLimitException rle) {\n        // Retryable - provider rate limited us\n        return ProviderPaymentResponse.builder()\n            .providerRequestStatus(RETRY_ABLE_FAILURE)\n            .providerError(ProviderError.builder()\n                .message(\"Rate limited, please retry\")\n                .retryable(true)\n                .build())\n            .build();\n\n    } catch (SocketTimeoutException ste) {\n        // Retryable - network timeout\n        return ProviderPaymentResponse.builder()\n            .providerRequestStatus(RETRY_ABLE_FAILURE)\n            .status(PaymentAttemptStatus.PROCESSING)\n            .build();\n\n    } catch (AppException ae) {\n        // Non-retryable - validation error\n        return ProviderPaymentResponse.builder()\n            .providerRequestStatus(NON_RETRY_ABLE_FAILURE)\n            .providerError(ProviderError.builder()\n                .message(ae.getMessage())\n                .retryable(false)\n                .build())\n            .build();\n    }\n}\n```\n\n### Circuit Breaker Configuration\n\n```java\n@Data\npublic class ShortCircuitConfiguration {\n    private Boolean enabled = false;\n    private Integer failureThreshold = 5;     // Failures before opening\n    private Integer successThreshold = 3;      // Successes to close\n    private Long waitDurationMs = 60000;       // Wait before half-open\n    private Integer permittedCalls = 10;       // Calls in half-open state\n}\n```\n\n---\n\n## Key Provider Integration Files\n\n### Core Architecture\n1. `v2/workflow/create/providers/IPaymentProviderAdapter.java` - Base adapter\n2. `v2/workflow/create/providers/PaymentProviderFactory.java` - Factory\n3. `planner/providerdecider/ProviderDeciderRouter.java` - Routing strategy\n\n### Decision Tree\n1. `planner/providerdecider/ProviderDeciderV2.java` - DT workflow\n2. `planner/providerdecider/ProviderDeciderViaLCM.java` - LCM routing\n3. `cache/DecisionTreeObjectCache.java` - DT caching\n\n### Webhooks\n1. `controller/WebhookController.java` - Generic webhook endpoint\n2. `controller/v2/CashfreeWebhookController.java` - Cashfree webhooks\n3. `service/WebhookService.java` - Webhook processing\n\n### Provider Implementations\n1. `v2/workflow/create/providers/CashfreeProviderAdapter.java`\n2. `v2/workflow/create/providers/cybersource/CybersourceProviderAdapter.java`\n3. `v2/workflow/create/providers/PayuProviderAdapter.java`\n\n### Configuration\n1. `entity/ProviderAccountEntity.java` - Provider credentials\n2. `entity/PaymentProviderEntity.java` - Provider definition\n3. `entity/ClientPaymentProviderConfigEntity.java` - Client-provider mapping\n\n---\n\n## Checkpoint\n\nAfter completing this section:\n- [ ] Understand adapter pattern and factory selection\n- [ ] Know how decision tree routing works\n- [ ] Understand webhook processing flow\n- [ ] Know error classification and retry patterns\n- [ ] Proceed to [04-payment-flow.md](./04-payment-flow.md)\n\n---\n\n*Next: [04 - Payment Flow](./04-payment-flow.md)*\n","structuredPatch":[],"originalFile":null}}
{"type":"file-history-snapshot","messageId":"d722c1f0-6b59-4870-a39f-8b48b7fbd67d","snapshot":{"messageId":"333b6ac7-26fd-4722-980d-e319ce733bba","trackedFileBackups":{"/Users/kiranbiliyawala/.claude/plans/distributed-marinating-mango.md":{"backupFileName":"c92f53c9f6085692@v2","version":2,"backupTime":"2025-12-31T09:58:40.829Z"},"docs/study-guide/README.md":{"backupFileName":"3fd18aad0b0250d2@v1","version":1,"backupTime":"2025-12-31T10:00:15.742Z"},"docs/study-guide/01-overview.md":{"backupFileName":"676b1c94834531cf@v1","version":1,"backupTime":"2025-12-31T10:02:50.120Z"},"docs/study-guide/02-data-layer.md":{"backupFileName":"bc4de0d863c98472@v1","version":1,"backupTime":"2025-12-31T10:02:50.268Z"},"docs/study-guide/03-provider-integration.md":{"backupFileName":"ec08d6b3a8bf7e15@v1","version":1,"backupTime":"2025-12-31T10:09:17.968Z"},"docs/study-guide/04-payment-flow.md":{"backupFileName":"3880d920c1011981@v1","version":1,"backupTime":"2025-12-31T10:09:18.024Z"}},"timestamp":"2025-12-31T09:58:40.824Z"},"isSnapshotUpdate":true}
{"parentUuid":"e0fcd16e-0129-4068-be6f-82b86d569298","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01R6KinaZ5eGsp5tSEAZ9YK7","type":"tool_result","content":"File created successfully at: /Users/kiranbiliyawala/code/cred/payments/payment-service/docs/study-guide/04-payment-flow.md"}]},"uuid":"360c750f-ea65-4847-8af4-37b0bfa7cc9d","timestamp":"2025-12-31T10:09:18.018Z","toolUseResult":{"type":"create","filePath":"/Users/kiranbiliyawala/code/cred/payments/payment-service/docs/study-guide/04-payment-flow.md","content":"# 04 - Payment Flow Deep-Dive\n\n> **Reading Time:** 90 minutes\n> **Prerequisites:** [03-provider-integration.md](./03-provider-integration.md)\n> **Next:** [05-key-files-reference.md](./05-key-files-reference.md)\n\n---\n\n## Table of Contents\n1. [The 7-Step Workflow Pipeline](#the-7-step-workflow-pipeline)\n2. [PaymentAttemptCreateWorkflow Detailed](#paymentattemptcreateworkflow-detailed)\n3. [State Machine Implementation](#state-machine-implementation)\n4. [End-to-End Payment Flow](#end-to-end-payment-flow)\n5. [3DS / Native OTP Authentication](#3ds--native-otp-authentication)\n6. [Instrument Processing](#instrument-processing)\n7. [Distributed Locking](#distributed-locking)\n8. [Event-Driven Architecture](#event-driven-architecture)\n\n---\n\n## The 7-Step Workflow Pipeline\n\n### Base Workflow Pattern (Template Method)\n**File:** `v2/workflow/create/Workflow.java`\n\n```java\npublic abstract class Workflow<Request, Response, Context> {\n\n    public Response execute(Request request) {\n        // STEP 1: Validate inputs and enrich context\n        Context context = validateAndEnrichContext(request);\n\n        // STEP 2: Persist to relational DB (transactional)\n        persistIntent(context);\n\n        // STEP 3: Pre-persist event hooks\n        publishEntityPrePersistEvents(context);\n\n        // STEP 4: Persist to non-relational DB (DynamoDB)\n        persistNonRelationalIntent(context);\n\n        // STEP 5: Process (external provider calls)\n        process(context);\n\n        // STEP 6: Post-process and save results (transactional)\n        Response response = postProcess(context);\n\n        // STEP 7: Post-persist & publish events\n        postPersistNonRelationalDataStore(context);\n        publishEntityChangeEvents(context);\n\n        throwErrorIfRequired(context);\n        return response;\n    }\n\n    // Abstract methods for subclasses to implement\n    protected abstract Context validateAndEnrichContext(Request request);\n    protected abstract void persistIntent(Context context);\n    protected abstract void process(Context context);\n    protected abstract Response postProcess(Context context);\n    protected abstract void publishEntityChangeEvents(Context context);\n}\n```\n\n### Step-by-Step Breakdown\n\n| Step | Method | Purpose | Transaction |\n|------|--------|---------|-------------|\n| 1 | `validateAndEnrichContext()` | Validate inputs, enrich with external data | None |\n| 2 | `persistIntent()` | Save entities to MySQL | Master TX |\n| 3 | `publishEntityPrePersistEvents()` | Pre-persist hooks | None |\n| 4 | `persistNonRelationalIntent()` | Save to DynamoDB | None |\n| 5 | `process()` | Call external provider APIs | None |\n| 6 | `postProcess()` | Update entities with response | Master TX |\n| 7 | `publishEntityChangeEvents()` | Trigger state machines, events | None |\n\n---\n\n## PaymentAttemptCreateWorkflow Detailed\n\n**File:** `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java`\n\n### Step 1: Validate & Enrich Context\n\n```java\n@Override\nprotected PaymentAttemptCreateContext validateAndEnrichContext(\n        CreatePaymentAttemptRequest request) {\n\n    PaymentAttemptCreateContext context = new PaymentAttemptCreateContext();\n    context.setRequest(request);\n\n    // 1. Fetch related entities\n    PaymentV2Entity payment = paymentRepository.findByExternalId(request.getPaymentId());\n    OrderEntity order = payment.getOrderEntity();\n    CustomerEntity customer = order.getCustomerEntity();\n    ClientEntity client = order.getClientEntity();\n\n    context.setPaymentEntity(payment);\n    context.setOrderEntity(order);\n    context.setCustomerEntity(customer);\n    context.setClientEntity(client);\n\n    // 2. Validate & enrich instrument\n    InstrumentTypeProcessorResult result = instrumentTypeProcessorManager\n        .validatePaymentInstrumentAndEnrich(request.getPaymentInstrument());\n    context.setInstrumentProcessorResult(result);\n\n    // 3. Route to provider via Decision Tree\n    ProviderRoutingDecisionResult routingResult = providerDeciderRouter\n        .resolve(context);\n    context.setRoutingDecisionResult(routingResult);\n    context.setProviderAccountEntity(routingResult.getProviderAccountEntity());\n\n    // 4. Determine auth type (3DS, OTP, None)\n    AuthType authType = authTypeDeciderFactory\n        .decideAuthType(context);\n    context.setAuthType(authType);\n\n    // 5. Validate settlement routes\n    RoutesBreakup routes = settlementRouteValidator\n        .validateAndEnrich(context);\n    context.setRoutesBreakup(routes);\n\n    // 6. Register mandate if eMandate flow\n    if (isEMandateFlow(context)) {\n        mandateServiceDataManager.registerMandate(context);\n    }\n\n    return context;\n}\n```\n\n### Enrichment Pipeline\n\n| Enricher | Input | Output |\n|----------|-------|--------|\n| `InstrumentTypeProcessorManager` | PaymentInstrument | BIN data, issuer, card type |\n| `ProviderDeciderRouter` | Context | Provider + Account |\n| `AuthTypeDeciderFactory` | Context | 3DS / OTP / None |\n| `NativeProviderDecider` | Context | Native OTP provider |\n| `SettlementRouteValidator` | Context | Routes breakup |\n| `MandateServiceDataManager` | Context | Mandate registration |\n\n### Context Object Structure\n\n```java\n@Data\npublic class PaymentAttemptCreateContext {\n    // Request/Response\n    private CreatePaymentAttemptRequest request;\n    private PaymentAttemptResponse response;\n\n    // Entities\n    private PaymentAttemptV2Entity paymentAttemptEntity;\n    private PaymentV2Entity paymentEntity;\n    private OrderEntity orderEntity;\n    private CustomerEntity customerEntity;\n    private ClientEntity clientEntity;\n\n    // Enriched Data\n    private InstrumentTypeProcessorResult instrumentProcessorResult;\n    private ProviderAccountEntity providerAccountEntity;\n    private ProviderRoutingDecisionResult routingDecisionResult;\n    private AuthType authType;\n    private RoutesBreakup routesBreakup;\n    private ProviderPaymentResponse createResponse;\n\n    // OTP/Auth Flow\n    private Boolean isPlatformNativeOtpSupported;\n    private PaymentAttemptNativeOTPDetailEntity nativeOTPDetailEntity;\n\n    // Error Collection\n    private List<WorkflowInternalError> errors = new ArrayList<>();\n}\n```\n\n### Step 2: Persist Intent\n\n```java\n@Override\n@Transactional(transactionManager = \"MasterTransactionManager\")\nprotected void persistIntent(PaymentAttemptCreateContext context) {\n\n    // Build PaymentAttemptV2Entity\n    PaymentAttemptV2Entity entity = PaymentAttemptV2Entity.builder()\n        .externalId(PaymentAttemptUUIdGenerator.generate())\n        .status(PaymentAttemptStatus.CREATED)\n        .paymentEntity(context.getPaymentEntity())\n        .orderId(context.getOrderEntity().getId())\n        .paymentProviderEntity(context.getRoutingDecisionResult().getPaymentProvider())\n        .providerAccountEntity(context.getProviderAccountEntity())\n        .paymentMethod(context.getInstrumentProcessorResult().getPaymentMethod())\n        .instrumentDetail(context.getInstrumentProcessorResult().getEnrichedInstrument())\n        .routesBreakup(context.getRoutesBreakup())\n        .build();\n\n    // Save to repository\n    paymentAttemptRepository.save(entity);\n    context.setPaymentAttemptEntity(entity);\n\n    // Save fees\n    List<FeeContext> feeContexts = buildFeeContexts(context);\n    feeCreateWorkflow.persistIntent(feeContexts);\n\n    // Add attributes (metadata)\n    enrichAttributes(entity, context);\n}\n\nprivate void enrichAttributes(PaymentAttemptV2Entity entity,\n                              PaymentAttemptCreateContext context) {\n    Set<PaymentAttemptAttributeEntity> attributes = new HashSet<>();\n\n    // Decision tree tracking\n    attributes.add(new PaymentAttemptAttributeEntity(\n        DT_ID, context.getRoutingDecisionResult().getDecisionTreeId()));\n    attributes.add(new PaymentAttemptAttributeEntity(\n        DT_RESULT, context.getRoutingDecisionResult().getDecisionPath()));\n\n    // Provider metadata\n    attributes.add(new PaymentAttemptAttributeEntity(\n        PROVIDER_KEY, context.getProviderAccountEntity().getPaymentProvider().getKey()));\n\n    entity.setAttributeEntities(attributes);\n}\n```\n\n### Step 5: Process (Provider Call)\n\n```java\n@Override\nprotected void process(PaymentAttemptCreateContext context) {\n\n    // Find the right adapter\n    IPaymentProviderAdapter adapter = paymentProviderFactory.findPaymentProviderAdapter(\n        context.getOrderEntity().getType(),           // PAY, REFUND\n        context.getRoutingDecisionResult().getProviderKey(),  // CASHFREE, etc.\n        context.getInstrumentProcessorResult().getInstrumentType(),  // CARD, UPI\n        context.getAuthType().getThreeDSType()        // 3DS1, 3DS2, NONE\n    );\n\n    // Execute provider call\n    ProviderPaymentResponse response = adapter.executePaymentAttempt(\n        context,\n        adapter::createPaymentAttempt,  // Method reference\n        FlowType.CREATE\n    );\n\n    // Check platform OTP capability\n    response = checkIfPlatformOtpEnabled(context, response);\n\n    context.setCreateResponse(response);\n}\n\nprivate ProviderPaymentResponse checkIfPlatformOtpEnabled(\n        PaymentAttemptCreateContext context,\n        ProviderPaymentResponse response) {\n\n    // If provider returned redirect but we support native OTP\n    if (response.getStatus() == AUTHENTICATION_REQUIRED\n            && context.getIsPlatformNativeOtpSupported()) {\n\n        // Override with SDK params for native OTP\n        CardNativeOTPSDKParamDetail sdkParams = CardNativeOTPSDKParamDetail.builder()\n            .authType(AuthType.NATIVE_OTP)\n            .challengeId(UUID.randomUUID().toString())\n            .fallbackUrl(response.getTransactionResponse().getAuthentication().getUrl())\n            .submitOTPAllowed(true)\n            .build();\n\n        response.getTransactionResponse().setSdkParams(sdkParams);\n    }\n\n    return response;\n}\n```\n\n### Step 6: Post-Process\n\n```java\n@Override\n@Transactional(transactionManager = \"MasterTransactionManager\")\nprotected PaymentAttemptResponse postProcess(PaymentAttemptCreateContext context) {\n\n    PaymentAttemptV2Entity entity = context.getPaymentAttemptEntity();\n    ProviderPaymentResponse response = context.getCreateResponse();\n\n    // Update from provider response\n    entity.setProviderStatus(response.getProviderStatus());\n    entity.setProviderReferenceId(response.getProviderReferenceId());\n    entity.setGatewayReferenceId(response.getGatewayReferenceId());\n\n    // Set error details if failed\n    if (response.getProviderError() != null) {\n        entity.setErrorCode(response.getProviderError().getCode());\n        entity.setErrorMessage(response.getProviderError().getMessage());\n    }\n\n    // Determine final status\n    if (response.getProviderRequestStatus() == REQUEST_SUCCESS) {\n        entity.setStatus(response.getStatus());\n    } else if (isEligibleForRetry(context)) {\n        // Set to PROCESSING for async status check\n        entity.setStatus(response.getStatus() == FAILED ? FAILED : PROCESSING);\n    }\n\n    // Save updated entity\n    paymentAttemptRepository.save(entity);\n\n    // Audit provider response\n    auditService.auditProviderData(\n        response.getProviderResponseObject(),\n        entity.getId(),\n        AuditType.CREATE_RESPONSE);\n\n    return mapper.toResponse(entity, response);\n}\n```\n\n### Step 7: Publish Events\n\n```java\n@Override\nprotected void publishEntityChangeEvents(PaymentAttemptCreateContext context) {\n    PaymentAttemptV2Entity entity = context.getPaymentAttemptEntity();\n\n    // 1. Post to synchronous EventBus (triggers PaymentStateMachine)\n    PaymentAttemptEvent event = PaymentAttemptEventFactory.findEvent(entity);\n    syncEventBus.post(event);\n\n    // 2. Post to asynchronous EventBus\n    asyncEventBus.post(event);\n\n    // 3. Publish to multi-tenant event system (client webhooks)\n    eventiService.publishEvent(entity);\n\n    // 4. Publish to analytics (Pinot)\n    eventiService.publishToPinot(buildAnalyticsEvent(entity));\n\n    // 5. Add to sync manager for webhook updates\n    paymentAttemptSyncManager.addEntityForSync(entity);\n}\n```\n\n---\n\n## State Machine Implementation\n\n### PaymentStateMachine\n**File:** `statemachine/payment/PaymentStateMachine.java`\n\n```java\n@Component\npublic class PaymentStateMachine {\n\n    @Subscribe\n    public void onPaymentAttemptCreated(PaymentAttemptCreatedEvent event) {\n        PaymentV2Entity payment = event.getPaymentAttemptEntity().getPaymentEntity();\n\n        if (payment.getStatus() == FAILED) {\n            // First attempt - change from FAILED to CREATED\n            payment.setStatus(CREATED);\n            paymentRepository.save(payment);\n            postPaymentEvent(payment, PaymentCreatedEvent.class);\n        }\n    }\n\n    @Subscribe\n    public void onPaymentAttemptFailed(PaymentAttemptFailedEvent event) {\n        PaymentV2Entity payment = event.getPaymentAttemptEntity().getPaymentEntity();\n\n        // Check if all attempts failed\n        boolean allAttemptsFailed = paymentAttemptRepository\n            .findByPaymentEntity_Id(payment.getId())\n            .stream()\n            .allMatch(a -> TERMINAL_FAILED_STATUSES.contains(a.getStatus()));\n\n        if (allAttemptsFailed && shouldUpdatePaymentStatus(payment)) {\n            payment.setStatus(FAILED);\n            paymentRepository.save(payment);\n            postPaymentEvent(payment, PaymentFailedEvent.class);\n        }\n    }\n\n    @Subscribe\n    @Retryable(maxAttempts = 3)  // Handle optimistic lock\n    public void onPaymentAttemptCompleted(PaymentAttemptCompletedEvent event) {\n        PaymentV2Entity payment = event.getPaymentAttemptEntity().getPaymentEntity();\n\n        if (shouldUpdatePaymentStatus(payment)) {\n            payment.setStatus(COMPLETED);\n            paymentRepository.save(payment);\n            postPaymentEvent(payment, PaymentCompletedEvent.class);\n        }\n    }\n\n    @Subscribe\n    public void onPaymentAttemptAuthorized(PaymentAttemptAuthorizedEvent event) {\n        PaymentV2Entity payment = event.getPaymentAttemptEntity().getPaymentEntity();\n\n        if (shouldUpdatePaymentStatus(payment)) {\n            payment.setStatus(AUTHORIZED);\n            paymentRepository.save(payment);\n            postPaymentEvent(payment, PaymentAuthorizedEvent.class);\n        }\n    }\n\n    @Subscribe\n    public void onPaymentAttemptProcessing(PaymentAttemptProcessingEvent event) {\n        PaymentV2Entity payment = event.getPaymentAttemptEntity().getPaymentEntity();\n\n        if (shouldUpdatePaymentStatus(payment)) {\n            payment.setStatus(PROCESSING);\n            paymentRepository.save(payment);\n            postPaymentEvent(payment, PaymentProcessingEvent.class);\n        }\n    }\n\n    private boolean shouldUpdatePaymentStatus(PaymentV2Entity entity) {\n        return !TERMINAL_STATUSES.contains(entity.getStatus());\n    }\n\n    private static final Set<PaymentStatus> TERMINAL_STATUSES = Set.of(\n        COMPLETED, FAILED, FORCE_FAILED, DISCARDED\n    );\n}\n```\n\n### OrderStateMachine\n**File:** `statemachine/order/OrderStateMachine.java`\n\n```java\n@Component\npublic class OrderStateMachine {\n\n    @Subscribe\n    public void onPaymentCreated(PaymentCreatedEvent event) {\n        OrderEntity order = event.getPaymentEntity().getOrderEntity();\n\n        if (order.getStatus() == OrderStatus.CREATED) {\n            // Check if authless flow\n            if (isAuthlessFlow(order)) {\n                order.setStatus(OrderStatus.AUTHLESS_READY_TO_PROCESS);\n            }\n            orderRepository.save(order);\n        }\n    }\n\n    @Subscribe\n    public void onPaymentFailed(PaymentFailedEvent event) {\n        OrderEntity order = event.getPaymentEntity().getOrderEntity();\n\n        // Check if all payments failed\n        boolean allPaymentsFailed = order.getPayments().stream()\n            .allMatch(p -> FAILED_STATUSES.contains(p.getStatus()));\n\n        if (allPaymentsFailed && shouldUpdateOrderStatus(order)) {\n            order.setStatus(OrderStatus.FAILED);\n            orderRepository.save(order);\n        }\n    }\n\n    @Subscribe\n    public void onPaymentCompleted(PaymentCompletedEvent event) {\n        OrderEntity order = event.getPaymentEntity().getOrderEntity();\n\n        // Check if all payments completed\n        boolean allPaymentsCompleted = order.getPayments().stream()\n            .allMatch(p -> p.getStatus() == PaymentStatus.COMPLETED);\n\n        if (allPaymentsCompleted && shouldUpdateOrderStatus(order)) {\n            order.setStatus(OrderStatus.COMPLETED);\n            orderRepository.save(order);\n        }\n    }\n\n    @Subscribe\n    public void onPaymentAuthorized(PaymentAuthorizedEvent event) {\n        OrderEntity order = event.getPaymentEntity().getOrderEntity();\n\n        if (shouldUpdateOrderStatus(order)) {\n            order.setStatus(OrderStatus.AUTHORIZED);\n            orderRepository.save(order);\n        }\n    }\n\n    @Subscribe\n    public void onPaymentProcessing(PaymentProcessingEvent event) {\n        OrderEntity order = event.getPaymentEntity().getOrderEntity();\n\n        if (shouldUpdateOrderStatus(order)) {\n            order.setStatus(OrderStatus.PROCESSING);\n            orderRepository.save(order);\n        }\n    }\n}\n```\n\n### State Transition Diagram\n\n```\nPaymentAttempt States:\n┌──────────────────────────────────────────────────────────────────┐\n│  CREATED ──► PROCESSING ──► AUTHORIZED ──► COMPLETED            │\n│      │           │              │                                │\n│      └───────────┴──────────────┴────► FAILED                   │\n│                                        FORCE_FAILED             │\n│                                        BLOCKED                  │\n└──────────────────────────────────────────────────────────────────┘\n\nPayment States:\n┌──────────────────────────────────────────────────────────────────┐\n│  CREATED ──► PROCESSING ──► AUTHORIZED ──► COMPLETED            │\n│      │           │              │                                │\n│      └───────────┴──────────────┴────► FAILED                   │\n│                                        FORCE_FAILED             │\n│                                        DISCARDED                │\n└──────────────────────────────────────────────────────────────────┘\n\nOrder States:\n┌──────────────────────────────────────────────────────────────────┐\n│  CREATED ──► PROCESSING ──► AUTHORIZED ──► COMPLETED            │\n│      │           │              │                                │\n│      └───────────┴──────────────┴────► FAILED                   │\n└──────────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## End-to-End Payment Flow\n\n### Complete Flow Diagram\n\n```\n┌─────────────────────────────────────────────────────────────────────────┐\n│                         CLIENT REQUEST                                   │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  1. ORDER CREATION                                                       │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ POST /v2/orders                                                     │ │\n│  │ OrderCreateWorkflow.execute()                                       │ │\n│  │ ├── validateAndEnrichContext() - Customer lookup, order validation │ │\n│  │ ├── persistIntent() - Save OrderEntity (status: CREATED)           │ │\n│  │ └── publishEvents() → OrderStateMachine                            │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  2. PAYMENT CREATION                                                     │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ POST /v2/orders/{orderId}/payments                                  │ │\n│  │ BulkPaymentCreateWorkflow.execute()                                 │ │\n│  │ ├── validateAndEnrichContext() - Payment mode validation           │ │\n│  │ ├── persistIntent() - Save PaymentV2Entity (status: CREATED)       │ │\n│  │ └── publishEvents() → PaymentStateMachine → OrderStateMachine      │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  3. PAYMENT ATTEMPT CREATION (Core Flow)                                 │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ POST /v2/payments/{paymentId}/attempts                              │ │\n│  │ PaymentAttemptCreateWorkflow.execute()                              │ │\n│  │ ├── validateAndEnrichContext()                                     │ │\n│  │ │   ├── InstrumentTypeProcessorManager (Card/UPI/NetBanking)       │ │\n│  │ │   ├── ProviderDeciderRouter (Decision Tree routing)              │ │\n│  │ │   ├── AuthTypeDeciderFactory (3DS/OTP/None)                      │ │\n│  │ │   └── SettlementRouteValidator                                   │ │\n│  │ ├── persistIntent() - Save PaymentAttemptV2Entity                  │ │\n│  │ ├── persistNonRelationalIntent() - DynamoDB (OTP details)          │ │\n│  │ ├── process() - Provider API call via Adapter                      │ │\n│  │ ├── postProcess() - Update entity with provider response           │ │\n│  │ └── publishEvents() → PaymentStateMachine → OrderStateMachine      │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n         ┌──────────────────────────┴──────────────────────────┐\n         ▼                                                      ▼\n┌─────────────────────────┐                    ┌─────────────────────────┐\n│  4A. 3DS/OTP FLOW       │                    │  4B. DIRECT SUCCESS     │\n│  ┌───────────────────┐  │                    │  ┌───────────────────┐  │\n│  │ Status:           │  │                    │  │ Status: COMPLETED │  │\n│  │ AUTHENTICATION_   │  │                    │  │ Payment done!     │  │\n│  │ REQUIRED          │  │                    │  └───────────────────┘  │\n│  └───────────────────┘  │                    └─────────────────────────┘\n│           │             │\n│           ▼             │\n│  Client performs auth   │\n│  (redirect/native OTP)  │\n│           │             │\n│           ▼             │\n│  POST /v2/authenticate  │\n│  PaymentAttempt         │\n│  AuthenticateWorkflow   │\n└─────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  5. WEBHOOK / SYNC UPDATE                                                │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ Provider sends webhook OR SyncManager polls status                  │ │\n│  │ ├── WebhookController receives update                              │ │\n│  │ ├── adapter.syncPaymentAttemptWithWebhook()                        │ │\n│  │ ├── Update PaymentAttemptV2Entity status                           │ │\n│  │ └── publishEvents() → State machines cascade updates               │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────┐\n│  6. FINAL STATE                                                          │\n│  ┌────────────────────────────────────────────────────────────────────┐ │\n│  │ PaymentAttempt: COMPLETED ──► Payment: COMPLETED ──► Order: COMPLETED│\n│  │                                                                     │ │\n│  │ eventiService.publishEvent() → Client webhook notification          │ │\n│  │ eventiService.publishToPinot() → Analytics dashboard               │ │\n│  └────────────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## 3DS / Native OTP Authentication\n\n### Native OTP Flow (Card Payments)\n\n```\n1. PaymentAttemptCreateWorkflow detects CARD + OTP-capable BIN\n         │\n         ▼\n2. wspService.isPlatformNativeOtpEnabled() returns true\n         │\n         ▼\n3. Provider returns redirect URL, but we override with SDK params\n         │\n         ▼\n4. CardNativeOTPSDKParamDetail created:\n   ├── authType: NATIVE_OTP\n   ├── challengeId: UUID\n   ├── fallbackUrl: Provider's original auth URL\n   └── submitOTPAllowed: true\n         │\n         ▼\n5. PaymentAttemptNativeOTPDetailEntity saved to DynamoDB\n         │\n         ▼\n6. Client submits OTP via PaymentAttemptAuthenticateWorkflow\n         │\n         ▼\n7. Provider validates OTP, returns success/failure\n         │\n         ▼\n8. State machines update payment/order status\n```\n\n### DynamoDB Entity for OTP\n\n```java\n@Data @Builder\n@DynamoDBTable(tableName = \"darwin_payment_attempt_native_otp_detail\")\npublic class PaymentAttemptNativeOTPDetailEntity {\n\n    @DynamoDBHashKey(attributeName = \"payment_attempt_external_id\")\n    private String paymentAttemptExternalId;\n\n    @DynamoDBAttribute(attributeName = \"challenge_id\")\n    private String challengeId;\n\n    @DynamoDBAttribute(attributeName = \"auth_type\")\n    private String authType;\n\n    @DynamoDBAttribute(attributeName = \"fallback_url\")\n    private String fallbackUrl;\n\n    @DynamoDBAttribute(attributeName = \"otp_submitted\")\n    private Boolean otpSubmitted;\n\n    @Builder.Default\n    private long ttl = LocalDateTime.now()\n        .plusDays(1)\n        .toEpochSecond(ZoneOffset.UTC);\n}\n```\n\n### 3DS Redirect Flow\n\n```\n1. Provider returns authentication URL\n         │\n         ▼\n2. Client redirects to issuer's 3DS page\n         │\n         ▼\n3. User completes authentication on issuer page\n         │\n         ▼\n4. Issuer redirects to return_url with callback data\n         │\n         ▼\n5. ValidateAuthenticationWorkflow processes callback\n         │\n         ▼\n6. Provider confirms authentication status\n         │\n         ▼\n7. State machines update accordingly\n```\n\n### Authentication Workflow\n**File:** `v2/workflow/authenticate/PaymentAttemptAuthenticateWorkflow.java`\n\n```java\n@Override\nprotected void process(PaymentAttemptAuthenticateContext context) {\n    PaymentAttemptV2Entity entity = context.getPaymentAttemptEntity();\n\n    // Find adapter\n    IPaymentProviderAdapter adapter = paymentProviderFactory\n        .findPaymentProviderAdapter(...);\n\n    // Submit OTP or process callback\n    if (context.isNativeOtpFlow()) {\n        adapter.submitOTP(entity, context.getOtp());\n    } else {\n        adapter.validateAuthentication(entity, context.getCallbackData());\n    }\n\n    // Sync status with provider\n    adapter.syncPaymentAttemptWithProviderId(entity);\n}\n```\n\n---\n\n## Instrument Processing\n\n### InstrumentTypeProcessorManager\n**File:** `processors/instrumenttype/InstrumentTypeProcessorManager.java`\n\n```java\n@Component\npublic class InstrumentTypeProcessorManager {\n\n    private Map<InstrumentType, IInstrumentTypeProcessor<?, ?, ?>> processorByType;\n\n    public InstrumentTypeProcessorResult validatePaymentInstrumentAndEnrich(\n            PaymentInstrument instrument) {\n\n        IInstrumentTypeProcessor processor = processorByType.get(instrument.getType());\n\n        if (processor == null) {\n            throw Error.unsupported_instrument_type.getBuilder().build();\n        }\n\n        return processor.validatePaymentInstrumentAndEnrich(instrument);\n    }\n}\n```\n\n### Processor Implementations\n\n| Processor | InstrumentType | Enrichment |\n|-----------|----------------|------------|\n| `CardInstrumentTypeProcessor` | CARD | BIN lookup, issuer, card type, network |\n| `UPIPayInstrumentTypeProcessor` | UPI_APPS | VPA validation, provider |\n| `UPICollectInstrumentTypeProcessor` | UPI_COLLECT | QR code, timeout |\n| `NetBankingInstrumentTypeProcessor` | NET_BANKING | Bank code, issuer |\n| `EMandateInstrumentTypeProcessor` | NET_BANKING_WITH_PI | Mandate details |\n\n### Card Instrument Processing\n**File:** `processors/instrumenttype/CardInstrumentTypeProcessor.java`\n\n```java\n@Component\npublic class CardInstrumentTypeProcessor\n        implements IInstrumentTypeProcessor<CardPaymentInstrument,\n                                           CardPaymentSubMethodDetail,\n                                           CardEnrichedPaymentInstrument> {\n\n    @Override\n    public InstrumentTypeProcessorResult<CardPaymentSubMethodDetail,\n                                         CardEnrichedPaymentInstrument>\n            validatePaymentInstrumentAndEnrich(CardPaymentInstrument instrument) {\n\n        // 1. Fetch card from Arsenal (tokenized vault)\n        CardVaultResponse cardData = arsenalClient.fetchCard(instrument.getToken());\n\n        // 2. Lookup BIN data\n        CardBinDetail binDetail = cardBinCache.getBinDetail(cardData.getBin());\n\n        // 3. Build enriched instrument\n        CardEnrichedPaymentInstrument enriched = CardEnrichedPaymentInstrument.builder()\n            .token(instrument.getToken())\n            .bin(cardData.getBin())\n            .last4(cardData.getLast4())\n            .cardType(binDetail.getCardType())        // CREDIT, DEBIT\n            .cardBrand(binDetail.getCardBrand())      // VISA, MASTERCARD\n            .issuingBank(binDetail.getIssuingBank())\n            .cardNetwork(binDetail.getNetwork())\n            .isInternational(binDetail.isInternational())\n            .build();\n\n        // 4. Determine payment method\n        PaymentInstrumentGroup method = binDetail.getCardType() == CREDIT\n            ? CREDIT_CARD : DEBIT_CARD;\n\n        return InstrumentTypeProcessorResult.builder()\n            .paymentMethod(method)\n            .paymentSubMethodDetail(buildSubMethodDetail(binDetail))\n            .enrichedPaymentInstrument(enriched)\n            .build();\n    }\n}\n```\n\n### InstrumentTypeProcessorResult\n\n```java\n@Data @Builder\npublic class InstrumentTypeProcessorResult<SubMethod, Enriched> {\n    private PaymentInstrumentGroup paymentMethod;  // CARD, UPI_PAY, NET_BANKING\n    private SubMethod paymentSubMethodDetail;       // CardPaymentSubMethodDetail\n    private Enriched enrichedPaymentInstrument;     // CardEnrichedPaymentInstrument\n    private InstrumentType instrumentType;          // CARD, UPI_APPS\n}\n```\n\n---\n\n## Distributed Locking\n\n### SequentialWorkflow Pattern\n**File:** `v2/workflow/create/SequentialWorkflow.java`\n\n```java\npublic abstract class SequentialWorkflow<Request, Response, Context>\n        extends Workflow<Request, Response, Context> {\n\n    @Override\n    public Response execute(Request request) {\n        LockSetting lockSetting = fetchLockSetting();\n        String lockKey = evaluateLockKey(request, lockSetting.getLockKey());\n\n        Optional<RLock> lock = Optional.empty();\n\n        try {\n            // Acquire Redis distributed lock\n            lock = redisLockUtil.acquireLock(lockKey, flowType);\n\n            if (lock.isPresent() || !lockSetting.getIsLockMandatory()) {\n                return super.execute(request);  // Run workflow\n            }\n\n            throw Error.unable_to_acquire_lock.getBuilder().build();\n\n        } finally {\n            lock.ifPresent(redisLockUtil::releaseLock);\n        }\n    }\n\n    protected abstract String evaluateLockKey(Request request, String keyTemplate);\n}\n```\n\n### Lock Settings\n\n```java\n@Data\npublic class LockSetting {\n    private String lockKey;           // Template: \"order:{orderId}\"\n    private Boolean isLockMandatory;  // Fail if can't acquire\n    private Long waitTimeMs;          // Time to wait for lock\n    private Long leaseTimeMs;         // Auto-release after\n}\n```\n\n### Use Cases\n\n| Workflow | Lock Key | Purpose |\n|----------|----------|---------|\n| PaymentAttemptCreate | `order:{orderId}` | Prevent concurrent attempts |\n| WebhookProcess | `attempt:{attemptId}` | Single webhook processing |\n| RefundCreate | `attempt:{attemptId}` | Sequential refunds |\n\n---\n\n## Event-Driven Architecture\n\n### Guava EventBus Setup\n\n```java\n@Configuration\npublic class EventBusConfiguration {\n\n    @Bean\n    public EventBus syncEventBus() {\n        return new EventBus(\"sync-payment-events\");\n    }\n\n    @Bean\n    public AsyncEventBus asyncEventBus() {\n        return new AsyncEventBus(\"async-payment-events\",\n            Executors.newFixedThreadPool(10));\n    }\n}\n```\n\n### Event Factory Pattern\n**File:** `statemachine/payment/events/PaymentAttemptEventFactory.java`\n\n```java\npublic class PaymentAttemptEventFactory {\n\n    public static PaymentAttemptEvent findEvent(PaymentAttemptV2Entity entity) {\n        switch (entity.getStatus()) {\n            case CREATED:\n                return new PaymentAttemptCreatedEvent(entity);\n            case PROCESSING:\n                return new PaymentAttemptProcessingEvent(entity);\n            case AUTHORIZED:\n                return new PaymentAttemptAuthorizedEvent(entity);\n            case COMPLETED:\n                return new PaymentAttemptCompletedEvent(entity);\n            case FAILED:\n            case FORCE_FAILED:\n                return new PaymentAttemptFailedEvent(entity);\n            case BLOCKED:\n                return new PaymentAttemptBlockedEvent(entity);\n            default:\n                return new PaymentAttemptUnknownEvent(entity);\n        }\n    }\n}\n```\n\n### Event Flow Diagram\n\n```\nPaymentAttemptCreateWorkflow\n         │\n         │ publishEntityChangeEvents()\n         │\n         ▼\n    syncEventBus.post(PaymentAttemptEvent)\n         │\n         ├────────────────────────────────────────┐\n         │                                        │\n         ▼                                        ▼\n┌─────────────────────┐              ┌─────────────────────┐\n│ PaymentStateMachine │              │ asyncEventBus.post()│\n│ @Subscribe methods  │              │ (Background tasks)  │\n└─────────────────────┘              └─────────────────────┘\n         │\n         │ Updates Payment status\n         │ postPaymentEvent(PaymentEvent)\n         │\n         ▼\n    syncEventBus.post(PaymentEvent)\n         │\n         ▼\n┌─────────────────────┐\n│ OrderStateMachine   │\n│ @Subscribe methods  │\n└─────────────────────┘\n         │\n         │ Updates Order status\n         │\n         ▼\n    Final state cascade complete\n```\n\n---\n\n## Key Payment Flow Files\n\n### Core Workflows\n1. `v2/workflow/create/Workflow.java` - Base template\n2. `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java` - Main flow\n3. `v2/workflow/create/payments/bulk/BulkPaymentCreateWorkflow.java` - Payment creation\n4. `v2/workflow/authenticate/PaymentAttemptAuthenticateWorkflow.java` - OTP auth\n\n### State Machines\n1. `statemachine/payment/PaymentStateMachine.java`\n2. `statemachine/order/OrderStateMachine.java`\n3. `statemachine/RefundStateMachine.java`\n\n### Instrument Processing\n1. `processors/instrumenttype/InstrumentTypeProcessorManager.java`\n2. `processors/instrumenttype/CardInstrumentTypeProcessor.java`\n3. `processors/instrumenttype/UPIPayInstrumentTypeProcessor.java`\n\n### Context & Events\n1. `v2/workflow/create/paymentattempts/PaymentAttemptCreateContext.java`\n2. `statemachine/payment/events/PaymentAttemptEventFactory.java`\n3. `statemachine/order/events/OrderEventFactory.java`\n\n### Locking & Sequencing\n1. `v2/workflow/create/SequentialWorkflow.java`\n2. `commons/lock/RedisLockUtil.java`\n\n---\n\n## Checkpoint\n\nAfter completing this section:\n- [ ] Understand the 7-step workflow pipeline\n- [ ] Know how PaymentAttemptCreateWorkflow works step by step\n- [ ] Understand state machine event cascading\n- [ ] Know 3DS and Native OTP authentication flows\n- [ ] Understand instrument processing\n- [ ] Know distributed locking patterns\n- [ ] Proceed to [05-key-files-reference.md](./05-key-files-reference.md)\n\n---\n\n*Next: [05 - Key Files Reference](./05-key-files-reference.md)*\n","structuredPatch":[],"originalFile":null}}
{"type":"file-history-snapshot","messageId":"0c030493-98d8-4260-96d0-4badc78aadb1","snapshot":{"messageId":"333b6ac7-26fd-4722-980d-e319ce733bba","trackedFileBackups":{"/Users/kiranbiliyawala/.claude/plans/distributed-marinating-mango.md":{"backupFileName":"c92f53c9f6085692@v2","version":2,"backupTime":"2025-12-31T09:58:40.829Z"},"docs/study-guide/README.md":{"backupFileName":"3fd18aad0b0250d2@v1","version":1,"backupTime":"2025-12-31T10:00:15.742Z"},"docs/study-guide/01-overview.md":{"backupFileName":"676b1c94834531cf@v1","version":1,"backupTime":"2025-12-31T10:02:50.120Z"},"docs/study-guide/02-data-layer.md":{"backupFileName":"bc4de0d863c98472@v1","version":1,"backupTime":"2025-12-31T10:02:50.268Z"},"docs/study-guide/03-provider-integration.md":{"backupFileName":"ec08d6b3a8bf7e15@v1","version":1,"backupTime":"2025-12-31T10:09:17.968Z"},"docs/study-guide/04-payment-flow.md":{"backupFileName":"3880d920c1011981@v1","version":1,"backupTime":"2025-12-31T10:09:18.024Z"},"docs/study-guide/05-key-files-reference.md":{"backupFileName":"f8129850f989174c@v1","version":1,"backupTime":"2025-12-31T10:09:18.087Z"}},"timestamp":"2025-12-31T09:58:40.824Z"},"isSnapshotUpdate":true}
{"parentUuid":"360c750f-ea65-4847-8af4-37b0bfa7cc9d","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01Ly9Nj5WyWVDTp6j5Jd2jnr","type":"tool_result","content":"File created successfully at: /Users/kiranbiliyawala/code/cred/payments/payment-service/docs/study-guide/05-key-files-reference.md"}]},"uuid":"2abea17e-c651-4729-8717-ec7120acb45a","timestamp":"2025-12-31T10:09:18.082Z","toolUseResult":{"type":"create","filePath":"/Users/kiranbiliyawala/code/cred/payments/payment-service/docs/study-guide/05-key-files-reference.md","content":"# 05 - Key Files Reference\n\n> **Purpose:** Quick lookup for all critical files in the codebase\n> **Usage:** Use this as a reference when debugging or exploring specific areas\n> **Next:** [06-study-path.md](./06-study-path.md)\n\n---\n\n## Table of Contents\n1. [Entry Point & Configuration](#entry-point--configuration)\n2. [Controllers (API Layer)](#controllers-api-layer)\n3. [Workflows (Business Logic)](#workflows-business-logic)\n4. [State Machines](#state-machines)\n5. [Entities (Data Model)](#entities-data-model)\n6. [Repositories (Data Access)](#repositories-data-access)\n7. [Provider Adapters](#provider-adapters)\n8. [Caches](#caches)\n9. [Processors](#processors)\n10. [Configuration Classes](#configuration-classes)\n11. [External Clients](#external-clients)\n12. [DynamoDB](#dynamodb)\n13. [Kafka & SQS](#kafka--sqs)\n14. [Filters & Security](#filters--security)\n15. [Error Handling](#error-handling)\n\n---\n\n## Entry Point & Configuration\n\n| File | Path | Purpose |\n|------|------|---------|\n| **DarwinApplication.java** | `DarwinApplication.java` | Main Spring Boot entry point |\n| **application.properties** | `src/main/resources/application.properties` | Main config (1300+ lines) |\n| **build.gradle** | `build.gradle` | Dependencies and build config |\n\n### DarwinApplication.java Key Annotations\n```java\n@SpringBootApplication\n@EnableRetry              // Spring Retry support\n@EntityScan(basePackages = {\"in.dreamplug\"})\n@EnableAspectJAutoProxy(exposeProxy = true)  // AOP proxying\n@EnableScheduling         // Scheduled tasks\n@ComponentScan(basePackages = {\"in.dreamplug\"})\n```\n\n---\n\n## Controllers (API Layer)\n\n### Primary V2 Controllers\n\n| Controller | Path | Endpoints |\n|------------|------|-----------|\n| **OrderV2Controller** | `controller/v2/order/OrderV2Controller.java` | Create/Get orders |\n| **PaymentV2Controller** | `controller/v2/payment/PaymentV2Controller.java` | Bulk payment creation |\n| **PaymentAttemptV2Controller** | `controller/v2/paymentattempt/PaymentAttemptV2Controller.java` | Payment attempts |\n\n### Webhook Controllers\n\n| Controller | Path | Provider |\n|------------|------|----------|\n| **WebhookController** | `controller/WebhookController.java` | Generic |\n| **CashfreeWebhookController** | `controller/v2/CashfreeWebhookController.java` | Cashfree |\n| **RazorpayWebhookController** | `controller/v2/RazorpayWebhookController.java` | Razorpay |\n| **PayuWebhookController** | `controller/v2/PayuWebhookController.java` | PayU |\n| **CybersourceWebhookController** | `controller/v2/CybersourceWebhookController.java` | Cybersource |\n| **JuspayWebhookController** | `controller/v2/JuspayWebhookController.java` | Juspay |\n| **YBLWebhookController** | `controller/v2/YBLWebhookController.java` | Yes Bank UPI |\n| **ICICIWebhookController** | `controller/v2/ICICIWebhookController.java` | ICICI UPI |\n| **RBLUpiWebhookController** | `controller/v2/RBLUpiWebhookController.java` | RBL UPI |\n| **DigioWebhookController** | `controller/v2/DigioWebhookController.java` | Digio |\n\n### Admin Controllers\n\n| Controller | Path | Purpose |\n|------------|------|---------|\n| **AdminOrderController** | `controller/admin/AdminOrderController.java` | Order management |\n| **AdminPaymentAttemptController** | `controller/admin/AdminPaymentAttemptController.java` | Attempt management |\n| **AdminRefundController** | `controller/admin/AdminRefundController.java` | Refund management |\n\n---\n\n## Workflows (Business Logic)\n\n### Base Workflows\n\n| File | Path | Purpose |\n|------|------|---------|\n| **Workflow.java** | `v2/workflow/create/Workflow.java` | Base 7-step template |\n| **SequentialWorkflow.java** | `v2/workflow/create/SequentialWorkflow.java` | With distributed locking |\n\n### Order Workflows\n\n| File | Path | Purpose |\n|------|------|---------|\n| **OrderCreateWorkflow** | `v2/workflow/create/order/OrderCreateWorkflow.java` | Order creation |\n| **OrderFetchWorkflow** | `v2/workflow/fetch/OrderFetchWorkflow.java` | Order retrieval |\n\n### Payment Workflows\n\n| File | Path | Purpose |\n|------|------|---------|\n| **BulkPaymentCreateWorkflow** | `v2/workflow/create/payments/bulk/BulkPaymentCreateWorkflow.java` | Bulk payment creation |\n| **PaymentFetchWorkflow** | `v2/workflow/fetch/PaymentFetchWorkflow.java` | Payment retrieval |\n\n### Payment Attempt Workflows\n\n| File | Path | Purpose |\n|------|------|---------|\n| **PaymentAttemptCreateWorkflow** | `v2/workflow/create/paymentattempts/PaymentAttemptCreateWorkflow.java` | **CRITICAL** - Main payment flow |\n| **PaymentAttemptCreateContext** | `v2/workflow/create/paymentattempts/PaymentAttemptCreateContext.java` | Context object |\n| **PaymentAttemptFetchWorkflow** | `v2/workflow/fetch/PaymentAttemptFetchWorkflow.java` | Attempt retrieval |\n| **PaymentAttemptSyncWorkflow** | `v2/workflow/sync/PaymentAttemptSyncWorkflow.java` | Status sync |\n\n### Authentication Workflows\n\n| File | Path | Purpose |\n|------|------|---------|\n| **PaymentAttemptAuthenticateWorkflow** | `v2/workflow/authenticate/PaymentAttemptAuthenticateWorkflow.java` | OTP/3DS auth |\n| **ValidateAuthenticationWorkflow** | `v2/workflow/authenticate/ValidateAuthenticationWorkflow.java` | Auth validation |\n\n### Refund Workflows\n\n| File | Path | Purpose |\n|------|------|---------|\n| **RefundCreateWorkflow** | `v2/workflow/create/refund/RefundCreateWorkflow.java` | Refund creation |\n| **RefundAttemptCreateWorkflow** | `v2/workflow/create/refund/RefundAttemptCreateWorkflow.java` | Refund attempt |\n\n---\n\n## State Machines\n\n| File | Path | Purpose |\n|------|------|---------|\n| **PaymentStateMachine** | `statemachine/payment/PaymentStateMachine.java` | Payment state transitions |\n| **OrderStateMachine** | `statemachine/order/OrderStateMachine.java` | Order state transitions |\n| **RefundStateMachine** | `statemachine/RefundStateMachine.java` | Refund state transitions |\n\n### Event Classes\n\n| File | Path | Purpose |\n|------|------|---------|\n| **PaymentAttemptEventFactory** | `statemachine/payment/events/PaymentAttemptEventFactory.java` | Event factory |\n| **PaymentAttemptCreatedEvent** | `statemachine/payment/events/PaymentAttemptCreatedEvent.java` | Created event |\n| **PaymentAttemptCompletedEvent** | `statemachine/payment/events/PaymentAttemptCompletedEvent.java` | Completed event |\n| **PaymentAttemptFailedEvent** | `statemachine/payment/events/PaymentAttemptFailedEvent.java` | Failed event |\n\n---\n\n## Entities (Data Model)\n\n### Base Entities\n\n| File | Path | Purpose |\n|------|------|---------|\n| **BaseEntity** | `entity/commons/BaseEntity.java` | Base with id, timestamps, audit |\n| **BaseExternalEntity** | `entity/provider/BaseExternalEntity.java` | + external_id, version |\n\n### Core Entities\n\n| File | Path | Table |\n|------|------|-------|\n| **OrderEntity** | `entity/OrderEntity.java` | `orders` |\n| **PaymentV2Entity** | `entity/v2/PaymentV2Entity.java` | `payments` |\n| **PaymentAttemptV2Entity** | `entity/v2/PaymentAttemptV2Entity.java` | `payment_attempts` |\n| **RefundEntity** | `entity/v2/RefundEntity.java` | `refunds` |\n| **RefundAttemptEntity** | `entity/v2/RefundAttemptEntity.java` | `refund_attempts` |\n| **FeeEntity** | `entity/v2/FeeEntity.java` | `fees` |\n\n### Configuration Entities\n\n| File | Path | Table |\n|------|------|-------|\n| **ClientEntity** | `entity/ClientEntity.java` | `clients` |\n| **CustomerEntity** | `entity/CustomerEntity.java` | `customers` |\n| **PaymentProviderEntity** | `entity/PaymentProviderEntity.java` | `payment_providers` |\n| **ProviderAccountEntity** | `entity/ProviderAccountEntity.java` | `provider_accounts` |\n| **MasterConfigurationEntity** | `entity/MasterConfigurationEntity.java` | `master_configurations` |\n\n### Attribute Entities\n\n| File | Path | Purpose |\n|------|------|---------|\n| **OrderAttributeEntity** | `entity/OrderAttributeEntity.java` | Order metadata |\n| **PaymentAttemptAttributeEntity** | `entity/PaymentAttemptAttributeEntity.java` | Attempt metadata |\n\n---\n\n## Repositories (Data Access)\n\n### JPA Repositories\n\n| File | Path | Entity |\n|------|------|--------|\n| **OrderRepository** | `repository/OrderRepository.java` | OrderEntity |\n| **PaymentRepository** | `repository/PaymentRepository.java` | PaymentV2Entity |\n| **PaymentAttemptRepository** | `repository/PaymentAttemptRepository.java` | PaymentAttemptV2Entity |\n| **RefundRepository** | `repository/RefundRepository.java` | RefundEntity |\n| **ClientRepository** | `repository/ClientRepository.java` | ClientEntity |\n| **CustomerRepository** | `repository/CustomerRepository.java` | CustomerEntity |\n| **PaymentProviderRepository** | `repository/PaymentProviderRepository.java` | PaymentProviderEntity |\n| **ProviderAccountRepository** | `repository/ProviderAccountRepository.java` | ProviderAccountEntity |\n\n### Custom DAOs\n\n| File | Path | Purpose |\n|------|------|---------|\n| **PaymentAttemptDAOV2Impl** | `repository/dao/PaymentAttemptDAOV2Impl.java` | Complex queries |\n| **RefundEntityReplicaDAOImpl** | `repository/read_only_repository/RefundEntityReplicaDAOImpl.java` | Replica reads |\n\n---\n\n## Provider Adapters\n\n### Base Classes\n\n| File | Path | Purpose |\n|------|------|---------|\n| **IPaymentProviderAdapter** | `v2/workflow/create/providers/IPaymentProviderAdapter.java` | Base adapter |\n| **I3DSPaymentProviderAdapter** | `v2/workflow/create/providers/I3DSPaymentProviderAdapter.java` | 3DS support |\n| **PaymentProviderFactory** | `v2/workflow/create/providers/PaymentProviderFactory.java` | Factory |\n\n### Provider Implementations\n\n| File | Path | Provider |\n|------|------|----------|\n| **CashfreeProviderAdapter** | `v2/workflow/create/providers/CashfreeProviderAdapter.java` | Cashfree base |\n| **CashfreeCardProviderAdapter** | `v2/workflow/create/providers/CashfreeCardProviderAdapter.java` | Cashfree cards |\n| **CashfreeUPIProviderAdapter** | `v2/workflow/create/providers/CashfreeUPIProviderAdapter.java` | Cashfree UPI |\n| **CybersourceProviderAdapter** | `v2/workflow/create/providers/cybersource/CybersourceProviderAdapter.java` | Cybersource |\n| **CybersourceRequestBuilder** | `v2/workflow/create/providers/cybersource/CybersourceRequestBuilder.java` | Request builder |\n| **PayuProviderAdapter** | `v2/workflow/create/providers/PayuProviderAdapter.java` | PayU |\n| **PineLabsEdgeProviderAdapter** | `v2/workflow/create/providers/PineLabsEdgeProviderAdapter.java` | Pine Labs |\n| **CredPointsProviderAdapter** | `v2/workflow/create/providers/CredPointsProviderAdapter.java` | CRED Points |\n\n### Provider Routing\n\n| File | Path | Purpose |\n|------|------|---------|\n| **ProviderDeciderRouter** | `planner/providerdecider/ProviderDeciderRouter.java` | Main router |\n| **ProviderDeciderV2** | `planner/providerdecider/ProviderDeciderV2.java` | Decision tree |\n| **ProviderDeciderViaLCM** | `planner/providerdecider/ProviderDeciderViaLCM.java` | LCM routing |\n\n---\n\n## Caches\n\n| File | Path | What It Caches |\n|------|------|----------------|\n| **ClientConfigurationCache** | `cache/ClientConfigurationCache.java` | Client settings |\n| **PaymentProviderCache** | `cache/PaymentProviderCache.java` | Provider configs |\n| **ProviderAccountCache** | `cache/ProviderAccountCache.java` | Provider accounts |\n| **DecisionTreeObjectCache** | `cache/DecisionTreeObjectCache.java` | Routing rules |\n| **CardBinCache** | `cache/CardBinCache.java` | Card BIN data |\n| **MerchantCache** | `cache/MerchantCache.java` | Merchant data |\n| **FeeCache** | `cache/FeeCache.java` | Fee configurations |\n| **MasterConfigurationCache** | `cache/MasterConfigurationCache.java` | Feature flags |\n| **PaymentErrorMessageMappingCache** | `cache/PaymentErrorMessageMappingCache.java` | Error messages |\n\n---\n\n## Processors\n\n### Instrument Processors\n\n| File | Path | Instrument |\n|------|------|------------|\n| **InstrumentTypeProcessorManager** | `processors/instrumenttype/InstrumentTypeProcessorManager.java` | Manager |\n| **CardInstrumentTypeProcessor** | `processors/instrumenttype/CardInstrumentTypeProcessor.java` | Cards |\n| **UPIPayInstrumentTypeProcessor** | `processors/instrumenttype/UPIPayInstrumentTypeProcessor.java` | UPI Pay |\n| **UPICollectInstrumentTypeProcessor** | `processors/instrumenttype/UPICollectInstrumentTypeProcessor.java` | UPI Collect |\n| **NetBankingInstrumentTypeProcessor** | `processors/instrumenttype/NetBankingInstrumentTypeProcessor.java` | NetBanking |\n\n### Auth Deciders\n\n| File | Path | Purpose |\n|------|------|---------|\n| **AuthTypeDeciderFactory** | `v2/workflow/create/paymentattempts/enrichment/AuthTypeDeciderFactory.java` | Auth type |\n| **SdkTypeDeciderFactory** | `v2/workflow/create/paymentattempts/enrichment/SdkTypeDeciderFactory.java` | SDK type |\n| **NativeProviderDecider** | `v2/workflow/create/paymentattempts/enrichment/NativeProviderDecider.java` | Native OTP |\n\n---\n\n## Configuration Classes\n\n### Database Configuration\n\n| File | Path | Purpose |\n|------|------|---------|\n| **MasterDataSourceConfiguration** | `configuration/database/MasterDataSourceConfiguration.java` | Master DB |\n| **ReplicaDataSourceConfiguration** | `configuration/database/ReplicaDataSourceConfiguration.java` | Replica DB |\n| **ReplicaRepository** | `configuration/database/annotation/ReplicaRepository.java` | Annotation |\n\n### Cache Configuration\n\n| File | Path | Purpose |\n|------|------|---------|\n| **CacheConfig** | `configuration/CacheConfig.java` | Caffeine setup |\n| **RedissonAutoConfiguration** | `configuration/RedissonAutoConfiguration.java` | Redis setup |\n\n### Other Configuration\n\n| File | Path | Purpose |\n|------|------|---------|\n| **EventBusConfiguration** | `configuration/EventBusConfiguration.java` | Guava EventBus |\n| **KafkaConfiguration** | `configuration/KafkaConfiguration.java` | Kafka setup |\n| **DynamoDBConfiguration** | `configuration/DynamoDBConfiguration.java` | DynamoDB setup |\n\n---\n\n## External Clients\n\n| File | Path | Service |\n|------|------|---------|\n| **ArsenalClient** | `client/arsenal/ArsenalClient.java` | Token vault |\n| **FalconClient** | `client/falcon/FalconClient.java` | Offers |\n| **LCMClient** | `client/lcm/LCMClient.java` | Terminal resolution |\n| **SyndicateClient** | `client/syndicate/SyndicateClient.java` | Authentication |\n| **NaradClient** | `client/narad/NaradClient.java` | Dynamic routing |\n| **InvokerClient** | `client/invoker/InvokerClient.java` | Task invocation |\n| **LeiaClient** | `client/leia/LeiaClient.java` | ID generation |\n| **VaultClient** | `client/vault/VaultClient.java` | Token vaulting |\n\n---\n\n## DynamoDB\n\n### DAOs\n\n| File | Path | Purpose |\n|------|------|---------|\n| **AbstractDynamoDBDAO** | `dynamo/dao/AbstractDynamoDBDAO.java` | Base DAO |\n| **PaymentAttemptWorkflowContextDAO** | `dynamo/dao/PaymentAttemptWorkflowContextDAO.java` | Workflow state |\n| **PaymentAttemptNativeOTPDetailDAO** | `dynamo/dao/PaymentAttemptNativeOTPDetailDAO.java` | OTP details |\n| **PaymentAttemptRedirectionDetailDAO** | `dynamo/dao/PaymentAttemptRedirectionDetailDAO.java` | 3DS redirects |\n\n### Entities\n\n| File | Path | Table |\n|------|------|-------|\n| **PaymentAttemptWorkflowContextEntity** | `dynamo/domain/PaymentAttemptWorkflowContextEntity.java` | `darwin_payment_attempt_workflow_context` |\n| **PaymentAttemptNativeOTPDetailEntity** | `dynamo/domain/PaymentAttemptNativeOTPDetailEntity.java` | `darwin_payment_attempt_native_otp_detail` |\n| **PaymentAttemptRedirectionDetailEntity** | `dynamo/domain/PaymentAttemptRedirectionDetailEntity.java` | `darwin_payment_attempt_redirection_detail` |\n| **PaymentAttemptMetadataAuditEntity** | `dynamo/domain/PaymentAttemptMetadataAuditEntity.java` | `darwin_payment_attempt_metadata_audit` |\n\n---\n\n## Kafka & SQS\n\n### Kafka\n\n| File | Path | Purpose |\n|------|------|---------|\n| **MessagingConfigs** | `kafka/MessagingConfigs.java` | Kafka config |\n| **PaymentAttemptAnalyticsEvent** | `kafka/dto/PaymentAttemptAnalyticsEvent.java` | Analytics event |\n| **CardPaymentAttemptAnalyticsEvent** | `kafka/dto/CardPaymentAttemptAnalyticsEvent.java` | Card analytics |\n\n### SQS\n\n| File | Path | Purpose |\n|------|------|---------|\n| **DarwinSQSMessageProcessor** | `sqs/DarwinSQSMessageProcessor.java` | Message processor |\n| **ForcePaymentFailureProcessor** | `sqs/ForcePaymentFailureProcessor.java` | Force failure |\n| **RefundRescheduleProcessor** | `sqs/RefundRescheduleProcessor.java` | Refund scheduling |\n| **OrderExpiryProcessor** | `sqs/OrderExpiryProcessor.java` | Order expiry |\n\n---\n\n## Filters & Security\n\n| File | Path | Purpose |\n|------|------|---------|\n| **ApplicationContextBuilderFilter** | `commons/spring/filters/ApplicationContextBuilderFilter.java` | Context building |\n| **PAMerchantAuthenticationFilter** | `commons/spring/filters/PAMerchantAuthenticationFilter.java` | Merchant auth |\n| **PAPartnerAuthorizationFilter** | `commons/spring/filters/PAPartnerAuthorizationFilter.java` | Partner auth |\n\n---\n\n## Error Handling\n\n| File | Path | Purpose |\n|------|------|---------|\n| **Error.java** | `error/Error.java` | Error enum |\n| **ProviderException** | `error/ProviderException.java` | Provider errors |\n| **AppException** | `error/AppException.java` | Application errors |\n| **GlobalExceptionHandler** | `error/GlobalExceptionHandler.java` | Exception handler |\n\n---\n\n## Quick Lookup by Topic\n\n### \"Where is X handled?\"\n\n| Topic | Key File |\n|-------|----------|\n| Payment creation | `PaymentAttemptCreateWorkflow.java` |\n| Provider selection | `ProviderDeciderRouter.java` |\n| 3DS authentication | `CybersourceProviderAdapter.java` |\n| State transitions | `PaymentStateMachine.java` |\n| Order status | `OrderStateMachine.java` |\n| Card BIN lookup | `CardInstrumentTypeProcessor.java` |\n| Client config | `ClientConfigurationCache.java` |\n| Webhooks | `*WebhookController.java` |\n| Database routing | `MasterDataSourceConfiguration.java` |\n| Distributed locks | `SequentialWorkflow.java` |\n\n---\n\n*Next: [06 - Study Path](./06-study-path.md)*\n","structuredPatch":[],"originalFile":null}}
{"type":"file-history-snapshot","messageId":"21c3962d-37ed-4406-95f8-35c6f05ec59f","snapshot":{"messageId":"333b6ac7-26fd-4722-980d-e319ce733bba","trackedFileBackups":{"/Users/kiranbiliyawala/.claude/plans/distributed-marinating-mango.md":{"backupFileName":"c92f53c9f6085692@v2","version":2,"backupTime":"2025-12-31T09:58:40.829Z"},"docs/study-guide/README.md":{"backupFileName":"3fd18aad0b0250d2@v1","version":1,"backupTime":"2025-12-31T10:00:15.742Z"},"docs/study-guide/01-overview.md":{"backupFileName":"676b1c94834531cf@v1","version":1,"backupTime":"2025-12-31T10:02:50.120Z"},"docs/study-guide/02-data-layer.md":{"backupFileName":"bc4de0d863c98472@v1","version":1,"backupTime":"2025-12-31T10:02:50.268Z"},"docs/study-guide/03-provider-integration.md":{"backupFileName":"ec08d6b3a8bf7e15@v1","version":1,"backupTime":"2025-12-31T10:09:17.968Z"},"docs/study-guide/04-payment-flow.md":{"backupFileName":"3880d920c1011981@v1","version":1,"backupTime":"2025-12-31T10:09:18.024Z"},"docs/study-guide/05-key-files-reference.md":{"backupFileName":"f8129850f989174c@v1","version":1,"backupTime":"2025-12-31T10:09:18.087Z"},"docs/study-guide/06-study-path.md":{"backupFileName":"bff2768a73842c11@v1","version":1,"backupTime":"2025-12-31T10:09:18.150Z"}},"timestamp":"2025-12-31T09:58:40.824Z"},"isSnapshotUpdate":true}
{"parentUuid":"2abea17e-c651-4729-8717-ec7120acb45a","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_0117FQhLqZPXPSwRS5hait8u","type":"tool_result","content":"File created successfully at: /Users/kiranbiliyawala/code/cred/payments/payment-service/docs/study-guide/06-study-path.md"}]},"uuid":"67aacc88-4372-4387-a920-75792502f2b8","timestamp":"2025-12-31T10:09:18.146Z","toolUseResult":{"type":"create","filePath":"/Users/kiranbiliyawala/code/cred/payments/payment-service/docs/study-guide/06-study-path.md","content":"# 06 - Study Path\n\n> **Purpose:** Track your progress through the codebase learning journey\n> **Usage:** Check off items as you complete them\n> **Estimated Time:** 4 weeks (part-time study)\n\n---\n\n## How to Use This Guide\n\n1. Work through each week sequentially\n2. Check off items as you complete them\n3. Use this file to resume after breaks\n4. Refer to specific docs when working on related features\n\n---\n\n## Week 1: Foundation\n\n### Day 1-2: Setup & Overview\n\n- [ ] Read [README.md](./README.md) completely\n- [ ] Read [01-overview.md](./01-overview.md)\n- [ ] Clone and build the project (`./gradlew build`)\n- [ ] Explore `DarwinApplication.java`\n- [ ] Scan `application.properties` (first 200 lines)\n\n### Day 3-4: Project Structure\n\n- [ ] Map the directory structure mentally\n- [ ] Identify the V2 package as primary\n- [ ] Understand controller → service → workflow pattern\n- [ ] Review API endpoints table\n\n### Day 5: Core Concepts\n\n- [ ] Understand Order → Payment → PaymentAttempt hierarchy\n- [ ] Learn the 7-step workflow pattern\n- [ ] Study entity lifecycle states\n- [ ] Review internal service dependencies\n\n### Week 1 Checkpoint\n\n- [ ] **CHECKPOINT 1:** Can explain the tech stack\n- [ ] **CHECKPOINT 1:** Know the project structure\n- [ ] **CHECKPOINT 1:** Understand core payment hierarchy\n\n---\n\n## Week 2: Data Layer\n\n### Day 1-2: Entities\n\n- [ ] Read [02-data-layer.md](./02-data-layer.md)\n- [ ] Study `BaseEntity.java` and `BaseExternalEntity.java`\n- [ ] Review `OrderEntity.java` structure\n- [ ] Study `PaymentV2Entity.java` and relationships\n- [ ] Understand `PaymentAttemptV2Entity.java` (most complex)\n\n### Day 3: Database Architecture\n\n- [ ] Understand Master-Replica routing\n- [ ] Study `MasterDataSourceConfiguration.java`\n- [ ] Study `ReplicaDataSourceConfiguration.java`\n- [ ] Learn `@ReplicaRepository` usage\n\n### Day 4: Repositories & Queries\n\n- [ ] Review `OrderRepository.java` FETCH JOIN patterns\n- [ ] Study `PaymentAttemptRepository.java`\n- [ ] Understand DAO pattern with custom EntityManager\n\n### Day 5: Caching & DynamoDB\n\n- [ ] Study `ClientConfigurationCache.java`\n- [ ] Understand jittered TTL pattern\n- [ ] Review DynamoDB tables and entities\n- [ ] Study `AbstractDynamoDBDAO.java`\n\n### Week 2 Checkpoint\n\n- [ ] **CHECKPOINT 2:** Can explain entity hierarchy\n- [ ] **CHECKPOINT 2:** Know Master-Replica routing\n- [ ] **CHECKPOINT 2:** Understand caching patterns\n- [ ] **CHECKPOINT 2:** Know when MySQL vs DynamoDB\n\n---\n\n## Week 3: Provider Integration\n\n### Day 1-2: Adapter Architecture\n\n- [ ] Read [03-provider-integration.md](./03-provider-integration.md)\n- [ ] Study `IPaymentProviderAdapter.java`\n- [ ] Understand `PaymentProviderFactory.java`\n- [ ] Review adapter inheritance diagram\n\n### Day 3: Decision Tree Routing\n\n- [ ] Study `ProviderDeciderRouter.java`\n- [ ] Understand LCM vs Decision Tree routing\n- [ ] Review `DecisionTreeObjectCache.java`\n- [ ] Study decision factors\n\n### Day 4: Provider Implementations\n\n- [ ] Study `CashfreeProviderAdapter.java`\n- [ ] Review `CybersourceProviderAdapter.java` (3DS)\n- [ ] Understand two-phase payment creation\n- [ ] Study provider response mapping\n\n### Day 5: Webhooks\n\n- [ ] Review `WebhookController.java`\n- [ ] Study `CashfreeWebhookController.java`\n- [ ] Understand idempotency handling\n- [ ] Review webhook → state machine flow\n\n### Week 3 Checkpoint\n\n- [ ] **CHECKPOINT 3:** Can explain adapter pattern\n- [ ] **CHECKPOINT 3:** Know how provider routing works\n- [ ] **CHECKPOINT 3:** Understand webhook processing\n- [ ] **CHECKPOINT 3:** Know error handling patterns\n\n---\n\n## Week 4: Payment Flow & Advanced\n\n### Day 1-2: Workflow Deep-Dive\n\n- [ ] Read [04-payment-flow.md](./04-payment-flow.md)\n- [ ] Study `Workflow.java` template\n- [ ] Master `PaymentAttemptCreateWorkflow.java`\n- [ ] Understand context enrichment pipeline\n\n### Day 3: State Machines\n\n- [ ] Study `PaymentStateMachine.java`\n- [ ] Study `OrderStateMachine.java`\n- [ ] Understand event cascading\n- [ ] Review terminal states\n\n### Day 4: Authentication Flows\n\n- [ ] Understand 3DS redirect flow\n- [ ] Study Native OTP flow\n- [ ] Review `PaymentAttemptAuthenticateWorkflow.java`\n- [ ] Study DynamoDB OTP storage\n\n### Day 5: Advanced Patterns\n\n- [ ] Study `SequentialWorkflow.java` (distributed locks)\n- [ ] Review Guava EventBus setup\n- [ ] Understand instrument processing\n- [ ] Study async processing (Kafka, SQS)\n\n### Week 4 Checkpoint\n\n- [ ] **CHECKPOINT 4:** Can trace payment creation flow\n- [ ] **CHECKPOINT 4:** Understand state machine cascading\n- [ ] **CHECKPOINT 4:** Know authentication flows\n- [ ] **CHECKPOINT 4:** Understand distributed locking\n\n---\n\n## Expert Level Challenges\n\nAfter completing the 4 weeks, attempt these challenges:\n\n### Challenge 1: Trace a Card Payment\n\n- [ ] Start from `PaymentAttemptV2Controller`\n- [ ] Follow through `PaymentAttemptCreateWorkflow`\n- [ ] Trace provider adapter selection\n- [ ] Follow 3DS flow if triggered\n- [ ] Track state machine events\n- [ ] End at final order status\n\n### Challenge 2: Add a New Provider\n\n- [ ] Identify extension points\n- [ ] Create adapter extending `IPaymentProviderAdapter`\n- [ ] Register in `PaymentProviderFactory`\n- [ ] Add webhook controller\n- [ ] Implement status mapping\n\n### Challenge 3: Debug a Failed Payment\n\n- [ ] Find payment attempt by external_id\n- [ ] Check provider_status and error_code\n- [ ] Review DynamoDB workflow context\n- [ ] Check state machine logs\n- [ ] Identify root cause\n\n### Challenge 4: Optimize a Query\n\n- [ ] Identify N+1 query in codebase\n- [ ] Add FETCH JOIN\n- [ ] Consider caching\n- [ ] Evaluate replica usage\n\n### Expert Checkpoint\n\n- [ ] **CHECKPOINT 5:** Can trace any payment flow end-to-end\n- [ ] **CHECKPOINT 5:** Can debug production issues\n- [ ] **CHECKPOINT 5:** Can design new features\n- [ ] **CHECKPOINT 5:** Can optimize performance\n\n---\n\n## Quick Reference During Work\n\n### When Working On...\n\n| Task | Start Here |\n|------|------------|\n| Payment issues | [04-payment-flow.md](./04-payment-flow.md) |\n| Provider issues | [03-provider-integration.md](./03-provider-integration.md) |\n| Database issues | [02-data-layer.md](./02-data-layer.md) |\n| File lookup | [05-key-files-reference.md](./05-key-files-reference.md) |\n| General overview | [01-overview.md](./01-overview.md) |\n\n### Common Debug Paths\n\n```\nPayment stuck in PROCESSING:\n1. Check PaymentAttemptV2Entity.status\n2. Check provider_status\n3. Check DynamoDB workflow context\n4. Check PaymentStateMachine logs\n\nWebhook not processed:\n1. Check WebhookController logs\n2. Verify signature validation\n3. Check idempotency (status changed?)\n4. Check state machine subscription\n\nProvider routing failed:\n1. Check ProviderDeciderRouter logs\n2. Verify decision tree cache\n3. Check client configuration\n4. Verify provider account active\n\nCache stale data:\n1. Check cache TTL configuration\n2. Verify cache key generation\n3. Check for refresh triggers\n4. Consider manual invalidation\n```\n\n---\n\n## Progress Summary\n\n| Week | Status | Completion Date |\n|------|--------|-----------------|\n| Week 1: Foundation | ☐ Not Started | |\n| Week 2: Data Layer | ☐ Not Started | |\n| Week 3: Provider Integration | ☐ Not Started | |\n| Week 4: Payment Flow | ☐ Not Started | |\n| Expert Challenges | ☐ Not Started | |\n\n---\n\n## Notes Section\n\nUse this space to add your own notes as you study:\n\n### Week 1 Notes\n```\n[Your notes here]\n```\n\n### Week 2 Notes\n```\n[Your notes here]\n```\n\n### Week 3 Notes\n```\n[Your notes here]\n```\n\n### Week 4 Notes\n```\n[Your notes here]\n```\n\n### Questions to Research\n```\n[Your questions here]\n```\n\n### Key Insights\n```\n[Your insights here]\n```\n\n---\n\n*Good luck on your journey to becoming a Darwin expert!*\n\n---\n\n*Generated by Claude Code - December 2025*\n","structuredPatch":[],"originalFile":null}}
{"parentUuid":"67aacc88-4372-4387-a920-75792502f2b8","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01SPTAhfcPgmrMooosd5PRko","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"All the documentation files have been created. Let me summarize what was created for the user.","signature":"EogCCkgICxABGAIqQL2T3QOYNfXDe8K4OXCAIYJLVR4/hPrm94WeZLWRccL/GO6DG/hxlm0tUgeTb9DhEaaUGfJXXVITdlpB7kVD3uMSDJUq39oAKj326LE1OBoMCOnWB8Z96hug0sAuIjAnpDKz7CwyzbVQknm0Tpl1ExibrZ03wZrs9JNMbcF0SzaA7KH3YsZoAJDsx/X0K9wqbmBMpiuc1XuYZ/5mU1PD2WPsIHh/ueDPV0i0zu8ieZusHJs2mfOROCIkkpqjky2LJKrLhd06WHUWtZs/+b3FhBQNPz1kNYZIQk+eunS8oVoRBSYrDPX4eltDPJoIUjiceKKTjTSBWBhSOfO6VXmZGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":65346,"cache_read_input_tokens":19463,"cache_creation":{"ephemeral_5m_input_tokens":65346,"ephemeral_1h_input_tokens":0},"output_tokens":1}},"type":"assistant","uuid":"19bed67d-b08e-4db9-929c-b7d800047c64","timestamp":"2025-12-31T10:09:25.674Z"}
{"parentUuid":"19bed67d-b08e-4db9-929c-b7d800047c64","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01SPTAhfcPgmrMooosd5PRko","type":"message","role":"assistant","content":[{"type":"text","text":"All documentation files have been created. Here's the complete study guide structure:\n\n## Documentation Created\n\n**Location:** `/Users/kiranbiliyawala/code/cred/payments/payment-service/docs/study-guide/`\n\n| File | Content | Lines |\n|------|---------|-------|\n| `README.md` | Main entry point, architecture overview, navigation | ~165 |\n| `01-overview.md` | Tech stack, project structure, API endpoints | ~450 |\n| `02-data-layer.md` | Entities, Master-Replica, caching, DynamoDB | ~685 |\n| `03-provider-integration.md` | Adapters, decision tree, webhooks, error handling | ~680 |\n| `04-payment-flow.md` | 7-step workflow, state machines, auth flows | ~800 |\n| `05-key-files-reference.md` | Quick lookup for 150+ files | ~400 |\n| `06-study-path.md` | 4-week learning path with checkboxes | ~350 |\n\n## How to Resume\n\n1. **Start each session** by reading `README.md` for quick context\n2. **Track progress** using `06-study-path.md` checkboxes\n3. **Quick file lookup** via `05-key-files-reference.md`\n4. **Deep dive** into specific topics using the numbered guides\n\n## Key Sections Covered\n\n- **Foundation:** Tech stack (Java 17, Spring Boot 2.7.14), project structure, core concepts\n- **Data Layer:** Entity hierarchy, Master-Replica DB, caching with jittered TTLs, DynamoDB\n- **Provider Integration:** 24+ provider adapters, decision tree routing, webhooks\n- **Payment Flow:** 7-step workflow pipeline, state machines, 3DS/OTP authentication\n\nThe plan file at `/Users/kiranbiliyawala/.claude/plans/distributed-marinating-mango.md` contains the full 42-section expert guide used to generate these documents."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":65346,"cache_read_input_tokens":19463,"cache_creation":{"ephemeral_5m_input_tokens":65346,"ephemeral_1h_input_tokens":0},"output_tokens":506}},"type":"assistant","uuid":"35b5143d-e628-4a15-b22e-7672745bb8b6","timestamp":"2025-12-31T10:09:33.791Z"}
{"type":"file-history-snapshot","messageId":"be5bd760-0206-49b4-8aa8-0b7d855cb08e","snapshot":{"messageId":"be5bd760-0206-49b4-8aa8-0b7d855cb08e","trackedFileBackups":{"/Users/kiranbiliyawala/.claude/plans/distributed-marinating-mango.md":{"backupFileName":"c92f53c9f6085692@v2","version":2,"backupTime":"2025-12-31T09:58:40.829Z"},"docs/study-guide/README.md":{"backupFileName":"3fd18aad0b0250d2@v1","version":1,"backupTime":"2025-12-31T10:00:15.742Z"},"docs/study-guide/01-overview.md":{"backupFileName":"676b1c94834531cf@v1","version":1,"backupTime":"2025-12-31T10:02:50.120Z"},"docs/study-guide/02-data-layer.md":{"backupFileName":"bc4de0d863c98472@v1","version":1,"backupTime":"2025-12-31T10:02:50.268Z"},"docs/study-guide/03-provider-integration.md":{"backupFileName":"ec08d6b3a8bf7e15@v1","version":1,"backupTime":"2025-12-31T10:09:17.968Z"},"docs/study-guide/04-payment-flow.md":{"backupFileName":"3880d920c1011981@v1","version":1,"backupTime":"2025-12-31T10:09:18.024Z"},"docs/study-guide/05-key-files-reference.md":{"backupFileName":"f8129850f989174c@v1","version":1,"backupTime":"2025-12-31T10:09:18.087Z"},"docs/study-guide/06-study-path.md":{"backupFileName":"bff2768a73842c11@v1","version":1,"backupTime":"2025-12-31T10:09:18.150Z"}},"timestamp":"2025-12-31T10:11:42.426Z"},"isSnapshotUpdate":false}
{"parentUuid":"35b5143d-e628-4a15-b22e-7672745bb8b6","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","type":"user","message":{"role":"user","content":"let's add the PROGRESS.md containing the whole study plan, along with document(s) references with each todo"},"uuid":"be5bd760-0206-49b4-8aa8-0b7d855cb08e","timestamp":"2025-12-31T10:11:42.418Z","thinkingMetadata":{"level":"high","disabled":false,"triggers":[]},"todos":[]}
{"parentUuid":"be5bd760-0206-49b4-8aa8-0b7d855cb08e","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01WBtGaoShQgEgFYkaFvE6iV","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user wants me to create a PROGRESS.md file that contains the whole study plan with document references for each todo item. This should be a comprehensive progress tracker that ties together all the documentation we created.","signature":"Eo4DCkgICxABGAIqQO6RSATuUY2Hm4kPZMtMhTrz7OL50VmPsJCJ6sMeDHd3Zc3Y/5vriz6XSCVLwh09PtpJay6f+r5qSqtohWzR31cSDOnn16J/QDfxwG8LQxoMZwgCbMBUiBfKqc3kIjDXvtNsEwTLqc/70SXPhruNCCw5F7dInE9j3IqS2iHC+NrxK77ScB56A+pPgJps/bsq8wFjC5b5tbu8+WMFge6IuzXM/DD6+gn9QuxNhOJq91itRpoXGNkcAbJouW03DUV6MHJ7Z57LNhjZjQV/eogJ8cLCbWNsEZN/86OTx0QacnLrXmRobR57Nw8bsLzDspwSCXzKMq2gU/n2zxEdv2yKtjyx189lzLLU7TbW963f/+txbRD7Kq3TA+GzKKWJW+Jii2G8f0LOIY1943Kz/7DF7zkjiSt5EeGUcaSgBOUn4nvkMbY8M0dYkdU9bFucIFtZRooaIpa9/AId8fwoup51JuzJu172/iyUdjRI6JTSIsyoeMEbDwTed2d4mYp7W4IS5w7qbsgYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":130,"cache_read_input_tokens":85320,"cache_creation":{"ephemeral_5m_input_tokens":130,"ephemeral_1h_input_tokens":0},"output_tokens":6}},"type":"assistant","uuid":"5d5b2c69-de1b-4a98-a041-dd0140595840","timestamp":"2025-12-31T10:12:08.521Z"}
{"parentUuid":"5d5b2c69-de1b-4a98-a041-dd0140595840","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01WBtGaoShQgEgFYkaFvE6iV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_bdrk_012M97dU9uhkrqin7VGi1wJU","name":"Write","input":{"file_path":"/Users/kiranbiliyawala/code/cred/payments/payment-service/docs/study-guide/PROGRESS.md","content":"# Payment Service (Darwin) - Study Progress Tracker\n\n> **Started:** _______________\n> **Target Completion:** 4 weeks from start\n> **Current Status:** Not Started\n\n---\n\n## Quick Links\n\n| Document | Purpose |\n|----------|---------|\n| [README.md](./README.md) | Start here - Overview & navigation |\n| [01-overview.md](./01-overview.md) | Tech stack, project structure |\n| [02-data-layer.md](./02-data-layer.md) | Database, entities, caching |\n| [03-provider-integration.md](./03-provider-integration.md) | Provider adapters, webhooks |\n| [04-payment-flow.md](./04-payment-flow.md) | Workflows, state machines |\n| [05-key-files-reference.md](./05-key-files-reference.md) | File lookup reference |\n| [06-study-path.md](./06-study-path.md) | Weekly breakdown |\n\n---\n\n## Overall Progress\n\n```\nWeek 1: Foundation          [░░░░░░░░░░] 0%\nWeek 2: Data Layer          [░░░░░░░░░░] 0%\nWeek 3: Provider Integration [░░░░░░░░░░] 0%\nWeek 4: Payment Flow        [░░░░░░░░░░] 0%\nExpert Challenges           [░░░░░░░░░░] 0%\n─────────────────────────────────────────\nTOTAL                       [░░░░░░░░░░] 0%\n```\n\n---\n\n# WEEK 1: FOUNDATION\n\n**Goal:** Understand the big picture - tech stack, structure, and core concepts\n\n## Day 1-2: Setup & Overview\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Read the main README and understand navigation | [README.md](./README.md) |\n| ☐ | Read the complete overview document | [01-overview.md](./01-overview.md) |\n| ☐ | Clone and build the project (`./gradlew build`) | - |\n| ☐ | Explore `DarwinApplication.java` entry point | [01-overview.md#entry-point](./01-overview.md) |\n| ☐ | Scan `application.properties` (first 200 lines) | [01-overview.md#configuration](./01-overview.md) |\n\n### Key Learnings Checklist\n- [ ] Know the server runs on port 9010 with context path `/payments`\n- [ ] Understand Java 17 + Spring Boot 2.7.14 stack\n- [ ] Know the main databases: MySQL (Master-Replica), DynamoDB, Redis\n\n## Day 3-4: Project Structure\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Map the directory structure mentally | [01-overview.md#project-structure](./01-overview.md) |\n| ☐ | Identify V2 package as primary implementation | [01-overview.md#project-structure](./01-overview.md) |\n| ☐ | Understand controller → service → workflow pattern | [01-overview.md#project-structure](./01-overview.md) |\n| ☐ | Review key directories: `controller/v2/`, `v2/workflow/`, `entity/v2/` | [05-key-files-reference.md](./05-key-files-reference.md) |\n\n### Key Directories to Know\n```\nsrc/main/java/in/dreamplug/darwin/\n├── controller/v2/      # REST endpoints\n├── v2/workflow/create/ # Core business logic\n├── entity/v2/          # JPA entities\n├── statemachine/       # State machines\n├── planner/            # Provider routing\n└── cache/              # Caching layer\n```\n\n## Day 5: Core Concepts\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Understand Order → Payment → PaymentAttempt hierarchy | [01-overview.md#core-concepts](./01-overview.md) |\n| ☐ | Learn the 7-step workflow pattern | [01-overview.md#core-concepts](./01-overview.md), [04-payment-flow.md#the-7-step-workflow-pipeline](./04-payment-flow.md) |\n| ☐ | Study entity lifecycle states (CREATED → PROCESSING → COMPLETED) | [01-overview.md#core-concepts](./01-overview.md) |\n| ☐ | Review internal service dependencies | [01-overview.md#internal-service-dependencies](./01-overview.md) |\n| ☐ | Understand authentication filters | [01-overview.md#authentication--security](./01-overview.md) |\n\n### Payment Hierarchy (Critical)\n```\nOrder (1)\n    └── Payment (M)\n            └── PaymentAttempt (M)\n                    └── RefundAttempt (M via Refund)\n```\n\n---\n\n## ✅ WEEK 1 CHECKPOINT\n\n| Status | Checkpoint Item |\n|--------|-----------------|\n| ☐ | Can explain the tech stack to someone |\n| ☐ | Know the project directory structure |\n| ☐ | Understand Order → Payment → PaymentAttempt relationship |\n| ☐ | Know what the 7-step workflow pattern is |\n| ☐ | Can find key files in the codebase |\n\n**Week 1 Completion Date:** _______________\n\n---\n\n# WEEK 2: DATA LAYER\n\n**Goal:** Master the database architecture, entities, and caching patterns\n\n## Day 1-2: Entities\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Read the complete data layer document | [02-data-layer.md](./02-data-layer.md) |\n| ☐ | Study `BaseEntity.java` (id, timestamps, audit) | [02-data-layer.md#base-classes](./02-data-layer.md) |\n| ☐ | Study `BaseExternalEntity.java` (external_id, version) | [02-data-layer.md#baseexternalentity](./02-data-layer.md) |\n| ☐ | Review `OrderEntity.java` structure | [02-data-layer.md#orderentity](./02-data-layer.md), [05-key-files-reference.md#core-entities](./05-key-files-reference.md) |\n| ☐ | Study `PaymentV2Entity.java` and relationships | [02-data-layer.md#core-entities](./02-data-layer.md) |\n| ☐ | Understand `PaymentAttemptV2Entity.java` (most complex) | [02-data-layer.md#paymentattemptv2entity](./02-data-layer.md) |\n\n### Entity Inheritance\n```\nBaseEntity (id, created_at, updated_at, created_by, updated_by)\n    └── BaseExternalEntity (+ external_id UUID, @Version)\n            ├── OrderEntity\n            ├── PaymentV2Entity\n            ├── PaymentAttemptV2Entity\n            ├── RefundEntity\n            └── ClientEntity\n```\n\n## Day 3: Database Architecture\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Understand Master-Replica routing concept | [02-data-layer.md#master-replica-architecture](./02-data-layer.md) |\n| ☐ | Study `MasterDataSourceConfiguration.java` | [02-data-layer.md#configuration-files](./02-data-layer.md), [05-key-files-reference.md#database-configuration](./05-key-files-reference.md) |\n| ☐ | Study `ReplicaDataSourceConfiguration.java` | [02-data-layer.md#configuration-files](./02-data-layer.md) |\n| ☐ | Learn `@ReplicaRepository` annotation usage | [02-data-layer.md#usage-pattern](./02-data-layer.md) |\n| ☐ | Understand HikariCP connection pools | [02-data-layer.md#hikaricp-pool-configuration](./02-data-layer.md) |\n\n### Master-Replica Pattern\n```java\n// Writes go to Master (default)\n@Repository\npublic interface PaymentRepository extends JpaRepository<...> {}\n\n// Reads can use Replica\n@Repository\n@ReplicaRepository  // Routes to replica\npublic class RefundEntityReplicaDAOImpl extends AbstractReplicaDAOImpl<...> {}\n```\n\n## Day 4: Repositories & Queries\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Review `OrderRepository.java` with FETCH JOIN patterns | [02-data-layer.md#jpa-repository-pattern](./02-data-layer.md) |\n| ☐ | Study `PaymentAttemptRepository.java` | [05-key-files-reference.md#jpa-repositories](./05-key-files-reference.md) |\n| ☐ | Understand DAO pattern with custom EntityManager | [02-data-layer.md#dao-pattern-custom-entitymanager](./02-data-layer.md) |\n| ☐ | Learn about JSON columns and converters | [02-data-layer.md#json-columns--converters](./02-data-layer.md) |\n| ☐ | Understand optimistic locking with @Version | [02-data-layer.md#optimistic-locking--audit](./02-data-layer.md) |\n\n## Day 5: Caching & DynamoDB\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Study `ClientConfigurationCache.java` as pattern example | [02-data-layer.md#cache-implementation-pattern](./02-data-layer.md), [05-key-files-reference.md#caches](./05-key-files-reference.md) |\n| ☐ | Understand jittered TTL pattern (thundering herd prevention) | [02-data-layer.md#jittered-ttls-thundering-herd-prevention](./02-data-layer.md) |\n| ☐ | Review all Caffeine caches and their TTLs | [02-data-layer.md#caffeine-caches](./02-data-layer.md) |\n| ☐ | Understand MySQL vs DynamoDB usage | [02-data-layer.md#what-goes-where](./02-data-layer.md) |\n| ☐ | Study DynamoDB tables and entities | [02-data-layer.md#dynamodb-tables](./02-data-layer.md) |\n| ☐ | Review `AbstractDynamoDBDAO.java` pattern | [02-data-layer.md#dynamodb-dao-pattern](./02-data-layer.md) |\n\n### Cache TTLs Quick Reference\n| Cache | TTL |\n|-------|-----|\n| ClientConfigurationCache | 10-20 min |\n| PaymentProviderCache | 15-25 min |\n| DecisionTreeObjectCache | 180-190 min |\n| FeeCache | 1 day |\n\n---\n\n## ✅ WEEK 2 CHECKPOINT\n\n| Status | Checkpoint Item |\n|--------|-----------------|\n| ☐ | Can explain entity inheritance (BaseEntity → BaseExternalEntity) |\n| ☐ | Know how Master-Replica routing works |\n| ☐ | Understand caching patterns with jittered TTLs |\n| ☐ | Know when to use MySQL vs DynamoDB |\n| ☐ | Can identify N+1 query patterns and FETCH JOIN solutions |\n\n**Week 2 Completion Date:** _______________\n\n---\n\n# WEEK 3: PROVIDER INTEGRATION\n\n**Goal:** Understand how payment providers are integrated and routed\n\n## Day 1-2: Adapter Architecture\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Read the complete provider integration document | [03-provider-integration.md](./03-provider-integration.md) |\n| ☐ | Study `IPaymentProviderAdapter.java` base class | [03-provider-integration.md#base-adapter-pattern](./03-provider-integration.md), [05-key-files-reference.md#base-classes](./05-key-files-reference.md) |\n| ☐ | Understand `PaymentProviderFactory.java` | [03-provider-integration.md#factory-pattern-for-adapter-selection](./03-provider-integration.md) |\n| ☐ | Review adapter inheritance diagram | [03-provider-integration.md#adapter-inheritance-diagram](./03-provider-integration.md) |\n| ☐ | Understand `ProviderPaymentResponse` structure | [03-provider-integration.md#provider-response-structure](./03-provider-integration.md) |\n\n### Adapter Selection Key\n```java\nPaymentWorkflowKey {\n    OrderType orderType;           // PAY, REFUND\n    PaymentProviderKey providerKey; // CASHFREE, CYBERSOURCE\n    InstrumentType instrumentType;  // CARD, UPI_APPS\n    ThreeDSType threeDSType;        // 3DS1, 3DS2, NONE\n}\n```\n\n## Day 3: Decision Tree Routing\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Study `ProviderDeciderRouter.java` main router | [03-provider-integration.md#router-strategy-pattern](./03-provider-integration.md), [05-key-files-reference.md#provider-routing](./05-key-files-reference.md) |\n| ☐ | Understand LCM vs Decision Tree routing priority | [03-provider-integration.md#routing-flow-diagram](./03-provider-integration.md) |\n| ☐ | Review `DecisionTreeObjectCache.java` | [03-provider-integration.md#decision-tree-caching](./03-provider-integration.md) |\n| ☐ | Study decision tree factors | [03-provider-integration.md#decision-tree-factors](./03-provider-integration.md) |\n| ☐ | Understand `ProviderRoutingDecisionResult` | [03-provider-integration.md#routing-flow-diagram](./03-provider-integration.md) |\n\n### Routing Priority\n```\n1. LCM (Lending Cloud Manager) - if instrument supported\n2. Decision Tree - JSON rules for provider selection\n```\n\n## Day 4: Provider Implementations\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Study `CashfreeProviderAdapter.java` (two-phase pattern) | [03-provider-integration.md#cashfree-adapter-example](./03-provider-integration.md), [05-key-files-reference.md#provider-implementations](./05-key-files-reference.md) |\n| ☐ | Review `CybersourceProviderAdapter.java` (3DS support) | [03-provider-integration.md#cybersource-adapter-3ds-support](./03-provider-integration.md) |\n| ☐ | Understand status code mapping | [03-provider-integration.md#status-code-mapping-cybersource](./03-provider-integration.md) |\n| ☐ | Review supported providers table | [03-provider-integration.md#supported-providers](./03-provider-integration.md) |\n| ☐ | Understand provider configuration entities | [03-provider-integration.md#provider-configuration](./03-provider-integration.md) |\n\n### 24+ Supported Providers\n- Cashfree, Cybersource, PayU, Razorpay, Juspay\n- ICICI UPI, Axis UPI, YBL UPI, RBL UPI\n- Pine Labs, Digio, Cred Points\n\n## Day 5: Webhooks & Error Handling\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Review webhook architecture | [03-provider-integration.md#webhook-architecture](./03-provider-integration.md) |\n| ☐ | Study `CashfreeWebhookController.java` | [03-provider-integration.md#cashfree-webhook-example](./03-provider-integration.md), [05-key-files-reference.md#webhook-controllers](./05-key-files-reference.md) |\n| ☐ | Understand idempotency handling | [03-provider-integration.md#idempotency-handling](./03-provider-integration.md) |\n| ☐ | Learn error classification (retryable vs non-retryable) | [03-provider-integration.md#error-classification](./03-provider-integration.md) |\n| ☐ | Study retry pattern | [03-provider-integration.md#retry-pattern](./03-provider-integration.md) |\n| ☐ | Review circuit breaker configuration | [03-provider-integration.md#circuit-breaker-configuration](./03-provider-integration.md) |\n\n### Error Classification\n```java\nProviderRequestStatus {\n    REQUEST_SUCCESS,          // Processed\n    RETRY_ABLE_FAILURE,       // Timeout, rate limit\n    NON_RETRY_ABLE_FAILURE    // Invalid request\n}\n```\n\n---\n\n## ✅ WEEK 3 CHECKPOINT\n\n| Status | Checkpoint Item |\n|--------|-----------------|\n| ☐ | Can explain adapter pattern and factory selection |\n| ☐ | Know how decision tree routing works |\n| ☐ | Understand webhook processing flow |\n| ☐ | Know error classification and retry patterns |\n| ☐ | Can trace a request from routing to provider call |\n\n**Week 3 Completion Date:** _______________\n\n---\n\n# WEEK 4: PAYMENT FLOW\n\n**Goal:** Master the end-to-end payment flow and state machines\n\n## Day 1-2: Workflow Deep-Dive\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Read the complete payment flow document | [04-payment-flow.md](./04-payment-flow.md) |\n| ☐ | Study `Workflow.java` base template | [04-payment-flow.md#base-workflow-pattern-template-method](./04-payment-flow.md), [05-key-files-reference.md#base-workflows](./05-key-files-reference.md) |\n| ☐ | Master `PaymentAttemptCreateWorkflow.java` | [04-payment-flow.md#paymentattemptcreateworkflow-detailed](./04-payment-flow.md) |\n| ☐ | Understand context enrichment pipeline | [04-payment-flow.md#step-1-validate--enrich-context](./04-payment-flow.md) |\n| ☐ | Study `PaymentAttemptCreateContext` structure | [04-payment-flow.md#context-object-structure](./04-payment-flow.md) |\n| ☐ | Review each step: persist, process, postProcess | [04-payment-flow.md#step-2-persist-intent](./04-payment-flow.md) |\n\n### 7-Step Workflow Pipeline\n```\n1. validateAndEnrichContext()    // Validate & enrich\n2. persistIntent()               // Save to MySQL\n3. publishEntityPrePersistEvents() // Pre-persist hooks\n4. persistNonRelationalIntent()  // Save to DynamoDB\n5. process()                     // Provider API call\n6. postProcess()                 // Update with response\n7. publishEntityChangeEvents()   // Trigger state machines\n```\n\n## Day 3: State Machines\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Study `PaymentStateMachine.java` | [04-payment-flow.md#paymentstatemachine](./04-payment-flow.md), [05-key-files-reference.md#state-machines](./05-key-files-reference.md) |\n| ☐ | Study `OrderStateMachine.java` | [04-payment-flow.md#orderstatemachine](./04-payment-flow.md) |\n| ☐ | Understand event cascading pattern | [04-payment-flow.md#event-flow-diagram](./04-payment-flow.md) |\n| ☐ | Review terminal states | [04-payment-flow.md#state-transition-diagram](./04-payment-flow.md) |\n| ☐ | Study `PaymentAttemptEventFactory` | [04-payment-flow.md#event-factory-pattern](./04-payment-flow.md) |\n\n### State Cascade\n```\nPaymentAttemptEvent → PaymentStateMachine\n                           ↓\n                    PaymentEvent → OrderStateMachine\n                                         ↓\n                                  Final Order Status\n```\n\n## Day 4: Authentication Flows\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Understand 3DS redirect flow | [04-payment-flow.md#3ds-redirect-flow](./04-payment-flow.md) |\n| ☐ | Study Native OTP flow | [04-payment-flow.md#native-otp-flow-card-payments](./04-payment-flow.md) |\n| ☐ | Review `PaymentAttemptAuthenticateWorkflow.java` | [04-payment-flow.md#authentication-workflow](./04-payment-flow.md), [05-key-files-reference.md#authentication-workflows](./05-key-files-reference.md) |\n| ☐ | Study DynamoDB OTP storage | [04-payment-flow.md#dynamodb-entity-for-otp](./04-payment-flow.md) |\n| ☐ | Understand instrument processing | [04-payment-flow.md#instrument-processing](./04-payment-flow.md) |\n| ☐ | Study `CardInstrumentTypeProcessor.java` | [04-payment-flow.md#card-instrument-processing](./04-payment-flow.md) |\n\n### Auth Flow Types\n- **3DS Redirect:** User redirects to issuer page\n- **Native OTP:** OTP captured in app, sent to provider\n\n## Day 5: Advanced Patterns\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Study `SequentialWorkflow.java` (distributed locks) | [04-payment-flow.md#sequentialworkflow-pattern](./04-payment-flow.md), [05-key-files-reference.md#locking--sequencing](./05-key-files-reference.md) |\n| ☐ | Review Guava EventBus setup | [04-payment-flow.md#guava-eventbus-setup](./04-payment-flow.md) |\n| ☐ | Study end-to-end flow diagram | [04-payment-flow.md#complete-flow-diagram](./04-payment-flow.md) |\n| ☐ | Review async processing (Kafka, SQS) | [05-key-files-reference.md#kafka--sqs](./05-key-files-reference.md) |\n| ☐ | Study processor implementations | [04-payment-flow.md#processor-implementations](./04-payment-flow.md) |\n\n---\n\n## ✅ WEEK 4 CHECKPOINT\n\n| Status | Checkpoint Item |\n|--------|-----------------|\n| ☐ | Can trace payment creation flow step by step |\n| ☐ | Understand state machine event cascading |\n| ☐ | Know 3DS and Native OTP authentication flows |\n| ☐ | Understand distributed locking pattern |\n| ☐ | Can explain Guava EventBus usage |\n\n**Week 4 Completion Date:** _______________\n\n---\n\n# EXPERT CHALLENGES\n\n**Goal:** Apply your knowledge to real-world scenarios\n\n## Challenge 1: Trace a Card Payment End-to-End\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Start from `PaymentAttemptV2Controller` | [05-key-files-reference.md#primary-v2-controllers](./05-key-files-reference.md) |\n| ☐ | Follow through `PaymentAttemptCreateWorkflow` | [04-payment-flow.md#paymentattemptcreateworkflow-detailed](./04-payment-flow.md) |\n| ☐ | Trace provider adapter selection | [03-provider-integration.md#factory-pattern-for-adapter-selection](./03-provider-integration.md) |\n| ☐ | Follow 3DS flow if triggered | [04-payment-flow.md#3ds-redirect-flow](./04-payment-flow.md) |\n| ☐ | Track state machine events | [04-payment-flow.md#state-machine-implementation](./04-payment-flow.md) |\n| ☐ | End at final order status | [04-payment-flow.md#orderstatemachine](./04-payment-flow.md) |\n\n## Challenge 2: Add a New Provider (Conceptual)\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Identify extension points in adapter pattern | [03-provider-integration.md#provider-adapter-architecture](./03-provider-integration.md) |\n| ☐ | Design adapter extending `IPaymentProviderAdapter` | [03-provider-integration.md#base-adapter-pattern](./03-provider-integration.md) |\n| ☐ | Plan registration in `PaymentProviderFactory` | [03-provider-integration.md#paymentproviderfactory](./03-provider-integration.md) |\n| ☐ | Design webhook controller | [03-provider-integration.md#webhook-handling](./03-provider-integration.md) |\n| ☐ | Plan status code mapping | [03-provider-integration.md#status-code-mapping-cybersource](./03-provider-integration.md) |\n\n## Challenge 3: Debug a Failed Payment\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Find payment attempt by external_id | [02-data-layer.md#key-repository-methods](./02-data-layer.md) |\n| ☐ | Check `provider_status` and `error_code` fields | [02-data-layer.md#paymentattemptv2entity](./02-data-layer.md) |\n| ☐ | Review DynamoDB workflow context | [02-data-layer.md#dynamodb-tables](./02-data-layer.md) |\n| ☐ | Check state machine event logs | [04-payment-flow.md#state-machine-implementation](./04-payment-flow.md) |\n| ☐ | Identify root cause category | [03-provider-integration.md#error-classification](./03-provider-integration.md) |\n\n## Challenge 4: Optimize a Query\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Identify potential N+1 query pattern | [02-data-layer.md#jpa-repository-pattern](./02-data-layer.md) |\n| ☐ | Add FETCH JOIN to optimize | [02-data-layer.md#jpa-repository-pattern](./02-data-layer.md) |\n| ☐ | Consider caching opportunity | [02-data-layer.md#caching-architecture](./02-data-layer.md) |\n| ☐ | Evaluate replica usage for reads | [02-data-layer.md#usage-pattern](./02-data-layer.md) |\n\n---\n\n## ✅ EXPERT CHECKPOINT\n\n| Status | Checkpoint Item |\n|--------|-----------------|\n| ☐ | Can trace any payment flow end-to-end |\n| ☐ | Can debug production payment issues |\n| ☐ | Can design new provider integrations |\n| ☐ | Can optimize database queries |\n| ☐ | Can explain any component to team members |\n\n**Expert Level Completion Date:** _______________\n\n---\n\n# SUMMARY\n\n## Completion Status\n\n| Phase | Status | Date Completed |\n|-------|--------|----------------|\n| Week 1: Foundation | ☐ Not Complete | |\n| Week 2: Data Layer | ☐ Not Complete | |\n| Week 3: Provider Integration | ☐ Not Complete | |\n| Week 4: Payment Flow | ☐ Not Complete | |\n| Expert Challenges | ☐ Not Complete | |\n\n## Key Documents by Topic\n\n| When Debugging... | Reference |\n|-------------------|-----------|\n| Payment creation issues | [04-payment-flow.md](./04-payment-flow.md) |\n| Provider failures | [03-provider-integration.md](./03-provider-integration.md) |\n| Database/cache issues | [02-data-layer.md](./02-data-layer.md) |\n| State transition bugs | [04-payment-flow.md#state-machine-implementation](./04-payment-flow.md) |\n| Finding files | [05-key-files-reference.md](./05-key-files-reference.md) |\n\n## Critical Files Quick Reference\n\n| Category | File |\n|----------|------|\n| Entry Point | `DarwinApplication.java` |\n| Main Workflow | `PaymentAttemptCreateWorkflow.java` |\n| Payment States | `PaymentStateMachine.java` |\n| Provider Routing | `ProviderDeciderRouter.java` |\n| Base Adapter | `IPaymentProviderAdapter.java` |\n| Config | `application.properties` |\n\n---\n\n## Notes\n\n### Session Notes\n```\n[Add your notes from each study session here]\n```\n\n### Questions to Research\n```\n[Add questions that come up during study]\n```\n\n### Key Insights\n```\n[Add important discoveries and \"aha\" moments]\n```\n\n---\n\n*Last Updated: _______________*\n\n*Good luck on your journey to becoming a Darwin expert!*\n"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":130,"cache_read_input_tokens":85320,"cache_creation":{"ephemeral_5m_input_tokens":130,"ephemeral_1h_input_tokens":0},"output_tokens":7611}},"type":"assistant","uuid":"6391ed85-08bc-4ff2-817d-891c31204d6a","timestamp":"2025-12-31T10:13:30.471Z"}
{"type":"file-history-snapshot","messageId":"6391ed85-08bc-4ff2-817d-891c31204d6a","snapshot":{"messageId":"be5bd760-0206-49b4-8aa8-0b7d855cb08e","trackedFileBackups":{"/Users/kiranbiliyawala/.claude/plans/distributed-marinating-mango.md":{"backupFileName":"c92f53c9f6085692@v2","version":2,"backupTime":"2025-12-31T09:58:40.829Z"},"docs/study-guide/README.md":{"backupFileName":"3fd18aad0b0250d2@v1","version":1,"backupTime":"2025-12-31T10:00:15.742Z"},"docs/study-guide/01-overview.md":{"backupFileName":"676b1c94834531cf@v1","version":1,"backupTime":"2025-12-31T10:02:50.120Z"},"docs/study-guide/02-data-layer.md":{"backupFileName":"bc4de0d863c98472@v1","version":1,"backupTime":"2025-12-31T10:02:50.268Z"},"docs/study-guide/03-provider-integration.md":{"backupFileName":"ec08d6b3a8bf7e15@v1","version":1,"backupTime":"2025-12-31T10:09:17.968Z"},"docs/study-guide/04-payment-flow.md":{"backupFileName":"3880d920c1011981@v1","version":1,"backupTime":"2025-12-31T10:09:18.024Z"},"docs/study-guide/05-key-files-reference.md":{"backupFileName":"f8129850f989174c@v1","version":1,"backupTime":"2025-12-31T10:09:18.087Z"},"docs/study-guide/06-study-path.md":{"backupFileName":"bff2768a73842c11@v1","version":1,"backupTime":"2025-12-31T10:09:18.150Z"},"docs/study-guide/PROGRESS.md":{"backupFileName":"45ed5cc74cd9a9b9@v1","version":1,"backupTime":"2025-12-31T10:13:31.405Z"}},"timestamp":"2025-12-31T10:11:42.426Z"},"isSnapshotUpdate":true}
{"parentUuid":"6391ed85-08bc-4ff2-817d-891c31204d6a","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_012M97dU9uhkrqin7VGi1wJU","type":"tool_result","content":"File created successfully at: /Users/kiranbiliyawala/code/cred/payments/payment-service/docs/study-guide/PROGRESS.md"}]},"uuid":"3447359d-d6e4-410d-b8fb-219c76801f73","timestamp":"2025-12-31T10:13:31.399Z","toolUseResult":{"type":"create","filePath":"/Users/kiranbiliyawala/code/cred/payments/payment-service/docs/study-guide/PROGRESS.md","content":"# Payment Service (Darwin) - Study Progress Tracker\n\n> **Started:** _______________\n> **Target Completion:** 4 weeks from start\n> **Current Status:** Not Started\n\n---\n\n## Quick Links\n\n| Document | Purpose |\n|----------|---------|\n| [README.md](./README.md) | Start here - Overview & navigation |\n| [01-overview.md](./01-overview.md) | Tech stack, project structure |\n| [02-data-layer.md](./02-data-layer.md) | Database, entities, caching |\n| [03-provider-integration.md](./03-provider-integration.md) | Provider adapters, webhooks |\n| [04-payment-flow.md](./04-payment-flow.md) | Workflows, state machines |\n| [05-key-files-reference.md](./05-key-files-reference.md) | File lookup reference |\n| [06-study-path.md](./06-study-path.md) | Weekly breakdown |\n\n---\n\n## Overall Progress\n\n```\nWeek 1: Foundation          [░░░░░░░░░░] 0%\nWeek 2: Data Layer          [░░░░░░░░░░] 0%\nWeek 3: Provider Integration [░░░░░░░░░░] 0%\nWeek 4: Payment Flow        [░░░░░░░░░░] 0%\nExpert Challenges           [░░░░░░░░░░] 0%\n─────────────────────────────────────────\nTOTAL                       [░░░░░░░░░░] 0%\n```\n\n---\n\n# WEEK 1: FOUNDATION\n\n**Goal:** Understand the big picture - tech stack, structure, and core concepts\n\n## Day 1-2: Setup & Overview\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Read the main README and understand navigation | [README.md](./README.md) |\n| ☐ | Read the complete overview document | [01-overview.md](./01-overview.md) |\n| ☐ | Clone and build the project (`./gradlew build`) | - |\n| ☐ | Explore `DarwinApplication.java` entry point | [01-overview.md#entry-point](./01-overview.md) |\n| ☐ | Scan `application.properties` (first 200 lines) | [01-overview.md#configuration](./01-overview.md) |\n\n### Key Learnings Checklist\n- [ ] Know the server runs on port 9010 with context path `/payments`\n- [ ] Understand Java 17 + Spring Boot 2.7.14 stack\n- [ ] Know the main databases: MySQL (Master-Replica), DynamoDB, Redis\n\n## Day 3-4: Project Structure\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Map the directory structure mentally | [01-overview.md#project-structure](./01-overview.md) |\n| ☐ | Identify V2 package as primary implementation | [01-overview.md#project-structure](./01-overview.md) |\n| ☐ | Understand controller → service → workflow pattern | [01-overview.md#project-structure](./01-overview.md) |\n| ☐ | Review key directories: `controller/v2/`, `v2/workflow/`, `entity/v2/` | [05-key-files-reference.md](./05-key-files-reference.md) |\n\n### Key Directories to Know\n```\nsrc/main/java/in/dreamplug/darwin/\n├── controller/v2/      # REST endpoints\n├── v2/workflow/create/ # Core business logic\n├── entity/v2/          # JPA entities\n├── statemachine/       # State machines\n├── planner/            # Provider routing\n└── cache/              # Caching layer\n```\n\n## Day 5: Core Concepts\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Understand Order → Payment → PaymentAttempt hierarchy | [01-overview.md#core-concepts](./01-overview.md) |\n| ☐ | Learn the 7-step workflow pattern | [01-overview.md#core-concepts](./01-overview.md), [04-payment-flow.md#the-7-step-workflow-pipeline](./04-payment-flow.md) |\n| ☐ | Study entity lifecycle states (CREATED → PROCESSING → COMPLETED) | [01-overview.md#core-concepts](./01-overview.md) |\n| ☐ | Review internal service dependencies | [01-overview.md#internal-service-dependencies](./01-overview.md) |\n| ☐ | Understand authentication filters | [01-overview.md#authentication--security](./01-overview.md) |\n\n### Payment Hierarchy (Critical)\n```\nOrder (1)\n    └── Payment (M)\n            └── PaymentAttempt (M)\n                    └── RefundAttempt (M via Refund)\n```\n\n---\n\n## ✅ WEEK 1 CHECKPOINT\n\n| Status | Checkpoint Item |\n|--------|-----------------|\n| ☐ | Can explain the tech stack to someone |\n| ☐ | Know the project directory structure |\n| ☐ | Understand Order → Payment → PaymentAttempt relationship |\n| ☐ | Know what the 7-step workflow pattern is |\n| ☐ | Can find key files in the codebase |\n\n**Week 1 Completion Date:** _______________\n\n---\n\n# WEEK 2: DATA LAYER\n\n**Goal:** Master the database architecture, entities, and caching patterns\n\n## Day 1-2: Entities\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Read the complete data layer document | [02-data-layer.md](./02-data-layer.md) |\n| ☐ | Study `BaseEntity.java` (id, timestamps, audit) | [02-data-layer.md#base-classes](./02-data-layer.md) |\n| ☐ | Study `BaseExternalEntity.java` (external_id, version) | [02-data-layer.md#baseexternalentity](./02-data-layer.md) |\n| ☐ | Review `OrderEntity.java` structure | [02-data-layer.md#orderentity](./02-data-layer.md), [05-key-files-reference.md#core-entities](./05-key-files-reference.md) |\n| ☐ | Study `PaymentV2Entity.java` and relationships | [02-data-layer.md#core-entities](./02-data-layer.md) |\n| ☐ | Understand `PaymentAttemptV2Entity.java` (most complex) | [02-data-layer.md#paymentattemptv2entity](./02-data-layer.md) |\n\n### Entity Inheritance\n```\nBaseEntity (id, created_at, updated_at, created_by, updated_by)\n    └── BaseExternalEntity (+ external_id UUID, @Version)\n            ├── OrderEntity\n            ├── PaymentV2Entity\n            ├── PaymentAttemptV2Entity\n            ├── RefundEntity\n            └── ClientEntity\n```\n\n## Day 3: Database Architecture\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Understand Master-Replica routing concept | [02-data-layer.md#master-replica-architecture](./02-data-layer.md) |\n| ☐ | Study `MasterDataSourceConfiguration.java` | [02-data-layer.md#configuration-files](./02-data-layer.md), [05-key-files-reference.md#database-configuration](./05-key-files-reference.md) |\n| ☐ | Study `ReplicaDataSourceConfiguration.java` | [02-data-layer.md#configuration-files](./02-data-layer.md) |\n| ☐ | Learn `@ReplicaRepository` annotation usage | [02-data-layer.md#usage-pattern](./02-data-layer.md) |\n| ☐ | Understand HikariCP connection pools | [02-data-layer.md#hikaricp-pool-configuration](./02-data-layer.md) |\n\n### Master-Replica Pattern\n```java\n// Writes go to Master (default)\n@Repository\npublic interface PaymentRepository extends JpaRepository<...> {}\n\n// Reads can use Replica\n@Repository\n@ReplicaRepository  // Routes to replica\npublic class RefundEntityReplicaDAOImpl extends AbstractReplicaDAOImpl<...> {}\n```\n\n## Day 4: Repositories & Queries\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Review `OrderRepository.java` with FETCH JOIN patterns | [02-data-layer.md#jpa-repository-pattern](./02-data-layer.md) |\n| ☐ | Study `PaymentAttemptRepository.java` | [05-key-files-reference.md#jpa-repositories](./05-key-files-reference.md) |\n| ☐ | Understand DAO pattern with custom EntityManager | [02-data-layer.md#dao-pattern-custom-entitymanager](./02-data-layer.md) |\n| ☐ | Learn about JSON columns and converters | [02-data-layer.md#json-columns--converters](./02-data-layer.md) |\n| ☐ | Understand optimistic locking with @Version | [02-data-layer.md#optimistic-locking--audit](./02-data-layer.md) |\n\n## Day 5: Caching & DynamoDB\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Study `ClientConfigurationCache.java` as pattern example | [02-data-layer.md#cache-implementation-pattern](./02-data-layer.md), [05-key-files-reference.md#caches](./05-key-files-reference.md) |\n| ☐ | Understand jittered TTL pattern (thundering herd prevention) | [02-data-layer.md#jittered-ttls-thundering-herd-prevention](./02-data-layer.md) |\n| ☐ | Review all Caffeine caches and their TTLs | [02-data-layer.md#caffeine-caches](./02-data-layer.md) |\n| ☐ | Understand MySQL vs DynamoDB usage | [02-data-layer.md#what-goes-where](./02-data-layer.md) |\n| ☐ | Study DynamoDB tables and entities | [02-data-layer.md#dynamodb-tables](./02-data-layer.md) |\n| ☐ | Review `AbstractDynamoDBDAO.java` pattern | [02-data-layer.md#dynamodb-dao-pattern](./02-data-layer.md) |\n\n### Cache TTLs Quick Reference\n| Cache | TTL |\n|-------|-----|\n| ClientConfigurationCache | 10-20 min |\n| PaymentProviderCache | 15-25 min |\n| DecisionTreeObjectCache | 180-190 min |\n| FeeCache | 1 day |\n\n---\n\n## ✅ WEEK 2 CHECKPOINT\n\n| Status | Checkpoint Item |\n|--------|-----------------|\n| ☐ | Can explain entity inheritance (BaseEntity → BaseExternalEntity) |\n| ☐ | Know how Master-Replica routing works |\n| ☐ | Understand caching patterns with jittered TTLs |\n| ☐ | Know when to use MySQL vs DynamoDB |\n| ☐ | Can identify N+1 query patterns and FETCH JOIN solutions |\n\n**Week 2 Completion Date:** _______________\n\n---\n\n# WEEK 3: PROVIDER INTEGRATION\n\n**Goal:** Understand how payment providers are integrated and routed\n\n## Day 1-2: Adapter Architecture\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Read the complete provider integration document | [03-provider-integration.md](./03-provider-integration.md) |\n| ☐ | Study `IPaymentProviderAdapter.java` base class | [03-provider-integration.md#base-adapter-pattern](./03-provider-integration.md), [05-key-files-reference.md#base-classes](./05-key-files-reference.md) |\n| ☐ | Understand `PaymentProviderFactory.java` | [03-provider-integration.md#factory-pattern-for-adapter-selection](./03-provider-integration.md) |\n| ☐ | Review adapter inheritance diagram | [03-provider-integration.md#adapter-inheritance-diagram](./03-provider-integration.md) |\n| ☐ | Understand `ProviderPaymentResponse` structure | [03-provider-integration.md#provider-response-structure](./03-provider-integration.md) |\n\n### Adapter Selection Key\n```java\nPaymentWorkflowKey {\n    OrderType orderType;           // PAY, REFUND\n    PaymentProviderKey providerKey; // CASHFREE, CYBERSOURCE\n    InstrumentType instrumentType;  // CARD, UPI_APPS\n    ThreeDSType threeDSType;        // 3DS1, 3DS2, NONE\n}\n```\n\n## Day 3: Decision Tree Routing\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Study `ProviderDeciderRouter.java` main router | [03-provider-integration.md#router-strategy-pattern](./03-provider-integration.md), [05-key-files-reference.md#provider-routing](./05-key-files-reference.md) |\n| ☐ | Understand LCM vs Decision Tree routing priority | [03-provider-integration.md#routing-flow-diagram](./03-provider-integration.md) |\n| ☐ | Review `DecisionTreeObjectCache.java` | [03-provider-integration.md#decision-tree-caching](./03-provider-integration.md) |\n| ☐ | Study decision tree factors | [03-provider-integration.md#decision-tree-factors](./03-provider-integration.md) |\n| ☐ | Understand `ProviderRoutingDecisionResult` | [03-provider-integration.md#routing-flow-diagram](./03-provider-integration.md) |\n\n### Routing Priority\n```\n1. LCM (Lending Cloud Manager) - if instrument supported\n2. Decision Tree - JSON rules for provider selection\n```\n\n## Day 4: Provider Implementations\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Study `CashfreeProviderAdapter.java` (two-phase pattern) | [03-provider-integration.md#cashfree-adapter-example](./03-provider-integration.md), [05-key-files-reference.md#provider-implementations](./05-key-files-reference.md) |\n| ☐ | Review `CybersourceProviderAdapter.java` (3DS support) | [03-provider-integration.md#cybersource-adapter-3ds-support](./03-provider-integration.md) |\n| ☐ | Understand status code mapping | [03-provider-integration.md#status-code-mapping-cybersource](./03-provider-integration.md) |\n| ☐ | Review supported providers table | [03-provider-integration.md#supported-providers](./03-provider-integration.md) |\n| ☐ | Understand provider configuration entities | [03-provider-integration.md#provider-configuration](./03-provider-integration.md) |\n\n### 24+ Supported Providers\n- Cashfree, Cybersource, PayU, Razorpay, Juspay\n- ICICI UPI, Axis UPI, YBL UPI, RBL UPI\n- Pine Labs, Digio, Cred Points\n\n## Day 5: Webhooks & Error Handling\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Review webhook architecture | [03-provider-integration.md#webhook-architecture](./03-provider-integration.md) |\n| ☐ | Study `CashfreeWebhookController.java` | [03-provider-integration.md#cashfree-webhook-example](./03-provider-integration.md), [05-key-files-reference.md#webhook-controllers](./05-key-files-reference.md) |\n| ☐ | Understand idempotency handling | [03-provider-integration.md#idempotency-handling](./03-provider-integration.md) |\n| ☐ | Learn error classification (retryable vs non-retryable) | [03-provider-integration.md#error-classification](./03-provider-integration.md) |\n| ☐ | Study retry pattern | [03-provider-integration.md#retry-pattern](./03-provider-integration.md) |\n| ☐ | Review circuit breaker configuration | [03-provider-integration.md#circuit-breaker-configuration](./03-provider-integration.md) |\n\n### Error Classification\n```java\nProviderRequestStatus {\n    REQUEST_SUCCESS,          // Processed\n    RETRY_ABLE_FAILURE,       // Timeout, rate limit\n    NON_RETRY_ABLE_FAILURE    // Invalid request\n}\n```\n\n---\n\n## ✅ WEEK 3 CHECKPOINT\n\n| Status | Checkpoint Item |\n|--------|-----------------|\n| ☐ | Can explain adapter pattern and factory selection |\n| ☐ | Know how decision tree routing works |\n| ☐ | Understand webhook processing flow |\n| ☐ | Know error classification and retry patterns |\n| ☐ | Can trace a request from routing to provider call |\n\n**Week 3 Completion Date:** _______________\n\n---\n\n# WEEK 4: PAYMENT FLOW\n\n**Goal:** Master the end-to-end payment flow and state machines\n\n## Day 1-2: Workflow Deep-Dive\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Read the complete payment flow document | [04-payment-flow.md](./04-payment-flow.md) |\n| ☐ | Study `Workflow.java` base template | [04-payment-flow.md#base-workflow-pattern-template-method](./04-payment-flow.md), [05-key-files-reference.md#base-workflows](./05-key-files-reference.md) |\n| ☐ | Master `PaymentAttemptCreateWorkflow.java` | [04-payment-flow.md#paymentattemptcreateworkflow-detailed](./04-payment-flow.md) |\n| ☐ | Understand context enrichment pipeline | [04-payment-flow.md#step-1-validate--enrich-context](./04-payment-flow.md) |\n| ☐ | Study `PaymentAttemptCreateContext` structure | [04-payment-flow.md#context-object-structure](./04-payment-flow.md) |\n| ☐ | Review each step: persist, process, postProcess | [04-payment-flow.md#step-2-persist-intent](./04-payment-flow.md) |\n\n### 7-Step Workflow Pipeline\n```\n1. validateAndEnrichContext()    // Validate & enrich\n2. persistIntent()               // Save to MySQL\n3. publishEntityPrePersistEvents() // Pre-persist hooks\n4. persistNonRelationalIntent()  // Save to DynamoDB\n5. process()                     // Provider API call\n6. postProcess()                 // Update with response\n7. publishEntityChangeEvents()   // Trigger state machines\n```\n\n## Day 3: State Machines\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Study `PaymentStateMachine.java` | [04-payment-flow.md#paymentstatemachine](./04-payment-flow.md), [05-key-files-reference.md#state-machines](./05-key-files-reference.md) |\n| ☐ | Study `OrderStateMachine.java` | [04-payment-flow.md#orderstatemachine](./04-payment-flow.md) |\n| ☐ | Understand event cascading pattern | [04-payment-flow.md#event-flow-diagram](./04-payment-flow.md) |\n| ☐ | Review terminal states | [04-payment-flow.md#state-transition-diagram](./04-payment-flow.md) |\n| ☐ | Study `PaymentAttemptEventFactory` | [04-payment-flow.md#event-factory-pattern](./04-payment-flow.md) |\n\n### State Cascade\n```\nPaymentAttemptEvent → PaymentStateMachine\n                           ↓\n                    PaymentEvent → OrderStateMachine\n                                         ↓\n                                  Final Order Status\n```\n\n## Day 4: Authentication Flows\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Understand 3DS redirect flow | [04-payment-flow.md#3ds-redirect-flow](./04-payment-flow.md) |\n| ☐ | Study Native OTP flow | [04-payment-flow.md#native-otp-flow-card-payments](./04-payment-flow.md) |\n| ☐ | Review `PaymentAttemptAuthenticateWorkflow.java` | [04-payment-flow.md#authentication-workflow](./04-payment-flow.md), [05-key-files-reference.md#authentication-workflows](./05-key-files-reference.md) |\n| ☐ | Study DynamoDB OTP storage | [04-payment-flow.md#dynamodb-entity-for-otp](./04-payment-flow.md) |\n| ☐ | Understand instrument processing | [04-payment-flow.md#instrument-processing](./04-payment-flow.md) |\n| ☐ | Study `CardInstrumentTypeProcessor.java` | [04-payment-flow.md#card-instrument-processing](./04-payment-flow.md) |\n\n### Auth Flow Types\n- **3DS Redirect:** User redirects to issuer page\n- **Native OTP:** OTP captured in app, sent to provider\n\n## Day 5: Advanced Patterns\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Study `SequentialWorkflow.java` (distributed locks) | [04-payment-flow.md#sequentialworkflow-pattern](./04-payment-flow.md), [05-key-files-reference.md#locking--sequencing](./05-key-files-reference.md) |\n| ☐ | Review Guava EventBus setup | [04-payment-flow.md#guava-eventbus-setup](./04-payment-flow.md) |\n| ☐ | Study end-to-end flow diagram | [04-payment-flow.md#complete-flow-diagram](./04-payment-flow.md) |\n| ☐ | Review async processing (Kafka, SQS) | [05-key-files-reference.md#kafka--sqs](./05-key-files-reference.md) |\n| ☐ | Study processor implementations | [04-payment-flow.md#processor-implementations](./04-payment-flow.md) |\n\n---\n\n## ✅ WEEK 4 CHECKPOINT\n\n| Status | Checkpoint Item |\n|--------|-----------------|\n| ☐ | Can trace payment creation flow step by step |\n| ☐ | Understand state machine event cascading |\n| ☐ | Know 3DS and Native OTP authentication flows |\n| ☐ | Understand distributed locking pattern |\n| ☐ | Can explain Guava EventBus usage |\n\n**Week 4 Completion Date:** _______________\n\n---\n\n# EXPERT CHALLENGES\n\n**Goal:** Apply your knowledge to real-world scenarios\n\n## Challenge 1: Trace a Card Payment End-to-End\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Start from `PaymentAttemptV2Controller` | [05-key-files-reference.md#primary-v2-controllers](./05-key-files-reference.md) |\n| ☐ | Follow through `PaymentAttemptCreateWorkflow` | [04-payment-flow.md#paymentattemptcreateworkflow-detailed](./04-payment-flow.md) |\n| ☐ | Trace provider adapter selection | [03-provider-integration.md#factory-pattern-for-adapter-selection](./03-provider-integration.md) |\n| ☐ | Follow 3DS flow if triggered | [04-payment-flow.md#3ds-redirect-flow](./04-payment-flow.md) |\n| ☐ | Track state machine events | [04-payment-flow.md#state-machine-implementation](./04-payment-flow.md) |\n| ☐ | End at final order status | [04-payment-flow.md#orderstatemachine](./04-payment-flow.md) |\n\n## Challenge 2: Add a New Provider (Conceptual)\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Identify extension points in adapter pattern | [03-provider-integration.md#provider-adapter-architecture](./03-provider-integration.md) |\n| ☐ | Design adapter extending `IPaymentProviderAdapter` | [03-provider-integration.md#base-adapter-pattern](./03-provider-integration.md) |\n| ☐ | Plan registration in `PaymentProviderFactory` | [03-provider-integration.md#paymentproviderfactory](./03-provider-integration.md) |\n| ☐ | Design webhook controller | [03-provider-integration.md#webhook-handling](./03-provider-integration.md) |\n| ☐ | Plan status code mapping | [03-provider-integration.md#status-code-mapping-cybersource](./03-provider-integration.md) |\n\n## Challenge 3: Debug a Failed Payment\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Find payment attempt by external_id | [02-data-layer.md#key-repository-methods](./02-data-layer.md) |\n| ☐ | Check `provider_status` and `error_code` fields | [02-data-layer.md#paymentattemptv2entity](./02-data-layer.md) |\n| ☐ | Review DynamoDB workflow context | [02-data-layer.md#dynamodb-tables](./02-data-layer.md) |\n| ☐ | Check state machine event logs | [04-payment-flow.md#state-machine-implementation](./04-payment-flow.md) |\n| ☐ | Identify root cause category | [03-provider-integration.md#error-classification](./03-provider-integration.md) |\n\n## Challenge 4: Optimize a Query\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Identify potential N+1 query pattern | [02-data-layer.md#jpa-repository-pattern](./02-data-layer.md) |\n| ☐ | Add FETCH JOIN to optimize | [02-data-layer.md#jpa-repository-pattern](./02-data-layer.md) |\n| ☐ | Consider caching opportunity | [02-data-layer.md#caching-architecture](./02-data-layer.md) |\n| ☐ | Evaluate replica usage for reads | [02-data-layer.md#usage-pattern](./02-data-layer.md) |\n\n---\n\n## ✅ EXPERT CHECKPOINT\n\n| Status | Checkpoint Item |\n|--------|-----------------|\n| ☐ | Can trace any payment flow end-to-end |\n| ☐ | Can debug production payment issues |\n| ☐ | Can design new provider integrations |\n| ☐ | Can optimize database queries |\n| ☐ | Can explain any component to team members |\n\n**Expert Level Completion Date:** _______________\n\n---\n\n# SUMMARY\n\n## Completion Status\n\n| Phase | Status | Date Completed |\n|-------|--------|----------------|\n| Week 1: Foundation | ☐ Not Complete | |\n| Week 2: Data Layer | ☐ Not Complete | |\n| Week 3: Provider Integration | ☐ Not Complete | |\n| Week 4: Payment Flow | ☐ Not Complete | |\n| Expert Challenges | ☐ Not Complete | |\n\n## Key Documents by Topic\n\n| When Debugging... | Reference |\n|-------------------|-----------|\n| Payment creation issues | [04-payment-flow.md](./04-payment-flow.md) |\n| Provider failures | [03-provider-integration.md](./03-provider-integration.md) |\n| Database/cache issues | [02-data-layer.md](./02-data-layer.md) |\n| State transition bugs | [04-payment-flow.md#state-machine-implementation](./04-payment-flow.md) |\n| Finding files | [05-key-files-reference.md](./05-key-files-reference.md) |\n\n## Critical Files Quick Reference\n\n| Category | File |\n|----------|------|\n| Entry Point | `DarwinApplication.java` |\n| Main Workflow | `PaymentAttemptCreateWorkflow.java` |\n| Payment States | `PaymentStateMachine.java` |\n| Provider Routing | `ProviderDeciderRouter.java` |\n| Base Adapter | `IPaymentProviderAdapter.java` |\n| Config | `application.properties` |\n\n---\n\n## Notes\n\n### Session Notes\n```\n[Add your notes from each study session here]\n```\n\n### Questions to Research\n```\n[Add questions that come up during study]\n```\n\n### Key Insights\n```\n[Add important discoveries and \"aha\" moments]\n```\n\n---\n\n*Last Updated: _______________*\n\n*Good luck on your journey to becoming a Darwin expert!*\n","structuredPatch":[],"originalFile":null}}
{"parentUuid":"3447359d-d6e4-410d-b8fb-219c76801f73","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01Kehpq2ez7ceMUC36axcSv7","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"I've created the PROGRESS.md file with the complete study plan including document references for each todo item. Let me summarize what was created.","signature":"Er4CCkgICxABGAIqQNx0SCFUpQ4WMPbu+kx+v+XCK2IYVC40ENTjdl3WZ4xvlkjsuFRVCLgO7aiDGcRM2V3PNtXDaNAVUq18u/Yk+skSDEWdpHqqsmeCb6XGbRoM3D9llx3eOxYrPtMlIjA5WHin6PH7zob86KKGbvtXn+kwXDWkgDg0/riVz+GZ0h+j9RQHzjbTchfbdSFmtq8qowH2KQ961EVYI0/grx1+IFBK8TnImx2R2M7CVBEVaUzmk3JUxnOGHxafEkgw1M3GL85QPsWu9yCHbPTqtDgEDF2KWWLOW4vXGihM62BAP/PrXYyXWSzvFVZvX6CE4JdlwhU3dM3IzzJCzrMBrqReiD/M8WwBVu5y1bglBhyx08UTVSWgtYBQ3jsgwn04HgRnWHxUfcwBJTBN9uKJayOvRfSFzLVHGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":7668,"cache_read_input_tokens":85450,"cache_creation":{"ephemeral_5m_input_tokens":7668,"ephemeral_1h_input_tokens":0},"output_tokens":3}},"type":"assistant","uuid":"49e92f65-181f-41fc-a4ed-bb6989b27094","timestamp":"2025-12-31T10:13:38.143Z"}
{"parentUuid":"49e92f65-181f-41fc-a4ed-bb6989b27094","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_01Kehpq2ez7ceMUC36axcSv7","type":"message","role":"assistant","content":[{"type":"text","text":"Created `PROGRESS.md` with the complete study plan. Here's what it contains:\n\n## PROGRESS.md Structure\n\n### Overview Section\n- Quick links to all documents\n- Visual progress bars for each week\n- Overall completion tracking\n\n### Week-by-Week Study Plan\n\n| Week | Focus | Tasks | Document References |\n|------|-------|-------|---------------------|\n| **Week 1** | Foundation | 15 tasks | Links to README, 01-overview |\n| **Week 2** | Data Layer | 18 tasks | Links to 02-data-layer, 05-key-files |\n| **Week 3** | Provider Integration | 17 tasks | Links to 03-provider-integration |\n| **Week 4** | Payment Flow | 17 tasks | Links to 04-payment-flow |\n| **Expert** | Challenges | 4 challenges (18 tasks) | Cross-references all docs |\n\n### Features\n- **Checkboxes** for every task (GitHub-compatible `☐`)\n- **Direct links** to specific sections (e.g., `02-data-layer.md#caching-architecture`)\n- **Checkpoints** after each week\n- **Code snippets** for quick reference\n- **Tables** for quick lookup\n- **Notes sections** for personal annotations\n\n## Complete Documentation Structure\n\n```\ndocs/study-guide/\n├── README.md              # Entry point & navigation\n├── PROGRESS.md            # Full study plan with references ← NEW\n├── 01-overview.md         # Tech stack, structure\n├── 02-data-layer.md       # Database, entities, caching\n├── 03-provider-integration.md  # Providers, webhooks\n├── 04-payment-flow.md     # Workflows, state machines\n├── 05-key-files-reference.md   # 150+ file lookup\n└── 06-study-path.md       # Weekly breakdown\n```\n\nYou can now track your progress by checking off items in `PROGRESS.md`, and each task links directly to the relevant documentation section."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":7668,"cache_read_input_tokens":85450,"cache_creation":{"ephemeral_5m_input_tokens":7668,"ephemeral_1h_input_tokens":0},"output_tokens":519}},"type":"assistant","uuid":"08ca163c-5cfc-4da5-b3ee-a954d9733bc1","timestamp":"2025-12-31T10:13:46.742Z"}
{"type":"file-history-snapshot","messageId":"72ab4e67-d599-44c0-af46-985daa4f4491","snapshot":{"messageId":"72ab4e67-d599-44c0-af46-985daa4f4491","trackedFileBackups":{"/Users/kiranbiliyawala/.claude/plans/distributed-marinating-mango.md":{"backupFileName":"c92f53c9f6085692@v2","version":2,"backupTime":"2025-12-31T09:58:40.829Z"},"docs/study-guide/README.md":{"backupFileName":"3fd18aad0b0250d2@v1","version":1,"backupTime":"2025-12-31T10:00:15.742Z"},"docs/study-guide/01-overview.md":{"backupFileName":"676b1c94834531cf@v1","version":1,"backupTime":"2025-12-31T10:02:50.120Z"},"docs/study-guide/02-data-layer.md":{"backupFileName":"bc4de0d863c98472@v1","version":1,"backupTime":"2025-12-31T10:02:50.268Z"},"docs/study-guide/03-provider-integration.md":{"backupFileName":"ec08d6b3a8bf7e15@v1","version":1,"backupTime":"2025-12-31T10:09:17.968Z"},"docs/study-guide/04-payment-flow.md":{"backupFileName":"3880d920c1011981@v1","version":1,"backupTime":"2025-12-31T10:09:18.024Z"},"docs/study-guide/05-key-files-reference.md":{"backupFileName":"f8129850f989174c@v1","version":1,"backupTime":"2025-12-31T10:09:18.087Z"},"docs/study-guide/06-study-path.md":{"backupFileName":"bff2768a73842c11@v1","version":1,"backupTime":"2025-12-31T10:09:18.150Z"},"docs/study-guide/PROGRESS.md":{"backupFileName":"45ed5cc74cd9a9b9@v1","version":1,"backupTime":"2025-12-31T10:13:31.405Z"}},"timestamp":"2025-12-31T10:31:33.903Z"},"isSnapshotUpdate":false}
{"parentUuid":"08ca163c-5cfc-4da5-b3ee-a954d9733bc1","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","type":"user","message":{"role":"user","content":"let"},"uuid":"72ab4e67-d599-44c0-af46-985daa4f4491","timestamp":"2025-12-31T10:31:33.897Z","thinkingMetadata":{"level":"high","disabled":false,"triggers":[]},"todos":[]}
{"parentUuid":"72ab4e67-d599-44c0-af46-985daa4f4491","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","type":"user","message":{"role":"user","content":[{"type":"text","text":"[Request interrupted by user]"}]},"uuid":"221402a6-db9c-4e5f-ae8a-246102971a20","timestamp":"2025-12-31T10:31:35.414Z"}
{"type":"file-history-snapshot","messageId":"ff567f3d-7438-4aa8-9b78-029aad9af076","snapshot":{"messageId":"ff567f3d-7438-4aa8-9b78-029aad9af076","trackedFileBackups":{"/Users/kiranbiliyawala/.claude/plans/distributed-marinating-mango.md":{"backupFileName":"c92f53c9f6085692@v2","version":2,"backupTime":"2025-12-31T09:58:40.829Z"},"docs/study-guide/README.md":{"backupFileName":"3fd18aad0b0250d2@v1","version":1,"backupTime":"2025-12-31T10:00:15.742Z"},"docs/study-guide/01-overview.md":{"backupFileName":"676b1c94834531cf@v1","version":1,"backupTime":"2025-12-31T10:02:50.120Z"},"docs/study-guide/02-data-layer.md":{"backupFileName":"bc4de0d863c98472@v1","version":1,"backupTime":"2025-12-31T10:02:50.268Z"},"docs/study-guide/03-provider-integration.md":{"backupFileName":"ec08d6b3a8bf7e15@v1","version":1,"backupTime":"2025-12-31T10:09:17.968Z"},"docs/study-guide/04-payment-flow.md":{"backupFileName":"3880d920c1011981@v1","version":1,"backupTime":"2025-12-31T10:09:18.024Z"},"docs/study-guide/05-key-files-reference.md":{"backupFileName":"f8129850f989174c@v1","version":1,"backupTime":"2025-12-31T10:09:18.087Z"},"docs/study-guide/06-study-path.md":{"backupFileName":"bff2768a73842c11@v1","version":1,"backupTime":"2025-12-31T10:09:18.150Z"},"docs/study-guide/PROGRESS.md":{"backupFileName":"45ed5cc74cd9a9b9@v1","version":1,"backupTime":"2025-12-31T10:13:31.405Z"}},"timestamp":"2025-12-31T10:31:44.167Z"},"isSnapshotUpdate":false}
{"parentUuid":"221402a6-db9c-4e5f-ae8a-246102971a20","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","type":"user","message":{"role":"user","content":"let's start with first todo"},"uuid":"ff567f3d-7438-4aa8-9b78-029aad9af076","timestamp":"2025-12-31T10:31:44.158Z","thinkingMetadata":{"level":"high","disabled":false,"triggers":[]},"todos":[]}
{"parentUuid":"ff567f3d-7438-4aa8-9b78-029aad9af076","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_019DrkAt5PcNqMzBs7ZcqYU6","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user wants to start with the first todo from the study guide we created. Let me read the PROGRESS.md file to see what the first task is.","signature":"ErcCCkgICxABGAIqQL/UxvzZjcEnPTJf2wL9/DxHVexccuqbsZRVnY3KzQX3wvZ0jjHWpaCQHqBmEAFYNvX2C3TRJu0o/kA/eKtshqkSDF/dyYs7KkNlieNXPBoMQJ4zqAdBQTO9UypTIjBL36arSqhXJ3gN1e3b7EjSFNosmekK+BGeYYJX8Pu61mQU3Tiox+SKjfYa1Qh1eFwqnAHXMs2bcIDzNDZWCmqHRlF41rt4kx66tDV7qYN8H4BMzfOKpxtP0wUBiqv9vAJMcw+nIcUFAYJAh0ry0HW6xTajngSEjOC4d5jUNC0Ub0KXPUqbKf6kpxC8Nz+3Ux9iJJ7MxfFwcPJ7Q7Wz/Lf2iqsjWsLYa9MT1TXE4klMTgv1bOu8bw/MX6t2qoZGh6AQTW1n7pWQVFksThW1odcYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":12,"cache_read_input_tokens":94786,"cache_creation":{"ephemeral_5m_input_tokens":12,"ephemeral_1h_input_tokens":0},"output_tokens":3}},"type":"assistant","uuid":"3d32c0dd-fdd5-4457-9dfa-718f11aa54c8","timestamp":"2025-12-31T10:31:49.327Z"}
{"parentUuid":"3d32c0dd-fdd5-4457-9dfa-718f11aa54c8","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","message":{"model":"claude-opus-4-5-20251101","id":"msg_bdrk_019DrkAt5PcNqMzBs7ZcqYU6","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_bdrk_01NjjPTwAL7BGQBbAQQ2gWsq","name":"Read","input":{"file_path":"/Users/kiranbiliyawala/code/cred/payments/payment-service/docs/study-guide/PROGRESS.md","limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":12,"cache_read_input_tokens":94786,"cache_creation":{"ephemeral_5m_input_tokens":12,"ephemeral_1h_input_tokens":0},"output_tokens":141}},"type":"assistant","uuid":"337151e4-a7d2-48d3-a3e3-e70c65dfa1a2","timestamp":"2025-12-31T10:31:49.557Z"}
{"parentUuid":"337151e4-a7d2-48d3-a3e3-e70c65dfa1a2","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_bdrk_01NjjPTwAL7BGQBbAQQ2gWsq","type":"tool_result","content":"     1→# Payment Service (Darwin) - Study Progress Tracker\n     2→\n     3→> **Started:** _______________\n     4→> **Target Completion:** 4 weeks from start\n     5→> **Current Status:** Not Started\n     6→\n     7→---\n     8→\n     9→## Quick Links\n    10→\n    11→| Document | Purpose |\n    12→|----------|---------|\n    13→| [README.md](./README.md) | Start here - Overview & navigation |\n    14→| [01-overview.md](./01-overview.md) | Tech stack, project structure |\n    15→| [02-data-layer.md](./02-data-layer.md) | Database, entities, caching |\n    16→| [03-provider-integration.md](./03-provider-integration.md) | Provider adapters, webhooks |\n    17→| [04-payment-flow.md](./04-payment-flow.md) | Workflows, state machines |\n    18→| [05-key-files-reference.md](./05-key-files-reference.md) | File lookup reference |\n    19→| [06-study-path.md](./06-study-path.md) | Weekly breakdown |\n    20→\n    21→---\n    22→\n    23→## Overall Progress\n    24→\n    25→```\n    26→Week 1: Foundation          [░░░░░░░░░░] 0%\n    27→Week 2: Data Layer          [░░░░░░░░░░] 0%\n    28→Week 3: Provider Integration [░░░░░░░░░░] 0%\n    29→Week 4: Payment Flow        [░░░░░░░░░░] 0%\n    30→Expert Challenges           [░░░░░░░░░░] 0%\n    31→─────────────────────────────────────────\n    32→TOTAL                       [░░░░░░░░░░] 0%\n    33→```\n    34→\n    35→---\n    36→\n    37→# WEEK 1: FOUNDATION\n    38→\n    39→**Goal:** Understand the big picture - tech stack, structure, and core concepts\n    40→\n    41→## Day 1-2: Setup & Overview\n    42→\n    43→| Status | Task | Reference |\n    44→|--------|------|-----------|\n    45→| ☐ | Read the main README and understand navigation | [README.md](./README.md) |\n    46→| ☐ | Read the complete overview document | [01-overview.md](./01-overview.md) |\n    47→| ☐ | Clone and build the project (`./gradlew build`) | - |\n    48→| ☐ | Explore `DarwinApplication.java` entry point | [01-overview.md#entry-point](./01-overview.md) |\n    49→| ☐ | Scan `application.properties` (first 200 lines) | [01-overview.md#configuration](./01-overview.md) |\n    50→\n    51→### Key Learnings Checklist\n    52→- [ ] Know the server runs on port 9010 with context path `/payments`\n    53→- [ ] Understand Java 17 + Spring Boot 2.7.14 stack\n    54→- [ ] Know the main databases: MySQL (Master-Replica), DynamoDB, Redis\n    55→\n    56→## Day 3-4: Project Structure\n    57→\n    58→| Status | Task | Reference |\n    59→|--------|------|-----------|\n    60→| ☐ | Map the directory structure mentally | [01-overview.md#project-structure](./01-overview.md) |\n    61→| ☐ | Identify V2 package as primary implementation | [01-overview.md#project-structure](./01-overview.md) |\n    62→| ☐ | Understand controller → service → workflow pattern | [01-overview.md#project-structure](./01-overview.md) |\n    63→| ☐ | Review key directories: `controller/v2/`, `v2/workflow/`, `entity/v2/` | [05-key-files-reference.md](./05-key-files-reference.md) |\n    64→\n    65→### Key Directories to Know\n    66→```\n    67→src/main/java/in/dreamplug/darwin/\n    68→├── controller/v2/      # REST endpoints\n    69→├── v2/workflow/create/ # Core business logic\n    70→├── entity/v2/          # JPA entities\n    71→├── statemachine/       # State machines\n    72→├── planner/            # Provider routing\n    73→└── cache/              # Caching layer\n    74→```\n    75→\n    76→## Day 5: Core Concepts\n    77→\n    78→| Status | Task | Reference |\n    79→|--------|------|-----------|\n    80→| ☐ | Understand Order → Payment → PaymentAttempt hierarchy | [01-overview.md#core-concepts](./01-overview.md) |\n    81→| ☐ | Learn the 7-step workflow pattern | [01-overview.md#core-concepts](./01-overview.md), [04-payment-flow.md#the-7-step-workflow-pipeline](./04-payment-flow.md) |\n    82→| ☐ | Study entity lifecycle states (CREATED → PROCESSING → COMPLETED) | [01-overview.md#core-concepts](./01-overview.md) |\n    83→| ☐ | Review internal service dependencies | [01-overview.md#internal-service-dependencies](./01-overview.md) |\n    84→| ☐ | Understand authentication filters | [01-overview.md#authentication--security](./01-overview.md) |\n    85→\n    86→### Payment Hierarchy (Critical)\n    87→```\n    88→Order (1)\n    89→    └── Payment (M)\n    90→            └── PaymentAttempt (M)\n    91→                    └── RefundAttempt (M via Refund)\n    92→```\n    93→\n    94→---\n    95→\n    96→## ✅ WEEK 1 CHECKPOINT\n    97→\n    98→| Status | Checkpoint Item |\n    99→|--------|-----------------|\n   100→| ☐ | Can explain the tech stack to someone |\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"5e13de56-8f7f-4b70-996b-773f345ed4d4","timestamp":"2025-12-31T10:31:49.629Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/kiranbiliyawala/code/cred/payments/payment-service/docs/study-guide/PROGRESS.md","content":"# Payment Service (Darwin) - Study Progress Tracker\n\n> **Started:** _______________\n> **Target Completion:** 4 weeks from start\n> **Current Status:** Not Started\n\n---\n\n## Quick Links\n\n| Document | Purpose |\n|----------|---------|\n| [README.md](./README.md) | Start here - Overview & navigation |\n| [01-overview.md](./01-overview.md) | Tech stack, project structure |\n| [02-data-layer.md](./02-data-layer.md) | Database, entities, caching |\n| [03-provider-integration.md](./03-provider-integration.md) | Provider adapters, webhooks |\n| [04-payment-flow.md](./04-payment-flow.md) | Workflows, state machines |\n| [05-key-files-reference.md](./05-key-files-reference.md) | File lookup reference |\n| [06-study-path.md](./06-study-path.md) | Weekly breakdown |\n\n---\n\n## Overall Progress\n\n```\nWeek 1: Foundation          [░░░░░░░░░░] 0%\nWeek 2: Data Layer          [░░░░░░░░░░] 0%\nWeek 3: Provider Integration [░░░░░░░░░░] 0%\nWeek 4: Payment Flow        [░░░░░░░░░░] 0%\nExpert Challenges           [░░░░░░░░░░] 0%\n─────────────────────────────────────────\nTOTAL                       [░░░░░░░░░░] 0%\n```\n\n---\n\n# WEEK 1: FOUNDATION\n\n**Goal:** Understand the big picture - tech stack, structure, and core concepts\n\n## Day 1-2: Setup & Overview\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Read the main README and understand navigation | [README.md](./README.md) |\n| ☐ | Read the complete overview document | [01-overview.md](./01-overview.md) |\n| ☐ | Clone and build the project (`./gradlew build`) | - |\n| ☐ | Explore `DarwinApplication.java` entry point | [01-overview.md#entry-point](./01-overview.md) |\n| ☐ | Scan `application.properties` (first 200 lines) | [01-overview.md#configuration](./01-overview.md) |\n\n### Key Learnings Checklist\n- [ ] Know the server runs on port 9010 with context path `/payments`\n- [ ] Understand Java 17 + Spring Boot 2.7.14 stack\n- [ ] Know the main databases: MySQL (Master-Replica), DynamoDB, Redis\n\n## Day 3-4: Project Structure\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Map the directory structure mentally | [01-overview.md#project-structure](./01-overview.md) |\n| ☐ | Identify V2 package as primary implementation | [01-overview.md#project-structure](./01-overview.md) |\n| ☐ | Understand controller → service → workflow pattern | [01-overview.md#project-structure](./01-overview.md) |\n| ☐ | Review key directories: `controller/v2/`, `v2/workflow/`, `entity/v2/` | [05-key-files-reference.md](./05-key-files-reference.md) |\n\n### Key Directories to Know\n```\nsrc/main/java/in/dreamplug/darwin/\n├── controller/v2/      # REST endpoints\n├── v2/workflow/create/ # Core business logic\n├── entity/v2/          # JPA entities\n├── statemachine/       # State machines\n├── planner/            # Provider routing\n└── cache/              # Caching layer\n```\n\n## Day 5: Core Concepts\n\n| Status | Task | Reference |\n|--------|------|-----------|\n| ☐ | Understand Order → Payment → PaymentAttempt hierarchy | [01-overview.md#core-concepts](./01-overview.md) |\n| ☐ | Learn the 7-step workflow pattern | [01-overview.md#core-concepts](./01-overview.md), [04-payment-flow.md#the-7-step-workflow-pipeline](./04-payment-flow.md) |\n| ☐ | Study entity lifecycle states (CREATED → PROCESSING → COMPLETED) | [01-overview.md#core-concepts](./01-overview.md) |\n| ☐ | Review internal service dependencies | [01-overview.md#internal-service-dependencies](./01-overview.md) |\n| ☐ | Understand authentication filters | [01-overview.md#authentication--security](./01-overview.md) |\n\n### Payment Hierarchy (Critical)\n```\nOrder (1)\n    └── Payment (M)\n            └── PaymentAttempt (M)\n                    └── RefundAttempt (M via Refund)\n```\n\n---\n\n## ✅ WEEK 1 CHECKPOINT\n\n| Status | Checkpoint Item |\n|--------|-----------------|\n| ☐ | Can explain the tech stack to someone |","numLines":100,"startLine":1,"totalLines":497}}}
{"parentUuid":"5e13de56-8f7f-4b70-996b-773f345ed4d4","isSidechain":false,"userType":"external","cwd":"/Users/kiranbiliyawala/code/cred/payments/payment-service","sessionId":"d93eb521-1af9-4bd1-8f89-1cec73f534b1","version":"2.0.76","gitBranch":"master","slug":"distributed-marinating-mango","type":"user","message":{"role":"user","content":[{"type":"text","text":"[Request interrupted by user]"}]},"uuid":"6c04ee00-8266-43f2-a55c-5a61ed0c7894","timestamp":"2025-12-31T10:31:55.897Z"}
